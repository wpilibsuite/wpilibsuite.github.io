<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: wpi::memory::that Concept Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="wpilib-128.png"/></td>
  <td id="projectalign">
   <div id="projectname">WPILibC++<span id="projectnumber">&#160;2023.1.1-alpha-1-11-g8f2e34c</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('conceptwpi_1_1memory_1_1that.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle"><div class="title">wpi::memory::that Concept Reference<div class="ingroups"><a class="el" href="group__allocator.html">Allocator implementations</a> &#124; <a class="el" href="group__storage.html">Allocator storage</a> &#124; <a class="el" href="group__adapter.html">Adapters and Wrappers</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A uses a given.  
<a href="conceptwpi_1_1memory_1_1that.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="memory__arena_8hpp_source.html">/home/runner/work/allwpilib/allwpilib/wpiutil/src/main/native/thirdparty/memory/include/wpi/memory/memory_arena.hpp</a>&gt;</code></p>
<h2 class="groupheader">Concept definition</h2>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">concept </span><a class="code hl_concept" href="conceptwpi_1_1memory_1_1that.html">wpi::memory::that</a> = </div>
<div class="ttc" id="aconceptwpi_1_1memory_1_1that_html"><div class="ttname"><a href="conceptwpi_1_1memory_1_1that.html">wpi::memory::that</a></div><div class="ttdoc">A uses a given.</div></div>
</div><!-- fragment --><a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A uses a given. </p>
<p >A stateless allocates memory using (nothrow) <code>operator new</code>.</p>
<p >A stateful behaves as a collection of multiple memory_pool objects.</p>
<p >A stateful manages.</p>
<p >A stateful provides stack-like (LIFO) allocations.</p>
<p >A stateless allocates memory from the heap.</p>
<p >A uses the additional joint memory for its allocation.</p>
<p >A either uses the.</p>
<p >A composable will always fail.</p>
<p >A allocates until a maximum size.</p>
<p >A stores a reference to an allocator.</p>
<p >A stores the allocator directly.</p>
<p >A stores another allocator.</p>
<p >A reserves virtual memory and commits it part by part.</p>
<p >A stateless allocates memory using the virtual memory allocation functions.</p>
<p >A stateless allocates memory using <code>std::malloc()</code>.</p>
<p >A stateful handles temporary allocations.</p>
<p >will be used for their internal allocation, this type is the default value.</p>
<p >The default will be used as.</p>
<p >A allocates the blocks from a fixed size storage.</p>
<p >A stateful uses a fixed sized storage for the allocations.</p>
<p >A stateful is designed for allocations in a loop.</p>
<p >A allows only one block allocation.</p>
<p >It can be used to prevent higher-level allocators from expanding. The one block allocation is performed through the <code><a class="el" href="namespacewpi_1_1memory_1_1traits__detail.html#a11ba56c63dcf7c5763ae6d090efc699f">allocate_array()</a></code> function of the given</p>
<p >It uses <code>N</code> stacks for the allocation, one of them is always active. Allocation uses the currently active stack. Calling iteration_allocator::next_iteration() at the end of the loop, will make the next stack active for allocation, effectively releasing all of its memory. Any memory allocated will thus be usable for <code>N</code> iterations of the loop. This type of allocator is a generalization of the double frame allocator.</p>
<p >It works on a static_allocator_storage and uses its memory for all allocations. Deallocations are not supported, memory cannot be marked as freed.<br  />
 </p><dl class="section note"><dt>Note</dt><dd>It is not allowed to share an static_allocator_storage between multiple static_allocator objects.</dd></dl>
<p>It works on a static_allocator_storage and uses it for all allocations, deallocations are only allowed in reversed order which is guaranteed by memory_arena. </p><dl class="section note"><dt>Note</dt><dd>It is not allowed to share an static_allocator_storage between multiple static_allocator objects.</dd></dl>
<p>\requiredbe Its type can be changed via the CMake option <code>WPI_MEMORY_DEFAULT_ALLCOATOR</code>, but it must be one of the following: heap_allocator, new_allocator, malloc_allocator, static_allocator, virtual_memory_allocator. \defaultbe The default is heap_allocator.</p>
<p >It works similar to <code>alloca()</code> but uses a seperate memory_stack for the allocations, instead of the actual program stack. This avoids the stack overflow error and is portable, with a similar speed. All allocations done in the scope of the allocator object are automatically freed when the object is destroyed.</p>
<p >It throws out_of_memory when the allocation fails.</p>
<p >It does not prereserve any memory and will always reserve and commit combined.</p>
<p >It is similar to memory_stack but does not support growing and uses virtual memory, also meant for big blocks not small allocations.</p>
<p >The</p>
<p >It embeds the allocator inside it, i.e. moving the storage policy will move the allocator.</p>
<p >For stateful allocators it only stores a pointer to an allocator object and copying/moving only copies the pointer. For stateless allocators it does not store anything, an allocator will be constructed as needed. For allocators that are already shared (determined through is_shared_allocator) it will store the allocator type directly. </p><dl class="section note"><dt>Note</dt><dd>It does not take ownership over the allocator in the stateful case, the user has to ensure that the allocator object stays valid. In the other cases the lifetime does not matter.</dd></dl>
<p>This is useful for compositioning or as last resort in binary_segregator.</p>
<p >It is somewhat limited and allows only allocation once. All joint allocators for an object share the joint memory and must not be used in multiple threads. The memory it returns is owned by a joint_ptr and will be destroyed through it.</p>
<p >It uses the two functions heap_alloc and heap_dealloc for the allocation, which default to <code>std::malloc</code> and <code>std::free</code>.</p>
<p >It uses a memory_arena with a given <code>BlockOrRawAllocator</code> defaulting to growing_block_allocator to allocate huge blocks and saves a marker to the current top. Allocation simply moves this marker by the appropriate number of bytes and returns the pointer at the old marker position, deallocation is not directly supported, only setting the marker to a previously queried position.</p>
<p >It maintains a list of multiple free lists, whose types are controlled via the <code>PoolType</code> tags defined in <a class="el" href="memory__pool__type_8hpp.html">memory_pool_type.hpp</a>, each of a different size as defined in the <code>BucketDistribution</code> (identity_buckets or log2_buckets). Allocating a node of given size will use the appropriate free list.<br  />
 This allocator is ideal for</p>
<p >If the operator returns <code>nullptr</code>, it behaves like <code>new</code> and loops calling <code>std::new_handler</code>, but instead of throwing a <code>std::bad_alloc</code> exception, it throws out_of_memory. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacewpi.html">wpi</a></li><li class="navelem"><a class="el" href="namespacewpi_1_1memory.html">memory</a></li><li class="navelem"><a class="el" href="conceptwpi_1_1memory_1_1that.html">that</a></li>
    <li class="footer">Generated on Sat Oct 22 2022 02:27:10 for WPILibC++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
