<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: wpi Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="wpilib-128.png"/></td>
  <td id="projectalign">
   <div id="projectname">WPILibC++<span id="projectnumber">&#160;2023.1.1-beta-3-10-ge92b6dd</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacewpi.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">wpi Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>/file This file defines the <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> class.  
<a href="namespacewpi.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacewpi_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespacewpi_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">detail namespace with internal helper functions <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacewpi_1_1hashing"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1hashing.html">hashing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacewpi_1_1impl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1impl.html">impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacewpi_1_1java"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1java.html">java</a></td></tr>
<tr class="memdesc:namespacewpi_1_1java"><td class="mdescLeft">&#160;</td><td class="mdescRight">Java Native Interface (JNI) utility functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacewpi_1_1log"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1log.html">log</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacewpi_1_1math"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1math.html">math</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacewpi_1_1memory"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html">memory</a></td></tr>
<tr class="memdesc:namespacewpi_1_1memory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacewpi_1_1pointer__union__detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1pointer__union__detail.html">pointer_union_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacewpi_1_1sig"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1sig.html">sig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacewpi_1_1support"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1support.html">support</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacewpi_1_1sys"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1sys.html">sys</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacewpi_1_1uv"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1uv.html">uv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1add__const__past__pointer.html">add_const_past_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a pointer to X, return a pointer to const X.  <a href="structwpi_1_1add__const__past__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1add__const__past__pointer_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4.html">add_const_past_pointer&lt; T, std::enable_if_t&lt; std::is_pointer&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1add__lvalue__reference__if__not__pointer.html">add_lvalue_reference_if_not_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a pointer, just return it. If it is not, return T&amp;.  <a href="structwpi_1_1add__lvalue__reference__if__not__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1add__lvalue__reference__if__not__pointer_3_01_t_00_01std_1_1enable__if__t_3_01std_110a258e96b2dbdfeaef70416ac9c48e6.html">add_lvalue_reference_if_not_pointer&lt; T, std::enable_if_t&lt; std::is_pointer&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1adl__serializer.html">adl_serializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">default JSONSerializer template argument  <a href="structwpi_1_1adl__serializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_aligned_char_array_union.html">AlignedCharArrayUnion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A suitably aligned and sized character array member which can hold elements of any type.  <a href="structwpi_1_1_aligned_char_array_union.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_allocator_base.html">AllocatorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP base class providing obvious overloads for the core <code><a class="el" href="classwpi_1_1_allocator_base.html#a6240cd736c1f584d88fc7b7f0d747a2e" title="Allocate Size bytes of Alignment aligned memory.">Allocate()</a></code> methods of LLVM-style allocators.  <a href="classwpi_1_1_allocator_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a wrapper around std::array that does compile time size checking.  <a href="classwpi_1_1array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1buffer__ostream.html">buffer_ostream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1buffer__unique__ostream.html">buffer_unique_ostream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_calculate_small_vector_default_inlined_elements.html">CalculateSmallVectorDefaultInlinedElements</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for calculating the default number of inline elements for <code><a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a>&lt;T&gt;</code>.  <a href="structwpi_1_1_calculate_small_vector_default_inlined_elements.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_callback_listener_data.html">CallbackListenerData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_callback_manager.html">CallbackManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_callback_thread.html">CallbackThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1circular__buffer.html">circular_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple circular buffer so we don't need to "bucket brigade" copy old values.  <a href="classwpi_1_1circular__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_concurrent_queue.html">ConcurrentQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1conjunction.html">conjunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1conjunction_3_01_b1_01_4.html">conjunction&lt; B1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1conjunction_3_01_b1_00_01_bn_8_8_8_01_4.html">conjunction&lt; B1, Bn... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1const__pointer__or__const__ref.html">const_pointer_or_const_ref</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1const__pointer__or__const__ref_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__poinc93c4d34c51fc96d070c52031bec30c2.html">const_pointer_or_const_ref&lt; T, std::enable_if_t&lt; std::is_pointer&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_debug_epoch_base.html">DebugEpochBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for data structure classes wishing to make iterators ("handles") pointing into themselves fail-fast.  <a href="classwpi_1_1_debug_epoch_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_dense_map.html">DenseMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_dense_map_base.html">DenseMapBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info.html">DenseMapInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An information struct used to provide <a class="el" href="classwpi_1_1_dense_map.html">DenseMap</a> with the various necessary components for a given value type <code>T</code>.  <a href="structwpi_1_1_dense_map_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01char_01_4.html">DenseMapInfo&lt; char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01hash__code_00_01void_01_4.html">DenseMapInfo&lt; hash_code, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01int_01_4.html">DenseMapInfo&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01long_01_4.html">DenseMapInfo&lt; long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01long_01long_01_4.html">DenseMapInfo&lt; long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01_pointer_int_pair_3_01_pointer_ty_00_01_int_bits_00_01_int_type_01_4_00_01void_01_4.html">DenseMapInfo&lt; PointerIntPair&lt; PointerTy, IntBits, IntType &gt;, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01_pointer_union_3_01_p_ts_8_8_8_01_4_01_4.html">DenseMapInfo&lt; PointerUnion&lt; PTs... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01short_01_4.html">DenseMapInfo&lt; short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01std_1_1pair_3_01_t_00_01_u_01_4_01_4.html">DenseMapInfo&lt; std::pair&lt; T, U &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01std_1_1tuple_3_01_ts_8_8_8_01_4_01_4.html">DenseMapInfo&lt; std::tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01_t_01_5_01_4.html">DenseMapInfo&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01unsigned_01_4.html">DenseMapInfo&lt; unsigned &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01unsigned_01char_01_4.html">DenseMapInfo&lt; unsigned char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01unsigned_01long_01_4.html">DenseMapInfo&lt; unsigned long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01unsigned_01long_01long_01_4.html">DenseMapInfo&lt; unsigned long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01unsigned_01short_01_4.html">DenseMapInfo&lt; unsigned short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_dense_map_iterator.html">DenseMapIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1disjunction.html">disjunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1disjunction_3_01_b1_01_4.html">disjunction&lt; B1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1disjunction_3_01_b1_00_01_bn_8_8_8_01_4.html">disjunction&lt; B1, Bn... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_ds_client.html">DsClient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1empty__array__t.html">empty_array_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_event_loop_runner.html">EventLoopRunner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes an event loop on a separate thread.  <a href="classwpi_1_1_event_loop_runner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_event_vector.html">EventVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_first_index_of_type.html">FirstIndexOfType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first index where a type appears in a list of types.  <a href="structwpi_1_1_first_index_of_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_first_index_of_type_3_01_t_00_01_t_00_01_us_8_8_8_01_4.html">FirstIndexOfType&lt; T, T, Us... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_first_index_of_type_3_01_t_00_01_u_00_01_us_8_8_8_01_4.html">FirstIndexOfType&lt; T, U, Us... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1function__ref.html">function_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An efficient, type-erasing, non-owning reference to a callable.  <a href="classwpi_1_1function__ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1function__ref_3_01_ret_07_params_8_8_8_08_4.html">function_ref&lt; Ret(Params...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_function_pointer_like_type_traits.html">FunctionPointerLikeTypeTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide suitable custom traits struct for function pointers.  <a href="structwpi_1_1_function_pointer_like_type_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1future.html">future</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight version of std::future.  <a href="classwpi_1_1future.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1future_3_01void_01_4.html">future&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit specialization for <a class="el" href="classwpi_1_1future_3_01void_01_4.html" title="Explicit specialization for future&lt;void&gt;.">future&lt;void&gt;</a>.  <a href="classwpi_1_1future_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque object representing a hash code.  <a href="classwpi_1_1hash__code.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1http__parser.html">http_parser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1http__parser__settings.html">http_parser_settings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1http__parser__url.html">http_parser_url</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_http_connection.html">HttpConnection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_http_location.html">HttpLocation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_http_multipart_scanner.html">HttpMultipartScanner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_http_parser.html">HttpParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">HTTP protocol parser.  <a href="classwpi_1_1_http_parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_http_path.html">HttpPath</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for HTTP path matching.  <a href="classwpi_1_1_http_path.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_http_path_ref.html">HttpPathRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy reference object for a portion of a <a class="el" href="classwpi_1_1_http_path.html" title="Class for HTTP path matching.">HttpPath</a>.  <a href="classwpi_1_1_http_path_ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_http_query_map.html">HttpQueryMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map for looking up elements of the query portion of a URI.  <a href="classwpi_1_1_http_query_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_http_request.html">HttpRequest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_http_server_connection.html">HttpServerConnection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_http_web_socket_server_connection.html">HttpWebSocketServerConnection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A server-side HTTP connection that also accepts <a class="el" href="classwpi_1_1_web_socket.html" title="RFC 6455 compliant WebSocket client and server implementation.">WebSocket</a> upgrades.  <a href="classwpi_1_1_http_web_socket_server_connection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1in__place__index__t.html">in_place_index_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1in__place__t.html">in_place_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1in__place__type__t.html">in_place_type_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1interpolating__map.html">interpolating_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a table of key-value pairs with linear interpolation between values.  <a href="classwpi_1_1interpolating__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1is__integral__or__enum.html">is_integral_or_enum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction that determines whether the given type is either an integral type or an enumeration type, including enum classes.  <a href="classwpi_1_1is__integral__or__enum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1iterator__adaptor__base.html">iterator_adaptor_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP base class for adapting an iterator to a different type.  <a href="classwpi_1_1iterator__adaptor__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1iterator__facade__base.html">iterator_facade_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP base class which implements the entire standard iterator facade in terms of a minimal subset of the interface.  <a href="classwpi_1_1iterator__facade__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1iterator__range.html">iterator_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range adaptor for a pair of iterators.  <a href="classwpi_1_1iterator__range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1json.html">json</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a class to store JSON values  <a href="classwpi_1_1json.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1json__pointer.html">json_pointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_logger.html">Logger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_malloc_allocator.html">MallocAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_mapped_file_region.html">MappedFileRegion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_map_vector.html">MapVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a map that also provides access to all stored values in a deterministic order.  <a href="classwpi_1_1_map_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_memory_buffer.html">MemoryBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface provides simple read-only access to a block of memory, and provides simple methods for reading files and standard input into a memory buffer.  <a href="classwpi_1_1_memory_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_memory_buffer_ref.html">MemoryBufferRef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1negation.html">negation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_network_acceptor.html">NetworkAcceptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_network_stream.html">NetworkStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_null_deleter.html">NullDeleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_parallel_tcp_connector.html">ParallelTcpConnector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel TCP connector.  <a href="classwpi_1_1_parallel_tcp_connector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1pointee__iterator.html">pointee_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator type that allows iterating over the pointees via some other iterator.  <a href="structwpi_1_1pointee__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1pointer__iterator.html">pointer_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_pointer_int_pair.html">PointerIntPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_pointer_int_pair.html" title="PointerIntPair - This class implements a pair of a pointer and small integer.">PointerIntPair</a> - This class implements a pair of a pointer and small integer.  <a href="classwpi_1_1_pointer_int_pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_pointer_int_pair_info.html">PointerIntPairInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_pointer_like_type_traits.html">PointerLikeTypeTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A traits type that is used to handle pointer types and things that are just wrappers for pointers as a uniform entity.  <a href="structwpi_1_1_pointer_like_type_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_pointer_like_type_traits_3_01const_01_t_01_5_01_4.html">PointerLikeTypeTraits&lt; const T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_pointer_like_type_traits_3_01const_01_t_01_4.html">PointerLikeTypeTraits&lt; const T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_pointer_like_type_traits_3_01_pointer_int_pair_3_01_pointer_ty_00_01_int_bits_00_07d15f14192fcce1c1fa879f2bfdb0181.html">PointerLikeTypeTraits&lt; PointerIntPair&lt; PointerTy, IntBits, IntType, PtrTraits &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_pointer_like_type_traits_3_01_pointer_union_3_01_p_ts_8_8_8_01_4_01_4.html">PointerLikeTypeTraits&lt; PointerUnion&lt; PTs... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_pointer_like_type_traits_3_01_return_t_07_5_08_07_param_ts_8_8_8_08_4.html">PointerLikeTypeTraits&lt; ReturnT(*)(ParamTs...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a default specialization for function pointers that assumes 4-byte alignment.  <a href="structwpi_1_1_pointer_like_type_traits_3_01_return_t_07_5_08_07_param_ts_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_pointer_like_type_traits_3_01_t_01_5_01_4.html">PointerLikeTypeTraits&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_pointer_like_type_traits_3_01uintptr__t_01_4.html">PointerLikeTypeTraits&lt; uintptr_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_pointer_like_type_traits_3_01void_01_5_01_4.html">PointerLikeTypeTraits&lt; void * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A discriminated union of two or more pointer types, with the discriminator in the low bit of the pointer.  <a href="classwpi_1_1_pointer_union.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_port_forwarder.html">PortForwarder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward ports to another host.  <a href="classwpi_1_1_port_forwarder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1priority__queue.html">priority_queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the same as std::priority_queue with two changes:  <a href="classwpi_1_1priority__queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1promise.html">promise</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight version of std::promise.  <a href="classwpi_1_1promise.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1promise_3_01void_01_4.html">promise&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit specialization for <a class="el" href="classwpi_1_1promise_3_01void_01_4.html" title="Explicit specialization for promise&lt;void&gt;.">promise&lt;void&gt;</a>.  <a href="classwpi_1_1promise_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_promise_factory.html">PromiseFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A promise factory for lightweight futures.  <a href="classwpi_1_1_promise_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_promise_factory_3_01void_01_4.html">PromiseFactory&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit specialization for <a class="el" href="classwpi_1_1_promise_factory_3_01void_01_4.html" title="Explicit specialization for PromiseFactory&lt;void&gt;.">PromiseFactory&lt;void&gt;</a>.  <a href="classwpi_1_1_promise_factory_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__fd__istream.html">raw_fd_istream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__fd__ostream.html">raw_fd_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> that writes to a file descriptor.  <a href="classwpi_1_1raw__fd__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__fd__stream.html">raw_fd_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> of a file for reading/writing/seeking.  <a href="classwpi_1_1raw__fd__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__istream.html">raw_istream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__mem__istream.html">raw_mem_istream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__null__ostream.html">raw_null_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> that discards all output.  <a href="classwpi_1_1raw__null__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__os__ostream.html">raw_os_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1raw__os__ostream.html" title="raw_os_ostream - A raw_ostream that writes to an std::ostream.">raw_os_ostream</a> - A <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> that writes to an std::ostream.  <a href="classwpi_1_1raw__os__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements an extremely fast bulk output stream that can <em>only</em> output to a stream.  <a href="classwpi_1_1raw__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__pwrite__stream.html">raw_pwrite_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract base class for streams implementations that also support a pwrite operation.  <a href="classwpi_1_1raw__pwrite__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__socket__istream.html">raw_socket_istream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__socket__ostream.html">raw_socket_ostream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__string__ostream.html">raw_string_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> that writes to an std::string.  <a href="classwpi_1_1raw__string__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__svector__ostream.html">raw_svector_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> that writes to an <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> or <a class="el" href="classwpi_1_1_small_string.html" title="SmallString - A SmallString is just a SmallVector with methods and accessors that make it work better...">SmallString</a>.  <a href="classwpi_1_1raw__svector__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__usvector__ostream.html">raw_usvector_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> that writes to an <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> or <a class="el" href="classwpi_1_1_small_string.html" title="SmallString - A SmallString is just a SmallVector with methods and accessors that make it work better...">SmallString</a>.  <a href="classwpi_1_1raw__usvector__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__uv__ostream.html">raw_uv_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> style output to a <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> of <a class="el" href="classwpi_1_1uv_1_1_buffer.html" title="Data buffer.">uv::Buffer</a> buffers.  <a href="classwpi_1_1raw__uv__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__uvector__ostream.html">raw_uvector_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> that writes to a vector.  <a href="classwpi_1_1raw__uvector__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__vector__ostream.html">raw_vector_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> that writes to a vector.  <a href="classwpi_1_1raw__vector__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1recursive__spinlock1.html">recursive_spinlock1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A recursive spinlock mutex.  <a href="classwpi_1_1recursive__spinlock1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1recursive__spinlock2.html">recursive_spinlock2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A recursive spinlock mutex.  <a href="classwpi_1_1recursive__spinlock2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1remove__cvref.html">remove_cvref</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_round_up_to_power_of_two.html">RoundUpToPowerOfTwo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structwpi_1_1_round_up_to_power_of_two.html" title="RoundUpToPowerOfTwo - This is a helper template that rounds N up to the next power of two (which mean...">RoundUpToPowerOfTwo</a> - This is a helper template that rounds N up to the next power of two (which means N itself if N is already a power of two).  <a href="structwpi_1_1_round_up_to_power_of_two.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_round_up_to_power_of_two_h.html">RoundUpToPowerOfTwoH</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structwpi_1_1_round_up_to_power_of_two_h.html" title="RoundUpToPowerOfTwoH - If N is not a power of two, increase it.">RoundUpToPowerOfTwoH</a> - If N is not a power of two, increase it.  <a href="structwpi_1_1_round_up_to_power_of_two_h.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_round_up_to_power_of_two_h_3_01_n_00_01false_01_4.html">RoundUpToPowerOfTwoH&lt; N, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_safe_thread.html">SafeThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_safe_thread_base.html">SafeThreadBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="classwpi_1_1_safe_thread_owner.html">SafeThreadOwner</a> threads.  <a href="classwpi_1_1_safe_thread_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_safe_thread_event.html">SafeThreadEvent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_safe_thread_owner.html">SafeThreadOwner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1scope__exit.html">scope_exit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_scoped_fatal_error_handler.html">ScopedFatalErrorHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structwpi_1_1_scoped_fatal_error_handler.html" title="ScopedFatalErrorHandler - This is a simple helper class which just calls install_fatal_error_handler ...">ScopedFatalErrorHandler</a> - This is a simple helper class which just calls install_fatal_error_handler in its constructor and remove_fatal_error_handler in its destructor.  <a href="structwpi_1_1_scoped_fatal_error_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_sendable.html">Sendable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for <a class="el" href="classwpi_1_1_sendable.html" title="Interface for Sendable objects.">Sendable</a> objects.  <a href="classwpi_1_1_sendable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_sendable_builder.html">SendableBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_sendable_helper.html">SendableHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for use with objects that add themselves to <a class="el" href="classwpi_1_1_sendable_registry.html" title="The SendableRegistry class is the public interface for registering sensors and actuators for use on d...">SendableRegistry</a>.  <a href="classwpi_1_1_sendable_helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_sendable_registry.html">SendableRegistry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classwpi_1_1_sendable_registry.html" title="The SendableRegistry class is the public interface for registering sensors and actuators for use on d...">SendableRegistry</a> class is the public interface for registering sensors and actuators for use on dashboards and LiveWindow.  <a href="classwpi_1_1_sendable_registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_s_h_a1.html">SHA1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_dense_map.html">SmallDenseMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_small_map_vector.html">SmallMapVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classwpi_1_1_map_vector.html" title="This class implements a map that also provides access to all stored values in a deterministic order.">MapVector</a> that performs no allocations if smaller than a certain size.  <a href="structwpi_1_1_small_map_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_ptr_set.html">SmallPtrSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_small_ptr_set.html" title="SmallPtrSet - This class implements a set which is optimized for holding SmallSize or less elements.">SmallPtrSet</a> - This class implements a set which is optimized for holding SmallSize or less elements.  <a href="classwpi_1_1_small_ptr_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_ptr_set_impl.html">SmallPtrSetImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A templated base class for <code><a class="el" href="classwpi_1_1_small_ptr_set.html" title="SmallPtrSet - This class implements a set which is optimized for holding SmallSize or less elements.">SmallPtrSet</a></code> which provides the typesafe interface that is common across all small sizes.  <a href="classwpi_1_1_small_ptr_set_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_ptr_set_impl_base.html">SmallPtrSetImplBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_small_ptr_set_impl_base.html" title="SmallPtrSetImplBase - This is the common code shared among all the SmallPtrSet&lt;&gt;&#39;s,...">SmallPtrSetImplBase</a> - This is the common code shared among all the SmallPtrSet&lt;&gt;'s, which is almost everything.  <a href="classwpi_1_1_small_ptr_set_impl_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_ptr_set_iterator.html">SmallPtrSetIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_small_ptr_set_iterator.html" title="SmallPtrSetIterator - This implements a const_iterator for SmallPtrSet.">SmallPtrSetIterator</a> - This implements a const_iterator for <a class="el" href="classwpi_1_1_small_ptr_set.html" title="SmallPtrSet - This class implements a set which is optimized for holding SmallSize or less elements.">SmallPtrSet</a>.  <a href="classwpi_1_1_small_ptr_set_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_ptr_set_iterator_impl.html">SmallPtrSetIteratorImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_small_ptr_set_iterator_impl.html" title="SmallPtrSetIteratorImpl - This is the common base class shared between all instances of SmallPtrSetIt...">SmallPtrSetIteratorImpl</a> - This is the common base class shared between all instances of <a class="el" href="classwpi_1_1_small_ptr_set_iterator.html" title="SmallPtrSetIterator - This implements a const_iterator for SmallPtrSet.">SmallPtrSetIterator</a>.  <a href="classwpi_1_1_small_ptr_set_iterator_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_set.html">SmallSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_small_set.html" title="SmallSet - This maintains a set of unique values, optimizing for the case when the set is small (less...">SmallSet</a> - This maintains a set of unique values, optimizing for the case when the set is small (less than N).  <a href="classwpi_1_1_small_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_set_3_01_pointee_type_01_5_00_01_n_01_4.html">SmallSet&lt; PointeeType *, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this set is of pointer values, transparently switch over to using <a class="el" href="classwpi_1_1_small_ptr_set.html" title="SmallPtrSet - This class implements a set which is optimized for holding SmallSize or less elements.">SmallPtrSet</a> for performance.  <a href="classwpi_1_1_small_set_3_01_pointee_type_01_5_00_01_n_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_set_iterator.html">SmallSetIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_small_set_iterator.html" title="SmallSetIterator - This class implements a const_iterator for SmallSet by delegating to the underlyin...">SmallSetIterator</a> - This class implements a const_iterator for <a class="el" href="classwpi_1_1_small_set.html" title="SmallSet - This maintains a set of unique values, optimizing for the case when the set is small (less...">SmallSet</a> by delegating to the underlying <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> or Set iterators.  <a href="classwpi_1_1_small_set_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_string.html">SmallString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_small_string.html" title="SmallString - A SmallString is just a SmallVector with methods and accessors that make it work better...">SmallString</a> - A <a class="el" href="classwpi_1_1_small_string.html" title="SmallString - A SmallString is just a SmallVector with methods and accessors that make it work better...">SmallString</a> is just a <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> with methods and accessors that make it work better as a string (e.g.  <a href="classwpi_1_1_small_string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_vector.html">SmallVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a 'vector' (really, a variable-sized array), optimized for the case when the array is small.  <a href="classwpi_1_1_small_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_small_vector_alignment_and_size.html">SmallVectorAlignmentAndSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Figure out the offset of the first element.  <a href="structwpi_1_1_small_vector_alignment_and_size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_vector_base.html">SmallVectorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is all the stuff common to all SmallVectors.  <a href="classwpi_1_1_small_vector_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class consists of common code factored out of the <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> class to reduce code duplication based on the <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> 'N' template parameter.  <a href="classwpi_1_1_small_vector_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_vector_memory_buffer.html">SmallVectorMemoryBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SmallVector-backed <a class="el" href="classwpi_1_1_memory_buffer.html" title="This interface provides simple read-only access to a block of memory, and provides simple methods for...">MemoryBuffer</a> instance.  <a href="classwpi_1_1_small_vector_memory_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_small_vector_storage.html">SmallVectorStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for the <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> elements.  <a href="structwpi_1_1_small_vector_storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_small_vector_storage_3_01_t_00_010_01_4.html">SmallVectorStorage&lt; T, 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">We need the storage to be properly aligned even for small-size of 0 so that the pointer math in <em>SmallVectorTemplateCommon::getFirstEl()</em> is well-defined.  <a href="structwpi_1_1_small_vector_storage_3_01_t_00_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_vector_template_base.html">SmallVectorTemplateBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_small_vector_template_base.html" title="SmallVectorTemplateBase&lt;TriviallyCopyable = false&gt; - This is where we put method implementations that...">SmallVectorTemplateBase</a>&lt;TriviallyCopyable = false&gt; - This is where we put method implementations that are designed to work with non-trivial T's.  <a href="classwpi_1_1_small_vector_template_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_vector_template_base_3_01_t_00_01true_01_4.html">SmallVectorTemplateBase&lt; T, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_small_vector_template_base.html" title="SmallVectorTemplateBase&lt;TriviallyCopyable = false&gt; - This is where we put method implementations that...">SmallVectorTemplateBase</a>&lt;TriviallyCopyable = true&gt; - This is where we put method implementations that are designed to work with trivially copyable T's.  <a href="classwpi_1_1_small_vector_template_base_3_01_t_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_vector_template_common.html">SmallVectorTemplateCommon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the part of <a class="el" href="classwpi_1_1_small_vector_template_base.html" title="SmallVectorTemplateBase&lt;TriviallyCopyable = false&gt; - This is where we put method implementations that...">SmallVectorTemplateBase</a> which does not depend on whether the type T is a POD.  <a href="classwpi_1_1_small_vector_template_common.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1spinlock.html">spinlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A spinlock mutex.  <a href="classwpi_1_1spinlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1static__circular__buffer.html">static_circular_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple circular buffer so we don't need to "bucket brigade" copy old values.  <a href="classwpi_1_1static__circular__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_string_map.html">StringMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_string_map.html" title="StringMap - This is an unconventional map that is specialized for handling keys that are &quot;strings&quot;,...">StringMap</a> - This is an unconventional map that is specialized for handling keys that are "strings", which are basically ranges of bytes.  <a href="classwpi_1_1_string_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_string_map_const_iterator.html">StringMapConstIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_string_map_entry.html">StringMapEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_string_map_entry.html" title="StringMapEntry - This is used to represent one value that is inserted into a StringMap.">StringMapEntry</a> - This is used to represent one value that is inserted into a <a class="el" href="classwpi_1_1_string_map.html" title="StringMap - This is an unconventional map that is specialized for handling keys that are &quot;strings&quot;,...">StringMap</a>.  <a href="classwpi_1_1_string_map_entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_string_map_entry_base.html">StringMapEntryBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_string_map_entry_base.html" title="StringMapEntryBase - Shared base class of StringMapEntry instances.">StringMapEntryBase</a> - Shared base class of <a class="el" href="classwpi_1_1_string_map_entry.html" title="StringMapEntry - This is used to represent one value that is inserted into a StringMap.">StringMapEntry</a> instances.  <a href="classwpi_1_1_string_map_entry_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_string_map_entry_storage.html">StringMapEntryStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_string_map_entry_storage.html" title="StringMapEntryStorage - Holds the value in a StringMapEntry.">StringMapEntryStorage</a> - Holds the value in a <a class="el" href="classwpi_1_1_string_map_entry.html" title="StringMapEntry - This is used to represent one value that is inserted into a StringMap.">StringMapEntry</a>.  <a href="classwpi_1_1_string_map_entry_storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_string_map_entry_storage_3_01std_1_1nullopt__t_01_4.html">StringMapEntryStorage&lt; std::nullopt_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_string_map_impl.html">StringMapImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_string_map_impl.html" title="StringMapImpl - This is the base class of StringMap that is shared among all of its instantiations.">StringMapImpl</a> - This is the base class of <a class="el" href="classwpi_1_1_string_map.html" title="StringMap - This is an unconventional map that is specialized for handling keys that are &quot;strings&quot;,...">StringMap</a> that is shared among all of its instantiations.  <a href="classwpi_1_1_string_map_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_string_map_iterator.html">StringMapIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_string_map_iter_base.html">StringMapIterBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_string_map_key_iterator.html">StringMapKeyIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_types_are_distinct.html">TypesAreDistinct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if all types in Ts are distinct.  <a href="structwpi_1_1_types_are_distinct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_types_are_distinct_3_4.html">TypesAreDistinct&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_u_d_p_client.html">UDPClient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_uid_vector.html">UidVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector which provides an integrated freelist for removal and reuse of individual elements.  <a href="classwpi_1_1_uid_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_uleb128_reader.html">Uleb128Reader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned LEB128 streaming reader.  <a href="classwpi_1_1_uleb128_reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1unique__function.html">unique_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1unique__function.html" title="unique_function is a type-erasing functor similar to std::function.">unique_function</a> is a type-erasing functor similar to std::function.  <a href="classwpi_1_1unique__function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1unique__function_3_01_r_07_p_8_8_8_08_01const_01_4.html">unique_function&lt; R(P...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1unique__function_3_01_r_07_p_8_8_8_08_4.html">unique_function&lt; R(P...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_url_parser.html">UrlParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a URL into its constiuent components.  <a href="classwpi_1_1_url_parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_version_tuple.html">VersionTuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a version number in the form major[.minor[.subminor[.build]]].  <a href="classwpi_1_1_version_tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_web_socket.html">WebSocket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RFC 6455 compliant <a class="el" href="classwpi_1_1_web_socket.html" title="RFC 6455 compliant WebSocket client and server implementation.">WebSocket</a> client and server implementation.  <a href="classwpi_1_1_web_socket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_web_socket_server.html">WebSocketServer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated <a class="el" href="classwpi_1_1_web_socket.html" title="RFC 6455 compliant WebSocket client and server implementation.">WebSocket</a> server.  <a href="classwpi_1_1_web_socket_server.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_web_socket_server_helper.html">WebSocketServerHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_web_socket.html" title="RFC 6455 compliant WebSocket client and server implementation.">WebSocket</a> HTTP server helper.  <a href="classwpi_1_1_web_socket_server_helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_worker_thread.html">WorkerThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_worker_thread_3_01_r_07_t_8_8_8_08_4.html">WorkerThread&lt; R(T...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_writable_memory_buffer.html">WritableMemoryBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is an extension of <a class="el" href="classwpi_1_1_memory_buffer.html" title="This interface provides simple read-only access to a block of memory, and provides simple methods for...">MemoryBuffer</a>, which allows copy-on-write access to the underlying contents.  <a href="classwpi_1_1_writable_memory_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_write_through_memory_buffer.html">WriteThroughMemoryBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is an extension of <a class="el" href="classwpi_1_1_memory_buffer.html" title="This interface provides simple read-only access to a block of memory, and provides simple methods for...">MemoryBuffer</a>, which allows write access to the underlying contents and committing those changes to the original source.  <a href="classwpi_1_1_write_through_memory_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad9fed3fc3490be636a867835e19df210"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ad9fed3fc3490be636a867835e19df210">recursive_spinlock</a> = <a class="el" href="classwpi_1_1recursive__spinlock1.html">recursive_spinlock1</a></td></tr>
<tr class="separator:ad9fed3fc3490be636a867835e19df210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97cc1139d8f910187e3d4cd6b8015af8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a97cc1139d8f910187e3d4cd6b8015af8">condition_variable</a> = ::std::condition_variable</td></tr>
<tr class="separator:a97cc1139d8f910187e3d4cd6b8015af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59819be5b11c0fbbc0b8e07c7638af24"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a59819be5b11c0fbbc0b8e07c7638af24">mutex</a> = ::std::mutex</td></tr>
<tr class="separator:a59819be5b11c0fbbc0b8e07c7638af24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac654fbccde78931efbd96a33a8af5726"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ac654fbccde78931efbd96a33a8af5726">recursive_mutex</a> = ::std::recursive_mutex</td></tr>
<tr class="separator:ac654fbccde78931efbd96a33a8af5726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd1500d4f0a79e36ea629a6ed4b6f81"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:a2fd1500d4f0a79e36ea629a6ed4b6f81"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a2fd1500d4f0a79e36ea629a6ed4b6f81">TypeAtIndex</a> = std::tuple_element_t&lt; I, std::tuple&lt; Ts... &gt; &gt;</td></tr>
<tr class="memdesc:a2fd1500d4f0a79e36ea629a6ed4b6f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the type at a given index in a list of types.  <a href="namespacewpi.html#a2fd1500d4f0a79e36ea629a6ed4b6f81">More...</a><br /></td></tr>
<tr class="separator:a2fd1500d4f0a79e36ea629a6ed4b6f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacde1332b72e968317ed516552a07ca8"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#aacde1332b72e968317ed516552a07ca8">fatal_error_handler_t</a>) (void *user_data, const char *reason, bool gen_crash_diag)</td></tr>
<tr class="memdesc:aacde1332b72e968317ed516552a07ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error handler callback.  <a href="namespacewpi.html#aacde1332b72e968317ed516552a07ca8">More...</a><br /></td></tr>
<tr class="separator:aacde1332b72e968317ed516552a07ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9d00d0810a9683b42e6a4b51cde3f1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5c9d00d0810a9683b42e6a4b51cde3f1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a5c9d00d0810a9683b42e6a4b51cde3f1">is_trivially_move_constructible</a> = std::is_trivially_move_constructible&lt; T &gt;</td></tr>
<tr class="separator:a5c9d00d0810a9683b42e6a4b51cde3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfe9b2fd329532b5e6a1bd52499d7d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1bfe9b2fd329532b5e6a1bd52499d7d6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a1bfe9b2fd329532b5e6a1bd52499d7d6">is_trivially_copy_constructible</a> = std::is_trivially_copy_constructible&lt; T &gt;</td></tr>
<tr class="separator:a1bfe9b2fd329532b5e6a1bd52499d7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4e2dafd0200d2e7686df5c99d07933"><td class="memTemplParams" colspan="2">template&lt;typename RangeType &gt; </td></tr>
<tr class="memitem:abd4e2dafd0200d2e7686df5c99d07933"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#abd4e2dafd0200d2e7686df5c99d07933">ValueTypeFromRangeType</a> = typename std::remove_const&lt; typename std::remove_reference&lt; decltype(*std::begin(std::declval&lt; RangeType &amp; &gt;()))&gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a> &gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a></td></tr>
<tr class="separator:abd4e2dafd0200d2e7686df5c99d07933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31f8b5d3b4b5750e308b9486c8063cf"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a></td></tr>
<tr class="separator:ab31f8b5d3b4b5750e308b9486c8063cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f45c50238ed154108c2d79c37d19ab"><td class="memItemLeft" align="right" valign="top">typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a45f45c50238ed154108c2d79c37d19ab">UTF16</a></td></tr>
<tr class="separator:a45f45c50238ed154108c2d79c37d19ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bbc3b1e95b6409a042b8089d3d8c00"><td class="memItemLeft" align="right" valign="top">typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a></td></tr>
<tr class="separator:a37bbc3b1e95b6409a042b8089d3d8c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9954615e01ad150570a0e1d4548d879"><td class="memItemLeft" align="right" valign="top">typedef bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ac9954615e01ad150570a0e1d4548d879">Boolean</a></td></tr>
<tr class="separator:ac9954615e01ad150570a0e1d4548d879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4422f8f70db09a132698318a6c17c9b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae4422f8f70db09a132698318a6c17c9b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ae4422f8f70db09a132698318a6c17c9b">remove_cvref_t</a> = typename <a class="el" href="structwpi_1_1remove__cvref.html">wpi::remove_cvref</a>&lt; T &gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a></td></tr>
<tr class="separator:ae4422f8f70db09a132698318a6c17c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985e3eb8f9f12493630c5b00866467dd"><td class="memTemplParams" colspan="2">template&lt;typename WrappedIteratorT , typename T1  = std::remove_reference_t&lt;decltype(              **std::declval&lt;WrappedIteratorT&gt;())&gt;, typename T2  = std::add_pointer_t&lt;T1&gt;&gt; </td></tr>
<tr class="memitem:a985e3eb8f9f12493630c5b00866467dd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a985e3eb8f9f12493630c5b00866467dd">raw_pointer_iterator</a> = <a class="el" href="classwpi_1_1pointer__iterator.html">pointer_iterator</a>&lt; <a class="el" href="structwpi_1_1pointee__iterator.html">pointee_iterator</a>&lt; WrappedIteratorT, T1 &gt;, T2 &gt;</td></tr>
<tr class="separator:a985e3eb8f9f12493630c5b00866467dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30c1ffd4dedd4ff88adccac000e4c18"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#af30c1ffd4dedd4ff88adccac000e4c18">http_data_cb</a>) (<a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *, const char *at, size_t length)</td></tr>
<tr class="separator:af30c1ffd4dedd4ff88adccac000e4c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15767624048ad142d04bc6b1eab0d646"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a15767624048ad142d04bc6b1eab0d646">http_cb</a>) (<a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *)</td></tr>
<tr class="separator:a15767624048ad142d04bc6b1eab0d646"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae00dc51f60e3a7f50eea48b914e9f88a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ae00dc51f60e3a7f50eea48b914e9f88a">LogLevel</a> { <br />
&#160;&#160;<a class="el" href="namespacewpi.html#ae00dc51f60e3a7f50eea48b914e9f88aa4eaaa435255d53d8ee1ad804ac2fde9d">WPI_LOG_CRITICAL</a> = 50
, <a class="el" href="namespacewpi.html#ae00dc51f60e3a7f50eea48b914e9f88aabd6cb7f9e35184593c719b52e3269f2e">WPI_LOG_ERROR</a> = 40
, <a class="el" href="namespacewpi.html#ae00dc51f60e3a7f50eea48b914e9f88aae6035e37ce53de5e15e2d11ab3aaa8d2">WPI_LOG_WARNING</a> = 30
, <a class="el" href="namespacewpi.html#ae00dc51f60e3a7f50eea48b914e9f88aafb54895e0b8a35d815e26607f33bc33c">WPI_LOG_INFO</a> = 20
, <br />
&#160;&#160;<a class="el" href="namespacewpi.html#ae00dc51f60e3a7f50eea48b914e9f88aa82615e27834c547fec2af93cf5d4b4a7">WPI_LOG_DEBUG</a> = 10
, <a class="el" href="namespacewpi.html#ae00dc51f60e3a7f50eea48b914e9f88aac7f7f9988bf8b7a36185cd7a19faa576">WPI_LOG_DEBUG1</a> = 9
, <a class="el" href="namespacewpi.html#ae00dc51f60e3a7f50eea48b914e9f88aa749ae7790a80d70497b9b873e51737c4">WPI_LOG_DEBUG2</a> = 8
, <a class="el" href="namespacewpi.html#ae00dc51f60e3a7f50eea48b914e9f88aaec2f6db5ca268bd387c48d6e06c06ecc">WPI_LOG_DEBUG3</a> = 7
, <br />
&#160;&#160;<a class="el" href="namespacewpi.html#ae00dc51f60e3a7f50eea48b914e9f88aae12c0145b954247e75447e15f40ba4e9">WPI_LOG_DEBUG4</a> = 6
<br />
 }</td></tr>
<tr class="separator:ae00dc51f60e3a7f50eea48b914e9f88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc73ce1be7e2680fb97374e03368001"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001">errc</a> { <br />
&#160;&#160;<a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001a1b245b26b5ea3428c050d7f1503d7715">argument_list_too_long</a> = int(std::errc::argument_list_too_long)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001a4b82222a0895b538d0597092b3ceab3e">argument_out_of_domain</a> = int(std::errc::argument_out_of_domain)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001aaf169f73a82794128aa491c4b4f1c071">bad_address</a> = int(std::errc::bad_address)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001a9941c5c8c58ff058b870e94e96ac38e1">bad_file_descriptor</a> = int(std::errc::bad_file_descriptor)
, <br />
&#160;&#160;<a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001a2f0338eed54503152be1d31c93c9c2f1">broken_pipe</a> = int(std::errc::broken_pipe)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001ab3ab5338a00f49c4451851cc5442f370">device_or_resource_busy</a> = int(std::errc::device_or_resource_busy)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001a6a336135d33e62f49edc55f29354e12e">directory_not_empty</a> = int(std::errc::directory_not_empty)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001a4dfaf9c996cf045f32d17edc9754fc95">executable_format_error</a> = int(std::errc::executable_format_error)
, <br />
&#160;&#160;<a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001a41edf636e3c7b59f797348fc58472258">file_exists</a> = int(std::errc::file_exists)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001aa1e14bfb89b41ddf654b1772c8fd2e74">file_too_large</a> = int(std::errc::file_too_large)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001a6e56e6ed055b9771b8192a4f229fee27">filename_too_long</a> = int(std::errc::filename_too_long)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001aa33c516bbdfb179cef733c8daeb97bed">function_not_supported</a> = int(std::errc::function_not_supported)
, <br />
&#160;&#160;<a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001a53a9e57a679708b2d8ff0ccd8ec96b18">illegal_byte_sequence</a> = int(std::errc::illegal_byte_sequence)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001a45fe7da1767194b580aeba752d7b44ae">inappropriate_io_control_operation</a>
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001afadb76763385627e57ec386c9b6038f0">interrupted</a> = int(std::errc::interrupted)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001ae55d43eabeefe5a8271b4a3c898bd18f">invalid_argument</a> = int(std::errc::invalid_argument)
, <br />
&#160;&#160;<a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001abd86a2c65caf6a270b916234ab321ce3">invalid_seek</a> = int(std::errc::invalid_seek)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001acccc32f2a5f7dc7b87d2f85daea66789">io_error</a> = int(std::errc::io_error)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001af3c51d7ea75a76f26c0a2bdc00c4e006">is_a_directory</a> = int(std::errc::is_a_directory)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001ad08d4c854a6810cebd2a8ab61876f919">no_child_process</a> = int(std::errc::no_child_process)
, <br />
&#160;&#160;<a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001a58688487c3e24313637a76bd29881e64">no_lock_available</a> = int(std::errc::no_lock_available)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001a1a5334dd8d1ca56e33887bd44630641b">no_space_on_device</a> = int(std::errc::no_space_on_device)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001a5c83a012eac17bbf458df5804801e373">no_such_device_or_address</a> = int(std::errc::no_such_device_or_address)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001af42b2e58729e2783b683c8610977fc22">no_such_device</a> = int(std::errc::no_such_device)
, <br />
&#160;&#160;<a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001a2e70fc89b08f26fa3fc77694c91e8f7a">no_such_file_or_directory</a> = int(std::errc::no_such_file_or_directory)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001ad91a9b8a734f2bef4b778f89806cbab7">no_such_process</a> = int(std::errc::no_such_process)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001a21e867ca95e1dfecff4701863547dcec">not_a_directory</a> = int(std::errc::not_a_directory)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001aafdb5594dc3e484fc1bfd7c564d550c1">not_enough_memory</a> = int(std::errc::not_enough_memory)
, <br />
&#160;&#160;<a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001aa55e82356e9721946aa9ba954733c6f0">not_supported</a> = int(std::errc::not_supported)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001a8344b3d509942f035d5e303022f9b986">operation_not_permitted</a> = int(std::errc::operation_not_permitted)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001ae8ee838822072f02738dbd7d97ea03fc">permission_denied</a> = int(std::errc::permission_denied)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001a06108efce8ef1cd8aa4cc440f8b4317f">read_only_file_system</a> = int(std::errc::read_only_file_system)
, <br />
&#160;&#160;<a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001aed65f7649c6f0e365673d65a9d8119d8">resource_deadlock_would_occur</a> = int(std::errc::resource_deadlock_would_occur)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001ae46a97ea2906921c8c626890bde832cf">resource_unavailable_try_again</a>
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001a8e0fafb181567cc468e1ee81983d739d">result_out_of_range</a> = int(std::errc::result_out_of_range)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001a3130d1d4e000cdc1e7c47013e313c10e">too_many_files_open_in_system</a> = int(std::errc::too_many_files_open_in_system)
, <br />
&#160;&#160;<a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001aed2c33c8fe874cfeba6f4a7747c62d05">too_many_files_open</a> = int(std::errc::too_many_files_open)
, <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001abfe22fc9b27a8ff13186aba60b6bc5c8">too_many_links</a> = int(std::errc::too_many_links)
<br />
 }</td></tr>
<tr class="separator:a0cc73ce1be7e2680fb97374e03368001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac792221430e4bf80c1b31493afd90bfe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a> { <a class="el" href="namespacewpi.html#ac792221430e4bf80c1b31493afd90bfeaa1d30cd6c73259c50b7ce68207a7650f">conversionOK</a>
, <a class="el" href="namespacewpi.html#ac792221430e4bf80c1b31493afd90bfea673cb258ea483b0e6f31d55cf61311d1">sourceExhausted</a>
, <a class="el" href="namespacewpi.html#ac792221430e4bf80c1b31493afd90bfeac785c0d8e74261d6cbde1d63f8535ed2">targetExhausted</a>
, <a class="el" href="namespacewpi.html#ac792221430e4bf80c1b31493afd90bfea34299b0f92763294d72a3117752dbbe0">sourceIllegal</a>
 }</td></tr>
<tr class="separator:ac792221430e4bf80c1b31493afd90bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6baba019eee7e75848c7c03db9557b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a> { <a class="el" href="namespacewpi.html#aae6baba019eee7e75848c7c03db9557ba32bafada5c584a9590053ed1bf5e7bfb">strictConversion</a> = 0
, <a class="el" href="namespacewpi.html#aae6baba019eee7e75848c7c03db9557ba26ee89af55088fc0f622de938525ad2a">lenientConversion</a>
 }</td></tr>
<tr class="separator:aae6baba019eee7e75848c7c03db9557b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1998965a76e8514d00562232f7b5efb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efb">ZeroBehavior</a> { <a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efba481d3ff2733f6df876f66977ac4e9824">ZB_Undefined</a>
, <a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efba7ca42989d02ebf0e4fb3387724228f43">ZB_Max</a>
, <a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efba9a9cbdc2a1d5bc51861d496d5243a048">ZB_Width</a>
 }</td></tr>
<tr class="memdesc:ad1998965a76e8514d00562232f7b5efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The behavior an operation has on an input of 0.  <a href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efb">More...</a><br /></td></tr>
<tr class="separator:ad1998965a76e8514d00562232f7b5efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89a1f90a8603e399f9cc0465b0ce21e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ae89a1f90a8603e399f9cc0465b0ce21e">http_status</a> </td></tr>
<tr class="separator:ae89a1f90a8603e399f9cc0465b0ce21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3458579fc7214ea6b0411bbadf6ffcbc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a3458579fc7214ea6b0411bbadf6ffcbc">http_method</a> </td></tr>
<tr class="separator:a3458579fc7214ea6b0411bbadf6ffcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37735642db3ab741e86bf064b2ddbbd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ab37735642db3ab741e86bf064b2ddbbd">http_parser_type</a> { <a class="el" href="namespacewpi.html#ab37735642db3ab741e86bf064b2ddbbda83022e72aaa06928c047700a88837608">HTTP_REQUEST</a>
, <a class="el" href="namespacewpi.html#ab37735642db3ab741e86bf064b2ddbbdaa131b28da3205e7a497320d97cead4a5">HTTP_RESPONSE</a>
, <a class="el" href="namespacewpi.html#ab37735642db3ab741e86bf064b2ddbbda404d2d378af4663f27fc14676459b13b">HTTP_BOTH</a>
 }</td></tr>
<tr class="separator:ab37735642db3ab741e86bf064b2ddbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0000b45b0b55789f757f1c3d2461cb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a7b0000b45b0b55789f757f1c3d2461cb">flags</a> { <br />
&#160;&#160;<a class="el" href="namespacewpi.html#a7b0000b45b0b55789f757f1c3d2461cba22ea0cf0d50ecfe6b139d83ecc83d8df">F_CHUNKED</a> = 1 &lt;&lt; 0
, <a class="el" href="namespacewpi.html#a7b0000b45b0b55789f757f1c3d2461cbaf14c04cd6f0125dbeceaf61b94fb1352">F_CONNECTION_KEEP_ALIVE</a> = 1 &lt;&lt; 1
, <a class="el" href="namespacewpi.html#a7b0000b45b0b55789f757f1c3d2461cba78a204621316260f385954c3bb0fff0f">F_CONNECTION_CLOSE</a> = 1 &lt;&lt; 2
, <a class="el" href="namespacewpi.html#a7b0000b45b0b55789f757f1c3d2461cba608843554e95e8438ea48d18e8034043">F_CONNECTION_UPGRADE</a> = 1 &lt;&lt; 3
, <br />
&#160;&#160;<a class="el" href="namespacewpi.html#a7b0000b45b0b55789f757f1c3d2461cba819c3d4c4621c49323e997ef186e81cb">F_TRAILING</a> = 1 &lt;&lt; 4
, <a class="el" href="namespacewpi.html#a7b0000b45b0b55789f757f1c3d2461cba91bd0dc716ef59be0726782a89b3fe42">F_UPGRADE</a> = 1 &lt;&lt; 5
, <a class="el" href="namespacewpi.html#a7b0000b45b0b55789f757f1c3d2461cba0741b53c2752382134a5c1548c4af772">F_SKIPBODY</a> = 1 &lt;&lt; 6
, <a class="el" href="namespacewpi.html#a7b0000b45b0b55789f757f1c3d2461cba63d30d0cca722219ca11f554a1adf1df">F_CONTENTLENGTH</a> = 1 &lt;&lt; 7
<br />
 }</td></tr>
<tr class="separator:a7b0000b45b0b55789f757f1c3d2461cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e56bd09798339ac4f86d36eb8ecea0b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a0e56bd09798339ac4f86d36eb8ecea0b">http_errno</a> </td></tr>
<tr class="separator:a0e56bd09798339ac4f86d36eb8ecea0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a0b479c88b876facf868f0c7a6b598"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#af3a0b479c88b876facf868f0c7a6b598">http_parser_url_fields</a> { <br />
&#160;&#160;<a class="el" href="namespacewpi.html#af3a0b479c88b876facf868f0c7a6b598a0fc67d54599dc5b503765fb0792e2a54">UF_SCHEMA</a> = 0
, <a class="el" href="namespacewpi.html#af3a0b479c88b876facf868f0c7a6b598af8e30e235a6bdffaac9f1945ce205851">UF_HOST</a> = 1
, <a class="el" href="namespacewpi.html#af3a0b479c88b876facf868f0c7a6b598afb2e77eaed47bcfcfee307b2e1aff53a">UF_PORT</a> = 2
, <a class="el" href="namespacewpi.html#af3a0b479c88b876facf868f0c7a6b598a45e701521a7ea4616989a7ed22cd0ae1">UF_PATH</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacewpi.html#af3a0b479c88b876facf868f0c7a6b598a0e308fa010b3352bb15d9dee67b5b6ff">UF_QUERY</a> = 4
, <a class="el" href="namespacewpi.html#af3a0b479c88b876facf868f0c7a6b598a8534d7d9e32ee9a877dddc70f7abdefd">UF_FRAGMENT</a> = 5
, <a class="el" href="namespacewpi.html#af3a0b479c88b876facf868f0c7a6b598ae015b71bf6bfa3cfe09f78f1c9360235">UF_USERINFO</a> = 6
, <a class="el" href="namespacewpi.html#af3a0b479c88b876facf868f0c7a6b598ac6a7f4a78be5640ed5c926efaf8301c2">UF_MAX</a> = 7
<br />
 }</td></tr>
<tr class="separator:af3a0b479c88b876facf868f0c7a6b598"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aed245bfb118e5dfe475bf2044a4985d8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed245bfb118e5dfe475bf2044a4985d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1future.html">future</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#aed245bfb118e5dfe475bf2044a4985d8">make_ready_future</a> (T &amp;&amp;<a class="el" href="classvalue.html">value</a>)</td></tr>
<tr class="memdesc:aed245bfb118e5dfe475bf2044a4985d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a valid future with the value set.  <a href="namespacewpi.html#aed245bfb118e5dfe475bf2044a4985d8">More...</a><br /></td></tr>
<tr class="separator:aed245bfb118e5dfe475bf2044a4985d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a0d64a50babc1c46b2ede08a2cf13d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1future.html">future</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a21a0d64a50babc1c46b2ede08a2cf13d">make_ready_future</a> ()</td></tr>
<tr class="memdesc:a21a0d64a50babc1c46b2ede08a2cf13d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a valid future with the value set.  <a href="namespacewpi.html#a21a0d64a50babc1c46b2ede08a2cf13d">More...</a><br /></td></tr>
<tr class="separator:a21a0d64a50babc1c46b2ede08a2cf13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad487e5ec5a2101d1f02907c77dd50558"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:ad487e5ec5a2101d1f02907c77dd50558"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ad487e5ec5a2101d1f02907c77dd50558">array</a> (T, Ts...) -&gt; <a class="el" href="classwpi_1_1array.html">array</a>&lt; <a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt;(std::is_same_v&lt; T, Ts &gt; &amp;&amp;...), T &gt;, 1+sizeof...(Ts)&gt;</td></tr>
<tr class="separator:ad487e5ec5a2101d1f02907c77dd50558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ea49dcab711bb9a5e64a569c32241b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a36ea49dcab711bb9a5e64a569c32241b">SizeUleb128</a> (uint64_t val)</td></tr>
<tr class="memdesc:a36ea49dcab711bb9a5e64a569c32241b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of unsigned LEB128 data.  <a href="namespacewpi.html#a36ea49dcab711bb9a5e64a569c32241b">More...</a><br /></td></tr>
<tr class="separator:a36ea49dcab711bb9a5e64a569c32241b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3dac2f55476ec2190adf33d5a123cf4"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ab3dac2f55476ec2190adf33d5a123cf4">WriteUleb128</a> (<a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;dest, uint64_t val)</td></tr>
<tr class="memdesc:ab3dac2f55476ec2190adf33d5a123cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write unsigned LEB128 data.  <a href="namespacewpi.html#ab3dac2f55476ec2190adf33d5a123cf4">More...</a><br /></td></tr>
<tr class="separator:ab3dac2f55476ec2190adf33d5a123cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d290fcc6f4ff08f10afc9eb18d5af16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a1d290fcc6f4ff08f10afc9eb18d5af16">WriteUleb128</a> (<a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;os, uint64_t val)</td></tr>
<tr class="memdesc:a1d290fcc6f4ff08f10afc9eb18d5af16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write unsigned LEB128 data.  <a href="namespacewpi.html#a1d290fcc6f4ff08f10afc9eb18d5af16">More...</a><br /></td></tr>
<tr class="separator:a1d290fcc6f4ff08f10afc9eb18d5af16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486cee9c105ed0e242f6c00183c682f3"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a486cee9c105ed0e242f6c00183c682f3">ReadUleb128</a> (const char *addr, uint64_t *ret)</td></tr>
<tr class="memdesc:a486cee9c105ed0e242f6c00183c682f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read unsigned LEB128 data.  <a href="namespacewpi.html#a486cee9c105ed0e242f6c00183c682f3">More...</a><br /></td></tr>
<tr class="separator:a486cee9c105ed0e242f6c00183c682f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4e972587009901ad40bc390e4bb8db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ade4e972587009901ad40bc390e4bb8db">ReadUleb128</a> (<a class="el" href="classwpi_1_1raw__istream.html">raw_istream</a> &amp;is, uint64_t *ret)</td></tr>
<tr class="memdesc:ade4e972587009901ad40bc390e4bb8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read unsigned LEB128 data from a stream.  <a href="namespacewpi.html#ade4e972587009901ad40bc390e4bb8db">More...</a><br /></td></tr>
<tr class="separator:ade4e972587009901ad40bc390e4bb8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84cf72de6e08899df61612e400beff1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#aa84cf72de6e08899df61612e400beff1">Base64Decode</a> (<a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;os, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> encoded)</td></tr>
<tr class="separator:aa84cf72de6e08899df61612e400beff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2dec1800b8c82d4cb942493afc4a828"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#af2dec1800b8c82d4cb942493afc4a828">Base64Decode</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> encoded, std::string *plain)</td></tr>
<tr class="separator:af2dec1800b8c82d4cb942493afc4a828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac503c8c47490fca90512a88b23b65358"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ac503c8c47490fca90512a88b23b65358">Base64Decode</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> encoded, size_t *num_read, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;buf)</td></tr>
<tr class="separator:ac503c8c47490fca90512a88b23b65358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c4d7b36efb76fd101c8cd219c9bdb8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a46c4d7b36efb76fd101c8cd219c9bdb8">Base64Decode</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> encoded, std::vector&lt; uint8_t &gt; *plain)</td></tr>
<tr class="separator:a46c4d7b36efb76fd101c8cd219c9bdb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa145997bec65a8d0e2b783c384a6e3e4"><td class="memItemLeft" align="right" valign="top">std::span&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#aa145997bec65a8d0e2b783c384a6e3e4">Base64Decode</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> encoded, size_t *num_read, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; uint8_t &gt; &amp;buf)</td></tr>
<tr class="separator:aa145997bec65a8d0e2b783c384a6e3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0cca388f8042851ed82359d23c61e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a8f0cca388f8042851ed82359d23c61e9">Base64Encode</a> (<a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;os, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> plain)</td></tr>
<tr class="separator:a8f0cca388f8042851ed82359d23c61e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4351dc23f99c30ed993190988f3da889"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a4351dc23f99c30ed993190988f3da889">Base64Encode</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> plain, std::string *encoded)</td></tr>
<tr class="separator:a4351dc23f99c30ed993190988f3da889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfd836e85f4e66313113339d542ae76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#adbfd836e85f4e66313113339d542ae76">Base64Encode</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> plain, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;buf)</td></tr>
<tr class="separator:adbfd836e85f4e66313113339d542ae76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d319e2a72f572e4fbdbb2017fd203e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ad2d319e2a72f572e4fbdbb2017fd203e">Base64Encode</a> (<a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;os, std::span&lt; const uint8_t &gt; plain)</td></tr>
<tr class="separator:ad2d319e2a72f572e4fbdbb2017fd203e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f1eed3c192da2db90b3d0ab15d24c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a94f1eed3c192da2db90b3d0ab15d24c8">Base64Encode</a> (std::span&lt; const uint8_t &gt; plain, std::string *encoded)</td></tr>
<tr class="separator:a94f1eed3c192da2db90b3d0ab15d24c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c10d4e853c1b2027f22c23c46106f15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a3c10d4e853c1b2027f22c23c46106f15">Base64Encode</a> (std::span&lt; const uint8_t &gt; plain, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;buf)</td></tr>
<tr class="separator:a3c10d4e853c1b2027f22c23c46106f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf0701ba0d3863a755e0b2a1cc08603"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbf0701ba0d3863a755e0b2a1cc08603"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::span&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#abbf0701ba0d3863a755e0b2a1cc08603">drop_front</a> (std::span&lt; T &gt; in, typename std::span&lt; T &gt;::size_type n=1)</td></tr>
<tr class="memdesc:abbf0701ba0d3863a755e0b2a1cc08603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the first <code>N</code> elements of the array.  <a href="namespacewpi.html#abbf0701ba0d3863a755e0b2a1cc08603">More...</a><br /></td></tr>
<tr class="separator:abbf0701ba0d3863a755e0b2a1cc08603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b74b99b021d98ad0b415c12920f259"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a58b74b99b021d98ad0b415c12920f259"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::span&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a58b74b99b021d98ad0b415c12920f259">drop_back</a> (std::span&lt; T &gt; in, typename std::span&lt; T &gt;::size_type n=1)</td></tr>
<tr class="memdesc:a58b74b99b021d98ad0b415c12920f259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the last <code>N</code> elements of the array.  <a href="namespacewpi.html#a58b74b99b021d98ad0b415c12920f259">More...</a><br /></td></tr>
<tr class="separator:a58b74b99b021d98ad0b415c12920f259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7e386e354d5ee78df311f700c7fae0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a1e7e386e354d5ee78df311f700c7fae0">Demangle</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> mangledSymbol)</td></tr>
<tr class="memdesc:a1e7e386e354d5ee78df311f700c7fae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Demangle a C++ symbol.  <a href="namespacewpi.html#a1e7e386e354d5ee78df311f700c7fae0">More...</a><br /></td></tr>
<tr class="separator:a1e7e386e354d5ee78df311f700c7fae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b125df3c2eaae6f9b8cd09ccd9da98d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a4b125df3c2eaae6f9b8cd09ccd9da98d">GetStackTrace</a> (int offset)</td></tr>
<tr class="memdesc:a4b125df3c2eaae6f9b8cd09ccd9da98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a stack trace, ignoring the first "offset" symbols.  <a href="namespacewpi.html#a4b125df3c2eaae6f9b8cd09ccd9da98d">More...</a><br /></td></tr>
<tr class="separator:a4b125df3c2eaae6f9b8cd09ccd9da98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c7ea157a96be60befa9ba11407f839"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a17c7ea157a96be60befa9ba11407f839">GetStackTraceDefault</a> (int offset)</td></tr>
<tr class="memdesc:a17c7ea157a96be60befa9ba11407f839"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default implementation used for <a class="el" href="namespacewpi.html#a4b125df3c2eaae6f9b8cd09ccd9da98d" title="Get a stack trace, ignoring the first &quot;offset&quot; symbols.">GetStackTrace()</a>.  <a href="namespacewpi.html#a17c7ea157a96be60befa9ba11407f839">More...</a><br /></td></tr>
<tr class="separator:a17c7ea157a96be60befa9ba11407f839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3776b907dc530ce3556e36bcb5a68462"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a3776b907dc530ce3556e36bcb5a68462">SetGetStackTraceImpl</a> (std::string(*func)(int offset))</td></tr>
<tr class="memdesc:a3776b907dc530ce3556e36bcb5a68462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the implementation used by <a class="el" href="namespacewpi.html#a4b125df3c2eaae6f9b8cd09ccd9da98d" title="Get a stack trace, ignoring the first &quot;offset&quot; symbols.">GetStackTrace()</a>.  <a href="namespacewpi.html#a3776b907dc530ce3556e36bcb5a68462">More...</a><br /></td></tr>
<tr class="separator:a3776b907dc530ce3556e36bcb5a68462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e2b9c52f4cd86842aa577863b93c2a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab9e2b9c52f4cd86842aa577863b93c2a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ab9e2b9c52f4cd86842aa577863b93c2a">insert_sorted</a> (std::vector&lt; T &gt; &amp;vec, T const &amp;item)</td></tr>
<tr class="separator:ab9e2b9c52f4cd86842aa577863b93c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb20671f09fd21f4f52662c86fd6521"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a6bb20671f09fd21f4f52662c86fd6521">make_error_code</a> (<a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001">errc</a> E)</td></tr>
<tr class="separator:a6bb20671f09fd21f4f52662c86fd6521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad70263229589236b932dc5ec227436"><td class="memTemplParams" colspan="2">template&lt;typename OStream , typename T &gt; </td></tr>
<tr class="memitem:afad70263229589236b932dc5ec227436"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt;!std::is_reference&lt; OStream &gt;<a class="el" href="classvalue.html">::value</a> &amp;&amp;std::is_base_of&lt; <a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a>, OStream &gt;<a class="el" href="classvalue.html">::value</a>, OStream &amp;&amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#afad70263229589236b932dc5ec227436">operator&lt;&lt;</a> (OStream &amp;&amp;OS, const T &amp;Value)</td></tr>
<tr class="memdesc:afad70263229589236b932dc5ec227436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the appropriate insertion operator, given an rvalue reference to a <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> object and return a stream of the same type as the argument.  <a href="namespacewpi.html#afad70263229589236b932dc5ec227436">More...</a><br /></td></tr>
<tr class="separator:afad70263229589236b932dc5ec227436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc9cf60e707bfcf728eb04c4e4b8d2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1raw__fd__ostream.html">raw_fd_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a4cc9cf60e707bfcf728eb04c4e4b8d2e">outs</a> ()</td></tr>
<tr class="memdesc:a4cc9cf60e707bfcf728eb04c4e4b8d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a reference to a <a class="el" href="classwpi_1_1raw__fd__ostream.html" title="A raw_ostream that writes to a file descriptor.">raw_fd_ostream</a> for standard output.  <a href="namespacewpi.html#a4cc9cf60e707bfcf728eb04c4e4b8d2e">More...</a><br /></td></tr>
<tr class="separator:a4cc9cf60e707bfcf728eb04c4e4b8d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca972941e2effcb07cfc0e14b7c783f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1raw__fd__ostream.html">raw_fd_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#aca972941e2effcb07cfc0e14b7c783f6">errs</a> ()</td></tr>
<tr class="memdesc:aca972941e2effcb07cfc0e14b7c783f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a reference to a <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> for standard error.  <a href="namespacewpi.html#aca972941e2effcb07cfc0e14b7c783f6">More...</a><br /></td></tr>
<tr class="separator:aca972941e2effcb07cfc0e14b7c783f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40031774febe762423c2bf6bb4e0094b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a40031774febe762423c2bf6bb4e0094b">nulls</a> ()</td></tr>
<tr class="memdesc:a40031774febe762423c2bf6bb4e0094b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a reference to a <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> which simply discards output.  <a href="namespacewpi.html#a40031774febe762423c2bf6bb4e0094b">More...</a><br /></td></tr>
<tr class="separator:a40031774febe762423c2bf6bb4e0094b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf26bf198ea436f545bf8205670ff7a"><td class="memTemplParams" colspan="2">template&lt;class T  = void *&gt; </td></tr>
<tr class="memitem:afbf26bf198ea436f545bf8205670ff7a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#afbf26bf198ea436f545bf8205670ff7a">shouldReverseIterate</a> ()</td></tr>
<tr class="separator:afbf26bf198ea436f545bf8205670ff7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3287d2b8e67eaf00c1f275eb1d2b1fd8"><td class="memTemplParams" colspan="2">template&lt;typename ... PTs&gt; </td></tr>
<tr class="memitem:a3287d2b8e67eaf00c1f275eb1d2b1fd8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a3287d2b8e67eaf00c1f275eb1d2b1fd8">operator==</a> (<a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt; lhs, <a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt; rhs)</td></tr>
<tr class="separator:a3287d2b8e67eaf00c1f275eb1d2b1fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088be308371a5cee44b52aedf5a619e7"><td class="memTemplParams" colspan="2">template&lt;typename ... PTs&gt; </td></tr>
<tr class="memitem:a088be308371a5cee44b52aedf5a619e7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a088be308371a5cee44b52aedf5a619e7">operator!=</a> (<a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt; lhs, <a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt; rhs)</td></tr>
<tr class="separator:a088be308371a5cee44b52aedf5a619e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e03174a92e237c3b5544c57d3dee498"><td class="memTemplParams" colspan="2">template&lt;typename ... PTs&gt; </td></tr>
<tr class="memitem:a4e03174a92e237c3b5544c57d3dee498"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a4e03174a92e237c3b5544c57d3dee498">operator&lt;</a> (<a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt; lhs, <a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt; rhs)</td></tr>
<tr class="separator:a4e03174a92e237c3b5544c57d3dee498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2da1fed2899fcfbd9f07d967326a525"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#af2da1fed2899fcfbd9f07d967326a525">ByteSwap_16</a> (uint16_t <a class="el" href="classvalue.html">value</a>)</td></tr>
<tr class="memdesc:af2da1fed2899fcfbd9f07d967326a525"><td class="mdescLeft">&#160;</td><td class="mdescRight">ByteSwap_16 - This function returns a byte-swapped representation of the 16-bit argument.  <a href="namespacewpi.html#af2da1fed2899fcfbd9f07d967326a525">More...</a><br /></td></tr>
<tr class="separator:af2da1fed2899fcfbd9f07d967326a525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1253127a996aadeccdec1c291d6ab1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a0b1253127a996aadeccdec1c291d6ab1">ByteSwap_32</a> (uint32_t <a class="el" href="classvalue.html">value</a>)</td></tr>
<tr class="memdesc:a0b1253127a996aadeccdec1c291d6ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a byte-swapped representation of the 32-bit argument.  <a href="namespacewpi.html#a0b1253127a996aadeccdec1c291d6ab1">More...</a><br /></td></tr>
<tr class="separator:a0b1253127a996aadeccdec1c291d6ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580a8d7ed139da4a7e9b6685138df8fa"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a580a8d7ed139da4a7e9b6685138df8fa">ByteSwap_64</a> (uint64_t <a class="el" href="classvalue.html">value</a>)</td></tr>
<tr class="memdesc:a580a8d7ed139da4a7e9b6685138df8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a byte-swapped representation of the 64-bit argument.  <a href="namespacewpi.html#a580a8d7ed139da4a7e9b6685138df8fa">More...</a><br /></td></tr>
<tr class="separator:a580a8d7ed139da4a7e9b6685138df8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309bc670f1bda6373a69c5a66eb9849a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a309bc670f1bda6373a69c5a66eb9849a">install_fatal_error_handler</a> (<a class="el" href="namespacewpi.html#aacde1332b72e968317ed516552a07ca8">fatal_error_handler_t</a> handler, void *user_data=nullptr)</td></tr>
<tr class="memdesc:a309bc670f1bda6373a69c5a66eb9849a"><td class="mdescLeft">&#160;</td><td class="mdescRight">install_fatal_error_handler - Installs a new error handler to be used whenever a serious (non-recoverable) error is encountered by LLVM.  <a href="namespacewpi.html#a309bc670f1bda6373a69c5a66eb9849a">More...</a><br /></td></tr>
<tr class="separator:a309bc670f1bda6373a69c5a66eb9849a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d89324acbf36872064573065959d20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a08d89324acbf36872064573065959d20">remove_fatal_error_handler</a> ()</td></tr>
<tr class="memdesc:a08d89324acbf36872064573065959d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores default error handling behavior.  <a href="namespacewpi.html#a08d89324acbf36872064573065959d20">More...</a><br /></td></tr>
<tr class="separator:a08d89324acbf36872064573065959d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6392584571d4e2bec4247503254d83a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a6392584571d4e2bec4247503254d83a3">report_fatal_error</a> (const char *reason, bool gen_crash_diag=true)</td></tr>
<tr class="memdesc:a6392584571d4e2bec4247503254d83a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports a serious error, calling any installed error handler.  <a href="namespacewpi.html#a6392584571d4e2bec4247503254d83a3">More...</a><br /></td></tr>
<tr class="separator:a6392584571d4e2bec4247503254d83a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2f5ea71a00431f1def0f2d7daf7af3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a2a2f5ea71a00431f1def0f2d7daf7af3">report_fatal_error</a> (const std::string &amp;reason, bool gen_crash_diag=true)</td></tr>
<tr class="separator:a2a2f5ea71a00431f1def0f2d7daf7af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5d4610f996de2254ee2eca97aa2da6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a9c5d4610f996de2254ee2eca97aa2da6">report_fatal_error</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> reason, bool gen_crash_diag=true)</td></tr>
<tr class="separator:a9c5d4610f996de2254ee2eca97aa2da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5490819a8d9ceedb98494b59ed05917"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ad5490819a8d9ceedb98494b59ed05917">install_bad_alloc_error_handler</a> (<a class="el" href="namespacewpi.html#aacde1332b72e968317ed516552a07ca8">fatal_error_handler_t</a> handler, void *user_data=nullptr)</td></tr>
<tr class="memdesc:ad5490819a8d9ceedb98494b59ed05917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a new bad alloc error handler that should be used whenever a bad alloc error, e.g.  <a href="namespacewpi.html#ad5490819a8d9ceedb98494b59ed05917">More...</a><br /></td></tr>
<tr class="separator:ad5490819a8d9ceedb98494b59ed05917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69094b92cf05fe59b51ae012a03d9474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a69094b92cf05fe59b51ae012a03d9474">remove_bad_alloc_error_handler</a> ()</td></tr>
<tr class="memdesc:a69094b92cf05fe59b51ae012a03d9474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores default bad alloc error handling behavior.  <a href="namespacewpi.html#a69094b92cf05fe59b51ae012a03d9474">More...</a><br /></td></tr>
<tr class="separator:a69094b92cf05fe59b51ae012a03d9474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97e6b598cd8e5fe3f4d4e75e83dbb9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ad97e6b598cd8e5fe3f4d4e75e83dbb9e">install_out_of_memory_new_handler</a> ()</td></tr>
<tr class="separator:ad97e6b598cd8e5fe3f4d4e75e83dbb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3cd886beda7a2289aa18773f3aa103"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a6e3cd886beda7a2289aa18773f3aa103">report_bad_alloc_error</a> (const char *Reason, bool GenCrashDiag=true)</td></tr>
<tr class="memdesc:a6e3cd886beda7a2289aa18773f3aa103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports a bad alloc error, calling any user defined bad alloc error handler.  <a href="namespacewpi.html#a6e3cd886beda7a2289aa18773f3aa103">More...</a><br /></td></tr>
<tr class="separator:a6e3cd886beda7a2289aa18773f3aa103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a330e37a0f2a3ac6bf2a664ea6d12db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a0a330e37a0f2a3ac6bf2a664ea6d12db">wpi_unreachable_internal</a> (const char *msg=nullptr, const char *<a class="el" href="_third_party_notices_8txt.html#a54c3aaa43358b77e4f57f4f72cbe56c6">file</a>=nullptr, unsigned line=0)</td></tr>
<tr class="memdesc:a0a330e37a0f2a3ac6bf2a664ea6d12db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calls abort(), and prints the optional message to stderr.  <a href="namespacewpi.html#a0a330e37a0f2a3ac6bf2a664ea6d12db">More...</a><br /></td></tr>
<tr class="separator:a0a330e37a0f2a3ac6bf2a664ea6d12db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95acb3c2c107b75867a237c1701577c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa95acb3c2c107b75867a237c1701577c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt; <a class="el" href="classwpi_1_1is__integral__or__enum.html">is_integral_or_enum</a>&lt; T &gt;<a class="el" href="classvalue.html">::value</a>, <a class="el" href="classwpi_1_1hash__code.html">hash_code</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#aa95acb3c2c107b75867a237c1701577c">hash_value</a> (T <a class="el" href="classvalue.html">value</a>)</td></tr>
<tr class="memdesc:aa95acb3c2c107b75867a237c1701577c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for any integer value.  <a href="namespacewpi.html#aa95acb3c2c107b75867a237c1701577c">More...</a><br /></td></tr>
<tr class="separator:aa95acb3c2c107b75867a237c1701577c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb96f94c028542a238feaf8cabb44dc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8eb96f94c028542a238feaf8cabb44dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a8eb96f94c028542a238feaf8cabb44dc">hash_value</a> (const T *<a class="el" href="format_8h.html#aa6ec2d4315570f27d9637ce3c770e787">ptr</a>)</td></tr>
<tr class="memdesc:a8eb96f94c028542a238feaf8cabb44dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a pointer's address.  <a href="namespacewpi.html#a8eb96f94c028542a238feaf8cabb44dc">More...</a><br /></td></tr>
<tr class="separator:a8eb96f94c028542a238feaf8cabb44dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9238bfb621b5c47abfc9480889408e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a6b9238bfb621b5c47abfc9480889408e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a6b9238bfb621b5c47abfc9480889408e">hash_value</a> (const std::pair&lt; T, U &gt; &amp;<a class="el" href="_array_cwise_unary_ops_8h.html#a41ceecca5805bbcbeb0928339a0714da">arg</a>)</td></tr>
<tr class="memdesc:a6b9238bfb621b5c47abfc9480889408e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a pair of objects.  <a href="namespacewpi.html#a6b9238bfb621b5c47abfc9480889408e">More...</a><br /></td></tr>
<tr class="separator:a6b9238bfb621b5c47abfc9480889408e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09058a5e42b0bee35ae7f6d7bf0822a0"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a09058a5e42b0bee35ae7f6d7bf0822a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a09058a5e42b0bee35ae7f6d7bf0822a0">hash_value</a> (const std::tuple&lt; Ts... &gt; &amp;<a class="el" href="_array_cwise_unary_ops_8h.html#a41ceecca5805bbcbeb0928339a0714da">arg</a>)</td></tr>
<tr class="memdesc:a09058a5e42b0bee35ae7f6d7bf0822a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a tuple.  <a href="namespacewpi.html#a09058a5e42b0bee35ae7f6d7bf0822a0">More...</a><br /></td></tr>
<tr class="separator:a09058a5e42b0bee35ae7f6d7bf0822a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2f8fc1e0870f5b219a8bc1d3654ecc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8e2f8fc1e0870f5b219a8bc1d3654ecc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a8e2f8fc1e0870f5b219a8bc1d3654ecc">hash_value</a> (const std::basic_string&lt; T &gt; &amp;<a class="el" href="_array_cwise_unary_ops_8h.html#a41ceecca5805bbcbeb0928339a0714da">arg</a>)</td></tr>
<tr class="memdesc:a8e2f8fc1e0870f5b219a8bc1d3654ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a standard string.  <a href="namespacewpi.html#a8e2f8fc1e0870f5b219a8bc1d3654ecc">More...</a><br /></td></tr>
<tr class="separator:a8e2f8fc1e0870f5b219a8bc1d3654ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9199d95a0d0ca4ba23a42b8c9cd4763"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ab9199d95a0d0ca4ba23a42b8c9cd4763">set_fixed_execution_hash_seed</a> (uint64_t fixed_value)</td></tr>
<tr class="memdesc:ab9199d95a0d0ca4ba23a42b8c9cd4763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override the execution seed with a fixed value.  <a href="namespacewpi.html#ab9199d95a0d0ca4ba23a42b8c9cd4763">More...</a><br /></td></tr>
<tr class="separator:ab9199d95a0d0ca4ba23a42b8c9cd4763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583ca8bbb8e3ee49e8f65df91a6ecaaf"><td class="memTemplParams" colspan="2">template&lt;typename InputIteratorT &gt; </td></tr>
<tr class="memitem:a583ca8bbb8e3ee49e8f65df91a6ecaaf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a583ca8bbb8e3ee49e8f65df91a6ecaaf">hash_combine_range</a> (InputIteratorT first, InputIteratorT last)</td></tr>
<tr class="memdesc:a583ca8bbb8e3ee49e8f65df91a6ecaaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a sequence of values.  <a href="namespacewpi.html#a583ca8bbb8e3ee49e8f65df91a6ecaaf">More...</a><br /></td></tr>
<tr class="separator:a583ca8bbb8e3ee49e8f65df91a6ecaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a8888fe7cb03223848f14e95e42764"><td class="memTemplParams" colspan="2">template&lt;typename ... Ts&gt; </td></tr>
<tr class="memitem:a70a8888fe7cb03223848f14e95e42764"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a70a8888fe7cb03223848f14e95e42764">hash_combine</a> (const Ts &amp;...args)</td></tr>
<tr class="memdesc:a70a8888fe7cb03223848f14e95e42764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine values into a single <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a>.  <a href="namespacewpi.html#a70a8888fe7cb03223848f14e95e42764">More...</a><br /></td></tr>
<tr class="separator:a70a8888fe7cb03223848f14e95e42764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc327c9a551f61642d9a6ef107c4593"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aacc327c9a551f61642d9a6ef107c4593"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1iterator__range.html">iterator_range</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#aacc327c9a551f61642d9a6ef107c4593">make_range</a> (T x, T y)</td></tr>
<tr class="memdesc:aacc327c9a551f61642d9a6ef107c4593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for iterating over sub-ranges.  <a href="namespacewpi.html#aacc327c9a551f61642d9a6ef107c4593">More...</a><br /></td></tr>
<tr class="separator:aacc327c9a551f61642d9a6ef107c4593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b2b7a19d614a944822ce6f577be33a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad1b2b7a19d614a944822ce6f577be33a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1iterator__range.html">iterator_range</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ad1b2b7a19d614a944822ce6f577be33a">make_range</a> (std::pair&lt; T, T &gt; p)</td></tr>
<tr class="separator:ad1b2b7a19d614a944822ce6f577be33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d4bc587263ead52e3057e41d1bcad8"><td class="memTemplParams" colspan="2">template&lt;typename ValueTy &gt; </td></tr>
<tr class="memitem:a20d4bc587263ead52e3057e41d1bcad8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a20d4bc587263ead52e3057e41d1bcad8">operator==</a> (const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;lhs, const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;rhs)</td></tr>
<tr class="separator:a20d4bc587263ead52e3057e41d1bcad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5de24f32a5e0e34e26400e1d2d019ab"><td class="memTemplParams" colspan="2">template&lt;typename ValueTy &gt; </td></tr>
<tr class="memitem:ae5de24f32a5e0e34e26400e1d2d019ab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ae5de24f32a5e0e34e26400e1d2d019ab">operator!=</a> (const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;lhs, const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;rhs)</td></tr>
<tr class="separator:ae5de24f32a5e0e34e26400e1d2d019ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0497f3ae3790ae4464ca31a28110983f"><td class="memTemplParams" colspan="2">template&lt;typename ValueTy &gt; </td></tr>
<tr class="memitem:a0497f3ae3790ae4464ca31a28110983f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a0497f3ae3790ae4464ca31a28110983f">operator&lt;</a> (const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;lhs, const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;rhs)</td></tr>
<tr class="separator:a0497f3ae3790ae4464ca31a28110983f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9955629bd414f4388de1629bbe618d"><td class="memTemplParams" colspan="2">template&lt;typename ValueTy &gt; </td></tr>
<tr class="memitem:afe9955629bd414f4388de1629bbe618d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#afe9955629bd414f4388de1629bbe618d">operator&lt;=</a> (const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;lhs, const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;rhs)</td></tr>
<tr class="separator:afe9955629bd414f4388de1629bbe618d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f5d37ffdbdece9dc4a138912d2384d"><td class="memTemplParams" colspan="2">template&lt;typename ValueTy &gt; </td></tr>
<tr class="memitem:af9f5d37ffdbdece9dc4a138912d2384d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#af9f5d37ffdbdece9dc4a138912d2384d">operator&gt;</a> (const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;lhs, const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;rhs)</td></tr>
<tr class="separator:af9f5d37ffdbdece9dc4a138912d2384d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5ef98f7e590a36648bdff48b4dfc57"><td class="memTemplParams" colspan="2">template&lt;typename ValueTy &gt; </td></tr>
<tr class="memitem:a0f5ef98f7e590a36648bdff48b4dfc57"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a0f5ef98f7e590a36648bdff48b4dfc57">operator&gt;=</a> (const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;lhs, const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;rhs)</td></tr>
<tr class="separator:a0f5ef98f7e590a36648bdff48b4dfc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e35647cd9f9f0d2c097ea72e6d9f608"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned N&gt; </td></tr>
<tr class="memitem:a0e35647cd9f9f0d2c097ea72e6d9f608"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a0e35647cd9f9f0d2c097ea72e6d9f608">capacity_in_bytes</a> (const <a class="el" href="classwpi_1_1_small_vector.html">SmallVector</a>&lt; T, N &gt; &amp;X)</td></tr>
<tr class="separator:a0e35647cd9f9f0d2c097ea72e6d9f608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5602e08ef8bfc0486d71717a291a06b4"><td class="memTemplParams" colspan="2">template&lt;unsigned Size, typename R &gt; </td></tr>
<tr class="memitem:a5602e08ef8bfc0486d71717a291a06b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1_small_vector.html">SmallVector</a>&lt; <a class="el" href="namespacewpi.html#abd4e2dafd0200d2e7686df5c99d07933">ValueTypeFromRangeType</a>&lt; R &gt;, Size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a5602e08ef8bfc0486d71717a291a06b4">to_vector</a> (R &amp;&amp;Range)</td></tr>
<tr class="memdesc:a5602e08ef8bfc0486d71717a291a06b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a range of type R, iterate the entire range and return a <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> with elements of the vector.  <a href="namespacewpi.html#a5602e08ef8bfc0486d71717a291a06b4">More...</a><br /></td></tr>
<tr class="separator:a5602e08ef8bfc0486d71717a291a06b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47d27507d50af1b79e67593bf1e8dc6"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:ab47d27507d50af1b79e67593bf1e8dc6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1_small_vector.html">SmallVector</a>&lt; <a class="el" href="namespacewpi.html#abd4e2dafd0200d2e7686df5c99d07933">ValueTypeFromRangeType</a>&lt; R &gt;, <a class="el" href="structwpi_1_1_calculate_small_vector_default_inlined_elements.html">CalculateSmallVectorDefaultInlinedElements</a>&lt; <a class="el" href="namespacewpi.html#abd4e2dafd0200d2e7686df5c99d07933">ValueTypeFromRangeType</a>&lt; R &gt; &gt;<a class="el" href="classvalue.html">::value</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ab47d27507d50af1b79e67593bf1e8dc6">to_vector</a> (R &amp;&amp;Range)</td></tr>
<tr class="separator:ab47d27507d50af1b79e67593bf1e8dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bada7642f7a62d2271fd42cd0cb01f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacewpi.html#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a4bada7642f7a62d2271fd42cd0cb01f3">ConvertUTF8toUTF16</a> (const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **sourceStart, const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *sourceEnd, <a class="el" href="namespacewpi.html#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> **targetStart, <a class="el" href="namespacewpi.html#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> *targetEnd, <a class="el" href="namespacewpi.html#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a> <a class="el" href="namespacewpi.html#a7b0000b45b0b55789f757f1c3d2461cb">flags</a>)</td></tr>
<tr class="separator:a4bada7642f7a62d2271fd42cd0cb01f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9f39188361bf855a010751dbafbaff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacewpi.html#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#aac9f39188361bf855a010751dbafbaff">ConvertUTF8toUTF32Partial</a> (const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **sourceStart, const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *sourceEnd, <a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> **targetStart, <a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *targetEnd, <a class="el" href="namespacewpi.html#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a> <a class="el" href="namespacewpi.html#a7b0000b45b0b55789f757f1c3d2461cb">flags</a>)</td></tr>
<tr class="memdesc:aac9f39188361bf855a010751dbafbaff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a partial UTF8 sequence to UTF32.  <a href="namespacewpi.html#aac9f39188361bf855a010751dbafbaff">More...</a><br /></td></tr>
<tr class="separator:aac9f39188361bf855a010751dbafbaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c663588a7ff49ab4cb3ffb71e5d5c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacewpi.html#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ab9c663588a7ff49ab4cb3ffb71e5d5c6">ConvertUTF8toUTF32</a> (const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **sourceStart, const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *sourceEnd, <a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> **targetStart, <a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *targetEnd, <a class="el" href="namespacewpi.html#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a> <a class="el" href="namespacewpi.html#a7b0000b45b0b55789f757f1c3d2461cb">flags</a>)</td></tr>
<tr class="memdesc:ab9c663588a7ff49ab4cb3ffb71e5d5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a partial UTF8 sequence to UTF32.  <a href="namespacewpi.html#ab9c663588a7ff49ab4cb3ffb71e5d5c6">More...</a><br /></td></tr>
<tr class="separator:ab9c663588a7ff49ab4cb3ffb71e5d5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54c2f26ecf324df5da9128c77052d31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacewpi.html#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ac54c2f26ecf324df5da9128c77052d31">ConvertUTF16toUTF8</a> (const <a class="el" href="namespacewpi.html#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> **sourceStart, const <a class="el" href="namespacewpi.html#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> *sourceEnd, <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **targetStart, <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *targetEnd, <a class="el" href="namespacewpi.html#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a> <a class="el" href="namespacewpi.html#a7b0000b45b0b55789f757f1c3d2461cb">flags</a>)</td></tr>
<tr class="separator:ac54c2f26ecf324df5da9128c77052d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903ac386cdae4917d7cc20ed662dcee5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacewpi.html#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a903ac386cdae4917d7cc20ed662dcee5">ConvertUTF32toUTF8</a> (const <a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> **sourceStart, const <a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *sourceEnd, <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **targetStart, <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *targetEnd, <a class="el" href="namespacewpi.html#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a> <a class="el" href="namespacewpi.html#a7b0000b45b0b55789f757f1c3d2461cb">flags</a>)</td></tr>
<tr class="separator:a903ac386cdae4917d7cc20ed662dcee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9257f3c46568bac25b1ba2f3fac4678a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacewpi.html#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a9257f3c46568bac25b1ba2f3fac4678a">ConvertUTF16toUTF32</a> (const <a class="el" href="namespacewpi.html#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> **sourceStart, const <a class="el" href="namespacewpi.html#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> *sourceEnd, <a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> **targetStart, <a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *targetEnd, <a class="el" href="namespacewpi.html#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a> <a class="el" href="namespacewpi.html#a7b0000b45b0b55789f757f1c3d2461cb">flags</a>)</td></tr>
<tr class="separator:a9257f3c46568bac25b1ba2f3fac4678a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323342b32a2c5cf6e46b217e4843c014"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacewpi.html#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a323342b32a2c5cf6e46b217e4843c014">ConvertUTF32toUTF16</a> (const <a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> **sourceStart, const <a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *sourceEnd, <a class="el" href="namespacewpi.html#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> **targetStart, <a class="el" href="namespacewpi.html#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> *targetEnd, <a class="el" href="namespacewpi.html#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a> <a class="el" href="namespacewpi.html#a7b0000b45b0b55789f757f1c3d2461cb">flags</a>)</td></tr>
<tr class="separator:a323342b32a2c5cf6e46b217e4843c014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e27444cfe3390c1682575a3ad1860b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacewpi.html#ac9954615e01ad150570a0e1d4548d879">Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a26e27444cfe3390c1682575a3ad1860b">isLegalUTF8Sequence</a> (const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *<a class="el" href="_third_party_notices_8txt.html#a7e4b2af6b1063d628370e894227dec10">source</a>, const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *sourceEnd)</td></tr>
<tr class="separator:a26e27444cfe3390c1682575a3ad1860b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c7efa3db3243cb89f4f1c15b2a2c10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacewpi.html#ac9954615e01ad150570a0e1d4548d879">Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ad8c7efa3db3243cb89f4f1c15b2a2c10">isLegalUTF8String</a> (const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **<a class="el" href="_third_party_notices_8txt.html#a7e4b2af6b1063d628370e894227dec10">source</a>, const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *sourceEnd)</td></tr>
<tr class="separator:ad8c7efa3db3243cb89f4f1c15b2a2c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a45aaed6f6214f0a95dc9fd352b628"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a54a45aaed6f6214f0a95dc9fd352b628">getNumBytesForUTF8</a> (<a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> firstByte)</td></tr>
<tr class="separator:a54a45aaed6f6214f0a95dc9fd352b628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f044a5abfa43152b4511fc34f422abd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a4f044a5abfa43152b4511fc34f422abd">ConvertUTF8toWide</a> (unsigned WideCharWidth, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> Source, char *&amp;ResultPtr, const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *&amp;ErrorPtr)</td></tr>
<tr class="memdesc:a4f044a5abfa43152b4511fc34f422abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an UTF8 string_view to UTF8, UTF16, or UTF32 depending on WideCharWidth.  <a href="namespacewpi.html#a4f044a5abfa43152b4511fc34f422abd">More...</a><br /></td></tr>
<tr class="separator:a4f044a5abfa43152b4511fc34f422abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c65f324a518248ea7c9e3dec6abd2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ab6c65f324a518248ea7c9e3dec6abd2e">ConvertUTF8toWide</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> Source, std::wstring &amp;Result)</td></tr>
<tr class="memdesc:ab6c65f324a518248ea7c9e3dec6abd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a UTF-8 string_view to a std::wstring.  <a href="namespacewpi.html#ab6c65f324a518248ea7c9e3dec6abd2e">More...</a><br /></td></tr>
<tr class="separator:ab6c65f324a518248ea7c9e3dec6abd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34dcbda849543386fc00cfa5e9a30b1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a34dcbda849543386fc00cfa5e9a30b1a">ConvertUTF8toWide</a> (const char *Source, std::wstring &amp;Result)</td></tr>
<tr class="memdesc:a34dcbda849543386fc00cfa5e9a30b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a UTF-8 C-string to a std::wstring.  <a href="namespacewpi.html#a34dcbda849543386fc00cfa5e9a30b1a">More...</a><br /></td></tr>
<tr class="separator:a34dcbda849543386fc00cfa5e9a30b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0d4fcb62d165827231b4132e83e1a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a4e0d4fcb62d165827231b4132e83e1a7">convertWideToUTF8</a> (const std::wstring &amp;Source, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;Result)</td></tr>
<tr class="memdesc:a4e0d4fcb62d165827231b4132e83e1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a std::wstring to a UTF-8 encoded std::string.  <a href="namespacewpi.html#a4e0d4fcb62d165827231b4132e83e1a7">More...</a><br /></td></tr>
<tr class="separator:a4e0d4fcb62d165827231b4132e83e1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2b50e25edd8fc47c0ef3b0929a9aac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a0b2b50e25edd8fc47c0ef3b0929a9aac">ConvertCodePointToUTF8</a> (unsigned Source, char *&amp;ResultPtr)</td></tr>
<tr class="memdesc:a0b2b50e25edd8fc47c0ef3b0929a9aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an Unicode code point to UTF8 sequence.  <a href="namespacewpi.html#a0b2b50e25edd8fc47c0ef3b0929a9aac">More...</a><br /></td></tr>
<tr class="separator:a0b2b50e25edd8fc47c0ef3b0929a9aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349ec073e684b8777cd7e7166dd3b465"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacewpi.html#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a349ec073e684b8777cd7e7166dd3b465">convertUTF8Sequence</a> (const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **<a class="el" href="_third_party_notices_8txt.html#a7e4b2af6b1063d628370e894227dec10">source</a>, const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *sourceEnd, <a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *target, <a class="el" href="namespacewpi.html#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a> <a class="el" href="namespacewpi.html#a7b0000b45b0b55789f757f1c3d2461cb">flags</a>)</td></tr>
<tr class="memdesc:a349ec073e684b8777cd7e7166dd3b465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the first UTF8 sequence in the given source buffer to a UTF32 code point.  <a href="namespacewpi.html#a349ec073e684b8777cd7e7166dd3b465">More...</a><br /></td></tr>
<tr class="separator:a349ec073e684b8777cd7e7166dd3b465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328c5e2f088e151affd5ff9d7b398c42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a328c5e2f088e151affd5ff9d7b398c42">hasUTF16ByteOrderMark</a> (std::span&lt; const char &gt; SrcBytes)</td></tr>
<tr class="memdesc:a328c5e2f088e151affd5ff9d7b398c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a blob of text starts with a UTF-16 big or little endian byte order mark.  <a href="namespacewpi.html#a328c5e2f088e151affd5ff9d7b398c42">More...</a><br /></td></tr>
<tr class="separator:a328c5e2f088e151affd5ff9d7b398c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96959c1be95aa4d288cc84e11ab6f1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ad96959c1be95aa4d288cc84e11ab6f1b">convertUTF16ToUTF8String</a> (std::span&lt; const char &gt; SrcBytes, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;Out)</td></tr>
<tr class="memdesc:ad96959c1be95aa4d288cc84e11ab6f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a stream of raw bytes assumed to be UTF16 into a UTF8 std::string.  <a href="namespacewpi.html#ad96959c1be95aa4d288cc84e11ab6f1b">More...</a><br /></td></tr>
<tr class="separator:ad96959c1be95aa4d288cc84e11ab6f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae550217f649fc634dfa84af9795df29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#aae550217f649fc634dfa84af9795df29">convertUTF16ToUTF8String</a> (std::span&lt; const <a class="el" href="namespacewpi.html#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> &gt; Src, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;Out)</td></tr>
<tr class="memdesc:aae550217f649fc634dfa84af9795df29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a UTF16 string into a UTF8 std::string.  <a href="namespacewpi.html#aae550217f649fc634dfa84af9795df29">More...</a><br /></td></tr>
<tr class="separator:aae550217f649fc634dfa84af9795df29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051a613a70381a8d15a4ed7630bfd942"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a051a613a70381a8d15a4ed7630bfd942">convertUTF8ToUTF16String</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> SrcUTF8, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; <a class="el" href="namespacewpi.html#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> &gt; &amp;DstUTF16)</td></tr>
<tr class="memdesc:a051a613a70381a8d15a4ed7630bfd942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a UTF-8 string into a UTF-16 string with native endianness.  <a href="namespacewpi.html#a051a613a70381a8d15a4ed7630bfd942">More...</a><br /></td></tr>
<tr class="separator:a051a613a70381a8d15a4ed7630bfd942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c6f38176a757997f4548366d10941c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ac2c6f38176a757997f4548366d10941c">operator&lt;&lt;</a> (<a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;OS, <a class="el" href="namespacewpi_1_1sys.html#a26b4c3769d9f1b9f371d2bf4c07e1946">sys::TimePoint</a>&lt;&gt; TP)</td></tr>
<tr class="separator:ac2c6f38176a757997f4548366d10941c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9258f2870864143e01a09bb5cf806ba6"><td class="memTemplParams" colspan="2">template&lt;typename DerivedT , typename KeyT , typename ValueT , typename KeyInfoT , typename BucketT &gt; </td></tr>
<tr class="memitem:a9258f2870864143e01a09bb5cf806ba6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a9258f2870864143e01a09bb5cf806ba6">operator==</a> (const <a class="el" href="classwpi_1_1_dense_map_base.html">DenseMapBase</a>&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt; &amp;LHS, const <a class="el" href="classwpi_1_1_dense_map_base.html">DenseMapBase</a>&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt; &amp;RHS)</td></tr>
<tr class="memdesc:a9258f2870864143e01a09bb5cf806ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison for <a class="el" href="classwpi_1_1_dense_map.html">DenseMap</a>.  <a href="namespacewpi.html#a9258f2870864143e01a09bb5cf806ba6">More...</a><br /></td></tr>
<tr class="separator:a9258f2870864143e01a09bb5cf806ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2bd96b09718980689f6278dd7ea224d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedT , typename KeyT , typename ValueT , typename KeyInfoT , typename BucketT &gt; </td></tr>
<tr class="memitem:ac2bd96b09718980689f6278dd7ea224d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ac2bd96b09718980689f6278dd7ea224d">operator!=</a> (const <a class="el" href="classwpi_1_1_dense_map_base.html">DenseMapBase</a>&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt; &amp;LHS, const <a class="el" href="classwpi_1_1_dense_map_base.html">DenseMapBase</a>&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt; &amp;RHS)</td></tr>
<tr class="memdesc:ac2bd96b09718980689f6278dd7ea224d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison for <a class="el" href="classwpi_1_1_dense_map.html">DenseMap</a>.  <a href="namespacewpi.html#ac2bd96b09718980689f6278dd7ea224d">More...</a><br /></td></tr>
<tr class="separator:ac2bd96b09718980689f6278dd7ea224d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703d958d0d00e12bac5736929f6f1b33"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT , typename KeyInfoT &gt; </td></tr>
<tr class="memitem:a703d958d0d00e12bac5736929f6f1b33"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a703d958d0d00e12bac5736929f6f1b33">capacity_in_bytes</a> (const <a class="el" href="classwpi_1_1_dense_map.html">DenseMap</a>&lt; KeyT, ValueT, KeyInfoT &gt; &amp;X)</td></tr>
<tr class="separator:a703d958d0d00e12bac5736929f6f1b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e2eb77f5b39477413026df59b92032"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a10e2eb77f5b39477413026df59b92032"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a10e2eb77f5b39477413026df59b92032">countTrailingZeros</a> (T Val, <a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efb">ZeroBehavior</a> ZB=<a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efba9a9cbdc2a1d5bc51861d496d5243a048">ZB_Width</a>)</td></tr>
<tr class="memdesc:a10e2eb77f5b39477413026df59b92032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count number of 0's from the least significant bit to the most stopping at the first 1.  <a href="namespacewpi.html#a10e2eb77f5b39477413026df59b92032">More...</a><br /></td></tr>
<tr class="separator:a10e2eb77f5b39477413026df59b92032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2b5dfad335d4ed298cf53a9abdfa07"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2c2b5dfad335d4ed298cf53a9abdfa07"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a2c2b5dfad335d4ed298cf53a9abdfa07">countLeadingZeros</a> (T Val, <a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efb">ZeroBehavior</a> ZB=<a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efba9a9cbdc2a1d5bc51861d496d5243a048">ZB_Width</a>)</td></tr>
<tr class="memdesc:a2c2b5dfad335d4ed298cf53a9abdfa07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count number of 0's from the most significant bit to the least stopping at the first 1.  <a href="namespacewpi.html#a2c2b5dfad335d4ed298cf53a9abdfa07">More...</a><br /></td></tr>
<tr class="separator:a2c2b5dfad335d4ed298cf53a9abdfa07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b142bef5a5b68ba5def7d5428653014"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b142bef5a5b68ba5def7d5428653014"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a3b142bef5a5b68ba5def7d5428653014">findFirstSet</a> (T Val, <a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efb">ZeroBehavior</a> ZB=<a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efba7ca42989d02ebf0e4fb3387724228f43">ZB_Max</a>)</td></tr>
<tr class="memdesc:a3b142bef5a5b68ba5def7d5428653014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the first set bit starting from the least significant bit.  <a href="namespacewpi.html#a3b142bef5a5b68ba5def7d5428653014">More...</a><br /></td></tr>
<tr class="separator:a3b142bef5a5b68ba5def7d5428653014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337beda02d2dd53b5d020a593c867e6d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a337beda02d2dd53b5d020a593c867e6d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a337beda02d2dd53b5d020a593c867e6d">maskTrailingOnes</a> (unsigned N)</td></tr>
<tr class="memdesc:a337beda02d2dd53b5d020a593c867e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a bitmask with the N right-most bits set to 1, and all other bits set to 0.  <a href="namespacewpi.html#a337beda02d2dd53b5d020a593c867e6d">More...</a><br /></td></tr>
<tr class="separator:a337beda02d2dd53b5d020a593c867e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca1a8d567765c25e5c8aaf6f2a3a51a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ca1a8d567765c25e5c8aaf6f2a3a51a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a0ca1a8d567765c25e5c8aaf6f2a3a51a">maskLeadingOnes</a> (unsigned N)</td></tr>
<tr class="memdesc:a0ca1a8d567765c25e5c8aaf6f2a3a51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a bitmask with the N left-most bits set to 1, and all other bits set to 0.  <a href="namespacewpi.html#a0ca1a8d567765c25e5c8aaf6f2a3a51a">More...</a><br /></td></tr>
<tr class="separator:a0ca1a8d567765c25e5c8aaf6f2a3a51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e2df17acd6bc9d36f64037926be88f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad6e2df17acd6bc9d36f64037926be88f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ad6e2df17acd6bc9d36f64037926be88f">maskTrailingZeros</a> (unsigned N)</td></tr>
<tr class="memdesc:ad6e2df17acd6bc9d36f64037926be88f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a bitmask with the N right-most bits set to 0, and all other bits set to 1.  <a href="namespacewpi.html#ad6e2df17acd6bc9d36f64037926be88f">More...</a><br /></td></tr>
<tr class="separator:ad6e2df17acd6bc9d36f64037926be88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed916b5acc65b9b7f1ff971ffc096030"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed916b5acc65b9b7f1ff971ffc096030"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#aed916b5acc65b9b7f1ff971ffc096030">maskLeadingZeros</a> (unsigned N)</td></tr>
<tr class="memdesc:aed916b5acc65b9b7f1ff971ffc096030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a bitmask with the N left-most bits set to 0, and all other bits set to 1.  <a href="namespacewpi.html#aed916b5acc65b9b7f1ff971ffc096030">More...</a><br /></td></tr>
<tr class="separator:aed916b5acc65b9b7f1ff971ffc096030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b04cd68057d9779f905d1a86d9c9fc9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b04cd68057d9779f905d1a86d9c9fc9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a2b04cd68057d9779f905d1a86d9c9fc9">findLastSet</a> (T Val, <a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efb">ZeroBehavior</a> ZB=<a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efba7ca42989d02ebf0e4fb3387724228f43">ZB_Max</a>)</td></tr>
<tr class="memdesc:a2b04cd68057d9779f905d1a86d9c9fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the last set bit starting from the least significant bit.  <a href="namespacewpi.html#a2b04cd68057d9779f905d1a86d9c9fc9">More...</a><br /></td></tr>
<tr class="separator:a2b04cd68057d9779f905d1a86d9c9fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538316af0297b9fa6d65a22c874d4a95"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a538316af0297b9fa6d65a22c874d4a95"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a538316af0297b9fa6d65a22c874d4a95">reverseBits</a> (T Val)</td></tr>
<tr class="memdesc:a538316af0297b9fa6d65a22c874d4a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the bits in <code>Val</code>.  <a href="namespacewpi.html#a538316af0297b9fa6d65a22c874d4a95">More...</a><br /></td></tr>
<tr class="separator:a538316af0297b9fa6d65a22c874d4a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3568938669eceec8a2a2e8060cf7550"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#af3568938669eceec8a2a2e8060cf7550">Hi_32</a> (uint64_t Value)</td></tr>
<tr class="memdesc:af3568938669eceec8a2a2e8060cf7550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the high 32 bits of a 64 bit value.  <a href="namespacewpi.html#af3568938669eceec8a2a2e8060cf7550">More...</a><br /></td></tr>
<tr class="separator:af3568938669eceec8a2a2e8060cf7550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cde0598116042ad77cd369e21b95d3"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a30cde0598116042ad77cd369e21b95d3">Lo_32</a> (uint64_t Value)</td></tr>
<tr class="memdesc:a30cde0598116042ad77cd369e21b95d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the low 32 bits of a 64 bit value.  <a href="namespacewpi.html#a30cde0598116042ad77cd369e21b95d3">More...</a><br /></td></tr>
<tr class="separator:a30cde0598116042ad77cd369e21b95d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6fd03a9b591a2f187f0a44e2b4a356"><td class="memItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#acc6fd03a9b591a2f187f0a44e2b4a356">Make_64</a> (uint32_t High, uint32_t Low)</td></tr>
<tr class="memdesc:acc6fd03a9b591a2f187f0a44e2b4a356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a 64-bit integer from a high / low pair of 32-bit integers.  <a href="namespacewpi.html#acc6fd03a9b591a2f187f0a44e2b4a356">More...</a><br /></td></tr>
<tr class="separator:acc6fd03a9b591a2f187f0a44e2b4a356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793cb5a31f3412455ec43e6030919a42"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a793cb5a31f3412455ec43e6030919a42"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a793cb5a31f3412455ec43e6030919a42">isInt</a> (int64_t x)</td></tr>
<tr class="memdesc:a793cb5a31f3412455ec43e6030919a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an integer fits into the given bit width.  <a href="namespacewpi.html#a793cb5a31f3412455ec43e6030919a42">More...</a><br /></td></tr>
<tr class="separator:a793cb5a31f3412455ec43e6030919a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf6e574a80a2f8050ab7d25db6cc90f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:acdf6e574a80a2f8050ab7d25db6cc90f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#acdf6e574a80a2f8050ab7d25db6cc90f">isInt&lt; 8 &gt;</a> (int64_t x)</td></tr>
<tr class="separator:acdf6e574a80a2f8050ab7d25db6cc90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cdf07df2553fd72ae7120423754a2e8"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1cdf07df2553fd72ae7120423754a2e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a1cdf07df2553fd72ae7120423754a2e8">isInt&lt; 16 &gt;</a> (int64_t x)</td></tr>
<tr class="separator:a1cdf07df2553fd72ae7120423754a2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8bb82c95f37cf16eafb659ab0bace65"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ae8bb82c95f37cf16eafb659ab0bace65"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ae8bb82c95f37cf16eafb659ab0bace65">isInt&lt; 32 &gt;</a> (int64_t x)</td></tr>
<tr class="separator:ae8bb82c95f37cf16eafb659ab0bace65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b38a6d85f09021ac8f5a253764011fb"><td class="memTemplParams" colspan="2">template&lt;unsigned N, unsigned S&gt; </td></tr>
<tr class="memitem:a3b38a6d85f09021ac8f5a253764011fb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a3b38a6d85f09021ac8f5a253764011fb">isShiftedInt</a> (int64_t x)</td></tr>
<tr class="memdesc:a3b38a6d85f09021ac8f5a253764011fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a signed integer is an N bit number shifted left by S.  <a href="namespacewpi.html#a3b38a6d85f09021ac8f5a253764011fb">More...</a><br /></td></tr>
<tr class="separator:a3b38a6d85f09021ac8f5a253764011fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5006d05631e33faae51ea19c2db37f9c"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a5006d05631e33faae51ea19c2db37f9c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt;(N&lt; 64), bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a5006d05631e33faae51ea19c2db37f9c">isUInt</a> (uint64_t X)</td></tr>
<tr class="memdesc:a5006d05631e33faae51ea19c2db37f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an unsigned integer fits into the given bit width.  <a href="namespacewpi.html#a5006d05631e33faae51ea19c2db37f9c">More...</a><br /></td></tr>
<tr class="separator:a5006d05631e33faae51ea19c2db37f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799f389ff49437c4c06b3e0eacf03ae6"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a799f389ff49437c4c06b3e0eacf03ae6">isUInt</a> (uint64_t)</td></tr>
<tr class="separator:a799f389ff49437c4c06b3e0eacf03ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f73ffa4ad91e9c389e85ebb69d072ce"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a7f73ffa4ad91e9c389e85ebb69d072ce"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a7f73ffa4ad91e9c389e85ebb69d072ce">isUInt&lt; 8 &gt;</a> (uint64_t x)</td></tr>
<tr class="separator:a7f73ffa4ad91e9c389e85ebb69d072ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12c213c574000935d92fa4547ae61f6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ab12c213c574000935d92fa4547ae61f6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ab12c213c574000935d92fa4547ae61f6">isUInt&lt; 16 &gt;</a> (uint64_t x)</td></tr>
<tr class="separator:ab12c213c574000935d92fa4547ae61f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af771a1ba991555e3aebf4b0b43fa270b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af771a1ba991555e3aebf4b0b43fa270b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#af771a1ba991555e3aebf4b0b43fa270b">isUInt&lt; 32 &gt;</a> (uint64_t x)</td></tr>
<tr class="separator:af771a1ba991555e3aebf4b0b43fa270b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24c771b8df1d9311b05e5aa01ec09b3"><td class="memTemplParams" colspan="2">template&lt;unsigned N, unsigned S&gt; </td></tr>
<tr class="memitem:ae24c771b8df1d9311b05e5aa01ec09b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ae24c771b8df1d9311b05e5aa01ec09b3">isShiftedUInt</a> (uint64_t x)</td></tr>
<tr class="memdesc:ae24c771b8df1d9311b05e5aa01ec09b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a unsigned integer is an N bit number shifted left by S.  <a href="namespacewpi.html#ae24c771b8df1d9311b05e5aa01ec09b3">More...</a><br /></td></tr>
<tr class="separator:ae24c771b8df1d9311b05e5aa01ec09b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb968c37d6007862cab0e2e2156d9df9"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#adb968c37d6007862cab0e2e2156d9df9">maxUIntN</a> (uint64_t N)</td></tr>
<tr class="memdesc:adb968c37d6007862cab0e2e2156d9df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum value for a N-bit unsigned integer.  <a href="namespacewpi.html#adb968c37d6007862cab0e2e2156d9df9">More...</a><br /></td></tr>
<tr class="separator:adb968c37d6007862cab0e2e2156d9df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb563f4c667933f0ebf44c6ca54e7ba"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#abfb563f4c667933f0ebf44c6ca54e7ba">minIntN</a> (int64_t N)</td></tr>
<tr class="memdesc:abfb563f4c667933f0ebf44c6ca54e7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the minimum value for a N-bit signed integer.  <a href="namespacewpi.html#abfb563f4c667933f0ebf44c6ca54e7ba">More...</a><br /></td></tr>
<tr class="separator:abfb563f4c667933f0ebf44c6ca54e7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01982bb8b119d94de4200ed371ad5397"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a01982bb8b119d94de4200ed371ad5397">maxIntN</a> (int64_t N)</td></tr>
<tr class="memdesc:a01982bb8b119d94de4200ed371ad5397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum value for a N-bit signed integer.  <a href="namespacewpi.html#a01982bb8b119d94de4200ed371ad5397">More...</a><br /></td></tr>
<tr class="separator:a01982bb8b119d94de4200ed371ad5397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2ea2c155eeb9a3662912e8c2ff880e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#adc2ea2c155eeb9a3662912e8c2ff880e">isUIntN</a> (unsigned N, uint64_t x)</td></tr>
<tr class="memdesc:adc2ea2c155eeb9a3662912e8c2ff880e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an unsigned integer fits into the given (dynamic) bit width.  <a href="namespacewpi.html#adc2ea2c155eeb9a3662912e8c2ff880e">More...</a><br /></td></tr>
<tr class="separator:adc2ea2c155eeb9a3662912e8c2ff880e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65bc8235c8a7ccfb15d4856909adc45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ae65bc8235c8a7ccfb15d4856909adc45">isIntN</a> (unsigned N, int64_t x)</td></tr>
<tr class="memdesc:ae65bc8235c8a7ccfb15d4856909adc45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an signed integer fits into the given (dynamic) bit width.  <a href="namespacewpi.html#ae65bc8235c8a7ccfb15d4856909adc45">More...</a><br /></td></tr>
<tr class="separator:ae65bc8235c8a7ccfb15d4856909adc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7868b72f26477d7e06a655a552b8886"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#af7868b72f26477d7e06a655a552b8886">isMask_32</a> (uint32_t Value)</td></tr>
<tr class="memdesc:af7868b72f26477d7e06a655a552b8886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the argument is a non-empty sequence of ones starting at the least significant bit with the remainder zero (32 bit version).  <a href="namespacewpi.html#af7868b72f26477d7e06a655a552b8886">More...</a><br /></td></tr>
<tr class="separator:af7868b72f26477d7e06a655a552b8886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba808be054c9d45a724cc14bf47b45b"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#abba808be054c9d45a724cc14bf47b45b">isMask_64</a> (uint64_t Value)</td></tr>
<tr class="memdesc:abba808be054c9d45a724cc14bf47b45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the argument is a non-empty sequence of ones starting at the least significant bit with the remainder zero (64 bit version).  <a href="namespacewpi.html#abba808be054c9d45a724cc14bf47b45b">More...</a><br /></td></tr>
<tr class="separator:abba808be054c9d45a724cc14bf47b45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca9c306cc27e6eb5d669b6d41e6dba0"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a3ca9c306cc27e6eb5d669b6d41e6dba0">isShiftedMask_32</a> (uint32_t Value)</td></tr>
<tr class="memdesc:a3ca9c306cc27e6eb5d669b6d41e6dba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the argument contains a non-empty sequence of ones with the remainder zero (32 bit version.) Ex.  <a href="namespacewpi.html#a3ca9c306cc27e6eb5d669b6d41e6dba0">More...</a><br /></td></tr>
<tr class="separator:a3ca9c306cc27e6eb5d669b6d41e6dba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76f4df15ef384517038996decd80631"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ae76f4df15ef384517038996decd80631">isShiftedMask_64</a> (uint64_t Value)</td></tr>
<tr class="memdesc:ae76f4df15ef384517038996decd80631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the argument contains a non-empty sequence of ones with the remainder zero (64 bit version.)  <a href="namespacewpi.html#ae76f4df15ef384517038996decd80631">More...</a><br /></td></tr>
<tr class="separator:ae76f4df15ef384517038996decd80631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ef6fef4b85937dabc224872f7ff540"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a44ef6fef4b85937dabc224872f7ff540">isPowerOf2_32</a> (uint32_t Value)</td></tr>
<tr class="memdesc:a44ef6fef4b85937dabc224872f7ff540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the argument is a power of two &gt; 0.  <a href="namespacewpi.html#a44ef6fef4b85937dabc224872f7ff540">More...</a><br /></td></tr>
<tr class="separator:a44ef6fef4b85937dabc224872f7ff540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab337d9f021792437e222ab8de869770c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ab337d9f021792437e222ab8de869770c">isPowerOf2_64</a> (uint64_t Value)</td></tr>
<tr class="memdesc:ab337d9f021792437e222ab8de869770c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the argument is a power of two &gt; 0 (64 bit edition.)  <a href="namespacewpi.html#ab337d9f021792437e222ab8de869770c">More...</a><br /></td></tr>
<tr class="separator:ab337d9f021792437e222ab8de869770c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf0e41abe6919730147bff8b43e321e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7bf0e41abe6919730147bff8b43e321e"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a7bf0e41abe6919730147bff8b43e321e">countLeadingOnes</a> (T Value, <a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efb">ZeroBehavior</a> ZB=<a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efba9a9cbdc2a1d5bc51861d496d5243a048">ZB_Width</a>)</td></tr>
<tr class="memdesc:a7bf0e41abe6919730147bff8b43e321e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of ones from the most significant bit to the first zero bit.  <a href="namespacewpi.html#a7bf0e41abe6919730147bff8b43e321e">More...</a><br /></td></tr>
<tr class="separator:a7bf0e41abe6919730147bff8b43e321e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d3b71dd4da9a85a35767dfe54e8c84"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a90d3b71dd4da9a85a35767dfe54e8c84"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a90d3b71dd4da9a85a35767dfe54e8c84">countTrailingOnes</a> (T Value, <a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efb">ZeroBehavior</a> ZB=<a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efba9a9cbdc2a1d5bc51861d496d5243a048">ZB_Width</a>)</td></tr>
<tr class="memdesc:a90d3b71dd4da9a85a35767dfe54e8c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of ones from the least significant bit to the first zero bit.  <a href="namespacewpi.html#a90d3b71dd4da9a85a35767dfe54e8c84">More...</a><br /></td></tr>
<tr class="separator:a90d3b71dd4da9a85a35767dfe54e8c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb722826475651bd5c1df0f02dff8948"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb722826475651bd5c1df0f02dff8948"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#aeb722826475651bd5c1df0f02dff8948">countPopulation</a> (T Value)</td></tr>
<tr class="memdesc:aeb722826475651bd5c1df0f02dff8948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of set bits in a value.  <a href="namespacewpi.html#aeb722826475651bd5c1df0f02dff8948">More...</a><br /></td></tr>
<tr class="separator:aeb722826475651bd5c1df0f02dff8948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5847649747d23028195684c90de9cfa1"><td class="memTemplParams" colspan="2">template&lt;size_t kValue&gt; </td></tr>
<tr class="memitem:a5847649747d23028195684c90de9cfa1"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a5847649747d23028195684c90de9cfa1">CTLog2</a> ()</td></tr>
<tr class="memdesc:a5847649747d23028195684c90de9cfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time Log2.  <a href="namespacewpi.html#a5847649747d23028195684c90de9cfa1">More...</a><br /></td></tr>
<tr class="separator:a5847649747d23028195684c90de9cfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a3d85b513c921ffa14928e047294b6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a72a3d85b513c921ffa14928e047294b6"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a72a3d85b513c921ffa14928e047294b6">CTLog2&lt; 1 &gt;</a> ()</td></tr>
<tr class="separator:a72a3d85b513c921ffa14928e047294b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1196434a670e3e907e365ee77a26479c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a1196434a670e3e907e365ee77a26479c">Log2</a> (double Value)</td></tr>
<tr class="memdesc:a1196434a670e3e907e365ee77a26479c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log base 2 of the specified value.  <a href="namespacewpi.html#a1196434a670e3e907e365ee77a26479c">More...</a><br /></td></tr>
<tr class="separator:a1196434a670e3e907e365ee77a26479c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fc40611c1ed874ebee9877f3866da8"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a12fc40611c1ed874ebee9877f3866da8">Log2_32</a> (uint32_t Value)</td></tr>
<tr class="memdesc:a12fc40611c1ed874ebee9877f3866da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floor log base 2 of the specified value, -1 if the value is zero.  <a href="namespacewpi.html#a12fc40611c1ed874ebee9877f3866da8">More...</a><br /></td></tr>
<tr class="separator:a12fc40611c1ed874ebee9877f3866da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab109b30376a3d157344b924e82ccd5ef"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ab109b30376a3d157344b924e82ccd5ef">Log2_64</a> (uint64_t Value)</td></tr>
<tr class="memdesc:ab109b30376a3d157344b924e82ccd5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floor log base 2 of the specified value, -1 if the value is zero.  <a href="namespacewpi.html#ab109b30376a3d157344b924e82ccd5ef">More...</a><br /></td></tr>
<tr class="separator:ab109b30376a3d157344b924e82ccd5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be06425de1e3346544e3600fda4f352"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a1be06425de1e3346544e3600fda4f352">Log2_32_Ceil</a> (uint32_t Value)</td></tr>
<tr class="memdesc:a1be06425de1e3346544e3600fda4f352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ceil log base 2 of the specified value, 32 if the value is zero.  <a href="namespacewpi.html#a1be06425de1e3346544e3600fda4f352">More...</a><br /></td></tr>
<tr class="separator:a1be06425de1e3346544e3600fda4f352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b43a321203f7b23732402ef5dc9709"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ae6b43a321203f7b23732402ef5dc9709">Log2_64_Ceil</a> (uint64_t Value)</td></tr>
<tr class="memdesc:ae6b43a321203f7b23732402ef5dc9709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ceil log base 2 of the specified value, 64 if the value is zero.  <a href="namespacewpi.html#ae6b43a321203f7b23732402ef5dc9709">More...</a><br /></td></tr>
<tr class="separator:ae6b43a321203f7b23732402ef5dc9709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2c9609d87a3fc56aef5f6f14b5f701"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5d2c9609d87a3fc56aef5f6f14b5f701"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a5d2c9609d87a3fc56aef5f6f14b5f701">greatestCommonDivisor</a> (T A, T B)</td></tr>
<tr class="memdesc:a5d2c9609d87a3fc56aef5f6f14b5f701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greatest common divisor of the values using Euclid's algorithm.  <a href="namespacewpi.html#a5d2c9609d87a3fc56aef5f6f14b5f701">More...</a><br /></td></tr>
<tr class="separator:a5d2c9609d87a3fc56aef5f6f14b5f701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9258c13f90593d3af2d92dde80a79e9b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a9258c13f90593d3af2d92dde80a79e9b">GreatestCommonDivisor64</a> (uint64_t A, uint64_t B)</td></tr>
<tr class="separator:a9258c13f90593d3af2d92dde80a79e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0832dfca121b25b2bafc62df9bf0fa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#abc0832dfca121b25b2bafc62df9bf0fa">BitsToDouble</a> (uint64_t Bits)</td></tr>
<tr class="memdesc:abc0832dfca121b25b2bafc62df9bf0fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a 64-bit integer and returns the bit equivalent double.  <a href="namespacewpi.html#abc0832dfca121b25b2bafc62df9bf0fa">More...</a><br /></td></tr>
<tr class="separator:abc0832dfca121b25b2bafc62df9bf0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359ca5bba5d202caf28f69f4102db2cb"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a359ca5bba5d202caf28f69f4102db2cb">BitsToFloat</a> (uint32_t Bits)</td></tr>
<tr class="memdesc:a359ca5bba5d202caf28f69f4102db2cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a 32-bit integer and returns the bit equivalent float.  <a href="namespacewpi.html#a359ca5bba5d202caf28f69f4102db2cb">More...</a><br /></td></tr>
<tr class="separator:a359ca5bba5d202caf28f69f4102db2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ceead4d80776d6071e511d8f5d9353"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#af5ceead4d80776d6071e511d8f5d9353">DoubleToBits</a> (double Double)</td></tr>
<tr class="memdesc:af5ceead4d80776d6071e511d8f5d9353"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a double and returns the bit equivalent 64-bit integer.  <a href="namespacewpi.html#af5ceead4d80776d6071e511d8f5d9353">More...</a><br /></td></tr>
<tr class="separator:af5ceead4d80776d6071e511d8f5d9353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c3ca08347209b40a7330a66e83bf05"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#aa1c3ca08347209b40a7330a66e83bf05">FloatToBits</a> (float Float)</td></tr>
<tr class="memdesc:aa1c3ca08347209b40a7330a66e83bf05"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a float and returns the bit equivalent 32-bit integer.  <a href="namespacewpi.html#aa1c3ca08347209b40a7330a66e83bf05">More...</a><br /></td></tr>
<tr class="separator:aa1c3ca08347209b40a7330a66e83bf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2c49962110e8c4bf54b763aac045c8"><td class="memItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#aaf2c49962110e8c4bf54b763aac045c8">MinAlign</a> (uint64_t A, uint64_t B)</td></tr>
<tr class="memdesc:aaf2c49962110e8c4bf54b763aac045c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A and B are either alignments or offsets.  <a href="namespacewpi.html#aaf2c49962110e8c4bf54b763aac045c8">More...</a><br /></td></tr>
<tr class="separator:aaf2c49962110e8c4bf54b763aac045c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c11fbdfabf91b962c2d6d49a243207"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a70c11fbdfabf91b962c2d6d49a243207">NextPowerOf2</a> (uint64_t A)</td></tr>
<tr class="memdesc:a70c11fbdfabf91b962c2d6d49a243207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next power of two (in 64-bits) that is strictly greater than A.  <a href="namespacewpi.html#a70c11fbdfabf91b962c2d6d49a243207">More...</a><br /></td></tr>
<tr class="separator:a70c11fbdfabf91b962c2d6d49a243207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9300a98f876116b78909d4aa78a47d1"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#aa9300a98f876116b78909d4aa78a47d1">PowerOf2Floor</a> (uint64_t A)</td></tr>
<tr class="memdesc:aa9300a98f876116b78909d4aa78a47d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the power of two which is less than or equal to the given value.  <a href="namespacewpi.html#aa9300a98f876116b78909d4aa78a47d1">More...</a><br /></td></tr>
<tr class="separator:aa9300a98f876116b78909d4aa78a47d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d2692504baab859a5288de06e96df3"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a22d2692504baab859a5288de06e96df3">PowerOf2Ceil</a> (uint64_t A)</td></tr>
<tr class="memdesc:a22d2692504baab859a5288de06e96df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the power of two which is greater than or equal to the given value.  <a href="namespacewpi.html#a22d2692504baab859a5288de06e96df3">More...</a><br /></td></tr>
<tr class="separator:a22d2692504baab859a5288de06e96df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16dea88f23b7732e0e9560e626e0e29c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a16dea88f23b7732e0e9560e626e0e29c">alignTo</a> (uint64_t Value, uint64_t Align, uint64_t Skew=0)</td></tr>
<tr class="memdesc:a16dea88f23b7732e0e9560e626e0e29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next integer (mod 2**64) that is greater than or equal to <code>Value</code> and is a multiple of <code>Align</code>.  <a href="namespacewpi.html#a16dea88f23b7732e0e9560e626e0e29c">More...</a><br /></td></tr>
<tr class="separator:a16dea88f23b7732e0e9560e626e0e29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e89f720bc5d42133b9e1fba299f9e6e"><td class="memTemplParams" colspan="2">template&lt;uint64_t Align&gt; </td></tr>
<tr class="memitem:a2e89f720bc5d42133b9e1fba299f9e6e"><td class="memTemplItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a2e89f720bc5d42133b9e1fba299f9e6e">alignTo</a> (uint64_t Value)</td></tr>
<tr class="memdesc:a2e89f720bc5d42133b9e1fba299f9e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next integer (mod 2**64) that is greater than or equal to <code>Value</code> and is a multiple of <code>Align</code>.  <a href="namespacewpi.html#a2e89f720bc5d42133b9e1fba299f9e6e">More...</a><br /></td></tr>
<tr class="separator:a2e89f720bc5d42133b9e1fba299f9e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86598beceb2a41ea10f4335f8d5b99e4"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a86598beceb2a41ea10f4335f8d5b99e4">divideCeil</a> (uint64_t Numerator, uint64_t Denominator)</td></tr>
<tr class="memdesc:a86598beceb2a41ea10f4335f8d5b99e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the integer ceil(Numerator / Denominator).  <a href="namespacewpi.html#a86598beceb2a41ea10f4335f8d5b99e4">More...</a><br /></td></tr>
<tr class="separator:a86598beceb2a41ea10f4335f8d5b99e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75514d8e686b9790882d92c4efc0c8f3"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a75514d8e686b9790882d92c4efc0c8f3">divideNearest</a> (uint64_t Numerator, uint64_t Denominator)</td></tr>
<tr class="memdesc:a75514d8e686b9790882d92c4efc0c8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the integer nearest(Numerator / Denominator).  <a href="namespacewpi.html#a75514d8e686b9790882d92c4efc0c8f3">More...</a><br /></td></tr>
<tr class="separator:a75514d8e686b9790882d92c4efc0c8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96597787b5255d8569295b2a87d33cf"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#af96597787b5255d8569295b2a87d33cf">alignDown</a> (uint64_t Value, uint64_t Align, uint64_t Skew=0)</td></tr>
<tr class="memdesc:af96597787b5255d8569295b2a87d33cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest uint64_t less than or equal to <code>Value</code> and is <code>Skew</code> mod <code>Align</code>.  <a href="namespacewpi.html#af96597787b5255d8569295b2a87d33cf">More...</a><br /></td></tr>
<tr class="separator:af96597787b5255d8569295b2a87d33cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae892922c9d93c91d358b554fec2b6505"><td class="memTemplParams" colspan="2">template&lt;unsigned B&gt; </td></tr>
<tr class="memitem:ae892922c9d93c91d358b554fec2b6505"><td class="memTemplItemLeft" align="right" valign="top">constexpr int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ae892922c9d93c91d358b554fec2b6505">SignExtend32</a> (uint32_t X)</td></tr>
<tr class="memdesc:ae892922c9d93c91d358b554fec2b6505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extend the number in the bottom B bits of X to a 32-bit integer.  <a href="namespacewpi.html#ae892922c9d93c91d358b554fec2b6505">More...</a><br /></td></tr>
<tr class="separator:ae892922c9d93c91d358b554fec2b6505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3d762ed7571ddac4e212f583eb0a12"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a9c3d762ed7571ddac4e212f583eb0a12">SignExtend32</a> (uint32_t X, unsigned B)</td></tr>
<tr class="memdesc:a9c3d762ed7571ddac4e212f583eb0a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extend the number in the bottom B bits of X to a 32-bit integer.  <a href="namespacewpi.html#a9c3d762ed7571ddac4e212f583eb0a12">More...</a><br /></td></tr>
<tr class="separator:a9c3d762ed7571ddac4e212f583eb0a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401f9f01b250b094f790fab7706106d8"><td class="memTemplParams" colspan="2">template&lt;unsigned B&gt; </td></tr>
<tr class="memitem:a401f9f01b250b094f790fab7706106d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a401f9f01b250b094f790fab7706106d8">SignExtend64</a> (uint64_t x)</td></tr>
<tr class="memdesc:a401f9f01b250b094f790fab7706106d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extend the number in the bottom B bits of X to a 64-bit integer.  <a href="namespacewpi.html#a401f9f01b250b094f790fab7706106d8">More...</a><br /></td></tr>
<tr class="separator:a401f9f01b250b094f790fab7706106d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2540c26db383c900eae86f2c67c41ce0"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a2540c26db383c900eae86f2c67c41ce0">SignExtend64</a> (uint64_t X, unsigned B)</td></tr>
<tr class="memdesc:a2540c26db383c900eae86f2c67c41ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extend the number in the bottom B bits of X to a 64-bit integer.  <a href="namespacewpi.html#a2540c26db383c900eae86f2c67c41ce0">More...</a><br /></td></tr>
<tr class="separator:a2540c26db383c900eae86f2c67c41ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6656e2d5f5ef57e67a1c35a3ed4b7f70"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6656e2d5f5ef57e67a1c35a3ed4b7f70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt; std::is_unsigned&lt; T &gt;<a class="el" href="classvalue.html">::value</a>, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a6656e2d5f5ef57e67a1c35a3ed4b7f70">AbsoluteDifference</a> (T X, T Y)</td></tr>
<tr class="memdesc:a6656e2d5f5ef57e67a1c35a3ed4b7f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two unsigned integers, X and Y, of type T and return the absolute value of the result.  <a href="namespacewpi.html#a6656e2d5f5ef57e67a1c35a3ed4b7f70">More...</a><br /></td></tr>
<tr class="separator:a6656e2d5f5ef57e67a1c35a3ed4b7f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c5ce165d2bf0db00fbcbfe8450c562"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac5c5ce165d2bf0db00fbcbfe8450c562"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt; std::is_unsigned&lt; T &gt;<a class="el" href="classvalue.html">::value</a>, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ac5c5ce165d2bf0db00fbcbfe8450c562">SaturatingAdd</a> (T X, T Y, bool *ResultOverflowed=nullptr)</td></tr>
<tr class="memdesc:ac5c5ce165d2bf0db00fbcbfe8450c562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two unsigned integers, X and Y, of type T.  <a href="namespacewpi.html#ac5c5ce165d2bf0db00fbcbfe8450c562">More...</a><br /></td></tr>
<tr class="separator:ac5c5ce165d2bf0db00fbcbfe8450c562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2396f98cc1c4e416c09a535bceb9f732"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2396f98cc1c4e416c09a535bceb9f732"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt; std::is_unsigned&lt; T &gt;<a class="el" href="classvalue.html">::value</a>, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a2396f98cc1c4e416c09a535bceb9f732">SaturatingMultiply</a> (T X, T Y, bool *ResultOverflowed=nullptr)</td></tr>
<tr class="memdesc:a2396f98cc1c4e416c09a535bceb9f732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two unsigned integers, X and Y, of type T.  <a href="namespacewpi.html#a2396f98cc1c4e416c09a535bceb9f732">More...</a><br /></td></tr>
<tr class="separator:a2396f98cc1c4e416c09a535bceb9f732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fbc7000c2b2e339238d6aff6b448e0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac3fbc7000c2b2e339238d6aff6b448e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt; std::is_unsigned&lt; T &gt;<a class="el" href="classvalue.html">::value</a>, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ac3fbc7000c2b2e339238d6aff6b448e0">SaturatingMultiplyAdd</a> (T X, T Y, T A, bool *ResultOverflowed=nullptr)</td></tr>
<tr class="memdesc:ac3fbc7000c2b2e339238d6aff6b448e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two unsigned integers, X and Y, and add the unsigned integer, A to the product.  <a href="namespacewpi.html#ac3fbc7000c2b2e339238d6aff6b448e0">More...</a><br /></td></tr>
<tr class="separator:ac3fbc7000c2b2e339238d6aff6b448e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c94ed7f2d7c45d0edf41ce8527c38f2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3c94ed7f2d7c45d0edf41ce8527c38f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt; <a class="el" href="format_8h.html#a56d0276c2e6f4b26cb3565e08ebc9181">std::is_signed</a>&lt; T &gt;<a class="el" href="classvalue.html">::value</a>, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a3c94ed7f2d7c45d0edf41ce8527c38f2">AddOverflow</a> (T X, T Y, T &amp;Result)</td></tr>
<tr class="memdesc:a3c94ed7f2d7c45d0edf41ce8527c38f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two signed integers, computing the two's complement truncated result, returning true if overflow occured.  <a href="namespacewpi.html#a3c94ed7f2d7c45d0edf41ce8527c38f2">More...</a><br /></td></tr>
<tr class="separator:a3c94ed7f2d7c45d0edf41ce8527c38f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802f3b89f5be2d7575a84558dc56b169"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a802f3b89f5be2d7575a84558dc56b169"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt; <a class="el" href="format_8h.html#a56d0276c2e6f4b26cb3565e08ebc9181">std::is_signed</a>&lt; T &gt;<a class="el" href="classvalue.html">::value</a>, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a802f3b89f5be2d7575a84558dc56b169">SubOverflow</a> (T X, T Y, T &amp;Result)</td></tr>
<tr class="memdesc:a802f3b89f5be2d7575a84558dc56b169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two signed integers, computing the two's complement truncated result, returning true if an overflow ocurred.  <a href="namespacewpi.html#a802f3b89f5be2d7575a84558dc56b169">More...</a><br /></td></tr>
<tr class="separator:a802f3b89f5be2d7575a84558dc56b169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdb620d2807ab13e9c16c8867cf081a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6cdb620d2807ab13e9c16c8867cf081a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt; <a class="el" href="format_8h.html#a56d0276c2e6f4b26cb3565e08ebc9181">std::is_signed</a>&lt; T &gt;<a class="el" href="classvalue.html">::value</a>, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a6cdb620d2807ab13e9c16c8867cf081a">MulOverflow</a> (T X, T Y, T &amp;Result)</td></tr>
<tr class="memdesc:a6cdb620d2807ab13e9c16c8867cf081a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two signed integers, computing the two's complement truncated result, returning true if an overflow ocurred.  <a href="namespacewpi.html#a6cdb620d2807ab13e9c16c8867cf081a">More...</a><br /></td></tr>
<tr class="separator:a6cdb620d2807ab13e9c16c8867cf081a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dca6ddf9e17f10ec7699c29819b6c18"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0dca6ddf9e17f10ec7699c29819b6c18"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a0dca6ddf9e17f10ec7699c29819b6c18">sgn</a> (T val)</td></tr>
<tr class="separator:a0dca6ddf9e17f10ec7699c29819b6c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905c54ca4b7fdb1633b425ad9ca5dc48"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a905c54ca4b7fdb1633b425ad9ca5dc48"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a905c54ca4b7fdb1633b425ad9ca5dc48">Lerp</a> (const T &amp;startValue, const T &amp;endValue, double t)</td></tr>
<tr class="memdesc:a905c54ca4b7fdb1633b425ad9ca5dc48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linearly interpolates between two values.  <a href="namespacewpi.html#a905c54ca4b7fdb1633b425ad9ca5dc48">More...</a><br /></td></tr>
<tr class="separator:a905c54ca4b7fdb1633b425ad9ca5dc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c0723b9fdd34186cb26335c29e4ccc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ac6c0723b9fdd34186cb26335c29e4ccc">djbHash</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> Buffer, uint32_t H=5381)</td></tr>
<tr class="memdesc:ac6c0723b9fdd34186cb26335c29e4ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Bernstein hash function used by the DWARF accelerator tables.  <a href="namespacewpi.html#ac6c0723b9fdd34186cb26335c29e4ccc">More...</a><br /></td></tr>
<tr class="separator:ac6c0723b9fdd34186cb26335c29e4ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01feba2e98f9634bb529eac857ffa4fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_compiler_8h.html#acbae7c06e77fa64145cca176963b6863">LLVM_ATTRIBUTE_RETURNS_NONNULL</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a01feba2e98f9634bb529eac857ffa4fb">safe_malloc</a> (size_t Sz)</td></tr>
<tr class="separator:a01feba2e98f9634bb529eac857ffa4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3107b50e4fba4c211bc3981f452dfbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_compiler_8h.html#acbae7c06e77fa64145cca176963b6863">LLVM_ATTRIBUTE_RETURNS_NONNULL</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#aa3107b50e4fba4c211bc3981f452dfbc">safe_calloc</a> (size_t Count, size_t Sz)</td></tr>
<tr class="separator:aa3107b50e4fba4c211bc3981f452dfbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780a79e5410f3c9082aa1ff62d997151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_compiler_8h.html#acbae7c06e77fa64145cca176963b6863">LLVM_ATTRIBUTE_RETURNS_NONNULL</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a780a79e5410f3c9082aa1ff62d997151">safe_realloc</a> (void *Ptr, size_t Sz)</td></tr>
<tr class="separator:a780a79e5410f3c9082aa1ff62d997151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17a307d96b6bf9787f0dc6aac310fee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_compiler_8h.html#acbae7c06e77fa64145cca176963b6863">LLVM_ATTRIBUTE_RETURNS_NONNULL</a> <a class="el" href="_compiler_8h.html#a33bc304d1e6e184f3ffd9fa1620fd14c">LLVM_ATTRIBUTE_RETURNS_NOALIAS</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ac17a307d96b6bf9787f0dc6aac310fee">allocate_buffer</a> (size_t Size, size_t Alignment)</td></tr>
<tr class="memdesc:ac17a307d96b6bf9787f0dc6aac310fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a buffer of memory with the given size and alignment.  <a href="namespacewpi.html#ac17a307d96b6bf9787f0dc6aac310fee">More...</a><br /></td></tr>
<tr class="separator:ac17a307d96b6bf9787f0dc6aac310fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693165287d8a8a5159fd739216188620"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a693165287d8a8a5159fd739216188620">deallocate_buffer</a> (void *Ptr, size_t Size, size_t Alignment)</td></tr>
<tr class="memdesc:a693165287d8a8a5159fd739216188620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate a buffer of memory with the given size and alignment.  <a href="namespacewpi.html#a693165287d8a8a5159fd739216188620">More...</a><br /></td></tr>
<tr class="separator:a693165287d8a8a5159fd739216188620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af9a7e30ba77940f2ef47d513252866"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a8af9a7e30ba77940f2ef47d513252866">mapWindowsError</a> (unsigned EV)</td></tr>
<tr class="separator:a8af9a7e30ba77940f2ef47d513252866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64cc2a8bb25b3e692e7aacd722fdd29"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned LN, unsigned RN, typename C &gt; </td></tr>
<tr class="memitem:ac64cc2a8bb25b3e692e7aacd722fdd29"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ac64cc2a8bb25b3e692e7aacd722fdd29">operator==</a> (const <a class="el" href="classwpi_1_1_small_set.html">SmallSet</a>&lt; T, LN, C &gt; &amp;LHS, const <a class="el" href="classwpi_1_1_small_set.html">SmallSet</a>&lt; T, RN, C &gt; &amp;RHS)</td></tr>
<tr class="memdesc:ac64cc2a8bb25b3e692e7aacd722fdd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison for <a class="el" href="classwpi_1_1_small_set.html" title="SmallSet - This maintains a set of unique values, optimizing for the case when the set is small (less...">SmallSet</a>.  <a href="namespacewpi.html#ac64cc2a8bb25b3e692e7aacd722fdd29">More...</a><br /></td></tr>
<tr class="separator:ac64cc2a8bb25b3e692e7aacd722fdd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad032764915283409382ba49638651b69"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned LN, unsigned RN, typename C &gt; </td></tr>
<tr class="memitem:ad032764915283409382ba49638651b69"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ad032764915283409382ba49638651b69">operator!=</a> (const <a class="el" href="classwpi_1_1_small_set.html">SmallSet</a>&lt; T, LN, C &gt; &amp;LHS, const <a class="el" href="classwpi_1_1_small_set.html">SmallSet</a>&lt; T, RN, C &gt; &amp;RHS)</td></tr>
<tr class="memdesc:ad032764915283409382ba49638651b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison for <a class="el" href="classwpi_1_1_small_set.html" title="SmallSet - This maintains a set of unique values, optimizing for the case when the set is small (less...">SmallSet</a>.  <a href="namespacewpi.html#ad032764915283409382ba49638651b69">More...</a><br /></td></tr>
<tr class="separator:ad032764915283409382ba49638651b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025d8760b23ac3786c52b2cc7d72f5eb"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a025d8760b23ac3786c52b2cc7d72f5eb">hexdigit</a> (unsigned X, bool LowerCase=false) noexcept</td></tr>
<tr class="memdesc:a025d8760b23ac3786c52b2cc7d72f5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">hexdigit - Return the hexadecimal character for the given number <code>X</code> (which should be less than 16).  <a href="namespacewpi.html#a025d8760b23ac3786c52b2cc7d72f5eb">More...</a><br /></td></tr>
<tr class="separator:a025d8760b23ac3786c52b2cc7d72f5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f23b372d35fd43e572bd6310538d3b4"><td class="memItemLeft" align="right" valign="top">constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a3f23b372d35fd43e572bd6310538d3b4">hexDigitValue</a> (char C) noexcept</td></tr>
<tr class="memdesc:a3f23b372d35fd43e572bd6310538d3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the given character <code>C</code> as a hexadecimal digit and return its value.  <a href="namespacewpi.html#a3f23b372d35fd43e572bd6310538d3b4">More...</a><br /></td></tr>
<tr class="separator:a3f23b372d35fd43e572bd6310538d3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368b03e8bb2ecfdc34b02b40523055e4"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a368b03e8bb2ecfdc34b02b40523055e4">isDigit</a> (char C) noexcept</td></tr>
<tr class="memdesc:a368b03e8bb2ecfdc34b02b40523055e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if character <code>C</code> is one of the 10 decimal digits.  <a href="namespacewpi.html#a368b03e8bb2ecfdc34b02b40523055e4">More...</a><br /></td></tr>
<tr class="separator:a368b03e8bb2ecfdc34b02b40523055e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33822f75a8aa525d240b60e5e79568b6"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a33822f75a8aa525d240b60e5e79568b6">isHexDigit</a> (char C) noexcept</td></tr>
<tr class="memdesc:a33822f75a8aa525d240b60e5e79568b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if character <code>C</code> is a hexadecimal numeric character.  <a href="namespacewpi.html#a33822f75a8aa525d240b60e5e79568b6">More...</a><br /></td></tr>
<tr class="separator:a33822f75a8aa525d240b60e5e79568b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40bed52c4db6c9d8ac4d6a34f701fca"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ad40bed52c4db6c9d8ac4d6a34f701fca">isAlpha</a> (char C) noexcept</td></tr>
<tr class="memdesc:ad40bed52c4db6c9d8ac4d6a34f701fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if character <code>C</code> is a valid letter as classified by "C" locale.  <a href="namespacewpi.html#ad40bed52c4db6c9d8ac4d6a34f701fca">More...</a><br /></td></tr>
<tr class="separator:ad40bed52c4db6c9d8ac4d6a34f701fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db9afebe0b9cb8a94691657ad62b71b"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a2db9afebe0b9cb8a94691657ad62b71b">isAlnum</a> (char C) noexcept</td></tr>
<tr class="memdesc:a2db9afebe0b9cb8a94691657ad62b71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether character <code>C</code> is either a decimal digit or an uppercase or lowercase letter as classified by "C" locale.  <a href="namespacewpi.html#a2db9afebe0b9cb8a94691657ad62b71b">More...</a><br /></td></tr>
<tr class="separator:a2db9afebe0b9cb8a94691657ad62b71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e6acbb1ecc26fc431a01798885b5a1"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ad2e6acbb1ecc26fc431a01798885b5a1">isASCII</a> (char C) noexcept</td></tr>
<tr class="memdesc:ad2e6acbb1ecc26fc431a01798885b5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether character <code>C</code> is valid ASCII (high bit is zero).  <a href="namespacewpi.html#ad2e6acbb1ecc26fc431a01798885b5a1">More...</a><br /></td></tr>
<tr class="separator:ad2e6acbb1ecc26fc431a01798885b5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c8224f526316dbd1d8e8c3e53362db"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a91c8224f526316dbd1d8e8c3e53362db">isPrint</a> (char C) noexcept</td></tr>
<tr class="memdesc:a91c8224f526316dbd1d8e8c3e53362db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether character <code>C</code> is printable.  <a href="namespacewpi.html#a91c8224f526316dbd1d8e8c3e53362db">More...</a><br /></td></tr>
<tr class="separator:a91c8224f526316dbd1d8e8c3e53362db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d0773c177190213ead75a95fe7fc46"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a47d0773c177190213ead75a95fe7fc46">toLower</a> (char x) noexcept</td></tr>
<tr class="memdesc:a47d0773c177190213ead75a95fe7fc46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the corresponding lowercase character if <code>x</code> is uppercase.  <a href="namespacewpi.html#a47d0773c177190213ead75a95fe7fc46">More...</a><br /></td></tr>
<tr class="separator:a47d0773c177190213ead75a95fe7fc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe9106b78ee79e9796550968c3ef216"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a4fe9106b78ee79e9796550968c3ef216">toUpper</a> (char x) noexcept</td></tr>
<tr class="memdesc:a4fe9106b78ee79e9796550968c3ef216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the corresponding uppercase character if <code>x</code> is lowercase.  <a href="namespacewpi.html#a4fe9106b78ee79e9796550968c3ef216">More...</a><br /></td></tr>
<tr class="separator:a4fe9106b78ee79e9796550968c3ef216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7da2e15d1e126422095bfbc0e66f1bc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ae7da2e15d1e126422095bfbc0e66f1bc">utohexstr</a> (unsigned long long val, bool lowerCase=false)</td></tr>
<tr class="separator:ae7da2e15d1e126422095bfbc0e66f1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861d18fea3edd7f459017ea02e79d5ea"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a861d18fea3edd7f459017ea02e79d5ea">equals</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> lhs, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> rhs) noexcept</td></tr>
<tr class="memdesc:a861d18fea3edd7f459017ea02e79d5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">equals - Check for string equality, this is more efficient than compare() when the relative ordering of inequal strings isn't needed.  <a href="namespacewpi.html#a861d18fea3edd7f459017ea02e79d5ea">More...</a><br /></td></tr>
<tr class="separator:a861d18fea3edd7f459017ea02e79d5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135363b62874f7e1527b3ee317063f28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a135363b62874f7e1527b3ee317063f28">compare_lower</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> lhs, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> rhs) noexcept</td></tr>
<tr class="memdesc:a135363b62874f7e1527b3ee317063f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare_lower - Compare two strings, ignoring case.  <a href="namespacewpi.html#a135363b62874f7e1527b3ee317063f28">More...</a><br /></td></tr>
<tr class="separator:a135363b62874f7e1527b3ee317063f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f467e8545fad85176bcf4e64ced7bc7"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a6f467e8545fad85176bcf4e64ced7bc7">equals_lower</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> lhs, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> rhs) noexcept</td></tr>
<tr class="memdesc:a6f467e8545fad85176bcf4e64ced7bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">equals_lower - Check for string equality, ignoring case.  <a href="namespacewpi.html#a6f467e8545fad85176bcf4e64ced7bc7">More...</a><br /></td></tr>
<tr class="separator:a6f467e8545fad85176bcf4e64ced7bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f2207fbd2f0fbd2a85bda3ef353ec5"><td class="memItemLeft" align="right" valign="top">std::string_view::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a32f2207fbd2f0fbd2a85bda3ef353ec5">find_lower</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, char ch, std::string_view::size_type <a class="el" href="_third_party_notices_8txt.html#ae1e371287219a11d6a2498f92d3e15d2">from</a>=0) noexcept</td></tr>
<tr class="memdesc:a32f2207fbd2f0fbd2a85bda3ef353ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first character <code>ch</code> in <code>str</code>, ignoring case.  <a href="namespacewpi.html#a32f2207fbd2f0fbd2a85bda3ef353ec5">More...</a><br /></td></tr>
<tr class="separator:a32f2207fbd2f0fbd2a85bda3ef353ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e73ed8bf4d49b2734570b2c83f9303"><td class="memItemLeft" align="right" valign="top">std::string_view::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#af5e73ed8bf4d49b2734570b2c83f9303">find_lower</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> other, std::string_view::size_type <a class="el" href="_third_party_notices_8txt.html#ae1e371287219a11d6a2498f92d3e15d2">from</a>=0) noexcept</td></tr>
<tr class="memdesc:af5e73ed8bf4d49b2734570b2c83f9303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first string <code>other</code> in <code>str</code>, ignoring case.  <a href="namespacewpi.html#af5e73ed8bf4d49b2734570b2c83f9303">More...</a><br /></td></tr>
<tr class="separator:af5e73ed8bf4d49b2734570b2c83f9303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f278b2f7c4f0f3d3417390f77979fd5"><td class="memItemLeft" align="right" valign="top">std::string_view::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a5f278b2f7c4f0f3d3417390f77979fd5">find_lower</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, const char *other, std::string_view::size_type <a class="el" href="_third_party_notices_8txt.html#ae1e371287219a11d6a2498f92d3e15d2">from</a>=0) noexcept</td></tr>
<tr class="memdesc:a5f278b2f7c4f0f3d3417390f77979fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first string <code>other</code> in <code>str</code>, ignoring case.  <a href="namespacewpi.html#a5f278b2f7c4f0f3d3417390f77979fd5">More...</a><br /></td></tr>
<tr class="separator:a5f278b2f7c4f0f3d3417390f77979fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676758fb3474980129376c4430e5965f"><td class="memItemLeft" align="right" valign="top">std::string_view::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a676758fb3474980129376c4430e5965f">rfind_lower</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, char ch, std::string_view::size_type <a class="el" href="_third_party_notices_8txt.html#ae1e371287219a11d6a2498f92d3e15d2">from</a>=std::string_view::npos) noexcept</td></tr>
<tr class="memdesc:a676758fb3474980129376c4430e5965f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last character <code>ch</code> in <code>str</code>, ignoring case.  <a href="namespacewpi.html#a676758fb3474980129376c4430e5965f">More...</a><br /></td></tr>
<tr class="separator:a676758fb3474980129376c4430e5965f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88303c617dfdc5eca2edb6fb7b10124b"><td class="memItemLeft" align="right" valign="top">std::string_view::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a88303c617dfdc5eca2edb6fb7b10124b">rfind_lower</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> other) noexcept</td></tr>
<tr class="memdesc:a88303c617dfdc5eca2edb6fb7b10124b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last string <code>other</code> in <code>str</code>, ignoring case.  <a href="namespacewpi.html#a88303c617dfdc5eca2edb6fb7b10124b">More...</a><br /></td></tr>
<tr class="separator:a88303c617dfdc5eca2edb6fb7b10124b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6670129d8dd67d55733dacac82fb6354"><td class="memItemLeft" align="right" valign="top">std::string_view::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a6670129d8dd67d55733dacac82fb6354">rfind_lower</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, const char *other) noexcept</td></tr>
<tr class="memdesc:a6670129d8dd67d55733dacac82fb6354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last string <code>other</code> in <code>str</code>, ignoring case.  <a href="namespacewpi.html#a6670129d8dd67d55733dacac82fb6354">More...</a><br /></td></tr>
<tr class="separator:a6670129d8dd67d55733dacac82fb6354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f010ee3e4dec5c5697534c0059aa046"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a7f010ee3e4dec5c5697534c0059aa046">substr</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, std::string_view::size_type start, std::string_view::size_type n=std::string_view::npos) noexcept</td></tr>
<tr class="memdesc:a7f010ee3e4dec5c5697534c0059aa046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the substring of <code>str</code> from [start, start + n).  <a href="namespacewpi.html#a7f010ee3e4dec5c5697534c0059aa046">More...</a><br /></td></tr>
<tr class="separator:a7f010ee3e4dec5c5697534c0059aa046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0739f65c4cc2835777cc34e9241c377"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#af0739f65c4cc2835777cc34e9241c377">starts_with</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> prefix) noexcept</td></tr>
<tr class="memdesc:af0739f65c4cc2835777cc34e9241c377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> starts with the given <code>prefix</code>.  <a href="namespacewpi.html#af0739f65c4cc2835777cc34e9241c377">More...</a><br /></td></tr>
<tr class="separator:af0739f65c4cc2835777cc34e9241c377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ed0964b7b3d671454f67babc4835bf"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a24ed0964b7b3d671454f67babc4835bf">starts_with</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, char prefix) noexcept</td></tr>
<tr class="memdesc:a24ed0964b7b3d671454f67babc4835bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> starts with the given <code>prefix</code>.  <a href="namespacewpi.html#a24ed0964b7b3d671454f67babc4835bf">More...</a><br /></td></tr>
<tr class="separator:a24ed0964b7b3d671454f67babc4835bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5432fef02a3f6f25d649439e5f37b291"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a5432fef02a3f6f25d649439e5f37b291">starts_with</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, const char *prefix) noexcept</td></tr>
<tr class="memdesc:a5432fef02a3f6f25d649439e5f37b291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> starts with the given <code>prefix</code>.  <a href="namespacewpi.html#a5432fef02a3f6f25d649439e5f37b291">More...</a><br /></td></tr>
<tr class="separator:a5432fef02a3f6f25d649439e5f37b291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6880afc62fe88adf620fbf7c0ae29cc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a6880afc62fe88adf620fbf7c0ae29cc6">starts_with_lower</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> prefix) noexcept</td></tr>
<tr class="memdesc:a6880afc62fe88adf620fbf7c0ae29cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> starts with the given <code>prefix</code>, ignoring case.  <a href="namespacewpi.html#a6880afc62fe88adf620fbf7c0ae29cc6">More...</a><br /></td></tr>
<tr class="separator:a6880afc62fe88adf620fbf7c0ae29cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bef3b73b83b04242caa60d6327ceb68"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a2bef3b73b83b04242caa60d6327ceb68">starts_with_lower</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, char prefix) noexcept</td></tr>
<tr class="memdesc:a2bef3b73b83b04242caa60d6327ceb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> starts with the given <code>prefix</code>, ignoring case.  <a href="namespacewpi.html#a2bef3b73b83b04242caa60d6327ceb68">More...</a><br /></td></tr>
<tr class="separator:a2bef3b73b83b04242caa60d6327ceb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddfda4dce07ee9575513ba636d6f383"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a9ddfda4dce07ee9575513ba636d6f383">starts_with_lower</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, const char *prefix) noexcept</td></tr>
<tr class="memdesc:a9ddfda4dce07ee9575513ba636d6f383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> starts with the given <code>prefix</code>, ignoring case.  <a href="namespacewpi.html#a9ddfda4dce07ee9575513ba636d6f383">More...</a><br /></td></tr>
<tr class="separator:a9ddfda4dce07ee9575513ba636d6f383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76aa40d978aab32a3dcfab7f8eb953b"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ae76aa40d978aab32a3dcfab7f8eb953b">ends_with</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> suffix) noexcept</td></tr>
<tr class="memdesc:ae76aa40d978aab32a3dcfab7f8eb953b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> ends with the given <code>suffix</code>.  <a href="namespacewpi.html#ae76aa40d978aab32a3dcfab7f8eb953b">More...</a><br /></td></tr>
<tr class="separator:ae76aa40d978aab32a3dcfab7f8eb953b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4df2968e94c4ee3ac050889f633446"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#abd4df2968e94c4ee3ac050889f633446">ends_with</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, char suffix) noexcept</td></tr>
<tr class="memdesc:abd4df2968e94c4ee3ac050889f633446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> ends with the given <code>suffix</code>.  <a href="namespacewpi.html#abd4df2968e94c4ee3ac050889f633446">More...</a><br /></td></tr>
<tr class="separator:abd4df2968e94c4ee3ac050889f633446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec868a416c46e73b09990b9accd5531"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a3ec868a416c46e73b09990b9accd5531">ends_with</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, const char *suffix) noexcept</td></tr>
<tr class="memdesc:a3ec868a416c46e73b09990b9accd5531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> ends with the given <code>suffix</code>.  <a href="namespacewpi.html#a3ec868a416c46e73b09990b9accd5531">More...</a><br /></td></tr>
<tr class="separator:a3ec868a416c46e73b09990b9accd5531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ce9b37507ebc31753938d388848714"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a63ce9b37507ebc31753938d388848714">ends_with_lower</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> suffix) noexcept</td></tr>
<tr class="memdesc:a63ce9b37507ebc31753938d388848714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> ends with the given <code>suffix</code>, ignoring case.  <a href="namespacewpi.html#a63ce9b37507ebc31753938d388848714">More...</a><br /></td></tr>
<tr class="separator:a63ce9b37507ebc31753938d388848714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95519eb02ecc90f51e4157b797a4c306"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a95519eb02ecc90f51e4157b797a4c306">ends_with_lower</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, char suffix) noexcept</td></tr>
<tr class="memdesc:a95519eb02ecc90f51e4157b797a4c306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> ends with the given <code>suffix</code>, ignoring case.  <a href="namespacewpi.html#a95519eb02ecc90f51e4157b797a4c306">More...</a><br /></td></tr>
<tr class="separator:a95519eb02ecc90f51e4157b797a4c306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1334c1afcb5a1b5592e57a78436915b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ac1334c1afcb5a1b5592e57a78436915b">ends_with_lower</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, const char *suffix) noexcept</td></tr>
<tr class="memdesc:ac1334c1afcb5a1b5592e57a78436915b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> ends with the given <code>suffix</code>, ignoring case.  <a href="namespacewpi.html#ac1334c1afcb5a1b5592e57a78436915b">More...</a><br /></td></tr>
<tr class="separator:ac1334c1afcb5a1b5592e57a78436915b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c338fbb3b9d95ab22856fb0aaacf94"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a57c338fbb3b9d95ab22856fb0aaacf94">contains</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> other) noexcept</td></tr>
<tr class="memdesc:a57c338fbb3b9d95ab22856fb0aaacf94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> contains the substring <code>other</code>.  <a href="namespacewpi.html#a57c338fbb3b9d95ab22856fb0aaacf94">More...</a><br /></td></tr>
<tr class="separator:a57c338fbb3b9d95ab22856fb0aaacf94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c14a6177075406fca400c8f46d0dc5"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ac0c14a6177075406fca400c8f46d0dc5">contains</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, char ch) noexcept</td></tr>
<tr class="memdesc:ac0c14a6177075406fca400c8f46d0dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> contains the substring <code>other</code>.  <a href="namespacewpi.html#ac0c14a6177075406fca400c8f46d0dc5">More...</a><br /></td></tr>
<tr class="separator:ac0c14a6177075406fca400c8f46d0dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1426c18248d3c2ba9769800334f2c596"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a1426c18248d3c2ba9769800334f2c596">contains</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, const char *other) noexcept</td></tr>
<tr class="memdesc:a1426c18248d3c2ba9769800334f2c596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> contains the substring <code>other</code>.  <a href="namespacewpi.html#a1426c18248d3c2ba9769800334f2c596">More...</a><br /></td></tr>
<tr class="separator:a1426c18248d3c2ba9769800334f2c596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec927e053502a01b8b57dbc9fe7ceea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#afec927e053502a01b8b57dbc9fe7ceea">contains_lower</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> other) noexcept</td></tr>
<tr class="memdesc:afec927e053502a01b8b57dbc9fe7ceea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> contains the substring <code>other</code>, ignoring case.  <a href="namespacewpi.html#afec927e053502a01b8b57dbc9fe7ceea">More...</a><br /></td></tr>
<tr class="separator:afec927e053502a01b8b57dbc9fe7ceea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e058e611f4cf33ce6a9355be266854"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ae7e058e611f4cf33ce6a9355be266854">contains_lower</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, char ch) noexcept</td></tr>
<tr class="memdesc:ae7e058e611f4cf33ce6a9355be266854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> contains the substring <code>other</code>, ignoring case.  <a href="namespacewpi.html#ae7e058e611f4cf33ce6a9355be266854">More...</a><br /></td></tr>
<tr class="separator:ae7e058e611f4cf33ce6a9355be266854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93417c92f7c6516d3746b419a5f6ec39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a93417c92f7c6516d3746b419a5f6ec39">contains_lower</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, const char *other) noexcept</td></tr>
<tr class="memdesc:a93417c92f7c6516d3746b419a5f6ec39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> contains the substring <code>other</code>, ignoring case.  <a href="namespacewpi.html#a93417c92f7c6516d3746b419a5f6ec39">More...</a><br /></td></tr>
<tr class="separator:a93417c92f7c6516d3746b419a5f6ec39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e1eeb77b140b88774935651084a248"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#aa5e1eeb77b140b88774935651084a248">drop_front</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, std::string_view::size_type n=1) noexcept</td></tr>
<tr class="memdesc:aa5e1eeb77b140b88774935651084a248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string_view equal to <code>str</code> but with the first <code>n</code> elements dropped.  <a href="namespacewpi.html#aa5e1eeb77b140b88774935651084a248">More...</a><br /></td></tr>
<tr class="separator:aa5e1eeb77b140b88774935651084a248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f57db8fe105b74dbfbd5897fa695c14"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a7f57db8fe105b74dbfbd5897fa695c14">drop_back</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, std::string_view::size_type n=1) noexcept</td></tr>
<tr class="memdesc:a7f57db8fe105b74dbfbd5897fa695c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string_view equal to <code>str</code> but with the last <code>n</code> elements dropped.  <a href="namespacewpi.html#a7f57db8fe105b74dbfbd5897fa695c14">More...</a><br /></td></tr>
<tr class="separator:a7f57db8fe105b74dbfbd5897fa695c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2f9b2ee4f037743d32eb831bb487c4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#aff2f9b2ee4f037743d32eb831bb487c4">take_front</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, std::string_view::size_type n=1) noexcept</td></tr>
<tr class="memdesc:aff2f9b2ee4f037743d32eb831bb487c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a view equal to <code>str</code> but with only the first <code>n</code> elements remaining.  <a href="namespacewpi.html#aff2f9b2ee4f037743d32eb831bb487c4">More...</a><br /></td></tr>
<tr class="separator:aff2f9b2ee4f037743d32eb831bb487c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a98666f01d85b3920861e2477e7926"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#aa8a98666f01d85b3920861e2477e7926">take_back</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, std::string_view::size_type n=1) noexcept</td></tr>
<tr class="memdesc:aa8a98666f01d85b3920861e2477e7926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a view equal to <code>str</code> but with only the last <code>n</code> elements remaining.  <a href="namespacewpi.html#aa8a98666f01d85b3920861e2477e7926">More...</a><br /></td></tr>
<tr class="separator:aa8a98666f01d85b3920861e2477e7926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f22fd8158dd46fe207d828ab907c6a9"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a0f22fd8158dd46fe207d828ab907c6a9">slice</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, std::string_view::size_type start, std::string_view::size_type end) noexcept</td></tr>
<tr class="memdesc:a0f22fd8158dd46fe207d828ab907c6a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the substring of <code>str</code> from [start, end).  <a href="namespacewpi.html#a0f22fd8158dd46fe207d828ab907c6a9">More...</a><br /></td></tr>
<tr class="separator:a0f22fd8158dd46fe207d828ab907c6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9d3d4eb9461ff65cb2743afa9fd08a"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a0f9d3d4eb9461ff65cb2743afa9fd08a">split</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, char separator) noexcept</td></tr>
<tr class="memdesc:a0f9d3d4eb9461ff65cb2743afa9fd08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits <code>str</code> into two substrings around the first occurrence of a separator character.  <a href="namespacewpi.html#a0f9d3d4eb9461ff65cb2743afa9fd08a">More...</a><br /></td></tr>
<tr class="separator:a0f9d3d4eb9461ff65cb2743afa9fd08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b559c84b004c61700aa0724cf658177"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a2b559c84b004c61700aa0724cf658177">split</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> separator) noexcept</td></tr>
<tr class="memdesc:a2b559c84b004c61700aa0724cf658177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits <code>str</code> into two substrings around the first occurrence of a separator string.  <a href="namespacewpi.html#a2b559c84b004c61700aa0724cf658177">More...</a><br /></td></tr>
<tr class="separator:a2b559c84b004c61700aa0724cf658177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a31eb74242495e03e1745ab82085c81"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a7a31eb74242495e03e1745ab82085c81">rsplit</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, char separator) noexcept</td></tr>
<tr class="memdesc:a7a31eb74242495e03e1745ab82085c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits <code>str</code> into two substrings around the last occurrence of a separator character.  <a href="namespacewpi.html#a7a31eb74242495e03e1745ab82085c81">More...</a><br /></td></tr>
<tr class="separator:a7a31eb74242495e03e1745ab82085c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2512b6f3e4faf374ccc818722784597b"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a2512b6f3e4faf374ccc818722784597b">rsplit</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> separator) noexcept</td></tr>
<tr class="memdesc:a2512b6f3e4faf374ccc818722784597b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits <code>str</code> into two substrings around the last occurrence of a separator string.  <a href="namespacewpi.html#a2512b6f3e4faf374ccc818722784597b">More...</a><br /></td></tr>
<tr class="separator:a2512b6f3e4faf374ccc818722784597b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd39f69badd5bed05f8020e76e688911"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#afd39f69badd5bed05f8020e76e688911">split</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> &gt; &amp;arr, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> separator, int maxSplit=-1, bool keepEmpty=true) noexcept</td></tr>
<tr class="memdesc:afd39f69badd5bed05f8020e76e688911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits <code>str</code> into substrings around the occurrences of a separator string.  <a href="namespacewpi.html#afd39f69badd5bed05f8020e76e688911">More...</a><br /></td></tr>
<tr class="separator:afd39f69badd5bed05f8020e76e688911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32a7896ab3ee6b24926527703eabade"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ac32a7896ab3ee6b24926527703eabade">split</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> &gt; &amp;arr, char separator, int maxSplit=-1, bool keepEmpty=true) noexcept</td></tr>
<tr class="memdesc:ac32a7896ab3ee6b24926527703eabade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits <code>str</code> into substrings around the occurrences of a separator character.  <a href="namespacewpi.html#ac32a7896ab3ee6b24926527703eabade">More...</a><br /></td></tr>
<tr class="separator:ac32a7896ab3ee6b24926527703eabade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7c271a14f5c78641600f41d7c32299"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a1b7c271a14f5c78641600f41d7c32299">ltrim</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, char ch) noexcept</td></tr>
<tr class="memdesc:a1b7c271a14f5c78641600f41d7c32299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>str</code> with consecutive <code>ch</code> characters starting from the the left removed.  <a href="namespacewpi.html#a1b7c271a14f5c78641600f41d7c32299">More...</a><br /></td></tr>
<tr class="separator:a1b7c271a14f5c78641600f41d7c32299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b05ebace5b75bf9c0d3b9513f2c2d11"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a2b05ebace5b75bf9c0d3b9513f2c2d11">ltrim</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> chars=&quot; \t\n\v\f\r&quot;) noexcept</td></tr>
<tr class="memdesc:a2b05ebace5b75bf9c0d3b9513f2c2d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>str</code> with consecutive characters in <code>chars</code> starting from the left removed.  <a href="namespacewpi.html#a2b05ebace5b75bf9c0d3b9513f2c2d11">More...</a><br /></td></tr>
<tr class="separator:a2b05ebace5b75bf9c0d3b9513f2c2d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3a6a546687b31a4770178e1036c589"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#adb3a6a546687b31a4770178e1036c589">rtrim</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, char ch) noexcept</td></tr>
<tr class="memdesc:adb3a6a546687b31a4770178e1036c589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>str</code> with consecutive <code>Char</code> characters starting from the right removed.  <a href="namespacewpi.html#adb3a6a546687b31a4770178e1036c589">More...</a><br /></td></tr>
<tr class="separator:adb3a6a546687b31a4770178e1036c589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c241695392bec8c5295c438f6e8d35f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a9c241695392bec8c5295c438f6e8d35f">rtrim</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> chars=&quot; \t\n\v\f\r&quot;) noexcept</td></tr>
<tr class="memdesc:a9c241695392bec8c5295c438f6e8d35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>str</code> with consecutive characters in <code>chars</code> starting from the right removed.  <a href="namespacewpi.html#a9c241695392bec8c5295c438f6e8d35f">More...</a><br /></td></tr>
<tr class="separator:a9c241695392bec8c5295c438f6e8d35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8e2346d8ddaaaecfd3bc8760d09d9a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a4c8e2346d8ddaaaecfd3bc8760d09d9a">trim</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, char ch) noexcept</td></tr>
<tr class="memdesc:a4c8e2346d8ddaaaecfd3bc8760d09d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>str</code> with consecutive <code>ch</code> characters starting from the left and right removed.  <a href="namespacewpi.html#a4c8e2346d8ddaaaecfd3bc8760d09d9a">More...</a><br /></td></tr>
<tr class="separator:a4c8e2346d8ddaaaecfd3bc8760d09d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddfebd5ca997fb76159b3d79f1a98c9"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a5ddfebd5ca997fb76159b3d79f1a98c9">trim</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> chars=&quot; \t\n\v\f\r&quot;) noexcept</td></tr>
<tr class="memdesc:a5ddfebd5ca997fb76159b3d79f1a98c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>str</code> with consecutive characters in <code>chars</code> starting from the left and right removed.  <a href="namespacewpi.html#a5ddfebd5ca997fb76159b3d79f1a98c9">More...</a><br /></td></tr>
<tr class="separator:a5ddfebd5ca997fb76159b3d79f1a98c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed163433a5d70554975df8e7ef7f4df"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt; std::numeric_limits&lt; T &gt;<a class="el" href="format_8h.html#a56d0276c2e6f4b26cb3565e08ebc9181">::is_signed</a>, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a3ed163433a5d70554975df8e7ef7f4df"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a3ed163433a5d70554975df8e7ef7f4df">parse_integer</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, unsigned radix) noexcept</td></tr>
<tr class="memdesc:a3ed163433a5d70554975df8e7ef7f4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the string <code>str</code> as an integer of the specified radix.  <a href="namespacewpi.html#a3ed163433a5d70554975df8e7ef7f4df">More...</a><br /></td></tr>
<tr class="separator:a3ed163433a5d70554975df8e7ef7f4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd59d01b80175e78c41a25b325fa22b"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt; std::numeric_limits&lt; T &gt;<a class="el" href="format_8h.html#a56d0276c2e6f4b26cb3565e08ebc9181">::is_signed</a>, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a2fd59d01b80175e78c41a25b325fa22b"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a2fd59d01b80175e78c41a25b325fa22b">consume_integer</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> *str, unsigned radix) noexcept</td></tr>
<tr class="memdesc:a2fd59d01b80175e78c41a25b325fa22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the string <code>str</code> as an integer of the specified radix.  <a href="namespacewpi.html#a2fd59d01b80175e78c41a25b325fa22b">More...</a><br /></td></tr>
<tr class="separator:a2fd59d01b80175e78c41a25b325fa22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e2a33d363a34850deae1866c324eb6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae3e2a33d363a34850deae1866c324eb6"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ae3e2a33d363a34850deae1866c324eb6">parse_float</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str) noexcept</td></tr>
<tr class="memdesc:ae3e2a33d363a34850deae1866c324eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the string <code>str</code> as a floating point value.  <a href="namespacewpi.html#ae3e2a33d363a34850deae1866c324eb6">More...</a><br /></td></tr>
<tr class="separator:ae3e2a33d363a34850deae1866c324eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3739b1e7e77b69e3ce650907ca69ed"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aea3739b1e7e77b69e3ce650907ca69ed"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; float &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#aea3739b1e7e77b69e3ce650907ca69ed">parse_float&lt; float &gt;</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str) noexcept</td></tr>
<tr class="separator:aea3739b1e7e77b69e3ce650907ca69ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d19c9cf09501aa0ab358fa74281e96d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a2d19c9cf09501aa0ab358fa74281e96d"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a2d19c9cf09501aa0ab358fa74281e96d">parse_float&lt; double &gt;</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str) noexcept</td></tr>
<tr class="separator:a2d19c9cf09501aa0ab358fa74281e96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ec79c288a28100e273ac8c3e41b85b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a77ec79c288a28100e273ac8c3e41b85b"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; long double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a77ec79c288a28100e273ac8c3e41b85b">parse_float&lt; long double &gt;</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str) noexcept</td></tr>
<tr class="separator:a77ec79c288a28100e273ac8c3e41b85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1ac8844d24e58fc06de7d1270f0c7d"><td class="memTemplParams" colspan="2">template&lt;typename PtrType &gt; </td></tr>
<tr class="memitem:afd1ac8844d24e58fc06de7d1270f0c7d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#afd1ac8844d24e58fc06de7d1270f0c7d">operator==</a> (const <a class="el" href="classwpi_1_1_small_ptr_set_impl.html">SmallPtrSetImpl</a>&lt; PtrType &gt; &amp;LHS, const <a class="el" href="classwpi_1_1_small_ptr_set_impl.html">SmallPtrSetImpl</a>&lt; PtrType &gt; &amp;RHS)</td></tr>
<tr class="memdesc:afd1ac8844d24e58fc06de7d1270f0c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison for <a class="el" href="classwpi_1_1_small_ptr_set.html" title="SmallPtrSet - This class implements a set which is optimized for holding SmallSize or less elements.">SmallPtrSet</a>.  <a href="namespacewpi.html#afd1ac8844d24e58fc06de7d1270f0c7d">More...</a><br /></td></tr>
<tr class="separator:afd1ac8844d24e58fc06de7d1270f0c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3493bed4041adb43e57361d40517a4d4"><td class="memTemplParams" colspan="2">template&lt;typename PtrType &gt; </td></tr>
<tr class="memitem:a3493bed4041adb43e57361d40517a4d4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a3493bed4041adb43e57361d40517a4d4">operator!=</a> (const <a class="el" href="classwpi_1_1_small_ptr_set_impl.html">SmallPtrSetImpl</a>&lt; PtrType &gt; &amp;LHS, const <a class="el" href="classwpi_1_1_small_ptr_set_impl.html">SmallPtrSetImpl</a>&lt; PtrType &gt; &amp;RHS)</td></tr>
<tr class="memdesc:a3493bed4041adb43e57361d40517a4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison for <a class="el" href="classwpi_1_1_small_ptr_set.html" title="SmallPtrSet - This class implements a set which is optimized for holding SmallSize or less elements.">SmallPtrSet</a>.  <a href="namespacewpi.html#a3493bed4041adb43e57361d40517a4d4">More...</a><br /></td></tr>
<tr class="separator:a3493bed4041adb43e57361d40517a4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9630e9cd2902c4dbc7f817a6a84bb9da"><td class="memTemplParams" colspan="2">template&lt;typename RangeT , typename WrappedIteratorT  = decltype(std::begin(std::declval&lt;RangeT&gt;()))&gt; </td></tr>
<tr class="memitem:a9630e9cd2902c4dbc7f817a6a84bb9da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="structwpi_1_1pointee__iterator.html">pointee_iterator</a>&lt; WrappedIteratorT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a9630e9cd2902c4dbc7f817a6a84bb9da">make_pointee_range</a> (RangeT &amp;&amp;Range)</td></tr>
<tr class="separator:a9630e9cd2902c4dbc7f817a6a84bb9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa300eeb1def26aef1ca3af133fb26971"><td class="memTemplParams" colspan="2">template&lt;typename RangeT , typename WrappedIteratorT  = decltype(std::begin(std::declval&lt;RangeT&gt;()))&gt; </td></tr>
<tr class="memitem:aa300eeb1def26aef1ca3af133fb26971"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classwpi_1_1pointer__iterator.html">pointer_iterator</a>&lt; WrappedIteratorT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#aa300eeb1def26aef1ca3af133fb26971">make_pointer_range</a> (RangeT &amp;&amp;Range)</td></tr>
<tr class="separator:aa300eeb1def26aef1ca3af133fb26971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9adbe1d3698433c32c8b78b84f582a5b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a9adbe1d3698433c32c8b78b84f582a5b">GetHostname</a> ()</td></tr>
<tr class="separator:a9adbe1d3698433c32c8b78b84f582a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c253c393e339cc29a6e8ff9cb648420"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a3c253c393e339cc29a6e8ff9cb648420">GetHostname</a> (<a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;name)</td></tr>
<tr class="separator:a3c253c393e339cc29a6e8ff9cb648420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af979beb47215754d9f91b67aab2dc4e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#af979beb47215754d9f91b67aab2dc4e7">SocketErrno</a> ()</td></tr>
<tr class="separator:af979beb47215754d9f91b67aab2dc4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b76c9ad108ae76959df39c1d0b6f03b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a8b76c9ad108ae76959df39c1d0b6f03b">SocketStrerror</a> (int <a class="el" href="_third_party_notices_8txt.html#a84115a3d674a21b7abd56eab103ff848">code</a>)</td></tr>
<tr class="separator:a8b76c9ad108ae76959df39c1d0b6f03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d3b98c9badfe33b94b7c6ec1ad3f9f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#aa4d3b98c9badfe33b94b7c6ec1ad3f9f">SocketStrerror</a> ()</td></tr>
<tr class="separator:aa4d3b98c9badfe33b94b7c6ec1ad3f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863f7dccbe48e628d0674d0957238fe6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a863f7dccbe48e628d0674d0957238fe6">MimeTypeFromPath</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> path)</td></tr>
<tr class="separator:a863f7dccbe48e628d0674d0957238fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1285c84e98d61b7f161a2213dd9f7940"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a1285c84e98d61b7f161a2213dd9f7940">http_parser_version</a> (void)</td></tr>
<tr class="separator:a1285c84e98d61b7f161a2213dd9f7940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfaa8c347e0e51020430bcd0d45660b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#adfaa8c347e0e51020430bcd0d45660b4">http_parser_init</a> (<a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *parser, enum <a class="el" href="namespacewpi.html#ab37735642db3ab741e86bf064b2ddbbd">http_parser_type</a> <a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">type</a>)</td></tr>
<tr class="separator:adfaa8c347e0e51020430bcd0d45660b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f661690631e2ba6da370fe0b5bcfc55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a9f661690631e2ba6da370fe0b5bcfc55">http_parser_settings_init</a> (<a class="el" href="structwpi_1_1http__parser__settings.html">http_parser_settings</a> *settings)</td></tr>
<tr class="separator:a9f661690631e2ba6da370fe0b5bcfc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cea3956c069ac99ed2e7eeebb5b3cfb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a9cea3956c069ac99ed2e7eeebb5b3cfb">http_parser_execute</a> (<a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *parser, const <a class="el" href="structwpi_1_1http__parser__settings.html">http_parser_settings</a> *settings, const char *<a class="el" href="structdata.html">data</a>, size_t len)</td></tr>
<tr class="separator:a9cea3956c069ac99ed2e7eeebb5b3cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d892e596ff2ee4287ebd021faa63b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ad1d892e596ff2ee4287ebd021faa63b4">http_should_keep_alive</a> (const <a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *parser)</td></tr>
<tr class="separator:ad1d892e596ff2ee4287ebd021faa63b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be802a6897b36bbcd4c2dcd23e9e7f3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a9be802a6897b36bbcd4c2dcd23e9e7f3">http_method_str</a> (enum <a class="el" href="namespacewpi.html#a3458579fc7214ea6b0411bbadf6ffcbc">http_method</a> m)</td></tr>
<tr class="separator:a9be802a6897b36bbcd4c2dcd23e9e7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af568f1219d61f5c74f4de5caac588a90"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#af568f1219d61f5c74f4de5caac588a90">http_status_str</a> (enum <a class="el" href="namespacewpi.html#ae89a1f90a8603e399f9cc0465b0ce21e">http_status</a> s)</td></tr>
<tr class="separator:af568f1219d61f5c74f4de5caac588a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b4fb11893062b968b86716e84aebae"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ab0b4fb11893062b968b86716e84aebae">http_errno_name</a> (enum <a class="el" href="namespacewpi.html#a0e56bd09798339ac4f86d36eb8ecea0b">http_errno</a> err)</td></tr>
<tr class="separator:ab0b4fb11893062b968b86716e84aebae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534aec91ecbd222189dd61e56e809443"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a534aec91ecbd222189dd61e56e809443">http_errno_description</a> (enum <a class="el" href="namespacewpi.html#a0e56bd09798339ac4f86d36eb8ecea0b">http_errno</a> err)</td></tr>
<tr class="separator:a534aec91ecbd222189dd61e56e809443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798587facfa5f28d28e137d96c97a0d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a798587facfa5f28d28e137d96c97a0d0">http_parser_url_init</a> (struct <a class="el" href="structwpi_1_1http__parser__url.html">http_parser_url</a> *u)</td></tr>
<tr class="separator:a798587facfa5f28d28e137d96c97a0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc17f817835ce41947523e20f3feeb1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a7fc17f817835ce41947523e20f3feeb1">http_parser_parse_url</a> (const char *buf, size_t buflen, int is_connect, struct <a class="el" href="structwpi_1_1http__parser__url.html">http_parser_url</a> *u)</td></tr>
<tr class="separator:a7fc17f817835ce41947523e20f3feeb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc98ce08cafe77beb6171b08d3065181"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#afc98ce08cafe77beb6171b08d3065181">http_parser_pause</a> (<a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *parser, int paused)</td></tr>
<tr class="separator:afc98ce08cafe77beb6171b08d3065181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab736f59b1f30b097d559e33acc6bb602"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ab736f59b1f30b097d559e33acc6bb602">http_body_is_final</a> (const <a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *parser)</td></tr>
<tr class="separator:ab736f59b1f30b097d559e33acc6bb602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55235b8d8fe2b869b11a04237f1c1b5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a55235b8d8fe2b869b11a04237f1c1b5f">UnescapeURI</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;buf, bool *error)</td></tr>
<tr class="separator:a55235b8d8fe2b869b11a04237f1c1b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e885a95d4fbe472d78076ecc824194"><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ab6e885a95d4fbe472d78076ecc824194">EscapeURI</a> (<a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> str, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;buf, bool spacePlus=true)</td></tr>
<tr class="separator:ab6e885a95d4fbe472d78076ecc824194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12877798c9e05cae590789ebe25883b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a12877798c9e05cae590789ebe25883b7">ParseHttpHeaders</a> (<a class="el" href="classwpi_1_1raw__istream.html">raw_istream</a> &amp;is, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; *contentType, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; *contentLength)</td></tr>
<tr class="separator:a12877798c9e05cae590789ebe25883b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efec7766be35df2a4782f6cb1004058"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a8efec7766be35df2a4782f6cb1004058">FindMultipartBoundary</a> (<a class="el" href="classwpi_1_1raw__istream.html">wpi::raw_istream</a> &amp;is, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> boundary, std::string *saveBuf)</td></tr>
<tr class="separator:a8efec7766be35df2a4782f6cb1004058"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab3cecb2351a66db7a659706908ff8764"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structwpi_1_1empty__array__t.html">empty_array_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#ab3cecb2351a66db7a659706908ff8764">empty_array</a></td></tr>
<tr class="separator:ab3cecb2351a66db7a659706908ff8764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ddf62331eda674218d045fb5376c13"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned N&gt; </td></tr>
<tr class="memitem:a74ddf62331eda674218d045fb5376c13"><td class="memTemplItemLeft" align="right" valign="top">class <a class="el" href="_compiler_8h.html#a61e566d072949de225fa6912528beaf5">LLVM_GSL_OWNER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a74ddf62331eda674218d045fb5376c13">SmallVector</a></td></tr>
<tr class="memdesc:a74ddf62331eda674218d045fb5376c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration of <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> so that calculateSmallVectorDefaultInlinedElements can reference <code>sizeof(<a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a>&lt;T, 0&gt;)</code>.  <a href="namespacewpi.html#a74ddf62331eda674218d045fb5376c13">More...</a><br /></td></tr>
<tr class="separator:a74ddf62331eda674218d045fb5376c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096e48bf0264a255eb2ff954146cc85b"><td class="memItemLeft" align="right" valign="top">static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a096e48bf0264a255eb2ff954146cc85b">BitReverseTable256</a> [256]</td></tr>
<tr class="memdesc:a096e48bf0264a255eb2ff954146cc85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro compressed bit reversal table for 256 bits.  <a href="namespacewpi.html#a096e48bf0264a255eb2ff954146cc85b">More...</a><br /></td></tr>
<tr class="separator:a096e48bf0264a255eb2ff954146cc85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68147e630fcf898faec5b0f4cacd7214"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a68147e630fcf898faec5b0f4cacd7214">huge_valf</a></td></tr>
<tr class="memdesc:a68147e630fcf898faec5b0f4cacd7214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this rather than HUGE_VALF; the latter causes warnings on MSVC.  <a href="namespacewpi.html#a68147e630fcf898faec5b0f4cacd7214">More...</a><br /></td></tr>
<tr class="separator:a68147e630fcf898faec5b0f4cacd7214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e441a1bfb8b548adcb3fd7e08eb3be0"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structwpi_1_1in__place__t.html">in_place_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi.html#a9e441a1bfb8b548adcb3fd7e08eb3be0">in_place</a></td></tr>
<tr class="separator:a9e441a1bfb8b548adcb3fd7e08eb3be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >/file This file defines the <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> class. </p>
<p >Foonathan namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ac9954615e01ad150570a0e1d4548d879" name="ac9954615e01ad150570a0e1d4548d879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9954615e01ad150570a0e1d4548d879">&#9670;&nbsp;</a></span>Boolean</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool <a class="el" href="namespacewpi.html#ac9954615e01ad150570a0e1d4548d879">wpi::Boolean</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97cc1139d8f910187e3d4cd6b8015af8" name="a97cc1139d8f910187e3d4cd6b8015af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97cc1139d8f910187e3d4cd6b8015af8">&#9670;&nbsp;</a></span>condition_variable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewpi.html#a97cc1139d8f910187e3d4cd6b8015af8">wpi::condition_variable</a> = typedef ::std::condition_variable</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aacde1332b72e968317ed516552a07ca8" name="aacde1332b72e968317ed516552a07ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacde1332b72e968317ed516552a07ca8">&#9670;&nbsp;</a></span>fatal_error_handler_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* wpi::fatal_error_handler_t) (void *user_data, const char *reason, bool gen_crash_diag)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An error handler callback. </p>

</div>
</div>
<a id="a15767624048ad142d04bc6b1eab0d646" name="a15767624048ad142d04bc6b1eab0d646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15767624048ad142d04bc6b1eab0d646">&#9670;&nbsp;</a></span>http_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* wpi::http_cb) (<a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af30c1ffd4dedd4ff88adccac000e4c18" name="af30c1ffd4dedd4ff88adccac000e4c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30c1ffd4dedd4ff88adccac000e4c18">&#9670;&nbsp;</a></span>http_data_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* wpi::http_data_cb) (<a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *, const char *at, size_t length)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1bfe9b2fd329532b5e6a1bd52499d7d6" name="a1bfe9b2fd329532b5e6a1bd52499d7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bfe9b2fd329532b5e6a1bd52499d7d6">&#9670;&nbsp;</a></span>is_trivially_copy_constructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewpi.html#a1bfe9b2fd329532b5e6a1bd52499d7d6">wpi::is_trivially_copy_constructible</a> = typedef std::is_trivially_copy_constructible&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c9d00d0810a9683b42e6a4b51cde3f1" name="a5c9d00d0810a9683b42e6a4b51cde3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9d00d0810a9683b42e6a4b51cde3f1">&#9670;&nbsp;</a></span>is_trivially_move_constructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewpi.html#a5c9d00d0810a9683b42e6a4b51cde3f1">wpi::is_trivially_move_constructible</a> = typedef std::is_trivially_move_constructible&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59819be5b11c0fbbc0b8e07c7638af24" name="a59819be5b11c0fbbc0b8e07c7638af24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59819be5b11c0fbbc0b8e07c7638af24">&#9670;&nbsp;</a></span>mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewpi.html#a59819be5b11c0fbbc0b8e07c7638af24">wpi::mutex</a> = typedef ::std::mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a985e3eb8f9f12493630c5b00866467dd" name="a985e3eb8f9f12493630c5b00866467dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985e3eb8f9f12493630c5b00866467dd">&#9670;&nbsp;</a></span>raw_pointer_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename WrappedIteratorT , typename T1  = std::remove_reference_t&lt;decltype(              **std::declval&lt;WrappedIteratorT&gt;())&gt;, typename T2  = std::add_pointer_t&lt;T1&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewpi.html#a985e3eb8f9f12493630c5b00866467dd">wpi::raw_pointer_iterator</a> = typedef <a class="el" href="classwpi_1_1pointer__iterator.html">pointer_iterator</a>&lt;<a class="el" href="structwpi_1_1pointee__iterator.html">pointee_iterator</a>&lt;WrappedIteratorT, T1&gt;, T2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac654fbccde78931efbd96a33a8af5726" name="ac654fbccde78931efbd96a33a8af5726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac654fbccde78931efbd96a33a8af5726">&#9670;&nbsp;</a></span>recursive_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewpi.html#ac654fbccde78931efbd96a33a8af5726">wpi::recursive_mutex</a> = typedef ::std::recursive_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9fed3fc3490be636a867835e19df210" name="ad9fed3fc3490be636a867835e19df210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9fed3fc3490be636a867835e19df210">&#9670;&nbsp;</a></span>recursive_spinlock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewpi.html#ad9fed3fc3490be636a867835e19df210">wpi::recursive_spinlock</a> = typedef <a class="el" href="classwpi_1_1recursive__spinlock1.html">recursive_spinlock1</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4422f8f70db09a132698318a6c17c9b" name="ae4422f8f70db09a132698318a6c17c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4422f8f70db09a132698318a6c17c9b">&#9670;&nbsp;</a></span>remove_cvref_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewpi.html#ae4422f8f70db09a132698318a6c17c9b">wpi::remove_cvref_t</a> = typedef typename <a class="el" href="structwpi_1_1remove__cvref.html">wpi::remove_cvref</a>&lt;T&gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2fd1500d4f0a79e36ea629a6ed4b6f81" name="a2fd1500d4f0a79e36ea629a6ed4b6f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd1500d4f0a79e36ea629a6ed4b6f81">&#9670;&nbsp;</a></span>TypeAtIndex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewpi.html#a2fd1500d4f0a79e36ea629a6ed4b6f81">wpi::TypeAtIndex</a> = typedef std::tuple_element_t&lt;I, std::tuple&lt;Ts...&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the type at a given index in a list of types. </p>
<p >TypeAtIndex&lt;I, Ts...&gt; is the type at index I in Ts. </p>

</div>
</div>
<a id="a45f45c50238ed154108c2d79c37d19ab" name="a45f45c50238ed154108c2d79c37d19ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f45c50238ed154108c2d79c37d19ab">&#9670;&nbsp;</a></span>UTF16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned short <a class="el" href="namespacewpi.html#a45f45c50238ed154108c2d79c37d19ab">wpi::UTF16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab31f8b5d3b4b5750e308b9486c8063cf" name="ab31f8b5d3b4b5750e308b9486c8063cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31f8b5d3b4b5750e308b9486c8063cf">&#9670;&nbsp;</a></span>UTF32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">wpi::UTF32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37bbc3b1e95b6409a042b8089d3d8c00" name="a37bbc3b1e95b6409a042b8089d3d8c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37bbc3b1e95b6409a042b8089d3d8c00">&#9670;&nbsp;</a></span>UTF8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned char <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">wpi::UTF8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd4e2dafd0200d2e7686df5c99d07933" name="abd4e2dafd0200d2e7686df5c99d07933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4e2dafd0200d2e7686df5c99d07933">&#9670;&nbsp;</a></span>ValueTypeFromRangeType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewpi.html#abd4e2dafd0200d2e7686df5c99d07933">wpi::ValueTypeFromRangeType</a> = typedef typename std::remove_const&lt;typename std::remove_reference&lt; decltype(*std::begin(std::declval&lt;RangeType &amp;&gt;()))&gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a>&gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aae6baba019eee7e75848c7c03db9557b" name="aae6baba019eee7e75848c7c03db9557b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae6baba019eee7e75848c7c03db9557b">&#9670;&nbsp;</a></span>ConversionFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacewpi.html#aae6baba019eee7e75848c7c03db9557b">wpi::ConversionFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aae6baba019eee7e75848c7c03db9557ba32bafada5c584a9590053ed1bf5e7bfb" name="aae6baba019eee7e75848c7c03db9557ba32bafada5c584a9590053ed1bf5e7bfb"></a>strictConversion&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aae6baba019eee7e75848c7c03db9557ba26ee89af55088fc0f622de938525ad2a" name="aae6baba019eee7e75848c7c03db9557ba26ee89af55088fc0f622de938525ad2a"></a>lenientConversion&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ac792221430e4bf80c1b31493afd90bfe" name="ac792221430e4bf80c1b31493afd90bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac792221430e4bf80c1b31493afd90bfe">&#9670;&nbsp;</a></span>ConversionResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacewpi.html#ac792221430e4bf80c1b31493afd90bfe">wpi::ConversionResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac792221430e4bf80c1b31493afd90bfeaa1d30cd6c73259c50b7ce68207a7650f" name="ac792221430e4bf80c1b31493afd90bfeaa1d30cd6c73259c50b7ce68207a7650f"></a>conversionOK&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac792221430e4bf80c1b31493afd90bfea673cb258ea483b0e6f31d55cf61311d1" name="ac792221430e4bf80c1b31493afd90bfea673cb258ea483b0e6f31d55cf61311d1"></a>sourceExhausted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac792221430e4bf80c1b31493afd90bfeac785c0d8e74261d6cbde1d63f8535ed2" name="ac792221430e4bf80c1b31493afd90bfeac785c0d8e74261d6cbde1d63f8535ed2"></a>targetExhausted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac792221430e4bf80c1b31493afd90bfea34299b0f92763294d72a3117752dbbe0" name="ac792221430e4bf80c1b31493afd90bfea34299b0f92763294d72a3117752dbbe0"></a>sourceIllegal&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a0cc73ce1be7e2680fb97374e03368001" name="a0cc73ce1be7e2680fb97374e03368001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc73ce1be7e2680fb97374e03368001">&#9670;&nbsp;</a></span>errc</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001">wpi::errc</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a1b245b26b5ea3428c050d7f1503d7715" name="a0cc73ce1be7e2680fb97374e03368001a1b245b26b5ea3428c050d7f1503d7715"></a>argument_list_too_long&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a4b82222a0895b538d0597092b3ceab3e" name="a0cc73ce1be7e2680fb97374e03368001a4b82222a0895b538d0597092b3ceab3e"></a>argument_out_of_domain&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001aaf169f73a82794128aa491c4b4f1c071" name="a0cc73ce1be7e2680fb97374e03368001aaf169f73a82794128aa491c4b4f1c071"></a>bad_address&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a9941c5c8c58ff058b870e94e96ac38e1" name="a0cc73ce1be7e2680fb97374e03368001a9941c5c8c58ff058b870e94e96ac38e1"></a>bad_file_descriptor&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a2f0338eed54503152be1d31c93c9c2f1" name="a0cc73ce1be7e2680fb97374e03368001a2f0338eed54503152be1d31c93c9c2f1"></a>broken_pipe&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001ab3ab5338a00f49c4451851cc5442f370" name="a0cc73ce1be7e2680fb97374e03368001ab3ab5338a00f49c4451851cc5442f370"></a>device_or_resource_busy&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a6a336135d33e62f49edc55f29354e12e" name="a0cc73ce1be7e2680fb97374e03368001a6a336135d33e62f49edc55f29354e12e"></a>directory_not_empty&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a4dfaf9c996cf045f32d17edc9754fc95" name="a0cc73ce1be7e2680fb97374e03368001a4dfaf9c996cf045f32d17edc9754fc95"></a>executable_format_error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a41edf636e3c7b59f797348fc58472258" name="a0cc73ce1be7e2680fb97374e03368001a41edf636e3c7b59f797348fc58472258"></a>file_exists&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001aa1e14bfb89b41ddf654b1772c8fd2e74" name="a0cc73ce1be7e2680fb97374e03368001aa1e14bfb89b41ddf654b1772c8fd2e74"></a>file_too_large&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a6e56e6ed055b9771b8192a4f229fee27" name="a0cc73ce1be7e2680fb97374e03368001a6e56e6ed055b9771b8192a4f229fee27"></a>filename_too_long&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001aa33c516bbdfb179cef733c8daeb97bed" name="a0cc73ce1be7e2680fb97374e03368001aa33c516bbdfb179cef733c8daeb97bed"></a>function_not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a53a9e57a679708b2d8ff0ccd8ec96b18" name="a0cc73ce1be7e2680fb97374e03368001a53a9e57a679708b2d8ff0ccd8ec96b18"></a>illegal_byte_sequence&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a45fe7da1767194b580aeba752d7b44ae" name="a0cc73ce1be7e2680fb97374e03368001a45fe7da1767194b580aeba752d7b44ae"></a>inappropriate_io_control_operation&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001afadb76763385627e57ec386c9b6038f0" name="a0cc73ce1be7e2680fb97374e03368001afadb76763385627e57ec386c9b6038f0"></a>interrupted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001ae55d43eabeefe5a8271b4a3c898bd18f" name="a0cc73ce1be7e2680fb97374e03368001ae55d43eabeefe5a8271b4a3c898bd18f"></a>invalid_argument&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001abd86a2c65caf6a270b916234ab321ce3" name="a0cc73ce1be7e2680fb97374e03368001abd86a2c65caf6a270b916234ab321ce3"></a>invalid_seek&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001acccc32f2a5f7dc7b87d2f85daea66789" name="a0cc73ce1be7e2680fb97374e03368001acccc32f2a5f7dc7b87d2f85daea66789"></a>io_error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001af3c51d7ea75a76f26c0a2bdc00c4e006" name="a0cc73ce1be7e2680fb97374e03368001af3c51d7ea75a76f26c0a2bdc00c4e006"></a>is_a_directory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001ad08d4c854a6810cebd2a8ab61876f919" name="a0cc73ce1be7e2680fb97374e03368001ad08d4c854a6810cebd2a8ab61876f919"></a>no_child_process&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a58688487c3e24313637a76bd29881e64" name="a0cc73ce1be7e2680fb97374e03368001a58688487c3e24313637a76bd29881e64"></a>no_lock_available&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a1a5334dd8d1ca56e33887bd44630641b" name="a0cc73ce1be7e2680fb97374e03368001a1a5334dd8d1ca56e33887bd44630641b"></a>no_space_on_device&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a5c83a012eac17bbf458df5804801e373" name="a0cc73ce1be7e2680fb97374e03368001a5c83a012eac17bbf458df5804801e373"></a>no_such_device_or_address&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001af42b2e58729e2783b683c8610977fc22" name="a0cc73ce1be7e2680fb97374e03368001af42b2e58729e2783b683c8610977fc22"></a>no_such_device&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a2e70fc89b08f26fa3fc77694c91e8f7a" name="a0cc73ce1be7e2680fb97374e03368001a2e70fc89b08f26fa3fc77694c91e8f7a"></a>no_such_file_or_directory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001ad91a9b8a734f2bef4b778f89806cbab7" name="a0cc73ce1be7e2680fb97374e03368001ad91a9b8a734f2bef4b778f89806cbab7"></a>no_such_process&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a21e867ca95e1dfecff4701863547dcec" name="a0cc73ce1be7e2680fb97374e03368001a21e867ca95e1dfecff4701863547dcec"></a>not_a_directory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001aafdb5594dc3e484fc1bfd7c564d550c1" name="a0cc73ce1be7e2680fb97374e03368001aafdb5594dc3e484fc1bfd7c564d550c1"></a>not_enough_memory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001aa55e82356e9721946aa9ba954733c6f0" name="a0cc73ce1be7e2680fb97374e03368001aa55e82356e9721946aa9ba954733c6f0"></a>not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a8344b3d509942f035d5e303022f9b986" name="a0cc73ce1be7e2680fb97374e03368001a8344b3d509942f035d5e303022f9b986"></a>operation_not_permitted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001ae8ee838822072f02738dbd7d97ea03fc" name="a0cc73ce1be7e2680fb97374e03368001ae8ee838822072f02738dbd7d97ea03fc"></a>permission_denied&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a06108efce8ef1cd8aa4cc440f8b4317f" name="a0cc73ce1be7e2680fb97374e03368001a06108efce8ef1cd8aa4cc440f8b4317f"></a>read_only_file_system&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001aed65f7649c6f0e365673d65a9d8119d8" name="a0cc73ce1be7e2680fb97374e03368001aed65f7649c6f0e365673d65a9d8119d8"></a>resource_deadlock_would_occur&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001ae46a97ea2906921c8c626890bde832cf" name="a0cc73ce1be7e2680fb97374e03368001ae46a97ea2906921c8c626890bde832cf"></a>resource_unavailable_try_again&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a8e0fafb181567cc468e1ee81983d739d" name="a0cc73ce1be7e2680fb97374e03368001a8e0fafb181567cc468e1ee81983d739d"></a>result_out_of_range&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a3130d1d4e000cdc1e7c47013e313c10e" name="a0cc73ce1be7e2680fb97374e03368001a3130d1d4e000cdc1e7c47013e313c10e"></a>too_many_files_open_in_system&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001aed2c33c8fe874cfeba6f4a7747c62d05" name="a0cc73ce1be7e2680fb97374e03368001aed2c33c8fe874cfeba6f4a7747c62d05"></a>too_many_files_open&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001abfe22fc9b27a8ff13186aba60b6bc5c8" name="a0cc73ce1be7e2680fb97374e03368001abfe22fc9b27a8ff13186aba60b6bc5c8"></a>too_many_links&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a7b0000b45b0b55789f757f1c3d2461cb" name="a7b0000b45b0b55789f757f1c3d2461cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b0000b45b0b55789f757f1c3d2461cb">&#9670;&nbsp;</a></span>flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacewpi.html#a7b0000b45b0b55789f757f1c3d2461cb">wpi::flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7b0000b45b0b55789f757f1c3d2461cba22ea0cf0d50ecfe6b139d83ecc83d8df" name="a7b0000b45b0b55789f757f1c3d2461cba22ea0cf0d50ecfe6b139d83ecc83d8df"></a>F_CHUNKED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b0000b45b0b55789f757f1c3d2461cbaf14c04cd6f0125dbeceaf61b94fb1352" name="a7b0000b45b0b55789f757f1c3d2461cbaf14c04cd6f0125dbeceaf61b94fb1352"></a>F_CONNECTION_KEEP_ALIVE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b0000b45b0b55789f757f1c3d2461cba78a204621316260f385954c3bb0fff0f" name="a7b0000b45b0b55789f757f1c3d2461cba78a204621316260f385954c3bb0fff0f"></a>F_CONNECTION_CLOSE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b0000b45b0b55789f757f1c3d2461cba608843554e95e8438ea48d18e8034043" name="a7b0000b45b0b55789f757f1c3d2461cba608843554e95e8438ea48d18e8034043"></a>F_CONNECTION_UPGRADE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b0000b45b0b55789f757f1c3d2461cba819c3d4c4621c49323e997ef186e81cb" name="a7b0000b45b0b55789f757f1c3d2461cba819c3d4c4621c49323e997ef186e81cb"></a>F_TRAILING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b0000b45b0b55789f757f1c3d2461cba91bd0dc716ef59be0726782a89b3fe42" name="a7b0000b45b0b55789f757f1c3d2461cba91bd0dc716ef59be0726782a89b3fe42"></a>F_UPGRADE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b0000b45b0b55789f757f1c3d2461cba0741b53c2752382134a5c1548c4af772" name="a7b0000b45b0b55789f757f1c3d2461cba0741b53c2752382134a5c1548c4af772"></a>F_SKIPBODY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b0000b45b0b55789f757f1c3d2461cba63d30d0cca722219ca11f554a1adf1df" name="a7b0000b45b0b55789f757f1c3d2461cba63d30d0cca722219ca11f554a1adf1df"></a>F_CONTENTLENGTH&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a0e56bd09798339ac4f86d36eb8ecea0b" name="a0e56bd09798339ac4f86d36eb8ecea0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e56bd09798339ac4f86d36eb8ecea0b">&#9670;&nbsp;</a></span>http_errno</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacewpi.html#a0e56bd09798339ac4f86d36eb8ecea0b">wpi::http_errno</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3458579fc7214ea6b0411bbadf6ffcbc" name="a3458579fc7214ea6b0411bbadf6ffcbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3458579fc7214ea6b0411bbadf6ffcbc">&#9670;&nbsp;</a></span>http_method</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacewpi.html#a3458579fc7214ea6b0411bbadf6ffcbc">wpi::http_method</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab37735642db3ab741e86bf064b2ddbbd" name="ab37735642db3ab741e86bf064b2ddbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37735642db3ab741e86bf064b2ddbbd">&#9670;&nbsp;</a></span>http_parser_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacewpi.html#ab37735642db3ab741e86bf064b2ddbbd">wpi::http_parser_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab37735642db3ab741e86bf064b2ddbbda83022e72aaa06928c047700a88837608" name="ab37735642db3ab741e86bf064b2ddbbda83022e72aaa06928c047700a88837608"></a>HTTP_REQUEST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab37735642db3ab741e86bf064b2ddbbdaa131b28da3205e7a497320d97cead4a5" name="ab37735642db3ab741e86bf064b2ddbbdaa131b28da3205e7a497320d97cead4a5"></a>HTTP_RESPONSE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab37735642db3ab741e86bf064b2ddbbda404d2d378af4663f27fc14676459b13b" name="ab37735642db3ab741e86bf064b2ddbbda404d2d378af4663f27fc14676459b13b"></a>HTTP_BOTH&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="af3a0b479c88b876facf868f0c7a6b598" name="af3a0b479c88b876facf868f0c7a6b598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a0b479c88b876facf868f0c7a6b598">&#9670;&nbsp;</a></span>http_parser_url_fields</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacewpi.html#af3a0b479c88b876facf868f0c7a6b598">wpi::http_parser_url_fields</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af3a0b479c88b876facf868f0c7a6b598a0fc67d54599dc5b503765fb0792e2a54" name="af3a0b479c88b876facf868f0c7a6b598a0fc67d54599dc5b503765fb0792e2a54"></a>UF_SCHEMA&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af3a0b479c88b876facf868f0c7a6b598af8e30e235a6bdffaac9f1945ce205851" name="af3a0b479c88b876facf868f0c7a6b598af8e30e235a6bdffaac9f1945ce205851"></a>UF_HOST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af3a0b479c88b876facf868f0c7a6b598afb2e77eaed47bcfcfee307b2e1aff53a" name="af3a0b479c88b876facf868f0c7a6b598afb2e77eaed47bcfcfee307b2e1aff53a"></a>UF_PORT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af3a0b479c88b876facf868f0c7a6b598a45e701521a7ea4616989a7ed22cd0ae1" name="af3a0b479c88b876facf868f0c7a6b598a45e701521a7ea4616989a7ed22cd0ae1"></a>UF_PATH&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af3a0b479c88b876facf868f0c7a6b598a0e308fa010b3352bb15d9dee67b5b6ff" name="af3a0b479c88b876facf868f0c7a6b598a0e308fa010b3352bb15d9dee67b5b6ff"></a>UF_QUERY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af3a0b479c88b876facf868f0c7a6b598a8534d7d9e32ee9a877dddc70f7abdefd" name="af3a0b479c88b876facf868f0c7a6b598a8534d7d9e32ee9a877dddc70f7abdefd"></a>UF_FRAGMENT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af3a0b479c88b876facf868f0c7a6b598ae015b71bf6bfa3cfe09f78f1c9360235" name="af3a0b479c88b876facf868f0c7a6b598ae015b71bf6bfa3cfe09f78f1c9360235"></a>UF_USERINFO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af3a0b479c88b876facf868f0c7a6b598ac6a7f4a78be5640ed5c926efaf8301c2" name="af3a0b479c88b876facf868f0c7a6b598ac6a7f4a78be5640ed5c926efaf8301c2"></a>UF_MAX&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ae89a1f90a8603e399f9cc0465b0ce21e" name="ae89a1f90a8603e399f9cc0465b0ce21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89a1f90a8603e399f9cc0465b0ce21e">&#9670;&nbsp;</a></span>http_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacewpi.html#ae89a1f90a8603e399f9cc0465b0ce21e">wpi::http_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae00dc51f60e3a7f50eea48b914e9f88a" name="ae00dc51f60e3a7f50eea48b914e9f88a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00dc51f60e3a7f50eea48b914e9f88a">&#9670;&nbsp;</a></span>LogLevel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacewpi.html#ae00dc51f60e3a7f50eea48b914e9f88a">wpi::LogLevel</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae00dc51f60e3a7f50eea48b914e9f88aa4eaaa435255d53d8ee1ad804ac2fde9d" name="ae00dc51f60e3a7f50eea48b914e9f88aa4eaaa435255d53d8ee1ad804ac2fde9d"></a>WPI_LOG_CRITICAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae00dc51f60e3a7f50eea48b914e9f88aabd6cb7f9e35184593c719b52e3269f2e" name="ae00dc51f60e3a7f50eea48b914e9f88aabd6cb7f9e35184593c719b52e3269f2e"></a>WPI_LOG_ERROR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae00dc51f60e3a7f50eea48b914e9f88aae6035e37ce53de5e15e2d11ab3aaa8d2" name="ae00dc51f60e3a7f50eea48b914e9f88aae6035e37ce53de5e15e2d11ab3aaa8d2"></a>WPI_LOG_WARNING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae00dc51f60e3a7f50eea48b914e9f88aafb54895e0b8a35d815e26607f33bc33c" name="ae00dc51f60e3a7f50eea48b914e9f88aafb54895e0b8a35d815e26607f33bc33c"></a>WPI_LOG_INFO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae00dc51f60e3a7f50eea48b914e9f88aa82615e27834c547fec2af93cf5d4b4a7" name="ae00dc51f60e3a7f50eea48b914e9f88aa82615e27834c547fec2af93cf5d4b4a7"></a>WPI_LOG_DEBUG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae00dc51f60e3a7f50eea48b914e9f88aac7f7f9988bf8b7a36185cd7a19faa576" name="ae00dc51f60e3a7f50eea48b914e9f88aac7f7f9988bf8b7a36185cd7a19faa576"></a>WPI_LOG_DEBUG1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae00dc51f60e3a7f50eea48b914e9f88aa749ae7790a80d70497b9b873e51737c4" name="ae00dc51f60e3a7f50eea48b914e9f88aa749ae7790a80d70497b9b873e51737c4"></a>WPI_LOG_DEBUG2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae00dc51f60e3a7f50eea48b914e9f88aaec2f6db5ca268bd387c48d6e06c06ecc" name="ae00dc51f60e3a7f50eea48b914e9f88aaec2f6db5ca268bd387c48d6e06c06ecc"></a>WPI_LOG_DEBUG3&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae00dc51f60e3a7f50eea48b914e9f88aae12c0145b954247e75447e15f40ba4e9" name="ae00dc51f60e3a7f50eea48b914e9f88aae12c0145b954247e75447e15f40ba4e9"></a>WPI_LOG_DEBUG4&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ad1998965a76e8514d00562232f7b5efb" name="ad1998965a76e8514d00562232f7b5efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1998965a76e8514d00562232f7b5efb">&#9670;&nbsp;</a></span>ZeroBehavior</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efb">wpi::ZeroBehavior</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The behavior an operation has on an input of 0. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad1998965a76e8514d00562232f7b5efba481d3ff2733f6df876f66977ac4e9824" name="ad1998965a76e8514d00562232f7b5efba481d3ff2733f6df876f66977ac4e9824"></a>ZB_Undefined&#160;</td><td class="fielddoc"><p >The returned value is undefined. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad1998965a76e8514d00562232f7b5efba7ca42989d02ebf0e4fb3387724228f43" name="ad1998965a76e8514d00562232f7b5efba7ca42989d02ebf0e4fb3387724228f43"></a>ZB_Max&#160;</td><td class="fielddoc"><p >The returned value is numeric_limits&lt;T&gt;::max() </p>
</td></tr>
<tr><td class="fieldname"><a id="ad1998965a76e8514d00562232f7b5efba9a9cbdc2a1d5bc51861d496d5243a048" name="ad1998965a76e8514d00562232f7b5efba9a9cbdc2a1d5bc51861d496d5243a048"></a>ZB_Width&#160;</td><td class="fielddoc"><p >The returned value is numeric_limits&lt;T&gt;::digits. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6656e2d5f5ef57e67a1c35a3ed4b7f70" name="a6656e2d5f5ef57e67a1c35a3ed4b7f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6656e2d5f5ef57e67a1c35a3ed4b7f70">&#9670;&nbsp;</a></span>AbsoluteDifference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt; std::is_unsigned&lt; T &gt;<a class="el" href="classvalue.html">::value</a>, T &gt; wpi::AbsoluteDifference </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract two unsigned integers, X and Y, of type T and return the absolute value of the result. </p>

</div>
</div>
<a id="a3c94ed7f2d7c45d0edf41ce8527c38f2" name="a3c94ed7f2d7c45d0edf41ce8527c38f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c94ed7f2d7c45d0edf41ce8527c38f2">&#9670;&nbsp;</a></span>AddOverflow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt; <a class="el" href="format_8h.html#a56d0276c2e6f4b26cb3565e08ebc9181">std::is_signed</a>&lt; T &gt;<a class="el" href="classvalue.html">::value</a>, T &gt; wpi::AddOverflow </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add two signed integers, computing the two's complement truncated result, returning true if overflow occured. </p>

</div>
</div>
<a id="af96597787b5255d8569295b2a87d33cf" name="af96597787b5255d8569295b2a87d33cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96597787b5255d8569295b2a87d33cf">&#9670;&nbsp;</a></span>alignDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::alignDown </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Skew</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the largest uint64_t less than or equal to <code>Value</code> and is <code>Skew</code> mod <code>Align</code>. </p>
<p ><code>Align</code> must be non-zero </p>

</div>
</div>
<a id="a2e89f720bc5d42133b9e1fba299f9e6e" name="a2e89f720bc5d42133b9e1fba299f9e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e89f720bc5d42133b9e1fba299f9e6e">&#9670;&nbsp;</a></span>alignTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint64_t Align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint64_t wpi::alignTo </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next integer (mod 2**64) that is greater than or equal to <code>Value</code> and is a multiple of <code>Align</code>. </p>
<p ><code>Align</code> must be non-zero. </p>

</div>
</div>
<a id="a16dea88f23b7732e0e9560e626e0e29c" name="a16dea88f23b7732e0e9560e626e0e29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16dea88f23b7732e0e9560e626e0e29c">&#9670;&nbsp;</a></span>alignTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::alignTo </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Skew</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next integer (mod 2**64) that is greater than or equal to <code>Value</code> and is a multiple of <code>Align</code>. </p>
<p ><code>Align</code> must be non-zero.</p>
<p >If non-zero <code>Skew</code> is specified, the return value will be a minimal integer that is greater than or equal to <code>Value</code> and equal to <code>Align</code> * N + <code>Skew</code> for some integer N. If <code>Skew</code> is larger than <code>Align</code>, its value is adjusted to '<code>Skew</code> mod <code>Align'</code>.</p>
<p >Examples: </p><div class="fragment"><div class="line"><a class="code hl_function" href="namespacewpi.html#a16dea88f23b7732e0e9560e626e0e29c">alignTo</a>(5, 8) = 8</div>
<div class="line"><a class="code hl_function" href="namespacewpi.html#a16dea88f23b7732e0e9560e626e0e29c">alignTo</a>(17, 8) = 24</div>
<div class="line"><a class="code hl_function" href="namespacewpi.html#a16dea88f23b7732e0e9560e626e0e29c">alignTo</a>(~0LL, 8) = 0</div>
<div class="line"><a class="code hl_function" href="namespacewpi.html#a16dea88f23b7732e0e9560e626e0e29c">alignTo</a>(321, 255) = 510</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespacewpi.html#a16dea88f23b7732e0e9560e626e0e29c">alignTo</a>(5, 8, 7) = 7</div>
<div class="line"><a class="code hl_function" href="namespacewpi.html#a16dea88f23b7732e0e9560e626e0e29c">alignTo</a>(17, 8, 1) = 17</div>
<div class="line"><a class="code hl_function" href="namespacewpi.html#a16dea88f23b7732e0e9560e626e0e29c">alignTo</a>(~0LL, 8, 3) = 3</div>
<div class="line"><a class="code hl_function" href="namespacewpi.html#a16dea88f23b7732e0e9560e626e0e29c">alignTo</a>(321, 255, 42) = 552</div>
<div class="ttc" id="anamespacewpi_html_a16dea88f23b7732e0e9560e626e0e29c"><div class="ttname"><a href="namespacewpi.html#a16dea88f23b7732e0e9560e626e0e29c">wpi::alignTo</a></div><div class="ttdeci">uint64_t alignTo(uint64_t Value, uint64_t Align, uint64_t Skew=0)</div><div class="ttdoc">Returns the next integer (mod 2**64) that is greater than or equal to Value and is a multiple of Alig...</div><div class="ttdef"><b>Definition:</b> MathExtras.h:701</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac17a307d96b6bf9787f0dc6aac310fee" name="ac17a307d96b6bf9787f0dc6aac310fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17a307d96b6bf9787f0dc6aac310fee">&#9670;&nbsp;</a></span>allocate_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_compiler_8h.html#acbae7c06e77fa64145cca176963b6863">LLVM_ATTRIBUTE_RETURNS_NONNULL</a> <a class="el" href="_compiler_8h.html#a33bc304d1e6e184f3ffd9fa1620fd14c">LLVM_ATTRIBUTE_RETURNS_NOALIAS</a> void * wpi::allocate_buffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a buffer of memory with the given size and alignment. </p>
<p >When the compiler supports aligned operator new, this will use it to to handle even over-aligned allocations.</p>
<p >However, this doesn't make any attempt to leverage the fancier techniques like posix_memalign due to portability. It is mostly intended to allow compatibility with platforms that, after aligned allocation was added, use reduced default alignment. </p>

</div>
</div>
<a id="ad487e5ec5a2101d1f02907c77dd50558" name="ad487e5ec5a2101d1f02907c77dd50558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad487e5ec5a2101d1f02907c77dd50558">&#9670;&nbsp;</a></span>array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1array.html">wpi::array</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts...&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classwpi_1_1array.html">array</a>&lt; <a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt;(std::is_same_v&lt; T, Ts &gt; &amp;&amp;...), T &gt;, 1+sizeof...(Ts)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa84cf72de6e08899df61612e400beff1" name="aa84cf72de6e08899df61612e400beff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84cf72de6e08899df61612e400beff1">&#9670;&nbsp;</a></span>Base64Decode() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t wpi::Base64Decode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>encoded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac503c8c47490fca90512a88b23b65358" name="ac503c8c47490fca90512a88b23b65358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac503c8c47490fca90512a88b23b65358">&#9670;&nbsp;</a></span>Base64Decode() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> wpi::Base64Decode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>encoded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>num_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa145997bec65a8d0e2b783c384a6e3e4" name="aa145997bec65a8d0e2b783c384a6e3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa145997bec65a8d0e2b783c384a6e3e4">&#9670;&nbsp;</a></span>Base64Decode() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; uint8_t &gt; wpi::Base64Decode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>encoded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>num_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2dec1800b8c82d4cb942493afc4a828" name="af2dec1800b8c82d4cb942493afc4a828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2dec1800b8c82d4cb942493afc4a828">&#9670;&nbsp;</a></span>Base64Decode() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t wpi::Base64Decode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>encoded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>plain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a46c4d7b36efb76fd101c8cd219c9bdb8" name="a46c4d7b36efb76fd101c8cd219c9bdb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c4d7b36efb76fd101c8cd219c9bdb8">&#9670;&nbsp;</a></span>Base64Decode() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t wpi::Base64Decode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>encoded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; *&#160;</td>
          <td class="paramname"><em>plain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2d319e2a72f572e4fbdbb2017fd203e" name="ad2d319e2a72f572e4fbdbb2017fd203e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d319e2a72f572e4fbdbb2017fd203e">&#9670;&nbsp;</a></span>Base64Encode() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::Base64Encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const uint8_t &gt;&#160;</td>
          <td class="paramname"><em>plain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f0cca388f8042851ed82359d23c61e9" name="a8f0cca388f8042851ed82359d23c61e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0cca388f8042851ed82359d23c61e9">&#9670;&nbsp;</a></span>Base64Encode() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::Base64Encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>plain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c10d4e853c1b2027f22c23c46106f15" name="a3c10d4e853c1b2027f22c23c46106f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c10d4e853c1b2027f22c23c46106f15">&#9670;&nbsp;</a></span>Base64Encode() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> wpi::Base64Encode </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const uint8_t &gt;&#160;</td>
          <td class="paramname"><em>plain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a94f1eed3c192da2db90b3d0ab15d24c8" name="a94f1eed3c192da2db90b3d0ab15d24c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f1eed3c192da2db90b3d0ab15d24c8">&#9670;&nbsp;</a></span>Base64Encode() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::Base64Encode </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const uint8_t &gt;&#160;</td>
          <td class="paramname"><em>plain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>encoded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adbfd836e85f4e66313113339d542ae76" name="adbfd836e85f4e66313113339d542ae76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbfd836e85f4e66313113339d542ae76">&#9670;&nbsp;</a></span>Base64Encode() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> wpi::Base64Encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>plain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4351dc23f99c30ed993190988f3da889" name="a4351dc23f99c30ed993190988f3da889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4351dc23f99c30ed993190988f3da889">&#9670;&nbsp;</a></span>Base64Encode() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::Base64Encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>plain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>encoded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc0832dfca121b25b2bafc62df9bf0fa" name="abc0832dfca121b25b2bafc62df9bf0fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0832dfca121b25b2bafc62df9bf0fa">&#9670;&nbsp;</a></span>BitsToDouble()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double wpi::BitsToDouble </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Bits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function takes a 64-bit integer and returns the bit equivalent double. </p>

</div>
</div>
<a id="a359ca5bba5d202caf28f69f4102db2cb" name="a359ca5bba5d202caf28f69f4102db2cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359ca5bba5d202caf28f69f4102db2cb">&#9670;&nbsp;</a></span>BitsToFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float wpi::BitsToFloat </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Bits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function takes a 32-bit integer and returns the bit equivalent float. </p>

</div>
</div>
<a id="af2da1fed2899fcfbd9f07d967326a525" name="af2da1fed2899fcfbd9f07d967326a525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2da1fed2899fcfbd9f07d967326a525">&#9670;&nbsp;</a></span>ByteSwap_16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t wpi::ByteSwap_16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ByteSwap_16 - This function returns a byte-swapped representation of the 16-bit argument. </p>

</div>
</div>
<a id="a0b1253127a996aadeccdec1c291d6ab1" name="a0b1253127a996aadeccdec1c291d6ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1253127a996aadeccdec1c291d6ab1">&#9670;&nbsp;</a></span>ByteSwap_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t wpi::ByteSwap_32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns a byte-swapped representation of the 32-bit argument. </p>

</div>
</div>
<a id="a580a8d7ed139da4a7e9b6685138df8fa" name="a580a8d7ed139da4a7e9b6685138df8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580a8d7ed139da4a7e9b6685138df8fa">&#9670;&nbsp;</a></span>ByteSwap_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::ByteSwap_64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns a byte-swapped representation of the 64-bit argument. </p>

</div>
</div>
<a id="a703d958d0d00e12bac5736929f6f1b33" name="a703d958d0d00e12bac5736929f6f1b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703d958d0d00e12bac5736929f6f1b33">&#9670;&nbsp;</a></span>capacity_in_bytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT , typename KeyInfoT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t wpi::capacity_in_bytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_dense_map.html">DenseMap</a>&lt; KeyT, ValueT, KeyInfoT &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e35647cd9f9f0d2c097ea72e6d9f608" name="a0e35647cd9f9f0d2c097ea72e6d9f608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e35647cd9f9f0d2c097ea72e6d9f608">&#9670;&nbsp;</a></span>capacity_in_bytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t wpi::capacity_in_bytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_small_vector.html">SmallVector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a135363b62874f7e1527b3ee317063f28" name="a135363b62874f7e1527b3ee317063f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135363b62874f7e1527b3ee317063f28">&#9670;&nbsp;</a></span>compare_lower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int wpi::compare_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compare_lower - Compare two strings, ignoring case. </p>

</div>
</div>
<a id="a2fd59d01b80175e78c41a25b325fa22b" name="a2fd59d01b80175e78c41a25b325fa22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd59d01b80175e78c41a25b325fa22b">&#9670;&nbsp;</a></span>consume_integer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt; std::numeric_limits&lt; T &gt;<a class="el" href="format_8h.html#a56d0276c2e6f4b26cb3565e08ebc9181">::is_signed</a>, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; T &gt; wpi::consume_integer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses the string <code>str</code> as an integer of the specified radix. </p>
<p >If <code>radix</code> is specified as zero, this does radix autosensing using extended C rules: 0 is octal, 0x is hex, 0b is binary.</p>
<p >If the string does not begin with a number of the specified radix, this returns nullopt to signify the error. The string is considered erroneous if empty or if it overflows T. The portion of the string representing the discovered numeric value is removed from the beginning of the string. </p>

</div>
</div>
<a id="ac0c14a6177075406fca400c8f46d0dc5" name="ac0c14a6177075406fca400c8f46d0dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c14a6177075406fca400c8f46d0dc5">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> contains the substring <code>other</code>. </p>

</div>
</div>
<a id="a1426c18248d3c2ba9769800334f2c596" name="a1426c18248d3c2ba9769800334f2c596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1426c18248d3c2ba9769800334f2c596">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> contains the substring <code>other</code>. </p>

</div>
</div>
<a id="a57c338fbb3b9d95ab22856fb0aaacf94" name="a57c338fbb3b9d95ab22856fb0aaacf94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c338fbb3b9d95ab22856fb0aaacf94">&#9670;&nbsp;</a></span>contains() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> contains the substring <code>other</code>. </p>

</div>
</div>
<a id="ae7e058e611f4cf33ce6a9355be266854" name="ae7e058e611f4cf33ce6a9355be266854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e058e611f4cf33ce6a9355be266854">&#9670;&nbsp;</a></span>contains_lower() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::contains_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> contains the substring <code>other</code>, ignoring case. </p>

</div>
</div>
<a id="a93417c92f7c6516d3746b419a5f6ec39" name="a93417c92f7c6516d3746b419a5f6ec39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93417c92f7c6516d3746b419a5f6ec39">&#9670;&nbsp;</a></span>contains_lower() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::contains_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> contains the substring <code>other</code>, ignoring case. </p>

</div>
</div>
<a id="afec927e053502a01b8b57dbc9fe7ceea" name="afec927e053502a01b8b57dbc9fe7ceea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec927e053502a01b8b57dbc9fe7ceea">&#9670;&nbsp;</a></span>contains_lower() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::contains_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> contains the substring <code>other</code>, ignoring case. </p>

</div>
</div>
<a id="a0b2b50e25edd8fc47c0ef3b0929a9aac" name="a0b2b50e25edd8fc47c0ef3b0929a9aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2b50e25edd8fc47c0ef3b0929a9aac">&#9670;&nbsp;</a></span>ConvertCodePointToUTF8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::ConvertCodePointToUTF8 </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>Source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>ResultPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an Unicode code point to UTF8 sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">Source</td><td>a Unicode code point. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ResultPtr</td><td>pointer to the output buffer, needs to be at least <code>UNI_MAX_UTF8_BYTES_PER_CODE_POINT</code> bytes. On success <code>ResultPtr</code> is updated one past end of the converted sequence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success. </dd></dl>

</div>
</div>
<a id="a9257f3c46568bac25b1ba2f3fac4678a" name="a9257f3c46568bac25b1ba2f3fac4678a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9257f3c46568bac25b1ba2f3fac4678a">&#9670;&nbsp;</a></span>ConvertUTF16toUTF32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacewpi.html#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a> wpi::ConvertUTF16toUTF32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacewpi.html#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> **&#160;</td>
          <td class="paramname"><em>sourceStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacewpi.html#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> *&#160;</td>
          <td class="paramname"><em>sourceEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> **&#160;</td>
          <td class="paramname"><em>targetStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *&#160;</td>
          <td class="paramname"><em>targetEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac54c2f26ecf324df5da9128c77052d31" name="ac54c2f26ecf324df5da9128c77052d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54c2f26ecf324df5da9128c77052d31">&#9670;&nbsp;</a></span>ConvertUTF16toUTF8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacewpi.html#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a> wpi::ConvertUTF16toUTF8 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacewpi.html#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> **&#160;</td>
          <td class="paramname"><em>sourceStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacewpi.html#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> *&#160;</td>
          <td class="paramname"><em>sourceEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **&#160;</td>
          <td class="paramname"><em>targetStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *&#160;</td>
          <td class="paramname"><em>targetEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad96959c1be95aa4d288cc84e11ab6f1b" name="ad96959c1be95aa4d288cc84e11ab6f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96959c1be95aa4d288cc84e11ab6f1b">&#9670;&nbsp;</a></span>convertUTF16ToUTF8String() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::convertUTF16ToUTF8String </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const char &gt;&#160;</td>
          <td class="paramname"><em>SrcBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>Out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a stream of raw bytes assumed to be UTF16 into a UTF8 std::string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SrcBytes</td><td>A buffer of what is assumed to be UTF-16 encoded text. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Out</td><td>Converted UTF-8 is stored here on success. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success </dd></dl>

</div>
</div>
<a id="aae550217f649fc634dfa84af9795df29" name="aae550217f649fc634dfa84af9795df29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae550217f649fc634dfa84af9795df29">&#9670;&nbsp;</a></span>convertUTF16ToUTF8String() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::convertUTF16ToUTF8String </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const <a class="el" href="namespacewpi.html#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> &gt;&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>Out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a UTF16 string into a UTF8 std::string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Src</td><td>A buffer of UTF-16 encoded text. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Out</td><td>Converted UTF-8 is stored here on success. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success </dd></dl>

</div>
</div>
<a id="a323342b32a2c5cf6e46b217e4843c014" name="a323342b32a2c5cf6e46b217e4843c014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323342b32a2c5cf6e46b217e4843c014">&#9670;&nbsp;</a></span>ConvertUTF32toUTF16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacewpi.html#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a> wpi::ConvertUTF32toUTF16 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> **&#160;</td>
          <td class="paramname"><em>sourceStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *&#160;</td>
          <td class="paramname"><em>sourceEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> **&#160;</td>
          <td class="paramname"><em>targetStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> *&#160;</td>
          <td class="paramname"><em>targetEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a903ac386cdae4917d7cc20ed662dcee5" name="a903ac386cdae4917d7cc20ed662dcee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903ac386cdae4917d7cc20ed662dcee5">&#9670;&nbsp;</a></span>ConvertUTF32toUTF8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacewpi.html#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a> wpi::ConvertUTF32toUTF8 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> **&#160;</td>
          <td class="paramname"><em>sourceStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *&#160;</td>
          <td class="paramname"><em>sourceEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **&#160;</td>
          <td class="paramname"><em>targetStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *&#160;</td>
          <td class="paramname"><em>targetEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a349ec073e684b8777cd7e7166dd3b465" name="a349ec073e684b8777cd7e7166dd3b465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a349ec073e684b8777cd7e7166dd3b465">&#9670;&nbsp;</a></span>convertUTF8Sequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacewpi.html#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a> wpi::convertUTF8Sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *&#160;</td>
          <td class="paramname"><em>sourceEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the first UTF8 sequence in the given source buffer to a UTF32 code point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">source</td><td>A pointer to the source buffer. If the conversion succeeds, this pointer will be updated to point to the byte just past the end of the converted sequence. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sourceEnd</td><td>A pointer just past the end of the source buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">target</td><td>The converted code </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">flags</td><td>Whether the conversion is strict or lenient.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>conversionOK on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacewpi.html#ab9c663588a7ff49ab4cb3ffb71e5d5c6" title="Convert a partial UTF8 sequence to UTF32.">ConvertUTF8toUTF32</a> </dd></dl>

</div>
</div>
<a id="a4bada7642f7a62d2271fd42cd0cb01f3" name="a4bada7642f7a62d2271fd42cd0cb01f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bada7642f7a62d2271fd42cd0cb01f3">&#9670;&nbsp;</a></span>ConvertUTF8toUTF16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacewpi.html#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a> wpi::ConvertUTF8toUTF16 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **&#160;</td>
          <td class="paramname"><em>sourceStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *&#160;</td>
          <td class="paramname"><em>sourceEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> **&#160;</td>
          <td class="paramname"><em>targetStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> *&#160;</td>
          <td class="paramname"><em>targetEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a051a613a70381a8d15a4ed7630bfd942" name="a051a613a70381a8d15a4ed7630bfd942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051a613a70381a8d15a4ed7630bfd942">&#9670;&nbsp;</a></span>convertUTF8ToUTF16String()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::convertUTF8ToUTF16String </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>SrcUTF8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; <a class="el" href="namespacewpi.html#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DstUTF16</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a UTF-8 string into a UTF-16 string with native endianness. </p>
<dl class="section return"><dt>Returns</dt><dd>true on success </dd></dl>

</div>
</div>
<a id="ab9c663588a7ff49ab4cb3ffb71e5d5c6" name="ab9c663588a7ff49ab4cb3ffb71e5d5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c663588a7ff49ab4cb3ffb71e5d5c6">&#9670;&nbsp;</a></span>ConvertUTF8toUTF32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacewpi.html#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a> wpi::ConvertUTF8toUTF32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **&#160;</td>
          <td class="paramname"><em>sourceStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *&#160;</td>
          <td class="paramname"><em>sourceEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> **&#160;</td>
          <td class="paramname"><em>targetStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *&#160;</td>
          <td class="paramname"><em>targetEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a partial UTF8 sequence to UTF32. </p>
<p >If the sequence ends in an incomplete code unit sequence, returns <code>sourceIllegal</code>. </p>

</div>
</div>
<a id="aac9f39188361bf855a010751dbafbaff" name="aac9f39188361bf855a010751dbafbaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9f39188361bf855a010751dbafbaff">&#9670;&nbsp;</a></span>ConvertUTF8toUTF32Partial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacewpi.html#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a> wpi::ConvertUTF8toUTF32Partial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **&#160;</td>
          <td class="paramname"><em>sourceStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *&#160;</td>
          <td class="paramname"><em>sourceEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> **&#160;</td>
          <td class="paramname"><em>targetStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *&#160;</td>
          <td class="paramname"><em>targetEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a partial UTF8 sequence to UTF32. </p>
<p >If the sequence ends in an incomplete code unit sequence, returns <code>sourceExhausted</code>. </p>

</div>
</div>
<a id="a34dcbda849543386fc00cfa5e9a30b1a" name="a34dcbda849543386fc00cfa5e9a30b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34dcbda849543386fc00cfa5e9a30b1a">&#9670;&nbsp;</a></span>ConvertUTF8toWide() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::ConvertUTF8toWide </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>Source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::wstring &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a UTF-8 C-string to a std::wstring. </p>
<dl class="section return"><dt>Returns</dt><dd>true on success. </dd></dl>

</div>
</div>
<a id="ab6c65f324a518248ea7c9e3dec6abd2e" name="ab6c65f324a518248ea7c9e3dec6abd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c65f324a518248ea7c9e3dec6abd2e">&#9670;&nbsp;</a></span>ConvertUTF8toWide() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::ConvertUTF8toWide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>Source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::wstring &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a UTF-8 string_view to a std::wstring. </p>
<dl class="section return"><dt>Returns</dt><dd>true on success. </dd></dl>

</div>
</div>
<a id="a4f044a5abfa43152b4511fc34f422abd" name="a4f044a5abfa43152b4511fc34f422abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f044a5abfa43152b4511fc34f422abd">&#9670;&nbsp;</a></span>ConvertUTF8toWide() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::ConvertUTF8toWide </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>WideCharWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>Source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>ResultPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *&amp;&#160;</td>
          <td class="paramname"><em>ErrorPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an UTF8 string_view to UTF8, UTF16, or UTF32 depending on WideCharWidth. </p>
<p >The converted data is written to ResultPtr, which needs to point to at least WideCharWidth * (Source.Size() + 1) bytes. On success, ResultPtr will point one after the end of the copied string. On failure, ResultPtr will not be changed, and ErrorPtr will be set to the location of the first character which could not be converted. </p><dl class="section return"><dt>Returns</dt><dd>true on success. </dd></dl>

</div>
</div>
<a id="a4e0d4fcb62d165827231b4132e83e1a7" name="a4e0d4fcb62d165827231b4132e83e1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0d4fcb62d165827231b4132e83e1a7">&#9670;&nbsp;</a></span>convertWideToUTF8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::convertWideToUTF8 </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>Source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a std::wstring to a UTF-8 encoded std::string. </p>
<dl class="section return"><dt>Returns</dt><dd>true on success. </dd></dl>

</div>
</div>
<a id="a7bf0e41abe6919730147bff8b43e321e" name="a7bf0e41abe6919730147bff8b43e321e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf0e41abe6919730147bff8b43e321e">&#9670;&nbsp;</a></span>countLeadingOnes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned wpi::countLeadingOnes </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efb">ZeroBehavior</a>&#160;</td>
          <td class="paramname"><em>ZB</em> = <code><a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efba9a9cbdc2a1d5bc51861d496d5243a048">ZB_Width</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of ones from the most significant bit to the first zero bit. </p>
<p >Ex. countLeadingOnes(0xFF0FFF00) == 8. Only unsigned integral types are allowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ZB</td><td>the behavior on an input of all ones. Only ZB_Width and ZB_Undefined are valid arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c2b5dfad335d4ed298cf53a9abdfa07" name="a2c2b5dfad335d4ed298cf53a9abdfa07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2b5dfad335d4ed298cf53a9abdfa07">&#9670;&nbsp;</a></span>countLeadingZeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned wpi::countLeadingZeros </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efb">ZeroBehavior</a>&#160;</td>
          <td class="paramname"><em>ZB</em> = <code><a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efba9a9cbdc2a1d5bc51861d496d5243a048">ZB_Width</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count number of 0's from the most significant bit to the least stopping at the first 1. </p>
<p >Only unsigned integral types are allowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ZB</td><td>the behavior on an input of 0. Only ZB_Width and ZB_Undefined are valid arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb722826475651bd5c1df0f02dff8948" name="aeb722826475651bd5c1df0f02dff8948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb722826475651bd5c1df0f02dff8948">&#9670;&nbsp;</a></span>countPopulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned wpi::countPopulation </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of set bits in a value. </p>
<p >Ex. countPopulation(0xF000F000) = 8 Returns 0 if the word is zero. </p>

</div>
</div>
<a id="a90d3b71dd4da9a85a35767dfe54e8c84" name="a90d3b71dd4da9a85a35767dfe54e8c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d3b71dd4da9a85a35767dfe54e8c84">&#9670;&nbsp;</a></span>countTrailingOnes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned wpi::countTrailingOnes </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efb">ZeroBehavior</a>&#160;</td>
          <td class="paramname"><em>ZB</em> = <code><a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efba9a9cbdc2a1d5bc51861d496d5243a048">ZB_Width</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of ones from the least significant bit to the first zero bit. </p>
<p >Ex. countTrailingOnes(0x00FF00FF) == 8. Only unsigned integral types are allowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ZB</td><td>the behavior on an input of all ones. Only ZB_Width and ZB_Undefined are valid arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10e2eb77f5b39477413026df59b92032" name="a10e2eb77f5b39477413026df59b92032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10e2eb77f5b39477413026df59b92032">&#9670;&nbsp;</a></span>countTrailingZeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned wpi::countTrailingZeros </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efb">ZeroBehavior</a>&#160;</td>
          <td class="paramname"><em>ZB</em> = <code><a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efba9a9cbdc2a1d5bc51861d496d5243a048">ZB_Width</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count number of 0's from the least significant bit to the most stopping at the first 1. </p>
<p >Only unsigned integral types are allowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ZB</td><td>the behavior on an input of 0. Only ZB_Width and ZB_Undefined are valid arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5847649747d23028195684c90de9cfa1" name="a5847649747d23028195684c90de9cfa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5847649747d23028195684c90de9cfa1">&#9670;&nbsp;</a></span>CTLog2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t kValue&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t wpi::CTLog2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time Log2. </p>
<p >Valid only for positive powers of two. </p>

</div>
</div>
<a id="a72a3d85b513c921ffa14928e047294b6" name="a72a3d85b513c921ffa14928e047294b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a3d85b513c921ffa14928e047294b6">&#9670;&nbsp;</a></span>CTLog2&lt; 1 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="namespacewpi.html#a5847649747d23028195684c90de9cfa1">wpi::CTLog2</a>&lt; 1 &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a693165287d8a8a5159fd739216188620" name="a693165287d8a8a5159fd739216188620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693165287d8a8a5159fd739216188620">&#9670;&nbsp;</a></span>deallocate_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::deallocate_buffer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate a buffer of memory with the given size and alignment. </p>
<p >If supported, this will used the sized delete operator. Also if supported, this will pass the alignment to the delete operator.</p>
<p >The pointer must have been allocated with the corresponding new operator, most likely using the above helper. </p>

</div>
</div>
<a id="a1e7e386e354d5ee78df311f700c7fae0" name="a1e7e386e354d5ee78df311f700c7fae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7e386e354d5ee78df311f700c7fae0">&#9670;&nbsp;</a></span>Demangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string wpi::Demangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>mangledSymbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Demangle a C++ symbol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mangledSymbol</td><td>the mangled symbol. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The demangled symbol, or mangledSymbol if demangling fails. </dd></dl>

</div>
</div>
<a id="a86598beceb2a41ea10f4335f8d5b99e4" name="a86598beceb2a41ea10f4335f8d5b99e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86598beceb2a41ea10f4335f8d5b99e4">&#9670;&nbsp;</a></span>divideCeil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::divideCeil </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Numerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Denominator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the integer ceil(Numerator / Denominator). </p>

</div>
</div>
<a id="a75514d8e686b9790882d92c4efc0c8f3" name="a75514d8e686b9790882d92c4efc0c8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75514d8e686b9790882d92c4efc0c8f3">&#9670;&nbsp;</a></span>divideNearest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::divideNearest </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Numerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Denominator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the integer nearest(Numerator / Denominator). </p>

</div>
</div>
<a id="ac6c0723b9fdd34186cb26335c29e4ccc" name="ac6c0723b9fdd34186cb26335c29e4ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c0723b9fdd34186cb26335c29e4ccc">&#9670;&nbsp;</a></span>djbHash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t wpi::djbHash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>H</em> = <code>5381</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Bernstein hash function used by the DWARF accelerator tables. </p>

</div>
</div>
<a id="af5ceead4d80776d6071e511d8f5d9353" name="af5ceead4d80776d6071e511d8f5d9353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ceead4d80776d6071e511d8f5d9353">&#9670;&nbsp;</a></span>DoubleToBits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::DoubleToBits </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Double</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function takes a double and returns the bit equivalent 64-bit integer. </p>
<p >Note that copying doubles around changes the bits of NaNs on some hosts, notably x86, so this routine cannot be used if these bits are needed. </p>

</div>
</div>
<a id="a58b74b99b021d98ad0b415c12920f259" name="a58b74b99b021d98ad0b415c12920f259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b74b99b021d98ad0b415c12920f259">&#9670;&nbsp;</a></span>drop_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::span&lt; T &gt; wpi::drop_back </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::span&lt; T &gt;::size_type&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop the last <code>N</code> elements of the array. </p>

</div>
</div>
<a id="a7f57db8fe105b74dbfbd5897fa695c14" name="a7f57db8fe105b74dbfbd5897fa695c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f57db8fe105b74dbfbd5897fa695c14">&#9670;&nbsp;</a></span>drop_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> wpi::drop_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a string_view equal to <code>str</code> but with the last <code>n</code> elements dropped. </p>

</div>
</div>
<a id="abbf0701ba0d3863a755e0b2a1cc08603" name="abbf0701ba0d3863a755e0b2a1cc08603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf0701ba0d3863a755e0b2a1cc08603">&#9670;&nbsp;</a></span>drop_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::span&lt; T &gt; wpi::drop_front </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::span&lt; T &gt;::size_type&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop the first <code>N</code> elements of the array. </p>

</div>
</div>
<a id="aa5e1eeb77b140b88774935651084a248" name="aa5e1eeb77b140b88774935651084a248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e1eeb77b140b88774935651084a248">&#9670;&nbsp;</a></span>drop_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> wpi::drop_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a string_view equal to <code>str</code> but with the first <code>n</code> elements dropped. </p>

</div>
</div>
<a id="abd4df2968e94c4ee3ac050889f633446" name="abd4df2968e94c4ee3ac050889f633446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4df2968e94c4ee3ac050889f633446">&#9670;&nbsp;</a></span>ends_with() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> ends with the given <code>suffix</code>. </p>

</div>
</div>
<a id="a3ec868a416c46e73b09990b9accd5531" name="a3ec868a416c46e73b09990b9accd5531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec868a416c46e73b09990b9accd5531">&#9670;&nbsp;</a></span>ends_with() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> ends with the given <code>suffix</code>. </p>

</div>
</div>
<a id="ae76aa40d978aab32a3dcfab7f8eb953b" name="ae76aa40d978aab32a3dcfab7f8eb953b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76aa40d978aab32a3dcfab7f8eb953b">&#9670;&nbsp;</a></span>ends_with() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> ends with the given <code>suffix</code>. </p>

</div>
</div>
<a id="a95519eb02ecc90f51e4157b797a4c306" name="a95519eb02ecc90f51e4157b797a4c306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95519eb02ecc90f51e4157b797a4c306">&#9670;&nbsp;</a></span>ends_with_lower() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::ends_with_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> ends with the given <code>suffix</code>, ignoring case. </p>

</div>
</div>
<a id="ac1334c1afcb5a1b5592e57a78436915b" name="ac1334c1afcb5a1b5592e57a78436915b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1334c1afcb5a1b5592e57a78436915b">&#9670;&nbsp;</a></span>ends_with_lower() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::ends_with_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> ends with the given <code>suffix</code>, ignoring case. </p>

</div>
</div>
<a id="a63ce9b37507ebc31753938d388848714" name="a63ce9b37507ebc31753938d388848714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ce9b37507ebc31753938d388848714">&#9670;&nbsp;</a></span>ends_with_lower() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::ends_with_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> ends with the given <code>suffix</code>, ignoring case. </p>

</div>
</div>
<a id="a861d18fea3edd7f459017ea02e79d5ea" name="a861d18fea3edd7f459017ea02e79d5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861d18fea3edd7f459017ea02e79d5ea">&#9670;&nbsp;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::equals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>equals - Check for string equality, this is more efficient than compare() when the relative ordering of inequal strings isn't needed. </p>

</div>
</div>
<a id="a6f467e8545fad85176bcf4e64ced7bc7" name="a6f467e8545fad85176bcf4e64ced7bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f467e8545fad85176bcf4e64ced7bc7">&#9670;&nbsp;</a></span>equals_lower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::equals_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>equals_lower - Check for string equality, ignoring case. </p>

</div>
</div>
<a id="aca972941e2effcb07cfc0e14b7c783f6" name="aca972941e2effcb07cfc0e14b7c783f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca972941e2effcb07cfc0e14b7c783f6">&#9670;&nbsp;</a></span>errs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1raw__fd__ostream.html">raw_fd_ostream</a> &amp; wpi::errs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns a reference to a <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> for standard error. </p>
<p >Use it like: <a class="el" href="namespacewpi.html#aca972941e2effcb07cfc0e14b7c783f6" title="This returns a reference to a raw_ostream for standard error.">errs()</a> &lt;&lt; "foo" &lt;&lt; "bar"; By default, the stream is tied to stdout to ensure stdout is flushed before stderr is written, to ensure the error messages are written in their expected place. </p>

</div>
</div>
<a id="ab6e885a95d4fbe472d78076ecc824194" name="ab6e885a95d4fbe472d78076ecc824194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e885a95d4fbe472d78076ecc824194">&#9670;&nbsp;</a></span>EscapeURI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> wpi::EscapeURI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>spacePlus</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a32f2207fbd2f0fbd2a85bda3ef353ec5" name="a32f2207fbd2f0fbd2a85bda3ef353ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f2207fbd2f0fbd2a85bda3ef353ec5">&#9670;&nbsp;</a></span>find_lower() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view::size_type wpi::find_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type&#160;</td>
          <td class="paramname"><em>from</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the first character <code>ch</code> in <code>str</code>, ignoring case. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first occurrence of <code>ch</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="a5f278b2f7c4f0f3d3417390f77979fd5" name="a5f278b2f7c4f0f3d3417390f77979fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f278b2f7c4f0f3d3417390f77979fd5">&#9670;&nbsp;</a></span>find_lower() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view::size_type wpi::find_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type&#160;</td>
          <td class="paramname"><em>from</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the first string <code>other</code> in <code>str</code>, ignoring case. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first occurrence of <code>other</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="af5e73ed8bf4d49b2734570b2c83f9303" name="af5e73ed8bf4d49b2734570b2c83f9303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e73ed8bf4d49b2734570b2c83f9303">&#9670;&nbsp;</a></span>find_lower() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view::size_type wpi::find_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type&#160;</td>
          <td class="paramname"><em>from</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the first string <code>other</code> in <code>str</code>, ignoring case. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first occurrence of <code>other</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="a3b142bef5a5b68ba5def7d5428653014" name="a3b142bef5a5b68ba5def7d5428653014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b142bef5a5b68ba5def7d5428653014">&#9670;&nbsp;</a></span>findFirstSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T wpi::findFirstSet </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efb">ZeroBehavior</a>&#160;</td>
          <td class="paramname"><em>ZB</em> = <code><a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efba7ca42989d02ebf0e4fb3387724228f43">ZB_Max</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of the first set bit starting from the least significant bit. </p>
<p >Only unsigned integral types are allowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ZB</td><td>the behavior on an input of 0. Only ZB_Max and ZB_Undefined are valid arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b04cd68057d9779f905d1a86d9c9fc9" name="a2b04cd68057d9779f905d1a86d9c9fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b04cd68057d9779f905d1a86d9c9fc9">&#9670;&nbsp;</a></span>findLastSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T wpi::findLastSet </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efb">ZeroBehavior</a>&#160;</td>
          <td class="paramname"><em>ZB</em> = <code><a class="el" href="namespacewpi.html#ad1998965a76e8514d00562232f7b5efba7ca42989d02ebf0e4fb3387724228f43">ZB_Max</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of the last set bit starting from the least significant bit. </p>
<p >Only unsigned integral types are allowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ZB</td><td>the behavior on an input of 0. Only ZB_Max and ZB_Undefined are valid arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8efec7766be35df2a4782f6cb1004058" name="a8efec7766be35df2a4782f6cb1004058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8efec7766be35df2a4782f6cb1004058">&#9670;&nbsp;</a></span>FindMultipartBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::FindMultipartBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1raw__istream.html">wpi::raw_istream</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>saveBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1c3ca08347209b40a7330a66e83bf05" name="aa1c3ca08347209b40a7330a66e83bf05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c3ca08347209b40a7330a66e83bf05">&#9670;&nbsp;</a></span>FloatToBits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t wpi::FloatToBits </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Float</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function takes a float and returns the bit equivalent 32-bit integer. </p>
<p >Note that copying floats around changes the bits of NaNs on some hosts, notably x86, so this routine cannot be used if these bits are needed. </p>

</div>
</div>
<a id="a9adbe1d3698433c32c8b78b84f582a5b" name="a9adbe1d3698433c32c8b78b84f582a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9adbe1d3698433c32c8b78b84f582a5b">&#9670;&nbsp;</a></span>GetHostname() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string wpi::GetHostname </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c253c393e339cc29a6e8ff9cb648420" name="a3c253c393e339cc29a6e8ff9cb648420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c253c393e339cc29a6e8ff9cb648420">&#9670;&nbsp;</a></span>GetHostname() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> wpi::GetHostname </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54a45aaed6f6214f0a95dc9fd352b628" name="a54a45aaed6f6214f0a95dc9fd352b628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a45aaed6f6214f0a95dc9fd352b628">&#9670;&nbsp;</a></span>getNumBytesForUTF8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned wpi::getNumBytesForUTF8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a>&#160;</td>
          <td class="paramname"><em>firstByte</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b125df3c2eaae6f9b8cd09ccd9da98d" name="a4b125df3c2eaae6f9b8cd09ccd9da98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b125df3c2eaae6f9b8cd09ccd9da98d">&#9670;&nbsp;</a></span>GetStackTrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string wpi::GetStackTrace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a stack trace, ignoring the first "offset" symbols. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The number of symbols at the top of the stack to ignore </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17c7ea157a96be60befa9ba11407f839" name="a17c7ea157a96be60befa9ba11407f839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c7ea157a96be60befa9ba11407f839">&#9670;&nbsp;</a></span>GetStackTraceDefault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string wpi::GetStackTraceDefault </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default implementation used for <a class="el" href="namespacewpi.html#a4b125df3c2eaae6f9b8cd09ccd9da98d" title="Get a stack trace, ignoring the first &quot;offset&quot; symbols.">GetStackTrace()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The number of symbols at the top of the stack to ignore </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d2c9609d87a3fc56aef5f6f14b5f701" name="a5d2c9609d87a3fc56aef5f6f14b5f701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2c9609d87a3fc56aef5f6f14b5f701">&#9670;&nbsp;</a></span>greatestCommonDivisor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T wpi::greatestCommonDivisor </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the greatest common divisor of the values using Euclid's algorithm. </p>

</div>
</div>
<a id="a9258c13f90593d3af2d92dde80a79e9b" name="a9258c13f90593d3af2d92dde80a79e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9258c13f90593d3af2d92dde80a79e9b">&#9670;&nbsp;</a></span>GreatestCommonDivisor64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::GreatestCommonDivisor64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a70a8888fe7cb03223848f14e95e42764" name="a70a8888fe7cb03223848f14e95e42764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a8888fe7cb03223848f14e95e42764">&#9670;&nbsp;</a></span>hash_combine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a> wpi::hash_combine </td>
          <td>(</td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine values into a single <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a>. </p>
<p >This routine accepts a varying number of arguments of any type. It will attempt to combine them into a single <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a>. For user-defined types it attempts to call a </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacewpi.html#aa95acb3c2c107b75867a237c1701577c" title="Compute a hash_code for any integer value.">hash_value</a> overload (via ADL) for the <a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">type</a>. For integer <a class="el" href="_third_party_notices_8txt.html#acd485de60b505d6cbad1f12045a09e92">and</a> pointer types it directly combines their <a class="el" href="structdata.html">data</a> into the resulting <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a>.</dd></dl>
<p>The result is suitable for returning from a user's hash_value <em>implementation</em> for their user-defined type. Consumers of a type should <em>not</em> call this routine, they should instead call 'hash_value'. </p>

</div>
</div>
<a id="a583ca8bbb8e3ee49e8f65df91a6ecaaf" name="a583ca8bbb8e3ee49e8f65df91a6ecaaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583ca8bbb8e3ee49e8f65df91a6ecaaf">&#9670;&nbsp;</a></span>hash_combine_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIteratorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a> wpi::hash_combine_range </td>
          <td>(</td>
          <td class="paramtype">InputIteratorT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIteratorT&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a sequence of values. </p>
<p >This hashes a sequence of values. It produces the same <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> as 'hash_combine(a, b, c, ...)', but can run over arbitrary sized sequences and is significantly faster given pointers and types which can be hashed as a sequence of bytes. </p>

</div>
</div>
<a id="a8e2f8fc1e0870f5b219a8bc1d3654ecc" name="a8e2f8fc1e0870f5b219a8bc1d3654ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2f8fc1e0870f5b219a8bc1d3654ecc">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a> wpi::hash_value </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a standard string. </p>

</div>
</div>
<a id="a6b9238bfb621b5c47abfc9480889408e" name="a6b9238bfb621b5c47abfc9480889408e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9238bfb621b5c47abfc9480889408e">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a> wpi::hash_value </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a pair of objects. </p>

</div>
</div>
<a id="a09058a5e42b0bee35ae7f6d7bf0822a0" name="a09058a5e42b0bee35ae7f6d7bf0822a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09058a5e42b0bee35ae7f6d7bf0822a0">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a> wpi::hash_value </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a tuple. </p>

</div>
</div>
<a id="a8eb96f94c028542a238feaf8cabb44dc" name="a8eb96f94c028542a238feaf8cabb44dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb96f94c028542a238feaf8cabb44dc">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a> wpi::hash_value </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a pointer's address. </p>
<p >N.B.: This hashes the <em>address</em>. Not the value and not the type. </p>

</div>
</div>
<a id="aa95acb3c2c107b75867a237c1701577c" name="aa95acb3c2c107b75867a237c1701577c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa95acb3c2c107b75867a237c1701577c">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt; <a class="el" href="classwpi_1_1is__integral__or__enum.html">is_integral_or_enum</a>&lt; T &gt;<a class="el" href="classvalue.html">::value</a>, <a class="el" href="classwpi_1_1hash__code.html">hash_code</a> &gt; wpi::hash_value </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for any integer value. </p>
<p >Note that this function is intended to compute the same <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a particular value without regard to the pre-promotion type. This is in contrast to hash_combine which may produce different hash_codes for differing argument types even if they would implicit promote to a common type without changing the value. </p>

</div>
</div>
<a id="a328c5e2f088e151affd5ff9d7b398c42" name="a328c5e2f088e151affd5ff9d7b398c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328c5e2f088e151affd5ff9d7b398c42">&#9670;&nbsp;</a></span>hasUTF16ByteOrderMark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::hasUTF16ByteOrderMark </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const char &gt;&#160;</td>
          <td class="paramname"><em>SrcBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if a blob of text starts with a UTF-16 big or little endian byte order mark. </p>

</div>
</div>
<a id="a025d8760b23ac3786c52b2cc7d72f5eb" name="a025d8760b23ac3786c52b2cc7d72f5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a025d8760b23ac3786c52b2cc7d72f5eb">&#9670;&nbsp;</a></span>hexdigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr char wpi::hexdigit </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>LowerCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>hexdigit - Return the hexadecimal character for the given number <code>X</code> (which should be less than 16). </p>

</div>
</div>
<a id="a3f23b372d35fd43e572bd6310538d3b4" name="a3f23b372d35fd43e572bd6310538d3b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f23b372d35fd43e572bd6310538d3b4">&#9670;&nbsp;</a></span>hexDigitValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned wpi::hexDigitValue </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpret the given character <code>C</code> as a hexadecimal digit and return its value. </p>
<p >If <code>C</code> is not a valid hex digit, -1U is returned. </p>

</div>
</div>
<a id="af3568938669eceec8a2a2e8060cf7550" name="af3568938669eceec8a2a2e8060cf7550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3568938669eceec8a2a2e8060cf7550">&#9670;&nbsp;</a></span>Hi_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t wpi::Hi_32 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the high 32 bits of a 64 bit value. </p>

</div>
</div>
<a id="ab736f59b1f30b097d559e33acc6bb602" name="ab736f59b1f30b097d559e33acc6bb602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab736f59b1f30b097d559e33acc6bb602">&#9670;&nbsp;</a></span>http_body_is_final()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wpi::http_body_is_final </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a534aec91ecbd222189dd61e56e809443" name="a534aec91ecbd222189dd61e56e809443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534aec91ecbd222189dd61e56e809443">&#9670;&nbsp;</a></span>http_errno_description()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * wpi::http_errno_description </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="namespacewpi.html#a0e56bd09798339ac4f86d36eb8ecea0b">http_errno</a>&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0b4fb11893062b968b86716e84aebae" name="ab0b4fb11893062b968b86716e84aebae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b4fb11893062b968b86716e84aebae">&#9670;&nbsp;</a></span>http_errno_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * wpi::http_errno_name </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="namespacewpi.html#a0e56bd09798339ac4f86d36eb8ecea0b">http_errno</a>&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9be802a6897b36bbcd4c2dcd23e9e7f3" name="a9be802a6897b36bbcd4c2dcd23e9e7f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be802a6897b36bbcd4c2dcd23e9e7f3">&#9670;&nbsp;</a></span>http_method_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * wpi::http_method_str </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="namespacewpi.html#a3458579fc7214ea6b0411bbadf6ffcbc">http_method</a>&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9cea3956c069ac99ed2e7eeebb5b3cfb" name="a9cea3956c069ac99ed2e7eeebb5b3cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cea3956c069ac99ed2e7eeebb5b3cfb">&#9670;&nbsp;</a></span>http_parser_execute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t wpi::http_parser_execute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structwpi_1_1http__parser__settings.html">http_parser_settings</a> *&#160;</td>
          <td class="paramname"><em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfaa8c347e0e51020430bcd0d45660b4" name="adfaa8c347e0e51020430bcd0d45660b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfaa8c347e0e51020430bcd0d45660b4">&#9670;&nbsp;</a></span>http_parser_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::http_parser_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="namespacewpi.html#ab37735642db3ab741e86bf064b2ddbbd">http_parser_type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7fc17f817835ce41947523e20f3feeb1" name="a7fc17f817835ce41947523e20f3feeb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc17f817835ce41947523e20f3feeb1">&#9670;&nbsp;</a></span>http_parser_parse_url()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wpi::http_parser_parse_url </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_connect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwpi_1_1http__parser__url.html">http_parser_url</a> *&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc98ce08cafe77beb6171b08d3065181" name="afc98ce08cafe77beb6171b08d3065181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc98ce08cafe77beb6171b08d3065181">&#9670;&nbsp;</a></span>http_parser_pause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::http_parser_pause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>paused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f661690631e2ba6da370fe0b5bcfc55" name="a9f661690631e2ba6da370fe0b5bcfc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f661690631e2ba6da370fe0b5bcfc55">&#9670;&nbsp;</a></span>http_parser_settings_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::http_parser_settings_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwpi_1_1http__parser__settings.html">http_parser_settings</a> *&#160;</td>
          <td class="paramname"><em>settings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a798587facfa5f28d28e137d96c97a0d0" name="a798587facfa5f28d28e137d96c97a0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798587facfa5f28d28e137d96c97a0d0">&#9670;&nbsp;</a></span>http_parser_url_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::http_parser_url_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwpi_1_1http__parser__url.html">http_parser_url</a> *&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1285c84e98d61b7f161a2213dd9f7940" name="a1285c84e98d61b7f161a2213dd9f7940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1285c84e98d61b7f161a2213dd9f7940">&#9670;&nbsp;</a></span>http_parser_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long wpi::http_parser_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1d892e596ff2ee4287ebd021faa63b4" name="ad1d892e596ff2ee4287ebd021faa63b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d892e596ff2ee4287ebd021faa63b4">&#9670;&nbsp;</a></span>http_should_keep_alive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wpi::http_should_keep_alive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af568f1219d61f5c74f4de5caac588a90" name="af568f1219d61f5c74f4de5caac588a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af568f1219d61f5c74f4de5caac588a90">&#9670;&nbsp;</a></span>http_status_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * wpi::http_status_str </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="namespacewpi.html#ae89a1f90a8603e399f9cc0465b0ce21e">http_status</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9e2b9c52f4cd86842aa577863b93c2a" name="ab9e2b9c52f4cd86842aa577863b93c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e2b9c52f4cd86842aa577863b93c2a">&#9670;&nbsp;</a></span>insert_sorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;::iterator wpi::insert_sorted </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5490819a8d9ceedb98494b59ed05917" name="ad5490819a8d9ceedb98494b59ed05917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5490819a8d9ceedb98494b59ed05917">&#9670;&nbsp;</a></span>install_bad_alloc_error_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::install_bad_alloc_error_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#aacde1332b72e968317ed516552a07ca8">fatal_error_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs a new bad alloc error handler that should be used whenever a bad alloc error, e.g. </p>
<p >failing malloc/calloc, is encountered by LLVM.</p>
<p >The user can install a bad alloc handler, in order to define the behavior in case of failing allocations, e.g. throwing an exception. Note that this handler must not trigger any additional allocations itself.</p>
<p >If no error handler is installed the default is to print the error message to stderr, and call exit(1). If an error handler is installed then it is the handler's responsibility to log the message, it will no longer be printed to stderr. If the error handler returns, then exit(1) will be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_data</td><td>- An argument which will be passed to the installed error handler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a309bc670f1bda6373a69c5a66eb9849a" name="a309bc670f1bda6373a69c5a66eb9849a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309bc670f1bda6373a69c5a66eb9849a">&#9670;&nbsp;</a></span>install_fatal_error_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::install_fatal_error_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#aacde1332b72e968317ed516552a07ca8">fatal_error_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>install_fatal_error_handler - Installs a new error handler to be used whenever a serious (non-recoverable) error is encountered by LLVM. </p>
<p >If no error handler is installed the default is to print the error message to stderr, and call exit(1). If an error handler is installed then it is the handler's responsibility to log the message, it will no longer be printed to stderr. If the error handler returns, then exit(1) will be called.</p>
<p >It is dangerous to naively use an error handler which throws an exception. Even though some applications desire to gracefully recover from arbitrary faults, blindly throwing exceptions through unfamiliar code isn't a way to achieve this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_data</td><td>- An argument which will be passed to the install error handler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad97e6b598cd8e5fe3f4d4e75e83dbb9e" name="ad97e6b598cd8e5fe3f4d4e75e83dbb9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97e6b598cd8e5fe3f4d4e75e83dbb9e">&#9670;&nbsp;</a></span>install_out_of_memory_new_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::install_out_of_memory_new_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2db9afebe0b9cb8a94691657ad62b71b" name="a2db9afebe0b9cb8a94691657ad62b71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db9afebe0b9cb8a94691657ad62b71b">&#9670;&nbsp;</a></span>isAlnum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::isAlnum </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether character <code>C</code> is either a decimal digit or an uppercase or lowercase letter as classified by "C" locale. </p>

</div>
</div>
<a id="ad40bed52c4db6c9d8ac4d6a34f701fca" name="ad40bed52c4db6c9d8ac4d6a34f701fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40bed52c4db6c9d8ac4d6a34f701fca">&#9670;&nbsp;</a></span>isAlpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::isAlpha </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if character <code>C</code> is a valid letter as classified by "C" locale. </p>

</div>
</div>
<a id="ad2e6acbb1ecc26fc431a01798885b5a1" name="ad2e6acbb1ecc26fc431a01798885b5a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e6acbb1ecc26fc431a01798885b5a1">&#9670;&nbsp;</a></span>isASCII()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::isASCII </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether character <code>C</code> is valid ASCII (high bit is zero). </p>

</div>
</div>
<a id="a368b03e8bb2ecfdc34b02b40523055e4" name="a368b03e8bb2ecfdc34b02b40523055e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368b03e8bb2ecfdc34b02b40523055e4">&#9670;&nbsp;</a></span>isDigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::isDigit </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if character <code>C</code> is one of the 10 decimal digits. </p>

</div>
</div>
<a id="a33822f75a8aa525d240b60e5e79568b6" name="a33822f75a8aa525d240b60e5e79568b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33822f75a8aa525d240b60e5e79568b6">&#9670;&nbsp;</a></span>isHexDigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::isHexDigit </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if character <code>C</code> is a hexadecimal numeric character. </p>

</div>
</div>
<a id="a793cb5a31f3412455ec43e6030919a42" name="a793cb5a31f3412455ec43e6030919a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793cb5a31f3412455ec43e6030919a42">&#9670;&nbsp;</a></span>isInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::isInt </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an integer fits into the given bit width. </p>

</div>
</div>
<a id="a1cdf07df2553fd72ae7120423754a2e8" name="a1cdf07df2553fd72ae7120423754a2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cdf07df2553fd72ae7120423754a2e8">&#9670;&nbsp;</a></span>isInt&lt; 16 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="namespacewpi.html#a793cb5a31f3412455ec43e6030919a42">wpi::isInt</a>&lt; 16 &gt; </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8bb82c95f37cf16eafb659ab0bace65" name="ae8bb82c95f37cf16eafb659ab0bace65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8bb82c95f37cf16eafb659ab0bace65">&#9670;&nbsp;</a></span>isInt&lt; 32 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="namespacewpi.html#a793cb5a31f3412455ec43e6030919a42">wpi::isInt</a>&lt; 32 &gt; </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acdf6e574a80a2f8050ab7d25db6cc90f" name="acdf6e574a80a2f8050ab7d25db6cc90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf6e574a80a2f8050ab7d25db6cc90f">&#9670;&nbsp;</a></span>isInt&lt; 8 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="namespacewpi.html#a793cb5a31f3412455ec43e6030919a42">wpi::isInt</a>&lt; 8 &gt; </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae65bc8235c8a7ccfb15d4856909adc45" name="ae65bc8235c8a7ccfb15d4856909adc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae65bc8235c8a7ccfb15d4856909adc45">&#9670;&nbsp;</a></span>isIntN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isIntN </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an signed integer fits into the given (dynamic) bit width. </p>

</div>
</div>
<a id="a26e27444cfe3390c1682575a3ad1860b" name="a26e27444cfe3390c1682575a3ad1860b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e27444cfe3390c1682575a3ad1860b">&#9670;&nbsp;</a></span>isLegalUTF8Sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacewpi.html#ac9954615e01ad150570a0e1d4548d879">Boolean</a> wpi::isLegalUTF8Sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *&#160;</td>
          <td class="paramname"><em>sourceEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8c7efa3db3243cb89f4f1c15b2a2c10" name="ad8c7efa3db3243cb89f4f1c15b2a2c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c7efa3db3243cb89f4f1c15b2a2c10">&#9670;&nbsp;</a></span>isLegalUTF8String()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacewpi.html#ac9954615e01ad150570a0e1d4548d879">Boolean</a> wpi::isLegalUTF8String </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacewpi.html#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *&#160;</td>
          <td class="paramname"><em>sourceEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7868b72f26477d7e06a655a552b8886" name="af7868b72f26477d7e06a655a552b8886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7868b72f26477d7e06a655a552b8886">&#9670;&nbsp;</a></span>isMask_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::isMask_32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the argument is a non-empty sequence of ones starting at the least significant bit with the remainder zero (32 bit version). </p>
<p >Ex. isMask_32(0x0000FFFFU) == true. </p>

</div>
</div>
<a id="abba808be054c9d45a724cc14bf47b45b" name="abba808be054c9d45a724cc14bf47b45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba808be054c9d45a724cc14bf47b45b">&#9670;&nbsp;</a></span>isMask_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::isMask_64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the argument is a non-empty sequence of ones starting at the least significant bit with the remainder zero (64 bit version). </p>

</div>
</div>
<a id="a44ef6fef4b85937dabc224872f7ff540" name="a44ef6fef4b85937dabc224872f7ff540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ef6fef4b85937dabc224872f7ff540">&#9670;&nbsp;</a></span>isPowerOf2_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::isPowerOf2_32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the argument is a power of two &gt; 0. </p>
<p >Ex. isPowerOf2_32(0x00100000U) == true (32 bit edition.) </p>

</div>
</div>
<a id="ab337d9f021792437e222ab8de869770c" name="ab337d9f021792437e222ab8de869770c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab337d9f021792437e222ab8de869770c">&#9670;&nbsp;</a></span>isPowerOf2_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::isPowerOf2_64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the argument is a power of two &gt; 0 (64 bit edition.) </p>

</div>
</div>
<a id="a91c8224f526316dbd1d8e8c3e53362db" name="a91c8224f526316dbd1d8e8c3e53362db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c8224f526316dbd1d8e8c3e53362db">&#9670;&nbsp;</a></span>isPrint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::isPrint </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether character <code>C</code> is printable. </p>
<p >Locale-independent version of the C standard library isprint whose results may differ on different platforms. </p>

</div>
</div>
<a id="a3b38a6d85f09021ac8f5a253764011fb" name="a3b38a6d85f09021ac8f5a253764011fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b38a6d85f09021ac8f5a253764011fb">&#9670;&nbsp;</a></span>isShiftedInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, unsigned S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::isShiftedInt </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a signed integer is an N bit number shifted left by S. </p>

</div>
</div>
<a id="a3ca9c306cc27e6eb5d669b6d41e6dba0" name="a3ca9c306cc27e6eb5d669b6d41e6dba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca9c306cc27e6eb5d669b6d41e6dba0">&#9670;&nbsp;</a></span>isShiftedMask_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::isShiftedMask_32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the argument contains a non-empty sequence of ones with the remainder zero (32 bit version.) Ex. </p>
<p >isShiftedMask_32(0x0000FF00U) == true. </p>

</div>
</div>
<a id="ae76f4df15ef384517038996decd80631" name="ae76f4df15ef384517038996decd80631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76f4df15ef384517038996decd80631">&#9670;&nbsp;</a></span>isShiftedMask_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::isShiftedMask_64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the argument contains a non-empty sequence of ones with the remainder zero (64 bit version.) </p>

</div>
</div>
<a id="ae24c771b8df1d9311b05e5aa01ec09b3" name="ae24c771b8df1d9311b05e5aa01ec09b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24c771b8df1d9311b05e5aa01ec09b3">&#9670;&nbsp;</a></span>isShiftedUInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, unsigned S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::isShiftedUInt </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a unsigned integer is an N bit number shifted left by S. </p>

</div>
</div>
<a id="a5006d05631e33faae51ea19c2db37f9c" name="a5006d05631e33faae51ea19c2db37f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5006d05631e33faae51ea19c2db37f9c">&#9670;&nbsp;</a></span>isUInt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt;(N&lt; 64), bool &gt; wpi::isUInt </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an unsigned integer fits into the given bit width. </p>
<p >This is written as two functions rather than as simply</p>
<p >return N &gt;= 64 || X &lt; (UINT64_C(1) &lt;&lt; N);</p>
<p >to keep MSVC from (incorrectly) warning on isUInt&lt;64&gt; that we're shifting left too many places. </p>

</div>
</div>
<a id="a799f389ff49437c4c06b3e0eacf03ae6" name="a799f389ff49437c4c06b3e0eacf03ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a799f389ff49437c4c06b3e0eacf03ae6">&#9670;&nbsp;</a></span>isUInt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::isUInt </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab12c213c574000935d92fa4547ae61f6" name="ab12c213c574000935d92fa4547ae61f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12c213c574000935d92fa4547ae61f6">&#9670;&nbsp;</a></span>isUInt&lt; 16 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="namespacewpi.html#a5006d05631e33faae51ea19c2db37f9c">wpi::isUInt</a>&lt; 16 &gt; </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af771a1ba991555e3aebf4b0b43fa270b" name="af771a1ba991555e3aebf4b0b43fa270b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af771a1ba991555e3aebf4b0b43fa270b">&#9670;&nbsp;</a></span>isUInt&lt; 32 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="namespacewpi.html#a5006d05631e33faae51ea19c2db37f9c">wpi::isUInt</a>&lt; 32 &gt; </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f73ffa4ad91e9c389e85ebb69d072ce" name="a7f73ffa4ad91e9c389e85ebb69d072ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f73ffa4ad91e9c389e85ebb69d072ce">&#9670;&nbsp;</a></span>isUInt&lt; 8 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="namespacewpi.html#a5006d05631e33faae51ea19c2db37f9c">wpi::isUInt</a>&lt; 8 &gt; </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adc2ea2c155eeb9a3662912e8c2ff880e" name="adc2ea2c155eeb9a3662912e8c2ff880e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2ea2c155eeb9a3662912e8c2ff880e">&#9670;&nbsp;</a></span>isUIntN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isUIntN </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an unsigned integer fits into the given (dynamic) bit width. </p>

</div>
</div>
<a id="a905c54ca4b7fdb1633b425ad9ca5dc48" name="a905c54ca4b7fdb1633b425ad9ca5dc48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905c54ca4b7fdb1633b425ad9ca5dc48">&#9670;&nbsp;</a></span>Lerp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T wpi::Lerp </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>startValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>endValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linearly interpolates between two values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startValue</td><td>The start value. </td></tr>
    <tr><td class="paramname">endValue</td><td>The end value. </td></tr>
    <tr><td class="paramname">t</td><td>The fraction for interpolation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated value. </dd></dl>

</div>
</div>
<a id="a30cde0598116042ad77cd369e21b95d3" name="a30cde0598116042ad77cd369e21b95d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30cde0598116042ad77cd369e21b95d3">&#9670;&nbsp;</a></span>Lo_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t wpi::Lo_32 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the low 32 bits of a 64 bit value. </p>

</div>
</div>
<a id="a1196434a670e3e907e365ee77a26479c" name="a1196434a670e3e907e365ee77a26479c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1196434a670e3e907e365ee77a26479c">&#9670;&nbsp;</a></span>Log2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double wpi::Log2 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the log base 2 of the specified value. </p>

</div>
</div>
<a id="a12fc40611c1ed874ebee9877f3866da8" name="a12fc40611c1ed874ebee9877f3866da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12fc40611c1ed874ebee9877f3866da8">&#9670;&nbsp;</a></span>Log2_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned wpi::Log2_32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the floor log base 2 of the specified value, -1 if the value is zero. </p>
<p >(32 bit edition.) Ex. Log2_32(32) == 5, Log2_32(1) == 0, Log2_32(0) == -1, Log2_32(6) == 2 </p>

</div>
</div>
<a id="a1be06425de1e3346544e3600fda4f352" name="a1be06425de1e3346544e3600fda4f352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be06425de1e3346544e3600fda4f352">&#9670;&nbsp;</a></span>Log2_32_Ceil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned wpi::Log2_32_Ceil </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the ceil log base 2 of the specified value, 32 if the value is zero. </p>
<p >(32 bit edition). Ex. Log2_32_Ceil(32) == 5, Log2_32_Ceil(1) == 0, Log2_32_Ceil(6) == 3 </p>

</div>
</div>
<a id="ab109b30376a3d157344b924e82ccd5ef" name="ab109b30376a3d157344b924e82ccd5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab109b30376a3d157344b924e82ccd5ef">&#9670;&nbsp;</a></span>Log2_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned wpi::Log2_64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the floor log base 2 of the specified value, -1 if the value is zero. </p>
<p >(64 bit edition.) </p>

</div>
</div>
<a id="ae6b43a321203f7b23732402ef5dc9709" name="ae6b43a321203f7b23732402ef5dc9709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b43a321203f7b23732402ef5dc9709">&#9670;&nbsp;</a></span>Log2_64_Ceil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned wpi::Log2_64_Ceil </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the ceil log base 2 of the specified value, 64 if the value is zero. </p>
<p >(64 bit edition.) </p>

</div>
</div>
<a id="a1b7c271a14f5c78641600f41d7c32299" name="a1b7c271a14f5c78641600f41d7c32299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7c271a14f5c78641600f41d7c32299">&#9670;&nbsp;</a></span>ltrim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> wpi::ltrim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>str</code> with consecutive <code>ch</code> characters starting from the the left removed. </p>

</div>
</div>
<a id="a2b05ebace5b75bf9c0d3b9513f2c2d11" name="a2b05ebace5b75bf9c0d3b9513f2c2d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b05ebace5b75bf9c0d3b9513f2c2d11">&#9670;&nbsp;</a></span>ltrim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> wpi::ltrim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>chars</em> = <code>&quot;&#160;\t\n\v\f\r&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>str</code> with consecutive characters in <code>chars</code> starting from the left removed. </p>

</div>
</div>
<a id="acc6fd03a9b591a2f187f0a44e2b4a356" name="acc6fd03a9b591a2f187f0a44e2b4a356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6fd03a9b591a2f187f0a44e2b4a356">&#9670;&nbsp;</a></span>Make_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint64_t wpi::Make_64 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>High</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Low</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a 64-bit integer from a high / low pair of 32-bit integers. </p>

</div>
</div>
<a id="a6bb20671f09fd21f4f52662c86fd6521" name="a6bb20671f09fd21f4f52662c86fd6521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb20671f09fd21f4f52662c86fd6521">&#9670;&nbsp;</a></span>make_error_code()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code wpi::make_error_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacewpi.html#a0cc73ce1be7e2680fb97374e03368001">errc</a>&#160;</td>
          <td class="paramname"><em>E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9630e9cd2902c4dbc7f817a6a84bb9da" name="a9630e9cd2902c4dbc7f817a6a84bb9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9630e9cd2902c4dbc7f817a6a84bb9da">&#9670;&nbsp;</a></span>make_pointee_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT , typename WrappedIteratorT  = decltype(std::begin(std::declval&lt;RangeT&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="structwpi_1_1pointee__iterator.html">pointee_iterator</a>&lt; WrappedIteratorT &gt; &gt; wpi::make_pointee_range </td>
          <td>(</td>
          <td class="paramtype">RangeT &amp;&amp;&#160;</td>
          <td class="paramname"><em>Range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa300eeb1def26aef1ca3af133fb26971" name="aa300eeb1def26aef1ca3af133fb26971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa300eeb1def26aef1ca3af133fb26971">&#9670;&nbsp;</a></span>make_pointer_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT , typename WrappedIteratorT  = decltype(std::begin(std::declval&lt;RangeT&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classwpi_1_1pointer__iterator.html">pointer_iterator</a>&lt; WrappedIteratorT &gt; &gt; wpi::make_pointer_range </td>
          <td>(</td>
          <td class="paramtype">RangeT &amp;&amp;&#160;</td>
          <td class="paramname"><em>Range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1b2b7a19d614a944822ce6f577be33a" name="ad1b2b7a19d614a944822ce6f577be33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b2b7a19d614a944822ce6f577be33a">&#9670;&nbsp;</a></span>make_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1iterator__range.html">iterator_range</a>&lt; T &gt; wpi::make_range </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; T, T &gt;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aacc327c9a551f61642d9a6ef107c4593" name="aacc327c9a551f61642d9a6ef107c4593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc327c9a551f61642d9a6ef107c4593">&#9670;&nbsp;</a></span>make_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1iterator__range.html">iterator_range</a>&lt; T &gt; wpi::make_range </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for iterating over sub-ranges. </p>
<p >This provides a bit of syntactic sugar to make using sub-ranges in for loops a bit easier. Analogous to std::make_pair(). </p>

</div>
</div>
<a id="a21a0d64a50babc1c46b2ede08a2cf13d" name="a21a0d64a50babc1c46b2ede08a2cf13d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a0d64a50babc1c46b2ede08a2cf13d">&#9670;&nbsp;</a></span>make_ready_future() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1future.html">future</a>&lt; void &gt; wpi::make_ready_future </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a valid future with the value set. </p>

</div>
</div>
<a id="aed245bfb118e5dfe475bf2044a4985d8" name="aed245bfb118e5dfe475bf2044a4985d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed245bfb118e5dfe475bf2044a4985d8">&#9670;&nbsp;</a></span>make_ready_future() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1future.html">future</a>&lt; T &gt; wpi::make_ready_future </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a valid future with the value set. </p>

</div>
</div>
<a id="a8af9a7e30ba77940f2ef47d513252866" name="a8af9a7e30ba77940f2ef47d513252866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af9a7e30ba77940f2ef47d513252866">&#9670;&nbsp;</a></span>mapWindowsError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code wpi::mapWindowsError </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>EV</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ca1a8d567765c25e5c8aaf6f2a3a51a" name="a0ca1a8d567765c25e5c8aaf6f2a3a51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca1a8d567765c25e5c8aaf6f2a3a51a">&#9670;&nbsp;</a></span>maskLeadingOnes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T wpi::maskLeadingOnes </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a bitmask with the N left-most bits set to 1, and all other bits set to 0. </p>
<p >Only unsigned types are allowed. </p>

</div>
</div>
<a id="aed916b5acc65b9b7f1ff971ffc096030" name="aed916b5acc65b9b7f1ff971ffc096030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed916b5acc65b9b7f1ff971ffc096030">&#9670;&nbsp;</a></span>maskLeadingZeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T wpi::maskLeadingZeros </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a bitmask with the N left-most bits set to 0, and all other bits set to 1. </p>
<p >Only unsigned types are allowed. </p>

</div>
</div>
<a id="a337beda02d2dd53b5d020a593c867e6d" name="a337beda02d2dd53b5d020a593c867e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337beda02d2dd53b5d020a593c867e6d">&#9670;&nbsp;</a></span>maskTrailingOnes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T wpi::maskTrailingOnes </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a bitmask with the N right-most bits set to 1, and all other bits set to 0. </p>
<p >Only unsigned types are allowed. </p>

</div>
</div>
<a id="ad6e2df17acd6bc9d36f64037926be88f" name="ad6e2df17acd6bc9d36f64037926be88f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e2df17acd6bc9d36f64037926be88f">&#9670;&nbsp;</a></span>maskTrailingZeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T wpi::maskTrailingZeros </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a bitmask with the N right-most bits set to 0, and all other bits set to 1. </p>
<p >Only unsigned types are allowed. </p>

</div>
</div>
<a id="a01982bb8b119d94de4200ed371ad5397" name="a01982bb8b119d94de4200ed371ad5397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01982bb8b119d94de4200ed371ad5397">&#9670;&nbsp;</a></span>maxIntN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t wpi::maxIntN </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum value for a N-bit signed integer. </p>

</div>
</div>
<a id="adb968c37d6007862cab0e2e2156d9df9" name="adb968c37d6007862cab0e2e2156d9df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb968c37d6007862cab0e2e2156d9df9">&#9670;&nbsp;</a></span>maxUIntN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::maxUIntN </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum value for a N-bit unsigned integer. </p>

</div>
</div>
<a id="a863f7dccbe48e628d0674d0957238fe6" name="a863f7dccbe48e628d0674d0957238fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863f7dccbe48e628d0674d0957238fe6">&#9670;&nbsp;</a></span>MimeTypeFromPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> wpi::MimeTypeFromPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf2c49962110e8c4bf54b763aac045c8" name="aaf2c49962110e8c4bf54b763aac045c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2c49962110e8c4bf54b763aac045c8">&#9670;&nbsp;</a></span>MinAlign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint64_t wpi::MinAlign </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A and B are either alignments or offsets. </p>
<p >Return the minimum alignment that may be assumed after adding the two together. </p>

</div>
</div>
<a id="abfb563f4c667933f0ebf44c6ca54e7ba" name="abfb563f4c667933f0ebf44c6ca54e7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb563f4c667933f0ebf44c6ca54e7ba">&#9670;&nbsp;</a></span>minIntN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t wpi::minIntN </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the minimum value for a N-bit signed integer. </p>

</div>
</div>
<a id="a6cdb620d2807ab13e9c16c8867cf081a" name="a6cdb620d2807ab13e9c16c8867cf081a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cdb620d2807ab13e9c16c8867cf081a">&#9670;&nbsp;</a></span>MulOverflow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt; <a class="el" href="format_8h.html#a56d0276c2e6f4b26cb3565e08ebc9181">std::is_signed</a>&lt; T &gt;<a class="el" href="classvalue.html">::value</a>, T &gt; wpi::MulOverflow </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two signed integers, computing the two's complement truncated result, returning true if an overflow ocurred. </p>

</div>
</div>
<a id="a70c11fbdfabf91b962c2d6d49a243207" name="a70c11fbdfabf91b962c2d6d49a243207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c11fbdfabf91b962c2d6d49a243207">&#9670;&nbsp;</a></span>NextPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::NextPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next power of two (in 64-bits) that is strictly greater than A. </p>
<p >Returns zero on overflow. </p>

</div>
</div>
<a id="a40031774febe762423c2bf6bb4e0094b" name="a40031774febe762423c2bf6bb4e0094b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40031774febe762423c2bf6bb4e0094b">&#9670;&nbsp;</a></span>nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp; wpi::nulls </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns a reference to a <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> which simply discards output. </p>

</div>
</div>
<a id="ac2bd96b09718980689f6278dd7ea224d" name="ac2bd96b09718980689f6278dd7ea224d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2bd96b09718980689f6278dd7ea224d">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedT , typename KeyT , typename ValueT , typename KeyInfoT , typename BucketT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="_array_cwise_unary_ops_8h.html#aa198852a6b380257ea3e34c8f7e6e250">wpi::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_dense_map_base.html">DenseMapBase</a>&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt; &amp;&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_dense_map_base.html">DenseMapBase</a>&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt; &amp;&#160;</td>
          <td class="paramname"><em>RHS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inequality comparison for <a class="el" href="classwpi_1_1_dense_map.html">DenseMap</a>. </p>
<p >Equivalent to !(LHS == RHS). See operator== for performance notes. </p>

</div>
</div>
<a id="a3493bed4041adb43e57361d40517a4d4" name="a3493bed4041adb43e57361d40517a4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3493bed4041adb43e57361d40517a4d4">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PtrType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="_array_cwise_unary_ops_8h.html#aa198852a6b380257ea3e34c8f7e6e250">wpi::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_small_ptr_set_impl.html">SmallPtrSetImpl</a>&lt; PtrType &gt; &amp;&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_small_ptr_set_impl.html">SmallPtrSetImpl</a>&lt; PtrType &gt; &amp;&#160;</td>
          <td class="paramname"><em>RHS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inequality comparison for <a class="el" href="classwpi_1_1_small_ptr_set.html" title="SmallPtrSet - This class implements a set which is optimized for holding SmallSize or less elements.">SmallPtrSet</a>. </p>
<p >Equivalent to !(LHS == RHS). </p>

</div>
</div>
<a id="ad032764915283409382ba49638651b69" name="ad032764915283409382ba49638651b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad032764915283409382ba49638651b69">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned LN, unsigned RN, typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="_array_cwise_unary_ops_8h.html#aa198852a6b380257ea3e34c8f7e6e250">wpi::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_small_set.html">SmallSet</a>&lt; T, LN, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_small_set.html">SmallSet</a>&lt; T, RN, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>RHS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inequality comparison for <a class="el" href="classwpi_1_1_small_set.html" title="SmallSet - This maintains a set of unique values, optimizing for the case when the set is small (less...">SmallSet</a>. </p>
<p >Equivalent to !(LHS == RHS). See operator== for performance notes. </p>

</div>
</div>
<a id="ae5de24f32a5e0e34e26400e1d2d019ab" name="ae5de24f32a5e0e34e26400e1d2d019ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5de24f32a5e0e34e26400e1d2d019ab">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="_array_cwise_unary_ops_8h.html#aa198852a6b380257ea3e34c8f7e6e250">wpi::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a088be308371a5cee44b52aedf5a619e7" name="a088be308371a5cee44b52aedf5a619e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088be308371a5cee44b52aedf5a619e7">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... PTs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="_array_cwise_unary_ops_8h.html#aa198852a6b380257ea3e34c8f7e6e250">wpi::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0497f3ae3790ae4464ca31a28110983f" name="a0497f3ae3790ae4464ca31a28110983f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0497f3ae3790ae4464ca31a28110983f">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e03174a92e237c3b5544c57d3dee498" name="a4e03174a92e237c3b5544c57d3dee498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e03174a92e237c3b5544c57d3dee498">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... PTs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afad70263229589236b932dc5ec227436" name="afad70263229589236b932dc5ec227436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad70263229589236b932dc5ec227436">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OStream , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt;!std::is_reference&lt; OStream &gt;<a class="el" href="classvalue.html">::value</a> &amp;&amp; std::is_base_of&lt; <a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a>, OStream &gt;<a class="el" href="classvalue.html">::value</a>, OStream &amp;&amp; &gt; wpi::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">OStream &amp;&amp;&#160;</td>
          <td class="paramname"><em>OS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the appropriate insertion operator, given an rvalue reference to a <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> object and return a stream of the same type as the argument. </p>

</div>
</div>
<a id="ac2c6f38176a757997f4548366d10941c" name="ac2c6f38176a757997f4548366d10941c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c6f38176a757997f4548366d10941c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp; wpi::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>OS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi_1_1sys.html#a26b4c3769d9f1b9f371d2bf4c07e1946">sys::TimePoint</a>&lt;&gt;&#160;</td>
          <td class="paramname"><em>TP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe9955629bd414f4388de1629bbe618d" name="afe9955629bd414f4388de1629bbe618d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9955629bd414f4388de1629bbe618d">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9258f2870864143e01a09bb5cf806ba6" name="a9258f2870864143e01a09bb5cf806ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9258f2870864143e01a09bb5cf806ba6">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedT , typename KeyT , typename ValueT , typename KeyInfoT , typename BucketT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_dense_map_base.html">DenseMapBase</a>&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt; &amp;&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_dense_map_base.html">DenseMapBase</a>&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt; &amp;&#160;</td>
          <td class="paramname"><em>RHS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality comparison for <a class="el" href="classwpi_1_1_dense_map.html">DenseMap</a>. </p>
<p >Iterates over elements of LHS confirming that each (key, value) pair in LHS is also in RHS, and that no additional pairs are in RHS. Equivalent to N calls to RHS.find and N value comparisons. Amortized complexity is linear, worst case is O(N^2) (if every hash collides). </p>

</div>
</div>
<a id="afd1ac8844d24e58fc06de7d1270f0c7d" name="afd1ac8844d24e58fc06de7d1270f0c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd1ac8844d24e58fc06de7d1270f0c7d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PtrType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_small_ptr_set_impl.html">SmallPtrSetImpl</a>&lt; PtrType &gt; &amp;&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_small_ptr_set_impl.html">SmallPtrSetImpl</a>&lt; PtrType &gt; &amp;&#160;</td>
          <td class="paramname"><em>RHS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality comparison for <a class="el" href="classwpi_1_1_small_ptr_set.html" title="SmallPtrSet - This class implements a set which is optimized for holding SmallSize or less elements.">SmallPtrSet</a>. </p>
<p >Iterates over elements of LHS confirming that each value from LHS is also in RHS, and that no additional values are in RHS. </p>

</div>
</div>
<a id="ac64cc2a8bb25b3e692e7aacd722fdd29" name="ac64cc2a8bb25b3e692e7aacd722fdd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64cc2a8bb25b3e692e7aacd722fdd29">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned LN, unsigned RN, typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_small_set.html">SmallSet</a>&lt; T, LN, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_small_set.html">SmallSet</a>&lt; T, RN, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>RHS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality comparison for <a class="el" href="classwpi_1_1_small_set.html" title="SmallSet - This maintains a set of unique values, optimizing for the case when the set is small (less...">SmallSet</a>. </p>
<p >Iterates over elements of LHS confirming that each element is also a member of RHS, and that RHS contains no additional values. Equivalent to N calls to RHS.count. For small-set mode amortized complexity is O(N^2) For large-set mode amortized complexity is linear, worst case is O(N^2) (if every hash collides). </p>

</div>
</div>
<a id="a20d4bc587263ead52e3057e41d1bcad8" name="a20d4bc587263ead52e3057e41d1bcad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d4bc587263ead52e3057e41d1bcad8">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3287d2b8e67eaf00c1f275eb1d2b1fd8" name="a3287d2b8e67eaf00c1f275eb1d2b1fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3287d2b8e67eaf00c1f275eb1d2b1fd8">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... PTs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af9f5d37ffdbdece9dc4a138912d2384d" name="af9f5d37ffdbdece9dc4a138912d2384d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f5d37ffdbdece9dc4a138912d2384d">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f5ef98f7e590a36648bdff48b4dfc57" name="a0f5ef98f7e590a36648bdff48b4dfc57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5ef98f7e590a36648bdff48b4dfc57">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4cc9cf60e707bfcf728eb04c4e4b8d2e" name="a4cc9cf60e707bfcf728eb04c4e4b8d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc9cf60e707bfcf728eb04c4e4b8d2e">&#9670;&nbsp;</a></span>outs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1raw__fd__ostream.html">raw_fd_ostream</a> &amp; wpi::outs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns a reference to a <a class="el" href="classwpi_1_1raw__fd__ostream.html" title="A raw_ostream that writes to a file descriptor.">raw_fd_ostream</a> for standard output. </p>
<p >Use it like: <a class="el" href="namespacewpi.html#a4cc9cf60e707bfcf728eb04c4e4b8d2e" title="This returns a reference to a raw_fd_ostream for standard output.">outs()</a> &lt;&lt; "foo" &lt;&lt; "bar"; </p>

</div>
</div>
<a id="ae3e2a33d363a34850deae1866c324eb6" name="ae3e2a33d363a34850deae1866c324eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e2a33d363a34850deae1866c324eb6">&#9670;&nbsp;</a></span>parse_float()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; T &gt; wpi::parse_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses the string <code>str</code> as a floating point value. </p>
<p >If the string is invalid or if only a subset of the string is valid, this returns nullopt to signify the error. The string is considered erroneous if empty or if it overflows T. </p>

</div>
</div>
<a id="a2d19c9cf09501aa0ab358fa74281e96d" name="a2d19c9cf09501aa0ab358fa74281e96d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d19c9cf09501aa0ab358fa74281e96d">&#9670;&nbsp;</a></span>parse_float&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; double &gt; <a class="el" href="namespacewpi.html#ae3e2a33d363a34850deae1866c324eb6">wpi::parse_float</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aea3739b1e7e77b69e3ce650907ca69ed" name="aea3739b1e7e77b69e3ce650907ca69ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3739b1e7e77b69e3ce650907ca69ed">&#9670;&nbsp;</a></span>parse_float&lt; float &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; float &gt; <a class="el" href="namespacewpi.html#ae3e2a33d363a34850deae1866c324eb6">wpi::parse_float</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a77ec79c288a28100e273ac8c3e41b85b" name="a77ec79c288a28100e273ac8c3e41b85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ec79c288a28100e273ac8c3e41b85b">&#9670;&nbsp;</a></span>parse_float&lt; long double &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; long double &gt; <a class="el" href="namespacewpi.html#ae3e2a33d363a34850deae1866c324eb6">wpi::parse_float</a>&lt; long double &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ed163433a5d70554975df8e7ef7f4df" name="a3ed163433a5d70554975df8e7ef7f4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed163433a5d70554975df8e7ef7f4df">&#9670;&nbsp;</a></span>parse_integer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt; std::numeric_limits&lt; T &gt;<a class="el" href="format_8h.html#a56d0276c2e6f4b26cb3565e08ebc9181">::is_signed</a>, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; T &gt; wpi::parse_integer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>radix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses the string <code>str</code> as an integer of the specified radix. </p>
<p >If <code>radix</code> is specified as zero, this does radix autosensing using extended C rules: 0 is octal, 0x is hex, 0b is binary.</p>
<p >If the string is invalid or if only a subset of the string is valid, this returns nullopt to signify the error. The string is considered erroneous if empty or if it overflows T. </p>

</div>
</div>
<a id="a12877798c9e05cae590789ebe25883b7" name="a12877798c9e05cae590789ebe25883b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12877798c9e05cae590789ebe25883b7">&#9670;&nbsp;</a></span>ParseHttpHeaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::ParseHttpHeaders </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1raw__istream.html">raw_istream</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; *&#160;</td>
          <td class="paramname"><em>contentType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; *&#160;</td>
          <td class="paramname"><em>contentLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a22d2692504baab859a5288de06e96df3" name="a22d2692504baab859a5288de06e96df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d2692504baab859a5288de06e96df3">&#9670;&nbsp;</a></span>PowerOf2Ceil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::PowerOf2Ceil </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the power of two which is greater than or equal to the given value. </p>
<p >Essentially, it is a ceil operation across the domain of powers of two. </p>

</div>
</div>
<a id="aa9300a98f876116b78909d4aa78a47d1" name="aa9300a98f876116b78909d4aa78a47d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9300a98f876116b78909d4aa78a47d1">&#9670;&nbsp;</a></span>PowerOf2Floor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::PowerOf2Floor </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the power of two which is less than or equal to the given value. </p>
<p >Essentially, it is a floor operation across the domain of powers of two. </p>

</div>
</div>
<a id="a486cee9c105ed0e242f6c00183c682f3" name="a486cee9c105ed0e242f6c00183c682f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486cee9c105ed0e242f6c00183c682f3">&#9670;&nbsp;</a></span>ReadUleb128() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::ReadUleb128 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read unsigned LEB128 data. </p>
<p >Decode an unsigned LEB128 encoded datum. The algorithm is taken from Appendix C of the DWARF 3 spec. For information on the encodings refer to section "7.6 - Variable Length Data". Return the number of bytes read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The address where the ULEB128 data is stored. </td></tr>
    <tr><td class="paramname">ret</td><td>Address to store the result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade4e972587009901ad40bc390e4bb8db" name="ade4e972587009901ad40bc390e4bb8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4e972587009901ad40bc390e4bb8db">&#9670;&nbsp;</a></span>ReadUleb128() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::ReadUleb128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1raw__istream.html">raw_istream</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read unsigned LEB128 data from a stream. </p>
<p >Decode an unsigned LEB128 encoded datum. The algorithm is taken from Appendix C of the DWARF 3 spec. For information on the encodings refer to section "7.6 - Variable Length Data". Return false on stream error, true on success.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The input stream where the ULEB128 data is to be read from. </td></tr>
    <tr><td class="paramname">ret</td><td>Address to store the result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69094b92cf05fe59b51ae012a03d9474" name="a69094b92cf05fe59b51ae012a03d9474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69094b92cf05fe59b51ae012a03d9474">&#9670;&nbsp;</a></span>remove_bad_alloc_error_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::remove_bad_alloc_error_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restores default bad alloc error handling behavior. </p>

</div>
</div>
<a id="a08d89324acbf36872064573065959d20" name="a08d89324acbf36872064573065959d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d89324acbf36872064573065959d20">&#9670;&nbsp;</a></span>remove_fatal_error_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::remove_fatal_error_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restores default error handling behavior. </p>

</div>
</div>
<a id="a6e3cd886beda7a2289aa18773f3aa103" name="a6e3cd886beda7a2289aa18773f3aa103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3cd886beda7a2289aa18773f3aa103">&#9670;&nbsp;</a></span>report_bad_alloc_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::report_bad_alloc_error </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>Reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>GenCrashDiag</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports a bad alloc error, calling any user defined bad alloc error handler. </p>
<p >In contrast to the generic 'report_fatal_error' functions, this function might not terminate, e.g. the user defined error handler throws an exception, but it won't return.</p>
<p >Note: When throwing an exception in the bad alloc handler, make sure that the following unwind succeeds, e.g. do not trigger additional allocations in the unwind chain.</p>
<p >If no error handler is installed (default), throws a bad_alloc exception if LLVM is compiled with exception support. Otherwise prints the error to standard error and calls abort(). </p>

</div>
</div>
<a id="a6392584571d4e2bec4247503254d83a3" name="a6392584571d4e2bec4247503254d83a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6392584571d4e2bec4247503254d83a3">&#9670;&nbsp;</a></span>report_fatal_error() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::report_fatal_error </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gen_crash_diag</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports a serious error, calling any installed error handler. </p>
<p >These functions are intended to be used for error conditions which are outside the control of the compiler (I/O errors, invalid user input, etc.)</p>
<p >If no error handler is installed the default is to print the message to standard error, followed by a newline. After the error handler is called this function will call abort(), it does not return. </p>

</div>
</div>
<a id="a2a2f5ea71a00431f1def0f2d7daf7af3" name="a2a2f5ea71a00431f1def0f2d7daf7af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2f5ea71a00431f1def0f2d7daf7af3">&#9670;&nbsp;</a></span>report_fatal_error() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::report_fatal_error </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gen_crash_diag</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c5d4610f996de2254ee2eca97aa2da6" name="a9c5d4610f996de2254ee2eca97aa2da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5d4610f996de2254ee2eca97aa2da6">&#9670;&nbsp;</a></span>report_fatal_error() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::report_fatal_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gen_crash_diag</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a538316af0297b9fa6d65a22c874d4a95" name="a538316af0297b9fa6d65a22c874d4a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538316af0297b9fa6d65a22c874d4a95">&#9670;&nbsp;</a></span>reverseBits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T wpi::reverseBits </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse the bits in <code>Val</code>. </p>

</div>
</div>
<a id="a676758fb3474980129376c4430e5965f" name="a676758fb3474980129376c4430e5965f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676758fb3474980129376c4430e5965f">&#9670;&nbsp;</a></span>rfind_lower() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view::size_type wpi::rfind_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type&#160;</td>
          <td class="paramname"><em>from</em> = <code>std::string_view::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the last character <code>ch</code> in <code>str</code>, ignoring case. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the last occurrence of <code>ch</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="a6670129d8dd67d55733dacac82fb6354" name="a6670129d8dd67d55733dacac82fb6354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6670129d8dd67d55733dacac82fb6354">&#9670;&nbsp;</a></span>rfind_lower() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view::size_type wpi::rfind_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the last string <code>other</code> in <code>str</code>, ignoring case. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the last occurrence of <code>other</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="a88303c617dfdc5eca2edb6fb7b10124b" name="a88303c617dfdc5eca2edb6fb7b10124b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88303c617dfdc5eca2edb6fb7b10124b">&#9670;&nbsp;</a></span>rfind_lower() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view::size_type wpi::rfind_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the last string <code>other</code> in <code>str</code>, ignoring case. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the last occurrence of <code>other</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="a7a31eb74242495e03e1745ab82085c81" name="a7a31eb74242495e03e1745ab82085c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a31eb74242495e03e1745ab82085c81">&#9670;&nbsp;</a></span>rsplit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt; <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> &gt; wpi::rsplit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>separator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits <code>str</code> into two substrings around the last occurrence of a separator character. </p>
<p >If <code>separator</code> is in the string, then the result is a pair (LHS, RHS) such that (str == LHS + separator + RHS) is true and RHS is minimal. If <code>separator</code> is not in the string, then the result is a pair (LHS, RHS) where (str == LHS) and (RHS == "").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>The string to split on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The split substrings. </dd></dl>

</div>
</div>
<a id="a2512b6f3e4faf374ccc818722784597b" name="a2512b6f3e4faf374ccc818722784597b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2512b6f3e4faf374ccc818722784597b">&#9670;&nbsp;</a></span>rsplit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt; <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> &gt; wpi::rsplit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>separator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits <code>str</code> into two substrings around the last occurrence of a separator string. </p>
<p >If <code>separator</code> is in the string, then the result is a pair (LHS, RHS) such that (str == LHS + separator + RHS) is true and RHS is minimal. If <code>separator</code> is not in the string, then the result is a pair (LHS, RHS) where (str == LHS) and (RHS == "").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>The string to split on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The split substrings. </dd></dl>

</div>
</div>
<a id="adb3a6a546687b31a4770178e1036c589" name="adb3a6a546687b31a4770178e1036c589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3a6a546687b31a4770178e1036c589">&#9670;&nbsp;</a></span>rtrim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> wpi::rtrim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>str</code> with consecutive <code>Char</code> characters starting from the right removed. </p>

</div>
</div>
<a id="a9c241695392bec8c5295c438f6e8d35f" name="a9c241695392bec8c5295c438f6e8d35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c241695392bec8c5295c438f6e8d35f">&#9670;&nbsp;</a></span>rtrim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> wpi::rtrim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>chars</em> = <code>&quot;&#160;\t\n\v\f\r&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>str</code> with consecutive characters in <code>chars</code> starting from the right removed. </p>

</div>
</div>
<a id="aa3107b50e4fba4c211bc3981f452dfbc" name="aa3107b50e4fba4c211bc3981f452dfbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3107b50e4fba4c211bc3981f452dfbc">&#9670;&nbsp;</a></span>safe_calloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_compiler_8h.html#acbae7c06e77fa64145cca176963b6863">LLVM_ATTRIBUTE_RETURNS_NONNULL</a> void * wpi::safe_calloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a01feba2e98f9634bb529eac857ffa4fb" name="a01feba2e98f9634bb529eac857ffa4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01feba2e98f9634bb529eac857ffa4fb">&#9670;&nbsp;</a></span>safe_malloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_compiler_8h.html#acbae7c06e77fa64145cca176963b6863">LLVM_ATTRIBUTE_RETURNS_NONNULL</a> void * wpi::safe_malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a780a79e5410f3c9082aa1ff62d997151" name="a780a79e5410f3c9082aa1ff62d997151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780a79e5410f3c9082aa1ff62d997151">&#9670;&nbsp;</a></span>safe_realloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_compiler_8h.html#acbae7c06e77fa64145cca176963b6863">LLVM_ATTRIBUTE_RETURNS_NONNULL</a> void * wpi::safe_realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5c5ce165d2bf0db00fbcbfe8450c562" name="ac5c5ce165d2bf0db00fbcbfe8450c562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c5ce165d2bf0db00fbcbfe8450c562">&#9670;&nbsp;</a></span>SaturatingAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt; std::is_unsigned&lt; T &gt;<a class="el" href="classvalue.html">::value</a>, T &gt; wpi::SaturatingAdd </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>ResultOverflowed</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add two unsigned integers, X and Y, of type T. </p>
<p >Clamp the result to the maximum representable value of T on overflow. ResultOverflowed indicates if the result is larger than the maximum representable value of type T. </p>

</div>
</div>
<a id="a2396f98cc1c4e416c09a535bceb9f732" name="a2396f98cc1c4e416c09a535bceb9f732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2396f98cc1c4e416c09a535bceb9f732">&#9670;&nbsp;</a></span>SaturatingMultiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt; std::is_unsigned&lt; T &gt;<a class="el" href="classvalue.html">::value</a>, T &gt; wpi::SaturatingMultiply </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>ResultOverflowed</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two unsigned integers, X and Y, of type T. </p>
<p >Clamp the result to the maximum representable value of T on overflow. ResultOverflowed indicates if the result is larger than the maximum representable value of type T. </p>

</div>
</div>
<a id="ac3fbc7000c2b2e339238d6aff6b448e0" name="ac3fbc7000c2b2e339238d6aff6b448e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3fbc7000c2b2e339238d6aff6b448e0">&#9670;&nbsp;</a></span>SaturatingMultiplyAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt; std::is_unsigned&lt; T &gt;<a class="el" href="classvalue.html">::value</a>, T &gt; wpi::SaturatingMultiplyAdd </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>ResultOverflowed</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two unsigned integers, X and Y, and add the unsigned integer, A to the product. </p>
<p >Clamp the result to the maximum representable value of T on overflow. ResultOverflowed indicates if the result is larger than the maximum representable value of type T. </p>

</div>
</div>
<a id="ab9199d95a0d0ca4ba23a42b8c9cd4763" name="ab9199d95a0d0ca4ba23a42b8c9cd4763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9199d95a0d0ca4ba23a42b8c9cd4763">&#9670;&nbsp;</a></span>set_fixed_execution_hash_seed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::set_fixed_execution_hash_seed </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>fixed_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override the execution seed with a fixed value. </p>
<p >This hashing library uses a per-execution seed designed to change on each run with high probability in order to ensure that the hash codes are not attackable and to ensure that output which is intended to be stable does not rely on the particulars of the hash codes produced.</p>
<p >That said, there are use cases where it is important to be able to reproduce <em>exactly</em> a specific behavior. To that end, we provide a function which will forcibly set the seed to a fixed value. This must be done at the start of the program, before any hashes are computed. Also, it cannot be undone. This makes it thread-hostile and very hard to use outside of immediately on start of a simple program designed for reproducible behavior. </p>

</div>
</div>
<a id="a3776b907dc530ce3556e36bcb5a68462" name="a3776b907dc530ce3556e36bcb5a68462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3776b907dc530ce3556e36bcb5a68462">&#9670;&nbsp;</a></span>SetGetStackTraceImpl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::SetGetStackTraceImpl </td>
          <td>(</td>
          <td class="paramtype">std::string(*)(int offset)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the implementation used by <a class="el" href="namespacewpi.html#a4b125df3c2eaae6f9b8cd09ccd9da98d" title="Get a stack trace, ignoring the first &quot;offset&quot; symbols.">GetStackTrace()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function called by <a class="el" href="namespacewpi.html#a4b125df3c2eaae6f9b8cd09ccd9da98d" title="Get a stack trace, ignoring the first &quot;offset&quot; symbols.">GetStackTrace()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0dca6ddf9e17f10ec7699c29819b6c18" name="a0dca6ddf9e17f10ec7699c29819b6c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dca6ddf9e17f10ec7699c29819b6c18">&#9670;&nbsp;</a></span>sgn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int wpi::sgn </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afbf26bf198ea436f545bf8205670ff7a" name="afbf26bf198ea436f545bf8205670ff7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf26bf198ea436f545bf8205670ff7a">&#9670;&nbsp;</a></span>shouldReverseIterate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T  = void *&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::shouldReverseIterate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae892922c9d93c91d358b554fec2b6505" name="ae892922c9d93c91d358b554fec2b6505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae892922c9d93c91d358b554fec2b6505">&#9670;&nbsp;</a></span>SignExtend32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int32_t wpi::SignExtend32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign-extend the number in the bottom B bits of X to a 32-bit integer. </p>
<p >Requires 0 &lt; B &lt;= 32. </p>

</div>
</div>
<a id="a9c3d762ed7571ddac4e212f583eb0a12" name="a9c3d762ed7571ddac4e212f583eb0a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3d762ed7571ddac4e212f583eb0a12">&#9670;&nbsp;</a></span>SignExtend32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t wpi::SignExtend32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign-extend the number in the bottom B bits of X to a 32-bit integer. </p>
<p >Requires 0 &lt; B &lt;= 32. </p>

</div>
</div>
<a id="a401f9f01b250b094f790fab7706106d8" name="a401f9f01b250b094f790fab7706106d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a401f9f01b250b094f790fab7706106d8">&#9670;&nbsp;</a></span>SignExtend64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int64_t wpi::SignExtend64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign-extend the number in the bottom B bits of X to a 64-bit integer. </p>
<p >Requires 0 &lt; B &lt;= 64. </p>

</div>
</div>
<a id="a2540c26db383c900eae86f2c67c41ce0" name="a2540c26db383c900eae86f2c67c41ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2540c26db383c900eae86f2c67c41ce0">&#9670;&nbsp;</a></span>SignExtend64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t wpi::SignExtend64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign-extend the number in the bottom B bits of X to a 64-bit integer. </p>
<p >Requires 0 &lt; B &lt;= 64. </p>

</div>
</div>
<a id="a36ea49dcab711bb9a5e64a569c32241b" name="a36ea49dcab711bb9a5e64a569c32241b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ea49dcab711bb9a5e64a569c32241b">&#9670;&nbsp;</a></span>SizeUleb128()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::SizeUleb128 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get size of unsigned LEB128 data. </p>
<p >Determine the number of bytes required to encode an unsigned LEB128 datum. The algorithm is taken from Appendix C of the DWARF 3 spec. For information on the encodings refer to section "7.6 - Variable Length Data". Return the number of bytes required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>LEB128 data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f22fd8158dd46fe207d828ab907c6a9" name="a0f22fd8158dd46fe207d828ab907c6a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f22fd8158dd46fe207d828ab907c6a9">&#9670;&nbsp;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> wpi::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the substring of <code>str</code> from [start, end). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The index of the starting character in the substring; if the index is npos or greater than the length of the string then the empty substring will be returned.</td></tr>
    <tr><td class="paramname">end</td><td>The index following the last character to include in the substring. If this is npos or exceeds the number of characters remaining in the string, the string suffix (starting with <code>start</code>) will be returned. If this is less than <code>start</code>, an empty string will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af979beb47215754d9f91b67aab2dc4e7" name="af979beb47215754d9f91b67aab2dc4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af979beb47215754d9f91b67aab2dc4e7">&#9670;&nbsp;</a></span>SocketErrno()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wpi::SocketErrno </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4d3b98c9badfe33b94b7c6ec1ad3f9f" name="aa4d3b98c9badfe33b94b7c6ec1ad3f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d3b98c9badfe33b94b7c6ec1ad3f9f">&#9670;&nbsp;</a></span>SocketStrerror() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string wpi::SocketStrerror </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b76c9ad108ae76959df39c1d0b6f03b" name="a8b76c9ad108ae76959df39c1d0b6f03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b76c9ad108ae76959df39c1d0b6f03b">&#9670;&nbsp;</a></span>SocketStrerror() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string wpi::SocketStrerror </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f9d3d4eb9461ff65cb2743afa9fd08a" name="a0f9d3d4eb9461ff65cb2743afa9fd08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9d3d4eb9461ff65cb2743afa9fd08a">&#9670;&nbsp;</a></span>split() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt; <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> &gt; wpi::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>separator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits <code>str</code> into two substrings around the first occurrence of a separator character. </p>
<p >If <code>separator</code> is in the string, then the result is a pair (LHS, RHS) such that (str == LHS + separator + RHS) is true and RHS is maximal. If <code>separator</code> is not in the string, then the result is a pair (LHS, RHS) where (str == LHS) and (RHS == "").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>The character to split on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The split substrings. </dd></dl>

</div>
</div>
<a id="ac32a7896ab3ee6b24926527703eabade" name="ac32a7896ab3ee6b24926527703eabade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32a7896ab3ee6b24926527703eabade">&#9670;&nbsp;</a></span>split() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxSplit</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepEmpty</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits <code>str</code> into substrings around the occurrences of a separator character. </p>
<p >Each substring is stored in <code>arr</code>. If <code>maxSplit</code> is &gt;= 0, at most <code>maxSplit</code> splits are done and consequently &lt;= <code>maxSplit</code> + 1 elements are added to arr. If <code>keepEmpty</code> is false, empty strings are not added to <code>arr</code>. They still count when considering <code>maxSplit</code> An useful invariant is that separator.join(arr) == str if maxSplit == -1 and keepEmpty == true</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Where to put the substrings. </td></tr>
    <tr><td class="paramname">separator</td><td>The character to split on. </td></tr>
    <tr><td class="paramname">maxSplit</td><td>The maximum number of times the string is split. </td></tr>
    <tr><td class="paramname">keepEmpty</td><td>True if empty substring should be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd39f69badd5bed05f8020e76e688911" name="afd39f69badd5bed05f8020e76e688911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd39f69badd5bed05f8020e76e688911">&#9670;&nbsp;</a></span>split() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxSplit</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepEmpty</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits <code>str</code> into substrings around the occurrences of a separator string. </p>
<p >Each substring is stored in <code>arr</code>. If <code>maxSplit</code> is &gt;= 0, at most <code>maxSplit</code> splits are done and consequently &lt;= <code>maxSplit</code> + 1 elements are added to arr. If <code>keepEmpty</code> is false, empty strings are not added to <code>arr</code>. They still count when considering <code>maxSplit</code> An useful invariant is that separator.join(arr) == str if maxSplit == -1 and keepEmpty == true</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Where to put the substrings. </td></tr>
    <tr><td class="paramname">separator</td><td>The string to split on. </td></tr>
    <tr><td class="paramname">maxSplit</td><td>The maximum number of times the string is split. </td></tr>
    <tr><td class="paramname">keepEmpty</td><td>True if empty substring should be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b559c84b004c61700aa0724cf658177" name="a2b559c84b004c61700aa0724cf658177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b559c84b004c61700aa0724cf658177">&#9670;&nbsp;</a></span>split() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt; <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>, <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> &gt; wpi::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>separator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits <code>str</code> into two substrings around the first occurrence of a separator string. </p>
<p >If <code>separator</code> is in the string, then the result is a pair (LHS, RHS) such that (str == LHS + separator + RHS) is true and RHS is maximal. If <code>separator</code> is not in the string, then the result is a pair (LHS, RHS) where (str == LHS) and (RHS == "").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>The string to split on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The split substrings. </dd></dl>

</div>
</div>
<a id="a24ed0964b7b3d671454f67babc4835bf" name="a24ed0964b7b3d671454f67babc4835bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ed0964b7b3d671454f67babc4835bf">&#9670;&nbsp;</a></span>starts_with() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::starts_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> starts with the given <code>prefix</code>. </p>

</div>
</div>
<a id="a5432fef02a3f6f25d649439e5f37b291" name="a5432fef02a3f6f25d649439e5f37b291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5432fef02a3f6f25d649439e5f37b291">&#9670;&nbsp;</a></span>starts_with() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::starts_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> starts with the given <code>prefix</code>. </p>

</div>
</div>
<a id="af0739f65c4cc2835777cc34e9241c377" name="af0739f65c4cc2835777cc34e9241c377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0739f65c4cc2835777cc34e9241c377">&#9670;&nbsp;</a></span>starts_with() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::starts_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> starts with the given <code>prefix</code>. </p>

</div>
</div>
<a id="a2bef3b73b83b04242caa60d6327ceb68" name="a2bef3b73b83b04242caa60d6327ceb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bef3b73b83b04242caa60d6327ceb68">&#9670;&nbsp;</a></span>starts_with_lower() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::starts_with_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> starts with the given <code>prefix</code>, ignoring case. </p>

</div>
</div>
<a id="a9ddfda4dce07ee9575513ba636d6f383" name="a9ddfda4dce07ee9575513ba636d6f383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ddfda4dce07ee9575513ba636d6f383">&#9670;&nbsp;</a></span>starts_with_lower() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::starts_with_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> starts with the given <code>prefix</code>, ignoring case. </p>

</div>
</div>
<a id="a6880afc62fe88adf620fbf7c0ae29cc6" name="a6880afc62fe88adf620fbf7c0ae29cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6880afc62fe88adf620fbf7c0ae29cc6">&#9670;&nbsp;</a></span>starts_with_lower() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::starts_with_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> starts with the given <code>prefix</code>, ignoring case. </p>

</div>
</div>
<a id="a802f3b89f5be2d7575a84558dc56b169" name="a802f3b89f5be2d7575a84558dc56b169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802f3b89f5be2d7575a84558dc56b169">&#9670;&nbsp;</a></span>SubOverflow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_8h.html#a012819c9e8b5e04872a271f50f8b8196">std::enable_if_t</a>&lt; <a class="el" href="format_8h.html#a56d0276c2e6f4b26cb3565e08ebc9181">std::is_signed</a>&lt; T &gt;<a class="el" href="classvalue.html">::value</a>, T &gt; wpi::SubOverflow </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract two signed integers, computing the two's complement truncated result, returning true if an overflow ocurred. </p>

</div>
</div>
<a id="a7f010ee3e4dec5c5697534c0059aa046" name="a7f010ee3e4dec5c5697534c0059aa046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f010ee3e4dec5c5697534c0059aa046">&#9670;&nbsp;</a></span>substr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> wpi::substr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type&#160;</td>
          <td class="paramname"><em>n</em> = <code>std::string_view::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the substring of <code>str</code> from [start, start + n). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The index of the starting character in the substring; if the index is npos or greater than the length of the string then the empty substring will be returned.</td></tr>
    <tr><td class="paramname">n</td><td>The number of characters to included in the substring. If n exceeds the number of characters remaining in the string, the string suffix (starting with <code>start</code>) will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8a98666f01d85b3920861e2477e7926" name="aa8a98666f01d85b3920861e2477e7926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a98666f01d85b3920861e2477e7926">&#9670;&nbsp;</a></span>take_back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> wpi::take_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a view equal to <code>str</code> but with only the last <code>n</code> elements remaining. </p>
<p >If <code>n</code> is greater than the length of the string, the entire string is returned. </p>

</div>
</div>
<a id="aff2f9b2ee4f037743d32eb831bb487c4" name="aff2f9b2ee4f037743d32eb831bb487c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2f9b2ee4f037743d32eb831bb487c4">&#9670;&nbsp;</a></span>take_front()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> wpi::take_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a view equal to <code>str</code> but with only the first <code>n</code> elements remaining. </p>
<p >If <code>n</code> is greater than the length of the string, the entire string is returned. </p>

</div>
</div>
<a id="a5602e08ef8bfc0486d71717a291a06b4" name="a5602e08ef8bfc0486d71717a291a06b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5602e08ef8bfc0486d71717a291a06b4">&#9670;&nbsp;</a></span>to_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned Size, typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1_small_vector.html">SmallVector</a>&lt; <a class="el" href="namespacewpi.html#abd4e2dafd0200d2e7686df5c99d07933">ValueTypeFromRangeType</a>&lt; R &gt;, Size &gt; wpi::to_vector </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>Range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a range of type R, iterate the entire range and return a <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> with elements of the vector. </p>
<p >This is useful, for example, when you want to iterate a range and then sort the results. </p>

</div>
</div>
<a id="ab47d27507d50af1b79e67593bf1e8dc6" name="ab47d27507d50af1b79e67593bf1e8dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47d27507d50af1b79e67593bf1e8dc6">&#9670;&nbsp;</a></span>to_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1_small_vector.html">SmallVector</a>&lt; <a class="el" href="namespacewpi.html#abd4e2dafd0200d2e7686df5c99d07933">ValueTypeFromRangeType</a>&lt; R &gt;, <a class="el" href="structwpi_1_1_calculate_small_vector_default_inlined_elements.html">CalculateSmallVectorDefaultInlinedElements</a>&lt; <a class="el" href="namespacewpi.html#abd4e2dafd0200d2e7686df5c99d07933">ValueTypeFromRangeType</a>&lt; R &gt; &gt;<a class="el" href="classvalue.html">::value</a> &gt; wpi::to_vector </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>Range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a47d0773c177190213ead75a95fe7fc46" name="a47d0773c177190213ead75a95fe7fc46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d0773c177190213ead75a95fe7fc46">&#9670;&nbsp;</a></span>toLower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr char wpi::toLower </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the corresponding lowercase character if <code>x</code> is uppercase. </p>

</div>
</div>
<a id="a4fe9106b78ee79e9796550968c3ef216" name="a4fe9106b78ee79e9796550968c3ef216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe9106b78ee79e9796550968c3ef216">&#9670;&nbsp;</a></span>toUpper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr char wpi::toUpper </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the corresponding uppercase character if <code>x</code> is lowercase. </p>

</div>
</div>
<a id="a4c8e2346d8ddaaaecfd3bc8760d09d9a" name="a4c8e2346d8ddaaaecfd3bc8760d09d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8e2346d8ddaaaecfd3bc8760d09d9a">&#9670;&nbsp;</a></span>trim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> wpi::trim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>str</code> with consecutive <code>ch</code> characters starting from the left and right removed. </p>

</div>
</div>
<a id="a5ddfebd5ca997fb76159b3d79f1a98c9" name="a5ddfebd5ca997fb76159b3d79f1a98c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ddfebd5ca997fb76159b3d79f1a98c9">&#9670;&nbsp;</a></span>trim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> wpi::trim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>chars</em> = <code>&quot;&#160;\t\n\v\f\r&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>str</code> with consecutive characters in <code>chars</code> starting from the left and right removed. </p>

</div>
</div>
<a id="a55235b8d8fe2b869b11a04237f1c1b5f" name="a55235b8d8fe2b869b11a04237f1c1b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55235b8d8fe2b869b11a04237f1c1b5f">&#9670;&nbsp;</a></span>UnescapeURI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a> wpi::UnescapeURI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="core_8h.html#a204ca715c2febee035464fa53dfc50c4">std::string_view</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7da2e15d1e126422095bfbc0e66f1bc" name="ae7da2e15d1e126422095bfbc0e66f1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7da2e15d1e126422095bfbc0e66f1bc">&#9670;&nbsp;</a></span>utohexstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string wpi::utohexstr </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lowerCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a330e37a0f2a3ac6bf2a664ea6d12db" name="a0a330e37a0f2a3ac6bf2a664ea6d12db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a330e37a0f2a3ac6bf2a664ea6d12db">&#9670;&nbsp;</a></span>wpi_unreachable_internal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::wpi_unreachable_internal </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calls abort(), and prints the optional message to stderr. </p>
<p >Use the wpi_unreachable macro (that adds location info), instead of calling this function directly. </p>

</div>
</div>
<a id="a1d290fcc6f4ff08f10afc9eb18d5af16" name="a1d290fcc6f4ff08f10afc9eb18d5af16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d290fcc6f4ff08f10afc9eb18d5af16">&#9670;&nbsp;</a></span>WriteUleb128() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::WriteUleb128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write unsigned LEB128 data. </p>
<p >Encode an unsigned LEB128 encoded datum. The algorithm is taken from Appendix C of the DWARF 3 spec. For information on the encodings refer to section "7.6 - Variable Length Data".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3dac2f55476ec2190adf33d5a123cf4" name="ab3dac2f55476ec2190adf33d5a123cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3dac2f55476ec2190adf33d5a123cf4">&#9670;&nbsp;</a></span>WriteUleb128() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::WriteUleb128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write unsigned LEB128 data. </p>
<p >Encode an unsigned LEB128 encoded datum. The algorithm is taken from Appendix C of the DWARF 3 spec. For information on the encodings refer to section "7.6 - Variable Length Data". Return the number of bytes written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The address where the ULEB128 data is to be stored. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a096e48bf0264a255eb2ff954146cc85b" name="a096e48bf0264a255eb2ff954146cc85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096e48bf0264a255eb2ff954146cc85b">&#9670;&nbsp;</a></span>BitReverseTable256</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char wpi::BitReverseTable256[256]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line"><span class="preprocessor">#define R2(n)                                      </span></div>
<div class="line"><span class="preprocessor">#define R4(n)                                                      </span></div>
<div class="line"><span class="preprocessor">#define R6(n)                                                   </span></div>
<div class="line">  <a class="code hl_define" href="_math_extras_8h.html#ace331bebb5bd2780b8dfb7e6e97db7dd">R6</a>(0), <a class="code hl_define" href="_math_extras_8h.html#ace331bebb5bd2780b8dfb7e6e97db7dd">R6</a>(2), <a class="code hl_define" href="_math_extras_8h.html#ace331bebb5bd2780b8dfb7e6e97db7dd">R6</a>(1), <a class="code hl_define" href="_math_extras_8h.html#ace331bebb5bd2780b8dfb7e6e97db7dd">R6</a>(3)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="a_math_extras_8h_html_ace331bebb5bd2780b8dfb7e6e97db7dd"><div class="ttname"><a href="_math_extras_8h.html#ace331bebb5bd2780b8dfb7e6e97db7dd">R6</a></div><div class="ttdeci">#define R6(n)</div></div>
</div><!-- fragment -->
<p>Macro compressed bit reversal table for 256 bits. </p>
<p ><a href="http://graphics.stanford.edu/~seander/bithacks.html#BitReverseTable">http://graphics.stanford.edu/~seander/bithacks.html#BitReverseTable</a> </p>

</div>
</div>
<a id="ab3cecb2351a66db7a659706908ff8764" name="ab3cecb2351a66db7a659706908ff8764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3cecb2351a66db7a659706908ff8764">&#9670;&nbsp;</a></span>empty_array</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structwpi_1_1empty__array__t.html">empty_array_t</a> wpi::empty_array</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68147e630fcf898faec5b0f4cacd7214" name="a68147e630fcf898faec5b0f4cacd7214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68147e630fcf898faec5b0f4cacd7214">&#9670;&nbsp;</a></span>huge_valf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const float wpi::huge_valf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use this rather than HUGE_VALF; the latter causes warnings on MSVC. </p>

</div>
</div>
<a id="a9e441a1bfb8b548adcb3fd7e08eb3be0" name="a9e441a1bfb8b548adcb3fd7e08eb3be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e441a1bfb8b548adcb3fd7e08eb3be0">&#9670;&nbsp;</a></span>in_place</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structwpi_1_1in__place__t.html">in_place_t</a> wpi::in_place</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>This must not be odr-used, as it cannot be made <code>inline</code> in C++14. </dd></dl>

</div>
</div>
<a id="a74ddf62331eda674218d045fb5376c13" name="a74ddf62331eda674218d045fb5376c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ddf62331eda674218d045fb5376c13">&#9670;&nbsp;</a></span>SmallVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="_compiler_8h.html#a61e566d072949de225fa6912528beaf5">LLVM_GSL_OWNER</a> <a class="el" href="classwpi_1_1_small_vector.html">wpi::SmallVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forward declaration of <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> so that calculateSmallVectorDefaultInlinedElements can reference <code>sizeof(<a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a>&lt;T, 0&gt;)</code>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacewpi.html">wpi</a></li>
    <li class="footer">Generated on Tue Nov 8 2022 21:30:48 for WPILibC++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
