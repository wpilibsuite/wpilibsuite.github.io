<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: frc::UnscentedKalmanFilter&lt; States, Inputs, Outputs &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">WPILibC++
   &#160;<span id="projectnumber">2021.2.2-56-gffb590b</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classfrc_1_1UnscentedKalmanFilter.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classfrc_1_1UnscentedKalmanFilter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">frc::UnscentedKalmanFilter&lt; States, Inputs, Outputs &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6423963161fc0d7d9247e76049cbb53b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1UnscentedKalmanFilter.html#a6423963161fc0d7d9247e76049cbb53b">UnscentedKalmanFilter</a> (std::function&lt; Eigen::Matrix&lt; double, States, 1 &gt;(const Eigen::Matrix&lt; double, States, 1 &gt; &amp;, const Eigen::Matrix&lt; double, Inputs, 1 &gt; &amp;)&gt; f, std::function&lt; Eigen::Matrix&lt; double, Outputs, 1 &gt;(const Eigen::Matrix&lt; double, States, 1 &gt; &amp;, const Eigen::Matrix&lt; double, Inputs, 1 &gt; &amp;)&gt; h, const <a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; double, States &gt; &amp;stateStdDevs, const <a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; double, Outputs &gt; &amp;measurementStdDevs, units::second_t dt)</td></tr>
<tr class="memdesc:a6423963161fc0d7d9247e76049cbb53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an unscented Kalman filter.  <a href="classfrc_1_1UnscentedKalmanFilter.html#a6423963161fc0d7d9247e76049cbb53b">More...</a><br /></td></tr>
<tr class="separator:a6423963161fc0d7d9247e76049cbb53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26c8b8959c7741ffa52c75e12ee47b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1UnscentedKalmanFilter.html#af26c8b8959c7741ffa52c75e12ee47b0">UnscentedKalmanFilter</a> (std::function&lt; Eigen::Matrix&lt; double, States, 1 &gt;(const Eigen::Matrix&lt; double, States, 1 &gt; &amp;, const Eigen::Matrix&lt; double, Inputs, 1 &gt; &amp;)&gt; f, std::function&lt; Eigen::Matrix&lt; double, Outputs, 1 &gt;(const Eigen::Matrix&lt; double, States, 1 &gt; &amp;, const Eigen::Matrix&lt; double, Inputs, 1 &gt; &amp;)&gt; h, const <a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; double, States &gt; &amp;stateStdDevs, const <a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; double, Outputs &gt; &amp;measurementStdDevs, std::function&lt; Eigen::Matrix&lt; double, States, 1 &gt;(const Eigen::Matrix&lt; double, States, 2 *States+1 &gt; &amp;, const Eigen::Matrix&lt; double, 2 *States+1, 1 &gt; &amp;)&gt; meanFuncX, std::function&lt; Eigen::Matrix&lt; double, Outputs, 1 &gt;(const Eigen::Matrix&lt; double, Outputs, 2 *States+1 &gt; &amp;, const Eigen::Matrix&lt; double, 2 *States+1, 1 &gt; &amp;)&gt; meanFuncY, std::function&lt; Eigen::Matrix&lt; double, States, 1 &gt;(const Eigen::Matrix&lt; double, States, 1 &gt; &amp;, const Eigen::Matrix&lt; double, States, 1 &gt; &amp;)&gt; residualFuncX, std::function&lt; Eigen::Matrix&lt; double, Outputs, 1 &gt;(const Eigen::Matrix&lt; double, Outputs, 1 &gt; &amp;, const Eigen::Matrix&lt; double, Outputs, 1 &gt; &amp;)&gt; residualFuncY, std::function&lt; Eigen::Matrix&lt; double, States, 1 &gt;(const Eigen::Matrix&lt; double, States, 1 &gt; &amp;, const Eigen::Matrix&lt; double, States, 1 &gt; &amp;)&gt; addFuncX, units::second_t dt)</td></tr>
<tr class="memdesc:af26c8b8959c7741ffa52c75e12ee47b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an unscented Kalman filter with custom mean, residual, and addition functions.  <a href="classfrc_1_1UnscentedKalmanFilter.html#af26c8b8959c7741ffa52c75e12ee47b0">More...</a><br /></td></tr>
<tr class="separator:af26c8b8959c7741ffa52c75e12ee47b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaced414fe9446825bbb450daf47772ea"><td class="memItemLeft" align="right" valign="top"><a id="aaced414fe9446825bbb450daf47772ea"></a>
const Eigen::Matrix&lt; double, States, States &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1UnscentedKalmanFilter.html#aaced414fe9446825bbb450daf47772ea">P</a> () const</td></tr>
<tr class="memdesc:aaced414fe9446825bbb450daf47772ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error covariance matrix P. <br /></td></tr>
<tr class="separator:aaced414fe9446825bbb450daf47772ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aabd4b8bdbf288c014995eced0e33fa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1UnscentedKalmanFilter.html#a5aabd4b8bdbf288c014995eced0e33fa">P</a> (int i, int j) const</td></tr>
<tr class="memdesc:a5aabd4b8bdbf288c014995eced0e33fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an element of the error covariance matrix P.  <a href="classfrc_1_1UnscentedKalmanFilter.html#a5aabd4b8bdbf288c014995eced0e33fa">More...</a><br /></td></tr>
<tr class="separator:a5aabd4b8bdbf288c014995eced0e33fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ee707e89f691ad5f5c995fb9f06787"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1UnscentedKalmanFilter.html#a83ee707e89f691ad5f5c995fb9f06787">SetP</a> (const Eigen::Matrix&lt; double, States, States &gt; &amp;<a class="el" href="classfrc_1_1UnscentedKalmanFilter.html#aaced414fe9446825bbb450daf47772ea">P</a>)</td></tr>
<tr class="memdesc:a83ee707e89f691ad5f5c995fb9f06787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current error covariance matrix P.  <a href="classfrc_1_1UnscentedKalmanFilter.html#a83ee707e89f691ad5f5c995fb9f06787">More...</a><br /></td></tr>
<tr class="separator:a83ee707e89f691ad5f5c995fb9f06787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab659c752ce137ad7aee133a1a2a4b2b"><td class="memItemLeft" align="right" valign="top"><a id="aab659c752ce137ad7aee133a1a2a4b2b"></a>
const Eigen::Matrix&lt; double, States, 1 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1UnscentedKalmanFilter.html#aab659c752ce137ad7aee133a1a2a4b2b">Xhat</a> () const</td></tr>
<tr class="memdesc:aab659c752ce137ad7aee133a1a2a4b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the state estimate x-hat. <br /></td></tr>
<tr class="separator:aab659c752ce137ad7aee133a1a2a4b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9eaaab42a142391a75d1472cd8ec12"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1UnscentedKalmanFilter.html#a1b9eaaab42a142391a75d1472cd8ec12">Xhat</a> (int i) const</td></tr>
<tr class="memdesc:a1b9eaaab42a142391a75d1472cd8ec12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an element of the state estimate x-hat.  <a href="classfrc_1_1UnscentedKalmanFilter.html#a1b9eaaab42a142391a75d1472cd8ec12">More...</a><br /></td></tr>
<tr class="separator:a1b9eaaab42a142391a75d1472cd8ec12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde6af1afe00eafc4539e04c220ef87d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1UnscentedKalmanFilter.html#adde6af1afe00eafc4539e04c220ef87d">SetXhat</a> (const Eigen::Matrix&lt; double, States, 1 &gt; &amp;xHat)</td></tr>
<tr class="memdesc:adde6af1afe00eafc4539e04c220ef87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set initial state estimate x-hat.  <a href="classfrc_1_1UnscentedKalmanFilter.html#adde6af1afe00eafc4539e04c220ef87d">More...</a><br /></td></tr>
<tr class="separator:adde6af1afe00eafc4539e04c220ef87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2be5c5aaae45fb7c67c341e1ae2e700"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1UnscentedKalmanFilter.html#ac2be5c5aaae45fb7c67c341e1ae2e700">SetXhat</a> (int i, double value)</td></tr>
<tr class="memdesc:ac2be5c5aaae45fb7c67c341e1ae2e700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an element of the initial state estimate x-hat.  <a href="classfrc_1_1UnscentedKalmanFilter.html#ac2be5c5aaae45fb7c67c341e1ae2e700">More...</a><br /></td></tr>
<tr class="separator:ac2be5c5aaae45fb7c67c341e1ae2e700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea76be479af4a0e4472930e49d8302d7"><td class="memItemLeft" align="right" valign="top"><a id="aea76be479af4a0e4472930e49d8302d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1UnscentedKalmanFilter.html#aea76be479af4a0e4472930e49d8302d7">Reset</a> ()</td></tr>
<tr class="memdesc:aea76be479af4a0e4472930e49d8302d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the observer. <br /></td></tr>
<tr class="separator:aea76be479af4a0e4472930e49d8302d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6add97e52efdc06f74068c864493de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1UnscentedKalmanFilter.html#a7a6add97e52efdc06f74068c864493de">Predict</a> (const Eigen::Matrix&lt; double, Inputs, 1 &gt; &amp;u, units::second_t dt)</td></tr>
<tr class="memdesc:a7a6add97e52efdc06f74068c864493de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project the model into the future with a new control input u.  <a href="classfrc_1_1UnscentedKalmanFilter.html#a7a6add97e52efdc06f74068c864493de">More...</a><br /></td></tr>
<tr class="separator:a7a6add97e52efdc06f74068c864493de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42b9c885ac152433abfc268014ff1f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1UnscentedKalmanFilter.html#af42b9c885ac152433abfc268014ff1f1">Correct</a> (const Eigen::Matrix&lt; double, Inputs, 1 &gt; &amp;u, const Eigen::Matrix&lt; double, Outputs, 1 &gt; &amp;y)</td></tr>
<tr class="memdesc:af42b9c885ac152433abfc268014ff1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correct the state estimate x-hat using the measurements in y.  <a href="classfrc_1_1UnscentedKalmanFilter.html#af42b9c885ac152433abfc268014ff1f1">More...</a><br /></td></tr>
<tr class="separator:af42b9c885ac152433abfc268014ff1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc3ccc9bbdb26f49c258ae771be5521"><td class="memTemplParams" colspan="2">template&lt;int Rows&gt; </td></tr>
<tr class="memitem:aecc3ccc9bbdb26f49c258ae771be5521"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfrc_1_1UnscentedKalmanFilter.html#aecc3ccc9bbdb26f49c258ae771be5521">Correct</a> (const Eigen::Matrix&lt; double, Inputs, 1 &gt; &amp;u, const Eigen::Matrix&lt; double, Rows, 1 &gt; &amp;y, std::function&lt; Eigen::Matrix&lt; double, Rows, 1 &gt;(const Eigen::Matrix&lt; double, States, 1 &gt; &amp;, const Eigen::Matrix&lt; double, Inputs, 1 &gt; &amp;)&gt; h, const Eigen::Matrix&lt; double, Rows, Rows &gt; &amp;R)</td></tr>
<tr class="memdesc:aecc3ccc9bbdb26f49c258ae771be5521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correct the state estimate x-hat using the measurements in y.  <a href="classfrc_1_1UnscentedKalmanFilter.html#aecc3ccc9bbdb26f49c258ae771be5521">More...</a><br /></td></tr>
<tr class="separator:aecc3ccc9bbdb26f49c258ae771be5521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c551bb9699ec614c9c90bce276ef2bb"><td class="memTemplParams" colspan="2">template&lt;int Rows&gt; </td></tr>
<tr class="memitem:a5c551bb9699ec614c9c90bce276ef2bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfrc_1_1UnscentedKalmanFilter.html#a5c551bb9699ec614c9c90bce276ef2bb">Correct</a> (const Eigen::Matrix&lt; double, Inputs, 1 &gt; &amp;u, const Eigen::Matrix&lt; double, Rows, 1 &gt; &amp;y, std::function&lt; Eigen::Matrix&lt; double, Rows, 1 &gt;(const Eigen::Matrix&lt; double, States, 1 &gt; &amp;, const Eigen::Matrix&lt; double, Inputs, 1 &gt; &amp;)&gt; h, const Eigen::Matrix&lt; double, Rows, Rows &gt; &amp;R, std::function&lt; Eigen::Matrix&lt; double, Rows, 1 &gt;(const Eigen::Matrix&lt; double, Rows, 2 *States+1 &gt; &amp;, const Eigen::Matrix&lt; double, 2 *States+1, 1 &gt; &amp;)&gt; meanFuncY, std::function&lt; Eigen::Matrix&lt; double, Rows, 1 &gt;(const Eigen::Matrix&lt; double, Rows, 1 &gt; &amp;, const Eigen::Matrix&lt; double, Rows, 1 &gt; &amp;)&gt; residualFuncY, std::function&lt; Eigen::Matrix&lt; double, States, 1 &gt;(const Eigen::Matrix&lt; double, States, 1 &gt; &amp;, const Eigen::Matrix&lt; double, States, 1 &gt; &amp;)&gt; residualFuncX, std::function&lt; Eigen::Matrix&lt; double, States, 1 &gt;(const Eigen::Matrix&lt; double, States, 1 &gt; &amp;, const Eigen::Matrix&lt; double, States, 1 &gt;)&gt; addFuncX)</td></tr>
<tr class="memdesc:a5c551bb9699ec614c9c90bce276ef2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correct the state estimate x-hat using the measurements in y.  <a href="classfrc_1_1UnscentedKalmanFilter.html#a5c551bb9699ec614c9c90bce276ef2bb">More...</a><br /></td></tr>
<tr class="separator:a5c551bb9699ec614c9c90bce276ef2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6423963161fc0d7d9247e76049cbb53b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6423963161fc0d7d9247e76049cbb53b">&#9670;&nbsp;</a></span>UnscentedKalmanFilter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int States, int Inputs, int Outputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfrc_1_1UnscentedKalmanFilter.html">frc::UnscentedKalmanFilter</a>&lt; States, Inputs, Outputs &gt;::<a class="el" href="classfrc_1_1UnscentedKalmanFilter.html">UnscentedKalmanFilter</a> </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Eigen::Matrix&lt; double, States, 1 &gt;(const Eigen::Matrix&lt; double, States, 1 &gt; &amp;, const Eigen::Matrix&lt; double, Inputs, 1 &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Eigen::Matrix&lt; double, Outputs, 1 &gt;(const Eigen::Matrix&lt; double, States, 1 &gt; &amp;, const Eigen::Matrix&lt; double, Inputs, 1 &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; double, States &gt; &amp;&#160;</td>
          <td class="paramname"><em>stateStdDevs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; double, Outputs &gt; &amp;&#160;</td>
          <td class="paramname"><em>measurementStdDevs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">units::second_t&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an unscented Kalman filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A vector-valued function of x and u that returns the derivative of the state vector. </td></tr>
    <tr><td class="paramname">h</td><td>A vector-valued function of x and u that returns the measurement vector. </td></tr>
    <tr><td class="paramname">stateStdDevs</td><td>Standard deviations of model states. </td></tr>
    <tr><td class="paramname">measurementStdDevs</td><td>Standard deviations of measurements. </td></tr>
    <tr><td class="paramname">dt</td><td>Nominal discretization timestep. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af26c8b8959c7741ffa52c75e12ee47b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26c8b8959c7741ffa52c75e12ee47b0">&#9670;&nbsp;</a></span>UnscentedKalmanFilter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int States, int Inputs, int Outputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfrc_1_1UnscentedKalmanFilter.html">frc::UnscentedKalmanFilter</a>&lt; States, Inputs, Outputs &gt;::<a class="el" href="classfrc_1_1UnscentedKalmanFilter.html">UnscentedKalmanFilter</a> </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Eigen::Matrix&lt; double, States, 1 &gt;(const Eigen::Matrix&lt; double, States, 1 &gt; &amp;, const Eigen::Matrix&lt; double, Inputs, 1 &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Eigen::Matrix&lt; double, Outputs, 1 &gt;(const Eigen::Matrix&lt; double, States, 1 &gt; &amp;, const Eigen::Matrix&lt; double, Inputs, 1 &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; double, States &gt; &amp;&#160;</td>
          <td class="paramname"><em>stateStdDevs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; double, Outputs &gt; &amp;&#160;</td>
          <td class="paramname"><em>measurementStdDevs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Eigen::Matrix&lt; double, States, 1 &gt;(const Eigen::Matrix&lt; double, States, 2 *States+1 &gt; &amp;, const Eigen::Matrix&lt; double, 2 *States+1, 1 &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>meanFuncX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Eigen::Matrix&lt; double, Outputs, 1 &gt;(const Eigen::Matrix&lt; double, Outputs, 2 *States+1 &gt; &amp;, const Eigen::Matrix&lt; double, 2 *States+1, 1 &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>meanFuncY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Eigen::Matrix&lt; double, States, 1 &gt;(const Eigen::Matrix&lt; double, States, 1 &gt; &amp;, const Eigen::Matrix&lt; double, States, 1 &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>residualFuncX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Eigen::Matrix&lt; double, Outputs, 1 &gt;(const Eigen::Matrix&lt; double, Outputs, 1 &gt; &amp;, const Eigen::Matrix&lt; double, Outputs, 1 &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>residualFuncY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Eigen::Matrix&lt; double, States, 1 &gt;(const Eigen::Matrix&lt; double, States, 1 &gt; &amp;, const Eigen::Matrix&lt; double, States, 1 &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>addFuncX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">units::second_t&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an unscented Kalman filter with custom mean, residual, and addition functions. </p>
<p>Using custom functions for arithmetic can be useful if you have angles in the state or measurements, because they allow you to correctly account for the modular nature of angle arithmetic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A vector-valued function of x and u that returns the derivative of the state vector. </td></tr>
    <tr><td class="paramname">h</td><td>A vector-valued function of x and u that returns the measurement vector. </td></tr>
    <tr><td class="paramname">stateStdDevs</td><td>Standard deviations of model states. </td></tr>
    <tr><td class="paramname">measurementStdDevs</td><td>Standard deviations of measurements. </td></tr>
    <tr><td class="paramname">meanFuncX</td><td>A function that computes the mean of 2 * States + 1 state vectors using a given set of weights. </td></tr>
    <tr><td class="paramname">meanFuncY</td><td>A function that computes the mean of 2 * States + 1 measurement vectors using a given set of weights. </td></tr>
    <tr><td class="paramname">residualFuncX</td><td>A function that computes the residual of two state vectors (i.e. it subtracts them.) </td></tr>
    <tr><td class="paramname">residualFuncY</td><td>A function that computes the residual of two measurement vectors (i.e. it subtracts them.) </td></tr>
    <tr><td class="paramname">addFuncX</td><td>A function that adds two state vectors. </td></tr>
    <tr><td class="paramname">dt</td><td>Nominal discretization timestep. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af42b9c885ac152433abfc268014ff1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42b9c885ac152433abfc268014ff1f1">&#9670;&nbsp;</a></span>Correct() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int States, int Inputs, int Outputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfrc_1_1UnscentedKalmanFilter.html">frc::UnscentedKalmanFilter</a>&lt; States, Inputs, Outputs &gt;::Correct </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Inputs, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Outputs, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Correct the state estimate x-hat using the measurements in y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Same control input used in the predict step. </td></tr>
    <tr><td class="paramname">y</td><td>Measurement vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecc3ccc9bbdb26f49c258ae771be5521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc3ccc9bbdb26f49c258ae771be5521">&#9670;&nbsp;</a></span>Correct() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int States, int Inputs, int Outputs&gt; </div>
<div class="memtemplate">
template&lt;int Rows&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfrc_1_1UnscentedKalmanFilter.html">frc::UnscentedKalmanFilter</a>&lt; States, Inputs, Outputs &gt;::Correct </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Inputs, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Rows, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Eigen::Matrix&lt; double, Rows, 1 &gt;(const Eigen::Matrix&lt; double, States, 1 &gt; &amp;, const Eigen::Matrix&lt; double, Inputs, 1 &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Rows, Rows &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Correct the state estimate x-hat using the measurements in y. </p>
<p>This is useful for when the measurements available during a timestep's <a class="el" href="classfrc_1_1UnscentedKalmanFilter.html#af42b9c885ac152433abfc268014ff1f1" title="Correct the state estimate x-hat using the measurements in y.">Correct()</a> call vary. The h(x, u) passed to the constructor is used if one is not provided (the two-argument version of this function).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Same control input used in the predict step. </td></tr>
    <tr><td class="paramname">y</td><td>Measurement vector. </td></tr>
    <tr><td class="paramname">h</td><td>A vector-valued function of x and u that returns the measurement vector. </td></tr>
    <tr><td class="paramname">R</td><td>Measurement noise covariance matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c551bb9699ec614c9c90bce276ef2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c551bb9699ec614c9c90bce276ef2bb">&#9670;&nbsp;</a></span>Correct() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int States, int Inputs, int Outputs&gt; </div>
<div class="memtemplate">
template&lt;int Rows&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfrc_1_1UnscentedKalmanFilter.html">frc::UnscentedKalmanFilter</a>&lt; States, Inputs, Outputs &gt;::Correct </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Inputs, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Rows, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Eigen::Matrix&lt; double, Rows, 1 &gt;(const Eigen::Matrix&lt; double, States, 1 &gt; &amp;, const Eigen::Matrix&lt; double, Inputs, 1 &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Rows, Rows &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Eigen::Matrix&lt; double, Rows, 1 &gt;(const Eigen::Matrix&lt; double, Rows, 2 *States+1 &gt; &amp;, const Eigen::Matrix&lt; double, 2 *States+1, 1 &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>meanFuncY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Eigen::Matrix&lt; double, Rows, 1 &gt;(const Eigen::Matrix&lt; double, Rows, 1 &gt; &amp;, const Eigen::Matrix&lt; double, Rows, 1 &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>residualFuncY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Eigen::Matrix&lt; double, States, 1 &gt;(const Eigen::Matrix&lt; double, States, 1 &gt; &amp;, const Eigen::Matrix&lt; double, States, 1 &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>residualFuncX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Eigen::Matrix&lt; double, States, 1 &gt;(const Eigen::Matrix&lt; double, States, 1 &gt; &amp;, const Eigen::Matrix&lt; double, States, 1 &gt;)&gt;&#160;</td>
          <td class="paramname"><em>addFuncX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Correct the state estimate x-hat using the measurements in y. </p>
<p>This is useful for when the measurements available during a timestep's <a class="el" href="classfrc_1_1UnscentedKalmanFilter.html#af42b9c885ac152433abfc268014ff1f1" title="Correct the state estimate x-hat using the measurements in y.">Correct()</a> call vary. The h(x, u) passed to the constructor is used if one is not provided (the two-argument version of this function).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Same control input used in the predict step. </td></tr>
    <tr><td class="paramname">y</td><td>Measurement vector. </td></tr>
    <tr><td class="paramname">h</td><td>A vector-valued function of x and u that returns the measurement vector. </td></tr>
    <tr><td class="paramname">R</td><td>Measurement noise covariance matrix. </td></tr>
    <tr><td class="paramname">meanFuncY</td><td>A function that computes the mean of 2 * States + 1 measurement vectors using a given set of weights. </td></tr>
    <tr><td class="paramname">residualFuncY</td><td>A function that computes the residual of two measurement vectors (i.e. it subtracts them.) </td></tr>
    <tr><td class="paramname">residualFuncX</td><td>A function that computes the residual of two state vectors (i.e. it subtracts them.) </td></tr>
    <tr><td class="paramname">addFuncX</td><td>A function that adds two state vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5aabd4b8bdbf288c014995eced0e33fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aabd4b8bdbf288c014995eced0e33fa">&#9670;&nbsp;</a></span>P()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int States, int Inputs, int Outputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classfrc_1_1UnscentedKalmanFilter.html">frc::UnscentedKalmanFilter</a>&lt; States, Inputs, Outputs &gt;::P </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an element of the error covariance matrix P. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Row of P. </td></tr>
    <tr><td class="paramname">j</td><td>Column of P. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a6add97e52efdc06f74068c864493de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6add97e52efdc06f74068c864493de">&#9670;&nbsp;</a></span>Predict()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int States, int Inputs, int Outputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfrc_1_1UnscentedKalmanFilter.html">frc::UnscentedKalmanFilter</a>&lt; States, Inputs, Outputs &gt;::Predict </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Inputs, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">units::second_t&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Project the model into the future with a new control input u. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>New control input from controller. </td></tr>
    <tr><td class="paramname">dt</td><td>Timestep for prediction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83ee707e89f691ad5f5c995fb9f06787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ee707e89f691ad5f5c995fb9f06787">&#9670;&nbsp;</a></span>SetP()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int States, int Inputs, int Outputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfrc_1_1UnscentedKalmanFilter.html">frc::UnscentedKalmanFilter</a>&lt; States, Inputs, Outputs &gt;::SetP </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, States, States &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current error covariance matrix P. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>The error covariance matrix P. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adde6af1afe00eafc4539e04c220ef87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde6af1afe00eafc4539e04c220ef87d">&#9670;&nbsp;</a></span>SetXhat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int States, int Inputs, int Outputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfrc_1_1UnscentedKalmanFilter.html">frc::UnscentedKalmanFilter</a>&lt; States, Inputs, Outputs &gt;::SetXhat </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, States, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>xHat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set initial state estimate x-hat. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xHat</td><td>The state estimate x-hat. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2be5c5aaae45fb7c67c341e1ae2e700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2be5c5aaae45fb7c67c341e1ae2e700">&#9670;&nbsp;</a></span>SetXhat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int States, int Inputs, int Outputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfrc_1_1UnscentedKalmanFilter.html">frc::UnscentedKalmanFilter</a>&lt; States, Inputs, Outputs &gt;::SetXhat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an element of the initial state estimate x-hat. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Row of x-hat. </td></tr>
    <tr><td class="paramname">value</td><td>Value for element of x-hat. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b9eaaab42a142391a75d1472cd8ec12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9eaaab42a142391a75d1472cd8ec12">&#9670;&nbsp;</a></span>Xhat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int States, int Inputs, int Outputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classfrc_1_1UnscentedKalmanFilter.html">frc::UnscentedKalmanFilter</a>&lt; States, Inputs, Outputs &gt;::Xhat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an element of the state estimate x-hat. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Row of x-hat. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>frc/estimator/<a class="el" href="UnscentedKalmanFilter_8h_source.html">UnscentedKalmanFilter.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefrc.html">frc</a></li><li class="navelem"><a class="el" href="classfrc_1_1UnscentedKalmanFilter.html">UnscentedKalmanFilter</a></li>
    <li class="footer">Generated on Sat Mar 27 2021 04:24:22 for WPILibC++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
