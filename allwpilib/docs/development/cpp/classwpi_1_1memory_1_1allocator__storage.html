<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: wpi::memory::allocator_storage&lt; StoragePolicy, Mutex &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="wpilib-128.png"/></td>
  <td id="projectalign">
   <div id="projectname">WPILibC++<span id="projectnumber">&#160;2023.1.1-alpha-1-6-gdc037f8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classwpi_1_1memory_1_1allocator__storage.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classwpi_1_1memory_1_1allocator__storage-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">wpi::memory::allocator_storage&lt; StoragePolicy, Mutex &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="allocator__storage_8hpp_source.html">/home/runner/work/allwpilib/allwpilib/wpiutil/src/main/native/thirdparty/memory/include/wpi/memory/allocator_storage.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for wpi::memory::allocator_storage&lt; StoragePolicy, Mutex &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classwpi_1_1memory_1_1allocator__storage.png" usemap="#wpi::memory::allocator_5Fstorage_3C_20StoragePolicy_2C_20Mutex_20_3E_map" alt=""/>
  <map id="wpi::memory::allocator_5Fstorage_3C_20StoragePolicy_2C_20Mutex_20_3E_map" name="wpi::memory::allocator_5Fstorage_3C_20StoragePolicy_2C_20Mutex_20_3E_map">
<area href="classwpi_1_1memory_1_1detail_1_1mutex__storage.html" alt="wpi::memory::detail::mutex_storage&lt; detail::mutex_for&lt; StoragePolicy::allocator_type, Mutex &gt; &gt;" shape="rect" coords="561,0,1112,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a11769d266a994a538ca9c5442654195e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#a11769d266a994a538ca9c5442654195e">allocator_type</a> = typename StoragePolicy::allocator_type</td></tr>
<tr class="separator:a11769d266a994a538ca9c5442654195e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5b728ba80d27f6764e273705b99a82"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#afb5b728ba80d27f6764e273705b99a82">storage_policy</a> = StoragePolicy</td></tr>
<tr class="separator:afb5b728ba80d27f6764e273705b99a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a967ae28ed733c0f62d8c42c70ad7af"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#a9a967ae28ed733c0f62d8c42c70ad7af">mutex</a> = Mutex</td></tr>
<tr class="separator:a9a967ae28ed733c0f62d8c42c70ad7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c240dbcd096674f61f74c796d81221"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#ae9c240dbcd096674f61f74c796d81221">is_stateful</a> = typename <a class="el" href="classwpi_1_1memory_1_1allocator__traits.html#a07ccc9776ab2ec8dfb85f1994d229843">traits::is_stateful</a></td></tr>
<tr class="separator:ae9c240dbcd096674f61f74c796d81221"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a85d270d119d99a92cd4338dd4910ca59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#a85d270d119d99a92cd4338dd4910ca59">allocator_storage</a> ()=default</td></tr>
<tr class="memdesc:a85d270d119d99a92cd4338dd4910ca59"><td class="mdescLeft">&#160;</td><td class="mdescRight">\effects Creates it by default-constructing the <code>StoragePolicy</code>.  <a href="classwpi_1_1memory_1_1allocator__storage.html#a85d270d119d99a92cd4338dd4910ca59">More...</a><br /></td></tr>
<tr class="separator:a85d270d119d99a92cd4338dd4910ca59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df77aa513fbd87a98b30d4a3c70609c"><td class="memTemplParams" colspan="2">template&lt;class Alloc , <a class="el" href="utility_8hpp.html#aad2ce6c0f67a732899fa005db1fe2f78">WPI_REQUIRES</a>((!std::is_base_of&lt; <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a>, typename std::decay&lt; Alloc &gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a> &gt;<a class="el" href="classvalue.html">::value</a>)) &gt; </td></tr>
<tr class="memitem:a7df77aa513fbd87a98b30d4a3c70609c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#a7df77aa513fbd87a98b30d4a3c70609c">allocator_storage</a> (Alloc &amp;&amp;alloc, <a class="el" href="utility_8hpp.html#a29cf68453fbb7724a89ba52139f84188">WPI_SFINAE</a>(new <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#afb5b728ba80d27f6764e273705b99a82">storage_policy</a>(<a class="el" href="namespacewpi_1_1memory_1_1detail.html#a8994bf0a428d46893ae0472833726332">detail::forward</a>&lt; Alloc &gt;(alloc))))</td></tr>
<tr class="memdesc:a7df77aa513fbd87a98b30d4a3c70609c"><td class="mdescLeft">&#160;</td><td class="mdescRight">\effects Creates it by passing it an allocator.  <a href="classwpi_1_1memory_1_1allocator__storage.html#a7df77aa513fbd87a98b30d4a3c70609c">More...</a><br /></td></tr>
<tr class="separator:a7df77aa513fbd87a98b30d4a3c70609c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00c39d36cf7bd211d1bd3124aae353b"><td class="memTemplParams" colspan="2">template&lt;class OtherPolicy &gt; </td></tr>
<tr class="memitem:ae00c39d36cf7bd211d1bd3124aae353b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#ae00c39d36cf7bd211d1bd3124aae353b">allocator_storage</a> (const <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a>&lt; OtherPolicy, Mutex &gt; &amp;other, <a class="el" href="utility_8hpp.html#a29cf68453fbb7724a89ba52139f84188">WPI_SFINAE</a>(new <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#afb5b728ba80d27f6764e273705b99a82">storage_policy</a>(other.get_allocator())))</td></tr>
<tr class="memdesc:ae00c39d36cf7bd211d1bd3124aae353b"><td class="mdescLeft">&#160;</td><td class="mdescRight">\effects Creates it by passing it another <code><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a></code> with a different <code>StoragePolicy</code> but the same <code>Mutex</code> type.  <a href="classwpi_1_1memory_1_1allocator__storage.html#ae00c39d36cf7bd211d1bd3124aae353b">More...</a><br /></td></tr>
<tr class="separator:ae00c39d36cf7bd211d1bd3124aae353b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae925563a6e9e3f138c2c29128390ae5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#ae925563a6e9e3f138c2c29128390ae5e">is_composable</a> () const noexcept</td></tr>
<tr class="separator:ae925563a6e9e3f138c2c29128390ae5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a23ffe1cf586cce4bb13b235ec7047b4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#a23ffe1cf586cce4bb13b235ec7047b4e">allocator_storage</a> (<a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a23ffe1cf586cce4bb13b235ec7047b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ead5a4dc2c8890a4eeb0d592753879"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#a27ead5a4dc2c8890a4eeb0d592753879">operator=</a> (<a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a27ead5a4dc2c8890a4eeb0d592753879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acda2896ec6090ccef4bb08ff49322103"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#acda2896ec6090ccef4bb08ff49322103">allocator_storage</a> (const <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a> &amp;)=default</td></tr>
<tr class="separator:acda2896ec6090ccef4bb08ff49322103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9085fe8269c2c762c91134f78080a91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#aa9085fe8269c2c762c91134f78080a91">operator=</a> (const <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a> &amp;)=default</td></tr>
<tr class="separator:aa9085fe8269c2c762c91134f78080a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0f9f66fff14fbc7a7ea167eb6cf6f00e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#a0f9f66fff14fbc7a7ea167eb6cf6f00e">allocate_node</a> (std::size_t size, std::size_t alignment)</td></tr>
<tr class="separator:a0f9f66fff14fbc7a7ea167eb6cf6f00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5cd1aa0ec5aed7b7f869d7fc864e6b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#a4d5cd1aa0ec5aed7b7f869d7fc864e6b">allocate_array</a> (std::size_t <a class="el" href="core_8h.html#a66b93840aa6a29b3802202f99668f78a">count</a>, std::size_t size, std::size_t alignment)</td></tr>
<tr class="separator:a4d5cd1aa0ec5aed7b7f869d7fc864e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af730b7bd452a58ea66eab5b06030a520"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#af730b7bd452a58ea66eab5b06030a520">deallocate_node</a> (void *<a class="el" href="format_8h.html#aa6ec2d4315570f27d9637ce3c770e787">ptr</a>, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:af730b7bd452a58ea66eab5b06030a520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ece6abc9f51bbfbf8d6b6bf432e7bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#a29ece6abc9f51bbfbf8d6b6bf432e7bc">deallocate_array</a> (void *<a class="el" href="format_8h.html#aa6ec2d4315570f27d9637ce3c770e787">ptr</a>, std::size_t <a class="el" href="core_8h.html#a66b93840aa6a29b3802202f99668f78a">count</a>, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:a29ece6abc9f51bbfbf8d6b6bf432e7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10766cf269778756a13b2fc14b5ff74d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#a10766cf269778756a13b2fc14b5ff74d">max_node_size</a> () const</td></tr>
<tr class="separator:a10766cf269778756a13b2fc14b5ff74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d66396aa6e3c020c3aa951bc499025"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#a27d66396aa6e3c020c3aa951bc499025">max_array_size</a> () const</td></tr>
<tr class="separator:a27d66396aa6e3c020c3aa951bc499025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c40e417a6279630216b191b8671220"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#a21c40e417a6279630216b191b8671220">max_alignment</a> () const</td></tr>
<tr class="separator:a21c40e417a6279630216b191b8671220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afd90ebe98b35c6f2d7b3d651307c6de0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#afd90ebe98b35c6f2d7b3d651307c6de0">try_allocate_node</a> (std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:afd90ebe98b35c6f2d7b3d651307c6de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a29b16703b975735aa9534535054d3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#a83a29b16703b975735aa9534535054d3">try_allocate_array</a> (std::size_t <a class="el" href="core_8h.html#a66b93840aa6a29b3802202f99668f78a">count</a>, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:a83a29b16703b975735aa9534535054d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669e18e19f582bd5d1384de888d70627"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#a669e18e19f582bd5d1384de888d70627">try_deallocate_node</a> (void *<a class="el" href="format_8h.html#aa6ec2d4315570f27d9637ce3c770e787">ptr</a>, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:a669e18e19f582bd5d1384de888d70627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e0882c8085673d806d01b2db853529"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#ad9e0882c8085673d806d01b2db853529">try_deallocate_array</a> (void *<a class="el" href="format_8h.html#aa6ec2d4315570f27d9637ce3c770e787">ptr</a>, std::size_t <a class="el" href="core_8h.html#a66b93840aa6a29b3802202f99668f78a">count</a>, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:ad9e0882c8085673d806d01b2db853529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a296607a4281dbe57c44271de29dda5fa"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#a296607a4281dbe57c44271de29dda5fa">get_allocator</a> () noexcept -&gt; decltype(std::declval&lt; <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#afb5b728ba80d27f6764e273705b99a82">storage_policy</a> &gt;().get_allocator())</td></tr>
<tr class="separator:a296607a4281dbe57c44271de29dda5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89305ac2d24e5acb00b829854eef48f3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#a89305ac2d24e5acb00b829854eef48f3">get_allocator</a> () const noexcept -&gt; decltype(std::declval&lt; const <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#afb5b728ba80d27f6764e273705b99a82">storage_policy</a> &gt;().get_allocator())</td></tr>
<tr class="separator:a89305ac2d24e5acb00b829854eef48f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a49ecd02cc39c71256de4d5199f3b931c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#a49ecd02cc39c71256de4d5199f3b931c">lock</a> () noexcept -&gt; <a class="el" href="config_8hpp.html#ad9ce7c7a9b4f995a3af52e594bc43e8d">WPI_IMPL_DEFINED</a>(decltype(<a class="el" href="namespacewpi_1_1memory_1_1detail.html#a746cb12c01973c8e0b361184fd3d23b8">detail::lock_allocator</a>(std::declval&lt; <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#afb5b728ba80d27f6764e273705b99a82">storage_policy</a> &gt;().<a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#a296607a4281dbe57c44271de29dda5fa">get_allocator</a>(), std::declval&lt; <a class="el" href="classwpi_1_1memory_1_1detail_1_1mutex__storage.html">actual_mutex</a> &amp; &gt;())))</td></tr>
<tr class="separator:a49ecd02cc39c71256de4d5199f3b931c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae267ee0667becd977a10a663b56dfb23"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#ae267ee0667becd977a10a663b56dfb23">lock</a> () const noexcept -&gt; <a class="el" href="config_8hpp.html#ad9ce7c7a9b4f995a3af52e594bc43e8d">WPI_IMPL_DEFINED</a>(decltype(<a class="el" href="namespacewpi_1_1memory_1_1detail.html#a746cb12c01973c8e0b361184fd3d23b8">detail::lock_allocator</a>(std::declval&lt; const <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#afb5b728ba80d27f6764e273705b99a82">storage_policy</a> &gt;().<a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#a296607a4281dbe57c44271de29dda5fa">get_allocator</a>(), std::declval&lt; <a class="el" href="classwpi_1_1memory_1_1detail_1_1mutex__storage.html">actual_mutex</a> &amp; &gt;())))</td></tr>
<tr class="separator:ae267ee0667becd977a10a663b56dfb23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a11769d266a994a538ca9c5442654195e" name="a11769d266a994a538ca9c5442654195e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11769d266a994a538ca9c5442654195e">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::allocator_type =  typename StoragePolicy::allocator_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9c240dbcd096674f61f74c796d81221" name="ae9c240dbcd096674f61f74c796d81221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c240dbcd096674f61f74c796d81221">&#9670;&nbsp;</a></span>is_stateful</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::is_stateful =  typename <a class="el" href="classwpi_1_1memory_1_1allocator__traits.html#a07ccc9776ab2ec8dfb85f1994d229843">traits::is_stateful</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a967ae28ed733c0f62d8c42c70ad7af" name="a9a967ae28ed733c0f62d8c42c70ad7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a967ae28ed733c0f62d8c42c70ad7af">&#9670;&nbsp;</a></span>mutex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::mutex =  Mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb5b728ba80d27f6764e273705b99a82" name="afb5b728ba80d27f6764e273705b99a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5b728ba80d27f6764e273705b99a82">&#9670;&nbsp;</a></span>storage_policy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::storage_policy =  StoragePolicy</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a85d270d119d99a92cd4338dd4910ca59" name="a85d270d119d99a92cd4338dd4910ca59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d270d119d99a92cd4338dd4910ca59">&#9670;&nbsp;</a></span>allocator_storage() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::allocator_storage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\effects Creates it by default-constructing the <code>StoragePolicy</code>. </p>
<p >\requires The <code>StoragePolicy</code> must be default-constructible. \notes The default constructor may create an invalid allocator storage not associated with any allocator. If that is the case, it must not be used. </p>

</div>
</div>
<a id="a7df77aa513fbd87a98b30d4a3c70609c" name="a7df77aa513fbd87a98b30d4a3c70609c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df77aa513fbd87a98b30d4a3c70609c">&#9670;&nbsp;</a></span>allocator_storage() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
<div class="memtemplate">
template&lt;class Alloc , <a class="el" href="utility_8hpp.html#aad2ce6c0f67a732899fa005db1fe2f78">WPI_REQUIRES</a>((!std::is_base_of&lt; <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a>, typename std::decay&lt; Alloc &gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a> &gt;<a class="el" href="classvalue.html">::value</a>)) &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::allocator_storage </td>
          <td>(</td>
          <td class="paramtype">Alloc &amp;&amp;&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utility_8hpp.html#a29cf68453fbb7724a89ba52139f84188">WPI_SFINAE</a>(new <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#afb5b728ba80d27f6764e273705b99a82">storage_policy</a>(<a class="el" href="namespacewpi_1_1memory_1_1detail.html#a8994bf0a428d46893ae0472833726332">detail::forward</a>&lt; Alloc &gt;(alloc)))&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\effects Creates it by passing it an allocator. </p>
<p >The allocator will be forwarded to the <code>StoragePolicy</code>, it decides whether it will be moved, its address stored or something else. \requires The expression <code>new storage_policy(std::forward&lt;Alloc&gt;(alloc))</code> must be well-formed, otherwise this constructor does not participate in overload resolution. </p>

</div>
</div>
<a id="ae00c39d36cf7bd211d1bd3124aae353b" name="ae00c39d36cf7bd211d1bd3124aae353b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00c39d36cf7bd211d1bd3124aae353b">&#9670;&nbsp;</a></span>allocator_storage() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
<div class="memtemplate">
template&lt;class OtherPolicy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::allocator_storage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a>&lt; OtherPolicy, Mutex &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utility_8hpp.html#a29cf68453fbb7724a89ba52139f84188">WPI_SFINAE</a>(new <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#afb5b728ba80d27f6764e273705b99a82">storage_policy</a>(other.get_allocator()))&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>\effects Creates it by passing it another <code><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a></code> with a different <code>StoragePolicy</code> but the same <code>Mutex</code> type. </p>
<p >Initializes it with the result of <code>other.get_allocator()</code>. \requires The expression <code>new storage_policy(other.get_allocator())</code> must be well-formed, otherwise this constructor does not participate in overload resolution. </p>

</div>
</div>
<a id="a23ffe1cf586cce4bb13b235ec7047b4e" name="a23ffe1cf586cce4bb13b235ec7047b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ffe1cf586cce4bb13b235ec7047b4e">&#9670;&nbsp;</a></span>allocator_storage() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::allocator_storage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a>&lt; StoragePolicy, Mutex &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >\effects Moves the <code><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a></code> object. A moved-out <code><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a></code> object must still store a valid allocator object. </p>

</div>
</div>
<a id="acda2896ec6090ccef4bb08ff49322103" name="acda2896ec6090ccef4bb08ff49322103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda2896ec6090ccef4bb08ff49322103">&#9670;&nbsp;</a></span>allocator_storage() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::allocator_storage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a>&lt; StoragePolicy, Mutex &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >\effects Copies the <code><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a></code> object. \requires The <code>StoragePolicy</code> must be copyable. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4d5cd1aa0ec5aed7b7f869d7fc864e6b" name="a4d5cd1aa0ec5aed7b7f869d7fc864e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5cd1aa0ec5aed7b7f869d7fc864e6b">&#9670;&nbsp;</a></span>allocate_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::allocate_array </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f9f66fff14fbc7a7ea167eb6cf6f00e" name="a0f9f66fff14fbc7a7ea167eb6cf6f00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9f66fff14fbc7a7ea167eb6cf6f00e">&#9670;&nbsp;</a></span>allocate_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::allocate_node </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >\effects Calls the function on the stored allocator. The <code>Mutex</code> will be locked during the operation. </p>

</div>
</div>
<a id="a29ece6abc9f51bbfbf8d6b6bf432e7bc" name="a29ece6abc9f51bbfbf8d6b6bf432e7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ece6abc9f51bbfbf8d6b6bf432e7bc">&#9670;&nbsp;</a></span>deallocate_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::deallocate_array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af730b7bd452a58ea66eab5b06030a520" name="af730b7bd452a58ea66eab5b06030a520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af730b7bd452a58ea66eab5b06030a520">&#9670;&nbsp;</a></span>deallocate_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::deallocate_node </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a89305ac2d24e5acb00b829854eef48f3" name="a89305ac2d24e5acb00b829854eef48f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89305ac2d24e5acb00b829854eef48f3">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; decltype(std::declval&lt;const <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#afb5b728ba80d27f6764e273705b99a82">storage_policy</a>&gt;().get_allocator())
            </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a296607a4281dbe57c44271de29dda5fa" name="a296607a4281dbe57c44271de29dda5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296607a4281dbe57c44271de29dda5fa">&#9670;&nbsp;</a></span>get_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; decltype(std::declval&lt;<a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#afb5b728ba80d27f6764e273705b99a82">storage_policy</a>&gt;().get_allocator())
            </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >\effects Forwards to the <code>StoragePolicy</code>. </p><dl class="section return"><dt>Returns</dt><dd>Returns a reference to the stored allocator. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This does not lock the <code>Mutex</code>. </dd></dl>

</div>
</div>
<a id="ae925563a6e9e3f138c2c29128390ae5e" name="ae925563a6e9e3f138c2c29128390ae5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae925563a6e9e3f138c2c29128390ae5e">&#9670;&nbsp;</a></span>is_composable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::is_composable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether or not the stored allocator is composable, that is you can use the compositioning functions. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Due to type-erased allocators, this function can not be <code>constexpr</code>. </dd></dl>

</div>
</div>
<a id="ae267ee0667becd977a10a663b56dfb23" name="ae267ee0667becd977a10a663b56dfb23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae267ee0667becd977a10a663b56dfb23">&#9670;&nbsp;</a></span>lock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="config_8hpp.html#ad9ce7c7a9b4f995a3af52e594bc43e8d">WPI_IMPL_DEFINED</a>(decltype(
                <a class="el" href="namespacewpi_1_1memory_1_1detail.html#a746cb12c01973c8e0b361184fd3d23b8">detail::lock_allocator</a>(std::declval&lt;const <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#afb5b728ba80d27f6764e273705b99a82">storage_policy</a>&gt;().<a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#a296607a4281dbe57c44271de29dda5fa">get_allocator</a>(),
                                       std::declval&lt;<a class="el" href="classwpi_1_1memory_1_1detail_1_1mutex__storage.html">actual_mutex</a>&amp;&gt;())))
            </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a49ecd02cc39c71256de4d5199f3b931c" name="a49ecd02cc39c71256de4d5199f3b931c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ecd02cc39c71256de4d5199f3b931c">&#9670;&nbsp;</a></span>lock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="config_8hpp.html#ad9ce7c7a9b4f995a3af52e594bc43e8d">WPI_IMPL_DEFINED</a>(decltype(<a class="el" href="namespacewpi_1_1memory_1_1detail.html#a746cb12c01973c8e0b361184fd3d23b8">detail::lock_allocator</a>(
                std::declval&lt;<a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#afb5b728ba80d27f6764e273705b99a82">storage_policy</a>&gt;().<a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#a296607a4281dbe57c44271de29dda5fa">get_allocator</a>(), std::declval&lt;<a class="el" href="classwpi_1_1memory_1_1detail_1_1mutex__storage.html">actual_mutex</a>&amp;&gt;())))
            </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A proxy object that acts like a pointer to the stored allocator. It cannot be reassigned to point to another allocator object and only moving is supported, which is destructive. As long as the proxy object lives and is not moved from, the <code>Mutex</code> will be kept locked. </dd></dl>

</div>
</div>
<a id="a21c40e417a6279630216b191b8671220" name="a21c40e417a6279630216b191b8671220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c40e417a6279630216b191b8671220">&#9670;&nbsp;</a></span>max_alignment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::max_alignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a27d66396aa6e3c020c3aa951bc499025" name="a27d66396aa6e3c020c3aa951bc499025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d66396aa6e3c020c3aa951bc499025">&#9670;&nbsp;</a></span>max_array_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::max_array_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a10766cf269778756a13b2fc14b5ff74d" name="a10766cf269778756a13b2fc14b5ff74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10766cf269778756a13b2fc14b5ff74d">&#9670;&nbsp;</a></span>max_node_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::max_node_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a27ead5a4dc2c8890a4eeb0d592753879" name="a27ead5a4dc2c8890a4eeb0d592753879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ead5a4dc2c8890a4eeb0d592753879">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a> &amp; <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a>&lt; StoragePolicy, Mutex &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9085fe8269c2c762c91134f78080a91" name="aa9085fe8269c2c762c91134f78080a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9085fe8269c2c762c91134f78080a91">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a> &amp; <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a>&lt; StoragePolicy, Mutex &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a83a29b16703b975735aa9534535054d3" name="a83a29b16703b975735aa9534535054d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a29b16703b975735aa9534535054d3">&#9670;&nbsp;</a></span>try_allocate_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::try_allocate_array </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd90ebe98b35c6f2d7b3d651307c6de0" name="afd90ebe98b35c6f2d7b3d651307c6de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd90ebe98b35c6f2d7b3d651307c6de0">&#9670;&nbsp;</a></span>try_allocate_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::try_allocate_node </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >\effects Calls the function on the stored composable allocator. The <code>Mutex</code> will be locked during the operation. \requires The allocator must be composable, i.e. <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html#ae925563a6e9e3f138c2c29128390ae5e">is_composable()</a> must return <code>true</code>. </p><dl class="section note"><dt>Note</dt><dd>This check is done at compile-time where possible, and at runtime in the case of type-erased storage. </dd></dl>

</div>
</div>
<a id="ad9e0882c8085673d806d01b2db853529" name="ad9e0882c8085673d806d01b2db853529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e0882c8085673d806d01b2db853529">&#9670;&nbsp;</a></span>try_deallocate_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::try_deallocate_array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a669e18e19f582bd5d1384de888d70627" name="a669e18e19f582bd5d1384de888d70627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669e18e19f582bd5d1384de888d70627">&#9670;&nbsp;</a></span>try_deallocate_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy , class Mutex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">wpi::memory::allocator_storage</a>&lt; StoragePolicy, Mutex &gt;::try_deallocate_node </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/allwpilib/allwpilib/wpiutil/src/main/native/thirdparty/memory/include/wpi/memory/<a class="el" href="allocator__storage_8hpp_source.html">allocator_storage.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacewpi.html">wpi</a></li><li class="navelem"><a class="el" href="namespacewpi_1_1memory.html">memory</a></li><li class="navelem"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a></li>
    <li class="footer">Generated on Fri Oct 21 2022 00:29:22 for WPILibC++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
