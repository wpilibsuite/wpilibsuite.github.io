<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: wpi::memory Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="wpilib-128.png"/></td>
  <td id="projectalign">
   <div id="projectname">WPILibC++<span id="projectnumber">&#160;2023.0.0-alpha-1-132-g3b81cf6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacewpi_1_1memory.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">wpi::memory Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Memory namespace.  
<a href="namespacewpi_1_1memory.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacewpi_1_1memory_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacewpi_1_1memory_1_1literals"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory_1_1literals.html">literals</a></td></tr>
<tr class="memdesc:namespacewpi_1_1memory_1_1literals"><td class="mdescLeft">&#160;</td><td class="mdescRight">Literals namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacewpi_1_1memory_1_1traits__detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory_1_1traits__detail.html">traits_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1aligned__allocator.html">aligned_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__deallocator.html">allocator_deallocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__deallocator_3_01_type_0f_0e_00_01_raw_allocator_01_4.html">allocator_deallocator&lt; Type[], RawAllocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classwpi_1_1memory_1_1allocator__deallocator.html">allocator_deallocator</a> for array types.  <a href="classwpi_1_1memory_1_1allocator__deallocator_3_01_type_0f_0e_00_01_raw_allocator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__deleter.html">allocator_deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classwpi_1_1memory_1_1allocator__deallocator.html">allocator_deallocator</a> but calls the destructors of the object.  <a href="classwpi_1_1memory_1_1allocator__deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__deleter_3_01_type_0f_0e_00_01_raw_allocator_01_4.html">allocator_deleter&lt; Type[], RawAllocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classwpi_1_1memory_1_1allocator__deleter.html">allocator_deleter</a> for array types.  <a href="classwpi_1_1memory_1_1allocator__deleter_3_01_type_0f_0e_00_01_raw_allocator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1allocator__info.html">allocator_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains information about an allocator.  <a href="structwpi_1_1memory_1_1allocator__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1allocator__is__raw__allocator.html">allocator_is_raw_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1allocator__is__raw__allocator_3_01std_1_1allocator_3_01_t_01_4_01_4.html">allocator_is_raw_allocator&lt; std::allocator&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structwpi_1_1memory_1_1allocator__is__raw__allocator.html">allocator_is_raw_allocator</a> that allows <code>std::allocator</code> again.  <a href="structwpi_1_1memory_1_1allocator__is__raw__allocator_3_01std_1_1allocator_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__polymorphic__deallocator.html">allocator_polymorphic_deallocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__polymorphic__deleter.html">allocator_polymorphic_deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classwpi_1_1memory_1_1allocator__polymorphic__deallocator.html">allocator_polymorphic_deallocator</a> but calls the destructors of the object.  <a href="classwpi_1_1memory_1_1allocator__polymorphic__deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__traits.html">allocator_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__traits_3_01iteration__allocator_3_01_n_00_01_block_allocator_01_4_01_4.html">allocator_traits&lt; iteration_allocator&lt; N, BlockAllocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the allocator_traits for <a class="el" href="classwpi_1_1memory_1_1iteration__allocator.html">iteration_allocator</a>.  <a href="classwpi_1_1memory_1_1allocator__traits_3_01iteration__allocator_3_01_n_00_01_block_allocator_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__traits_3_01memory__pool_3_01_pool_type_00_01_impl_raw_allocator_01_4_01_4.html">allocator_traits&lt; memory_pool&lt; PoolType, ImplRawAllocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the allocator_traits for <a class="el" href="classwpi_1_1memory_1_1memory__pool.html">memory_pool</a> classes.  <a href="classwpi_1_1memory_1_1allocator__traits_3_01memory__pool_3_01_pool_type_00_01_impl_raw_allocator_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__traits_3_01memory__pool__collection_3_01_pool_00_01_bucket_dist_00_01_raw_allocator_01_4_01_4.html">allocator_traits&lt; memory_pool_collection&lt; Pool, BucketDist, RawAllocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the allocator_traits for <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a> classes.  <a href="classwpi_1_1memory_1_1allocator__traits_3_01memory__pool__collection_3_01_pool_00_01_bucket_dist_00_01_raw_allocator_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__traits_3_01memory__stack_3_01_block_allocator_01_4_01_4.html">allocator_traits&lt; memory_stack&lt; BlockAllocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the allocator_traits for <a class="el" href="classwpi_1_1memory_1_1memory__stack.html">memory_stack</a> classes.  <a href="classwpi_1_1memory_1_1allocator__traits_3_01memory__stack_3_01_block_allocator_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__traits_3_01temporary__allocator_01_4.html">allocator_traits&lt; temporary_allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the allocator_traits for <a class="el" href="classwpi_1_1memory_1_1temporary__allocator.html">temporary_allocator</a> classes.  <a href="classwpi_1_1memory_1_1allocator__traits_3_01temporary__allocator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1any__allocator.html">any_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type that enables type-erasure in <a class="el" href="classwpi_1_1memory_1_1reference__storage.html">reference_storage</a>.  <a href="structwpi_1_1memory_1_1any__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1array__pool.html">array_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type defining a memory pool optimized for arrays.  <a href="structwpi_1_1memory_1_1array__pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1bad__alignment.html">bad_alignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when the alignment exceeds the supported maximum, i.e.  <a href="classwpi_1_1memory_1_1bad__alignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1bad__allocation__size.html">bad_allocation_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when an allocation size is bigger than the supported maximum.  <a href="classwpi_1_1memory_1_1bad__allocation__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1bad__array__size.html">bad_array_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when the array size exceeds the supported maximum, i.e.  <a href="classwpi_1_1memory_1_1bad__array__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1bad__node__size.html">bad_node_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when the node size exceeds the supported maximum, i.e.  <a href="classwpi_1_1memory_1_1bad__node__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1composable__allocator__traits.html">composable_allocator_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1composable__allocator__traits_3_01iteration__allocator_3_01_n_00_01_block_allocator_01_4_01_4.html">composable_allocator_traits&lt; iteration_allocator&lt; N, BlockAllocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="classwpi_1_1memory_1_1composable__allocator__traits.html">composable_allocator_traits</a> for <a class="el" href="classwpi_1_1memory_1_1iteration__allocator.html">iteration_allocator</a> classes.  <a href="classwpi_1_1memory_1_1composable__allocator__traits_3_01iteration__allocator_3_01_n_00_01_block_allocator_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1composable__allocator__traits_3_01memory__pool_3_01_pool_type_00_01_block_or_raw_allocator_01_4_01_4.html">composable_allocator_traits&lt; memory_pool&lt; PoolType, BlockOrRawAllocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="classwpi_1_1memory_1_1composable__allocator__traits.html">composable_allocator_traits</a> for <a class="el" href="classwpi_1_1memory_1_1memory__pool.html">memory_pool</a> classes.  <a href="classwpi_1_1memory_1_1composable__allocator__traits_3_01memory__pool_3_01_pool_type_00_01_block_or_raw_allocator_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1composable__allocator__traits_3_01memory__pool__collection_3_01_pool_00_01cb002dcf07085c1d53352faa4ab48c7f.html">composable_allocator_traits&lt; memory_pool_collection&lt; Pool, BucketDist, RawAllocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="classwpi_1_1memory_1_1composable__allocator__traits.html">composable_allocator_traits</a> for <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a> classes.  <a href="classwpi_1_1memory_1_1composable__allocator__traits_3_01memory__pool__collection_3_01_pool_00_01cb002dcf07085c1d53352faa4ab48c7f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1composable__allocator__traits_3_01memory__stack_3_01_block_allocator_01_4_01_4.html">composable_allocator_traits&lt; memory_stack&lt; BlockAllocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="classwpi_1_1memory_1_1composable__allocator__traits.html">composable_allocator_traits</a> for <a class="el" href="classwpi_1_1memory_1_1memory__stack.html">memory_stack</a> classes.  <a href="classwpi_1_1memory_1_1composable__allocator__traits_3_01memory__stack_3_01_block_allocator_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1direct__storage.html">direct_storage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1fallback__allocator.html">fallback_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1fixed__block__allocator.html">fixed_block_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1growing__block__allocator.html">growing_block_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1identity__buckets.html">identity_buckets</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>BucketDistribution</code> for <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a> defining that there is a bucket, i.e.  <a href="structwpi_1_1memory_1_1identity__buckets.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1is__block__allocator.html">is_block_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1is__composable__allocator.html">is_composable_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1is__raw__allocator.html">is_raw_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1is__shared__allocator.html">is_shared_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1is__shared__allocator_3_01joint__allocator_01_4.html">is_shared_allocator&lt; joint_allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structwpi_1_1memory_1_1is__shared__allocator.html">is_shared_allocator</a> to mark <a class="el" href="classwpi_1_1memory_1_1joint__allocator.html">joint_allocator</a> as shared.  <a href="structwpi_1_1memory_1_1is__shared__allocator_3_01joint__allocator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1is__shared__allocator_3_01memory__resource__allocator_01_4.html">is_shared_allocator&lt; memory_resource_allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structwpi_1_1memory_1_1is__shared__allocator.html">is_shared_allocator</a> to mark <a class="el" href="classwpi_1_1memory_1_1memory__resource__allocator.html">memory_resource_allocator</a> as shared.  <a href="structwpi_1_1memory_1_1is__shared__allocator_3_01memory__resource__allocator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1is__thread__safe__allocator.html">is_thread_safe_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1is__thread__safe__allocator_3_01joint__allocator_01_4.html">is_thread_safe_allocator&lt; joint_allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structwpi_1_1memory_1_1is__thread__safe__allocator.html">is_thread_safe_allocator</a> to mark <a class="el" href="classwpi_1_1memory_1_1joint__allocator.html">joint_allocator</a> as thread safe.  <a href="structwpi_1_1memory_1_1is__thread__safe__allocator_3_01joint__allocator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1iteration__allocator.html">iteration_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1joint.html">joint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type that can't be created.  <a href="classwpi_1_1memory_1_1joint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1joint__allocator.html">joint_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1joint__array.html">joint_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A zero overhead dynamic array using joint memory.  <a href="classwpi_1_1memory_1_1joint__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1joint__size.html">joint_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type to make the joint size more explicit.  <a href="structwpi_1_1memory_1_1joint__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1joint__type.html">joint_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP base class for all objects that want to use joint memory.  <a href="classwpi_1_1memory_1_1joint__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1log2__buckets.html">log2_buckets</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>BucketDistribution</code> for <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a> defining that there is a bucket, i.e.  <a href="structwpi_1_1memory_1_1log2__buckets.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1memory__arena.html">memory_arena</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1memory__block.html">memory_block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory block.  <a href="structwpi_1_1memory_1_1memory__block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1memory__pool.html">memory_pool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1memory__resource__adapter.html">memory_resource_adapter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1memory__resource__allocator.html">memory_resource_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1memory__stack.html">memory_stack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1memory__stack__raii__unwind.html">memory_stack_raii_unwind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple utility that automatically unwinds a <code>Stack</code> to a previously saved location.  <a href="classwpi_1_1memory_1_1memory__stack__raii__unwind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1no__mutex.html">no_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dummy <code>Mutex</code> class that does not lock anything.  <a href="structwpi_1_1memory_1_1no__mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1node__pool.html">node_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type defining a memory pool optimized for nodes.  <a href="structwpi_1_1memory_1_1node__pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1null__allocator.html">null_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1out__of__fixed__memory.html">out_of_fixed_memory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special case of <a class="el" href="classwpi_1_1memory_1_1out__of__memory.html">out_of_memory</a> errors thrown when a low-level allocator with a fixed size runs out of memory.  <a href="classwpi_1_1memory_1_1out__of__fixed__memory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1out__of__memory.html">out_of_memory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when a low level allocator runs out of memory.  <a href="classwpi_1_1memory_1_1out__of__memory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1propagation__traits.html">propagation_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1propagation__traits_3_01joint__allocator_01_4.html">propagation_traits&lt; joint_allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="structwpi_1_1memory_1_1propagation__traits.html">propagation_traits</a> for the <a class="el" href="classwpi_1_1memory_1_1joint__allocator.html">joint_allocator</a>.  <a href="structwpi_1_1memory_1_1propagation__traits_3_01joint__allocator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1reference__storage.html">reference_storage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1reference__storage_3_01any__allocator_01_4.html">reference_storage&lt; any_allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the class template <a class="el" href="classwpi_1_1memory_1_1reference__storage.html">reference_storage</a> that is type-erased.  <a href="classwpi_1_1memory_1_1reference__storage_3_01any__allocator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1segregator__size.html">segregator_size</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1small__node__pool.html">small_node_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type defining a memory pool optimized for small nodes.  <a href="structwpi_1_1memory_1_1small__node__pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1static__allocator.html">static_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1static__allocator__storage.html">static_allocator_storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for a <a class="el" href="classwpi_1_1memory_1_1static__allocator.html">static_allocator</a>.  <a href="structwpi_1_1memory_1_1static__allocator__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1static__block__allocator.html">static_block_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1temporary__allocator.html">temporary_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1temporary__stack.html">temporary_stack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around the <a class="el" href="classwpi_1_1memory_1_1memory__stack.html">memory_stack</a> that is used by the <a class="el" href="classwpi_1_1memory_1_1temporary__allocator.html">temporary_allocator</a>.  <a href="classwpi_1_1memory_1_1temporary__stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1temporary__stack__initializer.html">temporary_stack_initializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually takes care of the lifetime of the per-thread <a class="el" href="classwpi_1_1memory_1_1temporary__stack.html">temporary_stack</a>.  <a href="classwpi_1_1memory_1_1temporary__stack__initializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1threshold__segregatable.html">threshold_segregatable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1tracked__allocator.html">tracked_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1tracked__block__allocator.html">tracked_block_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1virtual__block__allocator.html">virtual_block_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1virtual__memory__allocator.html">virtual_memory_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1.html"></a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>std::unique_ptr</code> that deletes using a. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1and.html">and</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>std::unique_ptr</code> that deletes using a allows polymorphic types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1for.html">for</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code>std::unique_ptr</code> using a the allocation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1that.html">that</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stateless allocates memory using the virtual memory allocation functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1or.html">or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes either a a. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1as.html">as</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1of.html">of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">fixed size. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1in.html">in</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">memory arenas. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1is.html">is</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether or not a thread safe as-is. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1adapter.html">adapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A that tracks another allocator using a. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1uses.html">uses</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">deeply_tracked_block_allocator as <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1to.html">to</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tracked_allocator that has rebound any the corresponding deeply_tracked_block_allocator. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1allocations.html">allocations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">in any order but with a predefined set of sizes, not only one size like memory_pool. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1br.html">br</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits that check whether a type models concept&gt; It must either provide the necessary functions for the default traits specialization or has specialized it. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1defines.html">defines</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the allocator type being stored and how it is stored. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1the.html">the</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias template for allocator_storage using the direct_storage policy without a mutex. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1has.html">has</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether or not a shared semantics. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1with.html">with</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A a fallback. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1_it.html">It</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template for an STL container that uses a certain is just a shorthand for a passing in the <code>RawAllocator</code> wrapped in a <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">wpi::memory::std_allocator</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1returns.html">returns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1a.html">a</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of segregator has. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af0f1bb450799856d89c262c855060ec8"><td class="memTemplParams" colspan="2">template&lt;class BlockOrRawAllocator , template&lt; typename... &gt; class BlockAllocator = detail::default_block_wrapper&gt; </td></tr>
<tr class="memitem:af0f1bb450799856d89c262c855060ec8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#af0f1bb450799856d89c262c855060ec8">make_block_allocator_t</a> = <a class="el" href="config_8hpp.html#ad9ce7c7a9b4f995a3af52e594bc43e8d">WPI_IMPL_DEFINED</a>(typename std::conditional&lt; <a class="el" href="structwpi_1_1memory_1_1is__block__allocator.html">is_block_allocator</a>&lt; BlockOrRawAllocator &gt;<a class="el" href="classvalue.html">::value</a>, BlockOrRawAllocator, BlockAllocator&lt; BlockOrRawAllocator &gt; &gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a>)</td></tr>
<tr class="separator:af0f1bb450799856d89c262c855060ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0325b003d5eeefc8f020b296a8b581af"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a0325b003d5eeefc8f020b296a8b581af">default_allocator</a> = <a class="el" href="config_8hpp.html#ad9ce7c7a9b4f995a3af52e594bc43e8d">WPI_IMPL_DEFINED</a>(<a class="el" href="config__impl_8hpp.html#ac4852d047c9c0379a72f743d8f55526a">WPI_MEMORY_IMPL_DEFAULT_ALLOCATOR</a>)</td></tr>
<tr class="separator:a0325b003d5eeefc8f020b296a8b581af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4b33e608d367597cf4f0a0e525999a7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">leak_handler</a> = void(*)(const <a class="el" href="structwpi_1_1memory_1_1allocator__info.html">allocator_info</a> &amp;info, std::ptrdiff_t amount)</td></tr>
<tr class="memdesc:gaa4b33e608d367597cf4f0a0e525999a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the handler called when a memory leak is detected.  <a href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">More...</a><br /></td></tr>
<tr class="separator:gaa4b33e608d367597cf4f0a0e525999a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cab10357dccef1206a767c56cbbecb4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">invalid_pointer_handler</a> = void(*)(const <a class="el" href="structwpi_1_1memory_1_1allocator__info.html">allocator_info</a> &amp;info, const void *<a class="el" href="format_8h.html#aa6ec2d4315570f27d9637ce3c770e787">ptr</a>)</td></tr>
<tr class="memdesc:ga5cab10357dccef1206a767c56cbbecb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the handler called when an invalid pointer is passed to a deallocation function.  <a href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">More...</a><br /></td></tr>
<tr class="separator:ga5cab10357dccef1206a767c56cbbecb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2838b189f63bb9505d4ec3ae9d572ee6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">buffer_overflow_handler</a> = void(*)(const void *memory, std::size_t size, const void *<a class="el" href="format_8h.html#ab76a36e5b99a884b810fbd30211dd228">write_ptr</a>)</td></tr>
<tr class="memdesc:ga2838b189f63bb9505d4ec3ae9d572ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the handler called when a buffer under/overflow is detected.  <a href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">More...</a><br /></td></tr>
<tr class="separator:ga2838b189f63bb9505d4ec3ae9d572ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d58784d550a3eda4b186fed26e602bb"><td class="memTemplParams" colspan="2">template&lt;class Tracker , class BlockOrRawAllocator &gt; </td></tr>
<tr class="memitem:ga8d58784d550a3eda4b186fed26e602bb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__adapter.html#ga8d58784d550a3eda4b186fed26e602bb">deeply_tracked_block_allocator</a> = <a class="el" href="config_8hpp.html#ad9ce7c7a9b4f995a3af52e594bc43e8d">WPI_IMPL_DEFINED</a>(<a class="el" href="classwpi_1_1memory_1_1detail_1_1deeply__tracked__block__allocator.html">detail::deeply_tracked_block_allocator</a>&lt; Tracker, <a class="el" href="namespacewpi_1_1memory.html#af0f1bb450799856d89c262c855060ec8">make_block_allocator_t</a>&lt; BlockOrRawAllocator &gt; &gt;)</td></tr>
<tr class="memdesc:ga8d58784d550a3eda4b186fed26e602bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classwpi_1_1memory_1_1tracked__block__allocator.html">tracked_block_allocator</a>, but shares the tracker with the higher level allocator.  <a href="group__adapter.html#ga8d58784d550a3eda4b186fed26e602bb">More...</a><br /></td></tr>
<tr class="separator:ga8d58784d550a3eda4b186fed26e602bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d45e393fa087b34b4634e79203529b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#ae7d45e393fa087b34b4634e79203529b">heap_allocator</a> = <a class="el" href="config_8hpp.html#ad9ce7c7a9b4f995a3af52e594bc43e8d">WPI_IMPL_DEFINED</a>(<a class="el" href="classwpi_1_1memory_1_1detail_1_1lowlevel__allocator.html">detail::lowlevel_allocator</a>&lt; <a class="el" href="structwpi_1_1memory_1_1detail_1_1heap__allocator__impl.html">detail::heap_allocator_impl</a> &gt;)</td></tr>
<tr class="separator:ae7d45e393fa087b34b4634e79203529b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f66436ef97dbadd6d75fa3f474695df"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__storage.html#ga5f66436ef97dbadd6d75fa3f474695df">any_reference_storage</a> = <a class="el" href="classwpi_1_1memory_1_1reference__storage.html">reference_storage</a>&lt; <a class="el" href="structwpi_1_1memory_1_1any__allocator.html">any_allocator</a> &gt;</td></tr>
<tr class="memdesc:ga5f66436ef97dbadd6d75fa3f474695df"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for the <a class="el" href="classwpi_1_1memory_1_1reference__storage.html">reference_storage</a> specialization using type-erasure.  <a href="group__storage.html#ga5f66436ef97dbadd6d75fa3f474695df">More...</a><br /></td></tr>
<tr class="separator:ga5f66436ef97dbadd6d75fa3f474695df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392d09db7d4aace8b47eb6e4c3961961"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a392d09db7d4aace8b47eb6e4c3961961">any_allocator_reference</a> = <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a>&lt; <a class="el" href="group__storage.html#ga5f66436ef97dbadd6d75fa3f474695df">any_reference_storage</a>, <a class="el" href="structwpi_1_1memory_1_1no__mutex.html">no_mutex</a> &gt;</td></tr>
<tr class="separator:a392d09db7d4aace8b47eb6e4c3961961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7778578540eb33611902c32326c7e61"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#ac7778578540eb33611902c32326c7e61">new_allocator</a> = <a class="el" href="config_8hpp.html#ad9ce7c7a9b4f995a3af52e594bc43e8d">WPI_IMPL_DEFINED</a>(<a class="el" href="classwpi_1_1memory_1_1detail_1_1lowlevel__allocator.html">detail::lowlevel_allocator</a>&lt; <a class="el" href="structwpi_1_1memory_1_1detail_1_1new__allocator__impl.html">detail::new_allocator_impl</a> &gt;)</td></tr>
<tr class="separator:ac7778578540eb33611902c32326c7e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68e616af8334ef045a86b633ba2c280"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#ad68e616af8334ef045a86b633ba2c280">malloc_allocator</a> = <a class="el" href="config_8hpp.html#ad9ce7c7a9b4f995a3af52e594bc43e8d">WPI_IMPL_DEFINED</a>(<a class="el" href="classwpi_1_1memory_1_1detail_1_1lowlevel__allocator.html">detail::lowlevel_allocator</a>&lt; <a class="el" href="structwpi_1_1memory_1_1detail_1_1malloc__allocator__impl.html">detail::malloc_allocator_impl</a> &gt;)</td></tr>
<tr class="separator:ad68e616af8334ef045a86b633ba2c280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f754500044a675a6c2820cba487b394"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class Segregator &gt; </td></tr>
<tr class="memitem:a1f754500044a675a6c2820cba487b394"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a1f754500044a675a6c2820cba487b394">segregatable_allocator_type</a> = typename <a class="el" href="structwpi_1_1memory_1_1detail_1_1segregatable__type.html">detail::segregatable_type</a>&lt; I, Segregator &gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a></td></tr>
<tr class="separator:a1f754500044a675a6c2820cba487b394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226f6df0ddd808d944452b8210987fb5"><td class="memTemplParams" colspan="2">template&lt;class Segregator &gt; </td></tr>
<tr class="memitem:a226f6df0ddd808d944452b8210987fb5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a226f6df0ddd808d944452b8210987fb5">fallback_allocator_type</a> = typename <a class="el" href="structwpi_1_1memory_1_1detail_1_1fallback__type.html">detail::fallback_type</a>&lt; Segregator &gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a></td></tr>
<tr class="separator:a226f6df0ddd808d944452b8210987fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gadea26fb93affed8c409ec360412d762e"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gadea26fb93affed8c409ec360412d762e">debug_magic</a> : unsigned char { <br />
&#160;&#160;<a class="el" href="group__core.html#ggadea26fb93affed8c409ec360412d762ea7bd4be20559c1a287369c8df4c117afe">debug_magic::internal_memory</a> = 0xAB
, <a class="el" href="group__core.html#ggadea26fb93affed8c409ec360412d762eaa5c32a0fcc06d646d53c71b55c9cf5cb">debug_magic::internal_freed_memory</a> = 0xFB
, <a class="el" href="group__core.html#ggadea26fb93affed8c409ec360412d762ea9e1988b82181dbe51272459a8ac8e0c0">debug_magic::new_memory</a> = 0xCD
, <a class="el" href="group__core.html#ggadea26fb93affed8c409ec360412d762ea635e5f9da5635b909461fd93c09130ed">debug_magic::freed_memory</a> = 0xDD
, <br />
&#160;&#160;<a class="el" href="group__core.html#ggadea26fb93affed8c409ec360412d762ea682318fff515ed43a48b718f46c21308">debug_magic::alignment_memory</a> = 0xED
, <a class="el" href="group__core.html#ggadea26fb93affed8c409ec360412d762ea99ec421b05ddc9b5565897f6a0cfb360">debug_magic::fence_memory</a> = 0xFD
<br />
 }</td></tr>
<tr class="memdesc:gadea26fb93affed8c409ec360412d762e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The magic values that are used for debug filling.  <a href="group__core.html#gadea26fb93affed8c409ec360412d762e">More...</a><br /></td></tr>
<tr class="separator:gadea26fb93affed8c409ec360412d762e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac0bb256351fc5b5791f7ec1d5adf492d"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:ac0bb256351fc5b5791f7ec1d5adf492d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#ac0bb256351fc5b5791f7ec1d5adf492d">WPI_ALIAS_TEMPLATE</a> (unique_ptr, std::unique_ptr&lt; T, <a class="el" href="classwpi_1_1memory_1_1allocator__deleter.html">allocator_deleter</a>&lt; T, RawAllocator &gt; &gt;)</td></tr>
<tr class="separator:ac0bb256351fc5b5791f7ec1d5adf492d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e772ce8acf3ad961f92ae76df97cc77"><td class="memTemplParams" colspan="2">template&lt;class BaseType , class RawAllocator &gt; </td></tr>
<tr class="memitem:a8e772ce8acf3ad961f92ae76df97cc77"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a8e772ce8acf3ad961f92ae76df97cc77">WPI_ALIAS_TEMPLATE</a> (unique_base_ptr, std::unique_ptr&lt; BaseType, <a class="el" href="classwpi_1_1memory_1_1allocator__polymorphic__deleter.html">allocator_polymorphic_deleter</a>&lt; BaseType, RawAllocator &gt; &gt;)</td></tr>
<tr class="separator:a8e772ce8acf3ad961f92ae76df97cc77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb21e670ab68dc35ac728ccf62f6c34"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator , typename... Args&gt; </td></tr>
<tr class="memitem:a9eb21e670ab68dc35ac728ccf62f6c34"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a9eb21e670ab68dc35ac728ccf62f6c34">allocate_unique</a> (RawAllocator &amp;&amp;alloc, Args &amp;&amp;... args) -&gt; <a class="el" href="utility_8hpp.html#a4c25ba24150b80a31b9cfd323d73e4b4">WPI_REQUIRES_RET</a>(!std::is_array&lt; T &gt;<a class="el" href="classvalue.html">::value</a>, std::unique_ptr&lt; T, <a class="el" href="classwpi_1_1memory_1_1allocator__deleter.html">allocator_deleter</a>&lt; T, typename std::decay&lt; RawAllocator &gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a> &gt; &gt;)</td></tr>
<tr class="separator:a9eb21e670ab68dc35ac728ccf62f6c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d229612a188065f737d428f97947653"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator , typename... Args&gt; </td></tr>
<tr class="memitem:a1d229612a188065f737d428f97947653"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a1d229612a188065f737d428f97947653">allocate_unique</a> (<a class="el" href="structwpi_1_1memory_1_1any__allocator.html">any_allocator</a>, RawAllocator &amp;&amp;alloc, Args &amp;&amp;... args) -&gt; <a class="el" href="utility_8hpp.html#a4c25ba24150b80a31b9cfd323d73e4b4">WPI_REQUIRES_RET</a>(!std::is_array&lt; T &gt;<a class="el" href="classvalue.html">::value</a>, std::unique_ptr&lt; T, <a class="el" href="classwpi_1_1memory_1_1allocator__deleter.html">allocator_deleter</a>&lt; T, <a class="el" href="structwpi_1_1memory_1_1any__allocator.html">any_allocator</a> &gt; &gt;)</td></tr>
<tr class="separator:a1d229612a188065f737d428f97947653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac822d9f36329123c4192b68179f46be4"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:ac822d9f36329123c4192b68179f46be4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#ac822d9f36329123c4192b68179f46be4">allocate_unique</a> (RawAllocator &amp;&amp;alloc, std::size_t size) -&gt; <a class="el" href="utility_8hpp.html#a4c25ba24150b80a31b9cfd323d73e4b4">WPI_REQUIRES_RET</a>(std::is_array&lt; T &gt;<a class="el" href="classvalue.html">::value</a>, std::unique_ptr&lt; T, <a class="el" href="classwpi_1_1memory_1_1allocator__deleter.html">allocator_deleter</a>&lt; T, typename std::decay&lt; RawAllocator &gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a> &gt; &gt;)</td></tr>
<tr class="separator:ac822d9f36329123c4192b68179f46be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839f3c73949039b496b4815fe51e9304"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:a839f3c73949039b496b4815fe51e9304"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a839f3c73949039b496b4815fe51e9304">allocate_unique</a> (<a class="el" href="structwpi_1_1memory_1_1any__allocator.html">any_allocator</a>, RawAllocator &amp;&amp;alloc, std::size_t size) -&gt; <a class="el" href="utility_8hpp.html#a4c25ba24150b80a31b9cfd323d73e4b4">WPI_REQUIRES_RET</a>(std::is_array&lt; T &gt;<a class="el" href="classvalue.html">::value</a>, std::unique_ptr&lt; T, <a class="el" href="classwpi_1_1memory_1_1allocator__deleter.html">allocator_deleter</a>&lt; T, <a class="el" href="structwpi_1_1memory_1_1any__allocator.html">any_allocator</a> &gt; &gt;)</td></tr>
<tr class="separator:a839f3c73949039b496b4815fe51e9304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad71e94176eddd2fe4eab53c41fca57"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator , typename... Args&gt; </td></tr>
<tr class="memitem:a1ad71e94176eddd2fe4eab53c41fca57"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a1ad71e94176eddd2fe4eab53c41fca57">allocate_shared</a> (RawAllocator &amp;&amp;alloc, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a1ad71e94176eddd2fe4eab53c41fca57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1c35d9564850140e8d4b11f62a546c4"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__allocator.html#gac1c35d9564850140e8d4b11f62a546c4">get_virtual_memory_page_size</a> () noexcept</td></tr>
<tr class="separator:gac1c35d9564850140e8d4b11f62a546c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1a7c43913988fb500fba5d302314152"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__allocator.html#gad1a7c43913988fb500fba5d302314152">virtual_memory_reserve</a> (std::size_t no_pages) noexcept</td></tr>
<tr class="memdesc:gad1a7c43913988fb500fba5d302314152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves virtual memory.  <a href="group__allocator.html#gad1a7c43913988fb500fba5d302314152">More...</a><br /></td></tr>
<tr class="separator:gad1a7c43913988fb500fba5d302314152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22132476ee264f257141467ef137fce0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__allocator.html#ga22132476ee264f257141467ef137fce0">virtual_memory_release</a> (void *pages, std::size_t no_pages) noexcept</td></tr>
<tr class="memdesc:ga22132476ee264f257141467ef137fce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases reserved virtual memory.  <a href="group__allocator.html#ga22132476ee264f257141467ef137fce0">More...</a><br /></td></tr>
<tr class="separator:ga22132476ee264f257141467ef137fce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22dd891cd2e42c178cf34b695c4cbd5f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__allocator.html#ga22dd891cd2e42c178cf34b695c4cbd5f">virtual_memory_commit</a> (void *memory, std::size_t no_pages) noexcept</td></tr>
<tr class="memdesc:ga22dd891cd2e42c178cf34b695c4cbd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commits reserved virtual memory.  <a href="group__allocator.html#ga22dd891cd2e42c178cf34b695c4cbd5f">More...</a><br /></td></tr>
<tr class="separator:ga22dd891cd2e42c178cf34b695c4cbd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadf2703a4f915416dcc1c90081b2d708"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__allocator.html#gaadf2703a4f915416dcc1c90081b2d708">virtual_memory_decommit</a> (void *memory, std::size_t no_pages) noexcept</td></tr>
<tr class="memdesc:gaadf2703a4f915416dcc1c90081b2d708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decommits commited virtual memory.  <a href="group__allocator.html#gaadf2703a4f915416dcc1c90081b2d708">More...</a><br /></td></tr>
<tr class="separator:gaadf2703a4f915416dcc1c90081b2d708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f311d60d4857926d16396fc6a3be15a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1memory_1_1temporary__stack.html">temporary_stack</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a7f311d60d4857926d16396fc6a3be15a">get_temporary_stack</a> (std::size_t initial_size=<a class="el" href="classwpi_1_1memory_1_1temporary__stack__initializer.html#a0865fd66d723b06d205efe6a295bfa0c">temporary_stack_initializer::default_stack_size</a>)</td></tr>
<tr class="memdesc:a7f311d60d4857926d16396fc6a3be15a"><td class="mdescLeft">&#160;</td><td class="mdescRight">\effects Creates the per-thread <a class="el" href="classwpi_1_1memory_1_1temporary__stack.html">temporary_stack</a> with the given initial size, if it wasn't already created.  <a href="namespacewpi_1_1memory.html#a7f311d60d4857926d16396fc6a3be15a">More...</a><br /></td></tr>
<tr class="separator:a7f311d60d4857926d16396fc6a3be15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee98bf1c027ffa33eae0086d6385c33b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee98bf1c027ffa33eae0086d6385c33b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#aee98bf1c027ffa33eae0086d6385c33b">WPI_ALIAS_TEMPLATE</a> (any_std_allocator, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, <a class="el" href="structwpi_1_1memory_1_1any__allocator.html">any_allocator</a> &gt;)</td></tr>
<tr class="separator:aee98bf1c027ffa33eae0086d6385c33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga834abe9622c747efdfa8619009d2e373"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">leak_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga834abe9622c747efdfa8619009d2e373">set_leak_handler</a> (<a class="el" href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">leak_handler</a> h)</td></tr>
<tr class="memdesc:ga834abe9622c747efdfa8619009d2e373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the <a class="el" href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">leak_handler</a>.  <a href="group__core.html#ga834abe9622c747efdfa8619009d2e373">More...</a><br /></td></tr>
<tr class="separator:ga834abe9622c747efdfa8619009d2e373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa60befedaaf9af29fcf7ce4aa837cc6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">leak_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gaa60befedaaf9af29fcf7ce4aa837cc6e">get_leak_handler</a> ()</td></tr>
<tr class="memdesc:gaa60befedaaf9af29fcf7ce4aa837cc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">leak_handler</a>.  <a href="group__core.html#gaa60befedaaf9af29fcf7ce4aa837cc6e">More...</a><br /></td></tr>
<tr class="separator:gaa60befedaaf9af29fcf7ce4aa837cc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8d5aef2a6a2d4e65cfcc0eeac06c02b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">invalid_pointer_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gab8d5aef2a6a2d4e65cfcc0eeac06c02b">set_invalid_pointer_handler</a> (<a class="el" href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">invalid_pointer_handler</a> h)</td></tr>
<tr class="memdesc:gab8d5aef2a6a2d4e65cfcc0eeac06c02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the <a class="el" href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">invalid_pointer_handler</a>.  <a href="group__core.html#gab8d5aef2a6a2d4e65cfcc0eeac06c02b">More...</a><br /></td></tr>
<tr class="separator:gab8d5aef2a6a2d4e65cfcc0eeac06c02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34d9478573193d39208d340a6586f8a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">invalid_pointer_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga34d9478573193d39208d340a6586f8a1">get_invalid_pointer_handler</a> ()</td></tr>
<tr class="memdesc:ga34d9478573193d39208d340a6586f8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">invalid_pointer_handler</a>.  <a href="group__core.html#ga34d9478573193d39208d340a6586f8a1">More...</a><br /></td></tr>
<tr class="separator:ga34d9478573193d39208d340a6586f8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93b00d2fd1d3cd1f85f5331cf843fac3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">buffer_overflow_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga93b00d2fd1d3cd1f85f5331cf843fac3">set_buffer_overflow_handler</a> (<a class="el" href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">buffer_overflow_handler</a> h)</td></tr>
<tr class="memdesc:ga93b00d2fd1d3cd1f85f5331cf843fac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the <a class="el" href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">buffer_overflow_handler</a>.  <a href="group__core.html#ga93b00d2fd1d3cd1f85f5331cf843fac3">More...</a><br /></td></tr>
<tr class="separator:ga93b00d2fd1d3cd1f85f5331cf843fac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddb4989826b25f0f3d833c871cd74a0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">buffer_overflow_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gaddb4989826b25f0f3d833c871cd74a0d">get_buffer_overflow_handler</a> ()</td></tr>
<tr class="memdesc:gaddb4989826b25f0f3d833c871cd74a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">buffer_overflow_handler</a>.  <a href="group__core.html#gaddb4989826b25f0f3d833c871cd74a0d">More...</a><br /></td></tr>
<tr class="separator:gaddb4989826b25f0f3d833c871cd74a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b25fd8dd24cad7eb49ad308f7d14fc"><td class="memTemplParams" colspan="2">template&lt;class Tracker , class RawAllocator &gt; </td></tr>
<tr class="memitem:a23b25fd8dd24cad7eb49ad308f7d14fc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a23b25fd8dd24cad7eb49ad308f7d14fc">make_tracked_allocator</a> (Tracker t, RawAllocator &amp;&amp;alloc) -&gt; <a class="el" href="classwpi_1_1memory_1_1tracked__allocator.html">tracked_allocator</a>&lt; Tracker, typename std::decay&lt; RawAllocator &gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a> &gt;</td></tr>
<tr class="separator:a23b25fd8dd24cad7eb49ad308f7d14fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea1d3eceff768dc0fa3f074cef3970f"><td class="memTemplParams" colspan="2">template&lt;class Tracker , class RawAllocator &gt; </td></tr>
<tr class="memitem:a7ea1d3eceff768dc0fa3f074cef3970f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a7ea1d3eceff768dc0fa3f074cef3970f">WPI_ALIAS_TEMPLATE</a> (deeply_tracked_allocator, <a class="el" href="classwpi_1_1memory_1_1tracked__allocator.html">tracked_allocator</a>&lt; Tracker, <a class="el" href="namespacewpi_1_1memory_1_1detail.html#abfcc9a0a376d15210cca3deca1b242a8">detail::rebound_allocator</a>&lt; Tracker, RawAllocator &gt; &gt;)</td></tr>
<tr class="separator:a7ea1d3eceff768dc0fa3f074cef3970f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503c488b57684eb030d24c644b4d862a"><td class="memTemplParams" colspan="2">template&lt;class RawAllocator , class Tracker , typename... Args&gt; </td></tr>
<tr class="memitem:a503c488b57684eb030d24c644b4d862a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a503c488b57684eb030d24c644b4d862a">make_deeply_tracked_allocator</a> (Tracker t, Args &amp;&amp;... args) -&gt; deeply_tracked_allocator&lt; Tracker, RawAllocator &gt;</td></tr>
<tr class="separator:a503c488b57684eb030d24c644b4d862a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48968808f543510ec82f603606907bfa"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__allocator.html#ga48968808f543510ec82f603606907bfa">heap_alloc</a> (std::size_t size) noexcept</td></tr>
<tr class="memdesc:ga48968808f543510ec82f603606907bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates heap memory.  <a href="group__allocator.html#ga48968808f543510ec82f603606907bfa">More...</a><br /></td></tr>
<tr class="separator:ga48968808f543510ec82f603606907bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c1515d80116d4e210dfc0476731c01d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__allocator.html#ga3c1515d80116d4e210dfc0476731c01d">heap_dealloc</a> (void *<a class="el" href="format_8h.html#aa6ec2d4315570f27d9637ce3c770e787">ptr</a>, std::size_t size) noexcept</td></tr>
<tr class="memdesc:ga3c1515d80116d4e210dfc0476731c01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates heap memory.  <a href="group__allocator.html#ga3c1515d80116d4e210dfc0476731c01d">More...</a><br /></td></tr>
<tr class="separator:ga3c1515d80116d4e210dfc0476731c01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ad830d984ca9631883119a7dd2a0be2"><td class="memTemplParams" colspan="2">template&lt;class PoolType  = node_pool, class ImplAllocator  = default_allocator&gt; </td></tr>
<tr class="memitem:ga0ad830d984ca9631883119a7dd2a0be2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__allocator.html#ga0ad830d984ca9631883119a7dd2a0be2">WPI_ALIAS_TEMPLATE</a> (bucket_allocator, <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a>&lt; PoolType, <a class="el" href="structwpi_1_1memory_1_1identity__buckets.html">identity_buckets</a>, ImplAllocator &gt;)</td></tr>
<tr class="memdesc:ga0ad830d984ca9631883119a7dd2a0be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a> using the <a class="el" href="structwpi_1_1memory_1_1identity__buckets.html">identity_buckets</a> policy and a <code>PoolType</code> defaulting to <a class="el" href="structwpi_1_1memory_1_1node__pool.html">node_pool</a>.  <a href="group__allocator.html#ga0ad830d984ca9631883119a7dd2a0be2">More...</a><br /></td></tr>
<tr class="separator:ga0ad830d984ca9631883119a7dd2a0be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89ea4edade0b5d7a584b95aff659e7ad"><td class="memTemplParams" colspan="2">template&lt;class BlockOrRawAllocator  = default_allocator&gt; </td></tr>
<tr class="memitem:ga89ea4edade0b5d7a584b95aff659e7ad"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__allocator.html#ga89ea4edade0b5d7a584b95aff659e7ad">WPI_ALIAS_TEMPLATE</a> (double_frame_allocator, <a class="el" href="classwpi_1_1memory_1_1iteration__allocator.html">iteration_allocator</a>&lt; 2, BlockOrRawAllocator &gt;)</td></tr>
<tr class="memdesc:ga89ea4edade0b5d7a584b95aff659e7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for <a class="el" href="classwpi_1_1memory_1_1iteration__allocator.html">iteration_allocator</a> for two iterations.  <a href="group__allocator.html#ga89ea4edade0b5d7a584b95aff659e7ad">More...</a><br /></td></tr>
<tr class="separator:ga89ea4edade0b5d7a584b95aff659e7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c0b4bfaf4b7066043a77d9bf36da28"><td class="memTemplParams" colspan="2">template&lt;class RawAllocator &gt; </td></tr>
<tr class="memitem:a81c0b4bfaf4b7066043a77d9bf36da28"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a81c0b4bfaf4b7066043a77d9bf36da28">WPI_ALIAS_TEMPLATE</a> (allocator_adapter, <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a>&lt; <a class="el" href="classwpi_1_1memory_1_1direct__storage.html">direct_storage</a>&lt; RawAllocator &gt;, <a class="el" href="structwpi_1_1memory_1_1no__mutex.html">no_mutex</a> &gt;)</td></tr>
<tr class="separator:a81c0b4bfaf4b7066043a77d9bf36da28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38d782dac7e6ae8fbe750975bc759299"><td class="memTemplParams" colspan="2">template&lt;class RawAllocator , class Mutex &gt; </td></tr>
<tr class="memitem:ga38d782dac7e6ae8fbe750975bc759299"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__storage.html#ga38d782dac7e6ae8fbe750975bc759299">WPI_ALIAS_TEMPLATE</a> (thread_safe_allocator, <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a>&lt; <a class="el" href="classwpi_1_1memory_1_1direct__storage.html">direct_storage</a>&lt; RawAllocator &gt;, Mutex &gt;)</td></tr>
<tr class="memdesc:ga38d782dac7e6ae8fbe750975bc759299"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias template for <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a> using the <a class="el" href="classwpi_1_1memory_1_1direct__storage.html">direct_storage</a> policy with a mutex.  <a href="group__storage.html#ga38d782dac7e6ae8fbe750975bc759299">More...</a><br /></td></tr>
<tr class="separator:ga38d782dac7e6ae8fbe750975bc759299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33b038a6be46894ef0c28fdb6b0f86f5"><td class="memTemplParams" colspan="2">template&lt;class RawAllocator &gt; </td></tr>
<tr class="memitem:ga33b038a6be46894ef0c28fdb6b0f86f5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__storage.html#ga33b038a6be46894ef0c28fdb6b0f86f5">WPI_ALIAS_TEMPLATE</a> (allocator_reference, <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a>&lt; <a class="el" href="classwpi_1_1memory_1_1reference__storage.html">reference_storage</a>&lt; RawAllocator &gt;, <a class="el" href="structwpi_1_1memory_1_1no__mutex.html">no_mutex</a> &gt;)</td></tr>
<tr class="memdesc:ga33b038a6be46894ef0c28fdb6b0f86f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias template for <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a> using the <a class="el" href="classwpi_1_1memory_1_1reference__storage.html">reference_storage</a> policy.  <a href="group__storage.html#ga33b038a6be46894ef0c28fdb6b0f86f5">More...</a><br /></td></tr>
<tr class="separator:ga33b038a6be46894ef0c28fdb6b0f86f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a52e04544774b2c5fbdafae66fccde9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adapter.html#ga9a52e04544774b2c5fbdafae66fccde9">WPI_ALIAS_TEMPLATE</a> (memory_resource, foonathan_memory_pmr::memory_resource)</td></tr>
<tr class="memdesc:ga9a52e04544774b2c5fbdafae66fccde9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>memory_resource</code> abstract base class used in the implementation.  <a href="group__adapter.html#ga9a52e04544774b2c5fbdafae66fccde9">More...</a><br /></td></tr>
<tr class="separator:ga9a52e04544774b2c5fbdafae66fccde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24426d9ba265765e4762dd23e2a9f70a"><td class="memTemplParams" colspan="2">template&lt;class RawAllocator &gt; </td></tr>
<tr class="memitem:a24426d9ba265765e4762dd23e2a9f70a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1memory_1_1threshold__segregatable.html">threshold_segregatable</a>&lt; typename std::decay&lt; RawAllocator &gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a24426d9ba265765e4762dd23e2a9f70a">threshold</a> (std::size_t max_size, RawAllocator &amp;&amp;alloc)</td></tr>
<tr class="separator:a24426d9ba265765e4762dd23e2a9f70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4ef5c795a91a60c48275e56259ceec"><td class="memTemplParams" colspan="2">template&lt;class... Allocators&gt; </td></tr>
<tr class="memitem:a2e4ef5c795a91a60c48275e56259ceec"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a2e4ef5c795a91a60c48275e56259ceec">WPI_ALIAS_TEMPLATE</a> (segregator, typename <a class="el" href="structwpi_1_1memory_1_1detail_1_1make__segregator__t.html">detail::make_segregator_t</a>&lt; Allocators... &gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a>)</td></tr>
<tr class="separator:a2e4ef5c795a91a60c48275e56259ceec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aadbfe56850e983927e8a47d82b565f1e"><td class="memTemplParams" colspan="2">template&lt;class BlockOrRawAllocator , typename... Args&gt; </td></tr>
<tr class="memitem:aadbfe56850e983927e8a47d82b565f1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacewpi_1_1memory.html#af0f1bb450799856d89c262c855060ec8">make_block_allocator_t</a>&lt; BlockOrRawAllocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#aadbfe56850e983927e8a47d82b565f1e">make_block_allocator</a> (std::size_t block_size, Args &amp;&amp;... args)</td></tr>
<tr class="separator:aadbfe56850e983927e8a47d82b565f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2818c818ef45e69d31b01b11e0e8bb7b"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class BlockAllocator, class BlockOrRawAllocator , typename... Args&gt; </td></tr>
<tr class="memitem:a2818c818ef45e69d31b01b11e0e8bb7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacewpi_1_1memory.html#af0f1bb450799856d89c262c855060ec8">make_block_allocator_t</a>&lt; BlockOrRawAllocator, BlockAllocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a2818c818ef45e69d31b01b11e0e8bb7b">make_block_allocator</a> (std::size_t block_size, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a2818c818ef45e69d31b01b11e0e8bb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adc89098b5cf93bab9d2ec6629d0af4f6"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:adc89098b5cf93bab9d2ec6629d0af4f6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#adc89098b5cf93bab9d2ec6629d0af4f6">operator==</a> (std::nullptr_t, const <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt; &amp;<a class="el" href="format_8h.html#aa6ec2d4315570f27d9637ce3c770e787">ptr</a>)</td></tr>
<tr class="separator:adc89098b5cf93bab9d2ec6629d0af4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9341e2480e1ebc5809c6e2e08fd48102"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:a9341e2480e1ebc5809c6e2e08fd48102"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a9341e2480e1ebc5809c6e2e08fd48102">operator==</a> (T *p, const <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt; &amp;<a class="el" href="format_8h.html#aa6ec2d4315570f27d9637ce3c770e787">ptr</a>)</td></tr>
<tr class="separator:a9341e2480e1ebc5809c6e2e08fd48102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af5264ae0d5d04ad3175df9f5063ecaa4"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:af5264ae0d5d04ad3175df9f5063ecaa4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#af5264ae0d5d04ad3175df9f5063ecaa4">operator!=</a> (std::nullptr_t, const <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt; &amp;<a class="el" href="format_8h.html#aa6ec2d4315570f27d9637ce3c770e787">ptr</a>)</td></tr>
<tr class="separator:af5264ae0d5d04ad3175df9f5063ecaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abf70288c708a52bf2cc49f97389179e1"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:abf70288c708a52bf2cc49f97389179e1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#abf70288c708a52bf2cc49f97389179e1">operator!=</a> (T *p, const <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt; &amp;<a class="el" href="format_8h.html#aa6ec2d4315570f27d9637ce3c770e787">ptr</a>)</td></tr>
<tr class="separator:abf70288c708a52bf2cc49f97389179e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaa386e46d510b33b9ccd41de08abab54b"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator , typename... Args&gt; </td></tr>
<tr class="memitem:gaa386e46d510b33b9ccd41de08abab54b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__allocator.html#gaa386e46d510b33b9ccd41de08abab54b">allocate_joint</a> (RawAllocator &amp;alloc, <a class="el" href="structwpi_1_1memory_1_1joint__size.html">joint_size</a> additional_size, Args &amp;&amp;... args) -&gt; <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt;</td></tr>
<tr class="separator:gaa386e46d510b33b9ccd41de08abab54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bbc913798578781b6dea3d4aeae8a0e"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator , typename... Args&gt; </td></tr>
<tr class="memitem:ga2bbc913798578781b6dea3d4aeae8a0e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__allocator.html#ga2bbc913798578781b6dea3d4aeae8a0e">allocate_joint</a> (const RawAllocator &amp;alloc, <a class="el" href="structwpi_1_1memory_1_1joint__size.html">joint_size</a> additional_size, Args &amp;&amp;... args) -&gt; <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt;</td></tr>
<tr class="separator:ga2bbc913798578781b6dea3d4aeae8a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaf36e52257430764b51aa6f8938124dfe"><td class="memTemplParams" colspan="2">template&lt;class RawAllocator , typename T &gt; </td></tr>
<tr class="memitem:gaf36e52257430764b51aa6f8938124dfe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__allocator.html#gaf36e52257430764b51aa6f8938124dfe">clone_joint</a> (RawAllocator &amp;alloc, const <a class="el" href="classwpi_1_1memory_1_1joint__type.html">joint_type</a>&lt; T &gt; &amp;<a class="el" href="classwpi_1_1memory_1_1joint.html">joint</a>) -&gt; <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt;</td></tr>
<tr class="separator:gaf36e52257430764b51aa6f8938124dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39c25e85f4a787cb798de13ea70d16ca"><td class="memTemplParams" colspan="2">template&lt;class RawAllocator , typename T &gt; </td></tr>
<tr class="memitem:ga39c25e85f4a787cb798de13ea70d16ca"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__allocator.html#ga39c25e85f4a787cb798de13ea70d16ca">clone_joint</a> (const RawAllocator &amp;alloc, const <a class="el" href="classwpi_1_1memory_1_1joint__type.html">joint_type</a>&lt; T &gt; &amp;<a class="el" href="classwpi_1_1memory_1_1joint.html">joint</a>) -&gt; <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt;</td></tr>
<tr class="separator:ga39c25e85f4a787cb798de13ea70d16ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aac1cd336eb08ccc5224fa69660fd47a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#aac1cd336eb08ccc5224fa69660fd47a6">operator!=</a> (const <a class="el" href="classwpi_1_1memory_1_1joint__allocator.html">joint_allocator</a> &amp;lhs, const <a class="el" href="classwpi_1_1memory_1_1joint__allocator.html">joint_allocator</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:aac1cd336eb08ccc5224fa69660fd47a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1e35a2b77ea2d9b624e4715645c2fefb"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:a1e35a2b77ea2d9b624e4715645c2fefb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a1e35a2b77ea2d9b624e4715645c2fefb">WPI_ALIAS_TEMPLATE</a> (vector, std::vector&lt; T, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt;)</td></tr>
<tr class="separator:a1e35a2b77ea2d9b624e4715645c2fefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309ebac122e14c87a53cf09929657aa4"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:a309ebac122e14c87a53cf09929657aa4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a309ebac122e14c87a53cf09929657aa4">WPI_ALIAS_TEMPLATE</a> (vector_scoped_alloc, std::vector&lt; T, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt; &gt;)</td></tr>
<tr class="memdesc:a309ebac122e14c87a53cf09929657aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but uses <code>std::scoped_allocator_adaptor</code> so the allocator is inherited by all nested containers.  <a href="namespacewpi_1_1memory.html#a309ebac122e14c87a53cf09929657aa4">More...</a><br /></td></tr>
<tr class="separator:a309ebac122e14c87a53cf09929657aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89dbeb32b6f6af9f6092efce4c0be0ec"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:a89dbeb32b6f6af9f6092efce4c0be0ec"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a89dbeb32b6f6af9f6092efce4c0be0ec">WPI_ALIAS_TEMPLATE</a> (deque, std::deque&lt; T, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt;)</td></tr>
<tr class="separator:a89dbeb32b6f6af9f6092efce4c0be0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d3174f75a094039ffe76bc39eeb333"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:a23d3174f75a094039ffe76bc39eeb333"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a23d3174f75a094039ffe76bc39eeb333">WPI_ALIAS_TEMPLATE</a> (deque_scoped_alloc, std::deque&lt; T, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt; &gt;)</td></tr>
<tr class="separator:a23d3174f75a094039ffe76bc39eeb333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51522d791dda7bbbe1f2679179e4afb2"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:a51522d791dda7bbbe1f2679179e4afb2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a51522d791dda7bbbe1f2679179e4afb2">WPI_ALIAS_TEMPLATE</a> (list, std::list&lt; T, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt;)</td></tr>
<tr class="separator:a51522d791dda7bbbe1f2679179e4afb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d6c96847fea79a44fbb389995128c8"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:aa1d6c96847fea79a44fbb389995128c8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#aa1d6c96847fea79a44fbb389995128c8">WPI_ALIAS_TEMPLATE</a> (list_scoped_alloc, std::list&lt; T, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt; &gt;)</td></tr>
<tr class="separator:aa1d6c96847fea79a44fbb389995128c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f014318674394fca334aa05ab970a7a"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:a5f014318674394fca334aa05ab970a7a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a5f014318674394fca334aa05ab970a7a">WPI_ALIAS_TEMPLATE</a> (forward_list, std::forward_list&lt; T, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt;)</td></tr>
<tr class="separator:a5f014318674394fca334aa05ab970a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad256dce3c10cf4d4280cc8375c52df5e"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:ad256dce3c10cf4d4280cc8375c52df5e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#ad256dce3c10cf4d4280cc8375c52df5e">WPI_ALIAS_TEMPLATE</a> (forward_list_scoped_alloc, std::forward_list&lt; T, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt; &gt;)</td></tr>
<tr class="separator:ad256dce3c10cf4d4280cc8375c52df5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb94f5c67d5b2ca82051c66205a1902d"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:abb94f5c67d5b2ca82051c66205a1902d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#abb94f5c67d5b2ca82051c66205a1902d">WPI_ALIAS_TEMPLATE</a> (set, std::set&lt; T, std::less&lt; T &gt;, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt;)</td></tr>
<tr class="separator:abb94f5c67d5b2ca82051c66205a1902d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93efe59f6da1620e668aff609c437e57"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:a93efe59f6da1620e668aff609c437e57"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a93efe59f6da1620e668aff609c437e57">WPI_ALIAS_TEMPLATE</a> (set_scoped_alloc, std::set&lt; T, std::less&lt; T &gt;, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt; &gt;)</td></tr>
<tr class="separator:a93efe59f6da1620e668aff609c437e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a5c3d0d19e4c6670fa5f0d11c78f61"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:ac6a5c3d0d19e4c6670fa5f0d11c78f61"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#ac6a5c3d0d19e4c6670fa5f0d11c78f61">WPI_ALIAS_TEMPLATE</a> (multiset, std::multiset&lt; T, std::less&lt; T &gt;, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt;)</td></tr>
<tr class="separator:ac6a5c3d0d19e4c6670fa5f0d11c78f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa5f98f8edccf8219c7526d9873688e"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:a9fa5f98f8edccf8219c7526d9873688e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a9fa5f98f8edccf8219c7526d9873688e">WPI_ALIAS_TEMPLATE</a> (multiset_scoped_alloc, std::multiset&lt; T, std::less&lt; T &gt;, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt; &gt;)</td></tr>
<tr class="separator:a9fa5f98f8edccf8219c7526d9873688e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7faeb0f94d62ebb6d589ad21e4d13999"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Value , class RawAllocator &gt; </td></tr>
<tr class="memitem:a7faeb0f94d62ebb6d589ad21e4d13999"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a7faeb0f94d62ebb6d589ad21e4d13999">WPI_ALIAS_TEMPLATE</a> (map, std::map&lt; Key, Value, std::less&lt; Key &gt;, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; std::pair&lt; const Key, Value &gt;, RawAllocator &gt; &gt;)</td></tr>
<tr class="separator:a7faeb0f94d62ebb6d589ad21e4d13999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0afaf9caf0b61137acff15ac6f0608"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Value , class RawAllocator &gt; </td></tr>
<tr class="memitem:aae0afaf9caf0b61137acff15ac6f0608"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#aae0afaf9caf0b61137acff15ac6f0608">WPI_ALIAS_TEMPLATE</a> (map_scoped_alloc, std::map&lt; Key, Value, std::less&lt; Key &gt;, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; std::pair&lt; const Key, Value &gt;, RawAllocator &gt; &gt; &gt;)</td></tr>
<tr class="separator:aae0afaf9caf0b61137acff15ac6f0608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76d7787e9475cd39b4aa6899580a589"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Value , class RawAllocator &gt; </td></tr>
<tr class="memitem:ae76d7787e9475cd39b4aa6899580a589"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#ae76d7787e9475cd39b4aa6899580a589">WPI_ALIAS_TEMPLATE</a> (multimap, std::multimap&lt; Key, Value, std::less&lt; Key &gt;, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; std::pair&lt; const Key, Value &gt;, RawAllocator &gt; &gt;)</td></tr>
<tr class="separator:ae76d7787e9475cd39b4aa6899580a589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a47953bbabf90533f7b9b588324cd6"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Value , class RawAllocator &gt; </td></tr>
<tr class="memitem:a10a47953bbabf90533f7b9b588324cd6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a10a47953bbabf90533f7b9b588324cd6">WPI_ALIAS_TEMPLATE</a> (multimap_scoped_alloc, std::multimap&lt; Key, Value, std::less&lt; Key &gt;, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; std::pair&lt; const Key, Value &gt;, RawAllocator &gt; &gt; &gt;)</td></tr>
<tr class="separator:a10a47953bbabf90533f7b9b588324cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408432bed2e39ec711f4758efe6c3cb7"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:a408432bed2e39ec711f4758efe6c3cb7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a408432bed2e39ec711f4758efe6c3cb7">WPI_ALIAS_TEMPLATE</a> (unordered_set, std::unordered_set&lt; T, std::hash&lt; T &gt;, std::equal_to&lt; T &gt;, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt;)</td></tr>
<tr class="separator:a408432bed2e39ec711f4758efe6c3cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b55eb3b6d648255448390e95c2322e6"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:a5b55eb3b6d648255448390e95c2322e6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a5b55eb3b6d648255448390e95c2322e6">WPI_ALIAS_TEMPLATE</a> (unordered_set_scoped_alloc, std::unordered_set&lt; T, std::hash&lt; T &gt;, std::equal_to&lt; T &gt;, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt; &gt;)</td></tr>
<tr class="separator:a5b55eb3b6d648255448390e95c2322e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cfccf3bc6b8a1f26eb81fd96f2d8a3"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:ae2cfccf3bc6b8a1f26eb81fd96f2d8a3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#ae2cfccf3bc6b8a1f26eb81fd96f2d8a3">WPI_ALIAS_TEMPLATE</a> (unordered_multiset, std::unordered_multiset&lt; T, std::hash&lt; T &gt;, std::equal_to&lt; T &gt;, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt;)</td></tr>
<tr class="separator:ae2cfccf3bc6b8a1f26eb81fd96f2d8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab824087c1ee4957808700550288b483d"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:ab824087c1ee4957808700550288b483d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#ab824087c1ee4957808700550288b483d">WPI_ALIAS_TEMPLATE</a> (unordered_multiset_scoped_alloc, std::unordered_multiset&lt; T, std::hash&lt; T &gt;, std::equal_to&lt; T &gt;, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt; &gt;)</td></tr>
<tr class="separator:ab824087c1ee4957808700550288b483d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace913ef67456190aa2e0b953ca90cd38"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Value , class RawAllocator &gt; </td></tr>
<tr class="memitem:ace913ef67456190aa2e0b953ca90cd38"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#ace913ef67456190aa2e0b953ca90cd38">WPI_ALIAS_TEMPLATE</a> (unordered_map, std::unordered_map&lt; Key, Value, std::hash&lt; Key &gt;, std::equal_to&lt; Key &gt;, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; std::pair&lt; const Key, Value &gt;, RawAllocator &gt; &gt;)</td></tr>
<tr class="separator:ace913ef67456190aa2e0b953ca90cd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b30ee88be0e8c3db3c8d9928eef82c9"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Value , class RawAllocator &gt; </td></tr>
<tr class="memitem:a5b30ee88be0e8c3db3c8d9928eef82c9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a5b30ee88be0e8c3db3c8d9928eef82c9">WPI_ALIAS_TEMPLATE</a> (unordered_map_scoped_alloc, std::unordered_map&lt; Key, Value, std::hash&lt; Key &gt;, std::equal_to&lt; Key &gt;, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; std::pair&lt; const Key, Value &gt;, RawAllocator &gt; &gt; &gt;)</td></tr>
<tr class="separator:a5b30ee88be0e8c3db3c8d9928eef82c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8321304a3f18feb490f1d0910f18d4a"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Value , class RawAllocator &gt; </td></tr>
<tr class="memitem:af8321304a3f18feb490f1d0910f18d4a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#af8321304a3f18feb490f1d0910f18d4a">WPI_ALIAS_TEMPLATE</a> (unordered_multimap, std::unordered_multimap&lt; Key, Value, std::hash&lt; Key &gt;, std::equal_to&lt; Key &gt;, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; std::pair&lt; const Key, Value &gt;, RawAllocator &gt; &gt;)</td></tr>
<tr class="separator:af8321304a3f18feb490f1d0910f18d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75afbc771d3d27e65b491be16cab098b"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Value , class RawAllocator &gt; </td></tr>
<tr class="memitem:a75afbc771d3d27e65b491be16cab098b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a75afbc771d3d27e65b491be16cab098b">WPI_ALIAS_TEMPLATE</a> (unordered_multimap_scoped_alloc, std::unordered_multimap&lt; Key, Value, std::hash&lt; Key &gt;, std::equal_to&lt; Key &gt;, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; std::pair&lt; const Key, Value &gt;, RawAllocator &gt; &gt; &gt;)</td></tr>
<tr class="separator:a75afbc771d3d27e65b491be16cab098b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072b15e4e51dd97654f3792bb786912d"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:a072b15e4e51dd97654f3792bb786912d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a072b15e4e51dd97654f3792bb786912d">WPI_ALIAS_TEMPLATE</a> (stack, std::stack&lt; T, deque&lt; T, RawAllocator &gt; &gt;)</td></tr>
<tr class="separator:a072b15e4e51dd97654f3792bb786912d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b88b2ea4adef34ef6edb6b7448b6a3a"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:a8b88b2ea4adef34ef6edb6b7448b6a3a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a8b88b2ea4adef34ef6edb6b7448b6a3a">WPI_ALIAS_TEMPLATE</a> (stack_scoped_alloc, std::stack&lt; T, deque_scoped_alloc&lt; T, RawAllocator &gt; &gt;)</td></tr>
<tr class="separator:a8b88b2ea4adef34ef6edb6b7448b6a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6f4868f2f82be8d176210465456797"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:ada6f4868f2f82be8d176210465456797"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#ada6f4868f2f82be8d176210465456797">WPI_ALIAS_TEMPLATE</a> (queue, std::queue&lt; T, deque&lt; T, RawAllocator &gt; &gt;)</td></tr>
<tr class="separator:ada6f4868f2f82be8d176210465456797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0171a2a19ecb2069fcd730ce25db1dc"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:ab0171a2a19ecb2069fcd730ce25db1dc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#ab0171a2a19ecb2069fcd730ce25db1dc">WPI_ALIAS_TEMPLATE</a> (queue_scoped_alloc, std::queue&lt; T, deque_scoped_alloc&lt; T, RawAllocator &gt; &gt;)</td></tr>
<tr class="separator:ab0171a2a19ecb2069fcd730ce25db1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4ea696b25374ce799c9b7298ca80c3"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:a2f4ea696b25374ce799c9b7298ca80c3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a2f4ea696b25374ce799c9b7298ca80c3">WPI_ALIAS_TEMPLATE</a> (<a class="el" href="classwpi_1_1priority__queue.html">priority_queue</a>, std::priority_queue&lt; T, deque&lt; T, RawAllocator &gt; &gt;)</td></tr>
<tr class="separator:a2f4ea696b25374ce799c9b7298ca80c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82cef9d2a42bfedef0c114e339a16a64"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:a82cef9d2a42bfedef0c114e339a16a64"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a82cef9d2a42bfedef0c114e339a16a64">WPI_ALIAS_TEMPLATE</a> (priority_queue_scoped_alloc, std::priority_queue&lt; T, deque_scoped_alloc&lt; T, RawAllocator &gt; &gt;)</td></tr>
<tr class="separator:a82cef9d2a42bfedef0c114e339a16a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a8779f77b2046839555575ba263041"><td class="memTemplParams" colspan="2">template&lt;class RawAllocator &gt; </td></tr>
<tr class="memitem:a05a8779f77b2046839555575ba263041"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a05a8779f77b2046839555575ba263041">WPI_ALIAS_TEMPLATE</a> (string, std::basic_string&lt; char, std::char_traits&lt; char &gt;, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; char, RawAllocator &gt; &gt;)</td></tr>
<tr class="separator:a05a8779f77b2046839555575ba263041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1d38ee5d6a9b2d723f259c2c4607622f"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator , class Container  = deque&lt;T, RawAllocator&gt;&gt; </td></tr>
<tr class="memitem:a1d38ee5d6a9b2d723f259c2c4607622f"><td class="memTemplItemLeft" align="right" valign="top">std::stack&lt; T, Container &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a1d38ee5d6a9b2d723f259c2c4607622f">make_stack</a> (RawAllocator &amp;allocator)</td></tr>
<tr class="separator:a1d38ee5d6a9b2d723f259c2c4607622f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab060b6ef926a7d11d224db99f19bf708"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator , class Container  = deque&lt;T, RawAllocator&gt;&gt; </td></tr>
<tr class="memitem:ab060b6ef926a7d11d224db99f19bf708"><td class="memTemplItemLeft" align="right" valign="top">std::queue&lt; T, Container &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#ab060b6ef926a7d11d224db99f19bf708">make_queue</a> (RawAllocator &amp;allocator)</td></tr>
<tr class="separator:ab060b6ef926a7d11d224db99f19bf708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f596862c12bf216230bf62df611014"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator , class Container  = deque&lt;T, RawAllocator&gt;, class Compare  = std::less&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a37f596862c12bf216230bf62df611014"><td class="memTemplItemLeft" align="right" valign="top">std::priority_queue&lt; T, Container, Compare &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a37f596862c12bf216230bf62df611014">make_priority_queue</a> (RawAllocator &amp;allocator, Compare comp={})</td></tr>
<tr class="separator:a37f596862c12bf216230bf62df611014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3083c047d212b6d52b8ba27431d0d8e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a3083c047d212b6d52b8ba27431d0d8e2">operator!=</a> (const <a class="el" href="classwpi_1_1memory_1_1memory__resource__allocator.html">memory_resource_allocator</a> &amp;lhs, const <a class="el" href="classwpi_1_1memory_1_1memory__resource__allocator.html">memory_resource_allocator</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:a3083c047d212b6d52b8ba27431d0d8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ababd0351cf353d579a6bafab9aa8b29a"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class Segregator , class Fallback &gt; </td></tr>
<tr class="memitem:ababd0351cf353d579a6bafab9aa8b29a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#ababd0351cf353d579a6bafab9aa8b29a">get_segregatable_allocator</a> (<a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt; Segregator, Fallback &gt; &amp;s) -&gt; <a class="el" href="namespacewpi_1_1memory.html#a1f754500044a675a6c2820cba487b394">segregatable_allocator_type</a>&lt; I, <a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt; Segregator, Fallback &gt; &gt; &amp;</td></tr>
<tr class="separator:ababd0351cf353d579a6bafab9aa8b29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b62de1899448095fcf1a01b8d57ff4"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class Segregator , class Fallback &gt; </td></tr>
<tr class="memitem:a77b62de1899448095fcf1a01b8d57ff4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a77b62de1899448095fcf1a01b8d57ff4">get_segregatable_allocator</a> (const <a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt; Segregator, Fallback &gt; &amp;s) -&gt; const <a class="el" href="namespacewpi_1_1memory.html#a1f754500044a675a6c2820cba487b394">segregatable_allocator_type</a>&lt; I, <a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt; Segregator, Fallback &gt; &gt;</td></tr>
<tr class="separator:a77b62de1899448095fcf1a01b8d57ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae2bc48c782d7e3799a9f4e8be8aa085b"><td class="memTemplParams" colspan="2">template&lt;class Segregator , class Fallback &gt; </td></tr>
<tr class="memitem:ae2bc48c782d7e3799a9f4e8be8aa085b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#ae2bc48c782d7e3799a9f4e8be8aa085b">get_fallback_allocator</a> (<a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt; Segregator, Fallback &gt; &amp;s) -&gt; <a class="el" href="namespacewpi_1_1memory.html#a226f6df0ddd808d944452b8210987fb5">fallback_allocator_type</a>&lt; <a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt; Segregator, Fallback &gt; &gt; &amp;</td></tr>
<tr class="separator:ae2bc48c782d7e3799a9f4e8be8aa085b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1928bde45f651f7a9e6f02a76beb44"><td class="memTemplParams" colspan="2">template&lt;class Segregator , class Fallback &gt; </td></tr>
<tr class="memitem:a5d1928bde45f651f7a9e6f02a76beb44"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html#a5d1928bde45f651f7a9e6f02a76beb44">get_fallback_allocator</a> (const <a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt; Segregator, Fallback &gt; &amp;s) -&gt; const <a class="el" href="namespacewpi_1_1memory.html#a226f6df0ddd808d944452b8210987fb5">fallback_allocator_type</a>&lt; <a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt; Segregator, Fallback &gt; &gt; &amp;</td></tr>
<tr class="separator:a5d1928bde45f651f7a9e6f02a76beb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga638f9e52b33b10f14e50de5beb306976"><td class="memItemLeft" align="right" valign="top">const std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__allocator.html#ga638f9e52b33b10f14e50de5beb306976">virtual_memory_page_size</a></td></tr>
<tr class="memdesc:ga638f9e52b33b10f14e50de5beb306976"><td class="mdescLeft">&#160;</td><td class="mdescRight">The page size of the virtual memory.  <a href="group__allocator.html#ga638f9e52b33b10f14e50de5beb306976">More...</a><br /></td></tr>
<tr class="separator:ga638f9e52b33b10f14e50de5beb306976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga71ad064608460ad27607935f45a0ca69"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga71ad064608460ad27607935f45a0ca69">cached_arena</a> = true</td></tr>
<tr class="separator:ga71ad064608460ad27607935f45a0ca69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad457e2d02a734d669ba2490d2e4b0ef8"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gad457e2d02a734d669ba2490d2e4b0ef8">uncached_arena</a> = false</td></tr>
<tr class="separator:gad457e2d02a734d669ba2490d2e4b0ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Memory namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a392d09db7d4aace8b47eb6e4c3961961" name="a392d09db7d4aace8b47eb6e4c3961961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392d09db7d4aace8b47eb6e4c3961961">&#9670;&nbsp;</a></span>any_allocator_reference</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewpi_1_1memory.html#a392d09db7d4aace8b47eb6e4c3961961">wpi::memory::any_allocator_reference</a> = typedef <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a>&lt;<a class="el" href="group__storage.html#ga5f66436ef97dbadd6d75fa3f474695df">any_reference_storage</a>, <a class="el" href="structwpi_1_1memory_1_1no__mutex.html">no_mutex</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0325b003d5eeefc8f020b296a8b581af" name="a0325b003d5eeefc8f020b296a8b581af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0325b003d5eeefc8f020b296a8b581af">&#9670;&nbsp;</a></span>default_allocator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewpi_1_1memory.html#a0325b003d5eeefc8f020b296a8b581af">wpi::memory::default_allocator</a> = typedef <a class="el" href="config_8hpp.html#ad9ce7c7a9b4f995a3af52e594bc43e8d">WPI_IMPL_DEFINED</a>(<a class="el" href="config__impl_8hpp.html#ac4852d047c9c0379a72f743d8f55526a">WPI_MEMORY_IMPL_DEFAULT_ALLOCATOR</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a226f6df0ddd808d944452b8210987fb5" name="a226f6df0ddd808d944452b8210987fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226f6df0ddd808d944452b8210987fb5">&#9670;&nbsp;</a></span>fallback_allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Segregator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewpi_1_1memory.html#a226f6df0ddd808d944452b8210987fb5">wpi::memory::fallback_allocator_type</a> = typedef typename <a class="el" href="structwpi_1_1memory_1_1detail_1_1fallback__type.html">detail::fallback_type</a>&lt;Segregator&gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7d45e393fa087b34b4634e79203529b" name="ae7d45e393fa087b34b4634e79203529b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d45e393fa087b34b4634e79203529b">&#9670;&nbsp;</a></span>heap_allocator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewpi_1_1memory.html#ae7d45e393fa087b34b4634e79203529b">wpi::memory::heap_allocator</a> = typedef <a class="el" href="config_8hpp.html#ad9ce7c7a9b4f995a3af52e594bc43e8d">WPI_IMPL_DEFINED</a>(<a class="el" href="classwpi_1_1memory_1_1detail_1_1lowlevel__allocator.html">detail::lowlevel_allocator</a>&lt;<a class="el" href="structwpi_1_1memory_1_1detail_1_1heap__allocator__impl.html">detail::heap_allocator_impl</a>&gt;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af0f1bb450799856d89c262c855060ec8" name="af0f1bb450799856d89c262c855060ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f1bb450799856d89c262c855060ec8">&#9670;&nbsp;</a></span>make_block_allocator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockOrRawAllocator , template&lt; typename... &gt; class BlockAllocator = detail::default_block_wrapper&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewpi_1_1memory.html#af0f1bb450799856d89c262c855060ec8">wpi::memory::make_block_allocator_t</a> = typedef <a class="el" href="config_8hpp.html#ad9ce7c7a9b4f995a3af52e594bc43e8d">WPI_IMPL_DEFINED</a>( typename std::conditional&lt;<a class="el" href="structwpi_1_1memory_1_1is__block__allocator.html">is_block_allocator</a>&lt;BlockOrRawAllocator&gt;<a class="el" href="classvalue.html">::value</a>, BlockOrRawAllocator, BlockAllocator&lt;BlockOrRawAllocator&gt; &gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad68e616af8334ef045a86b633ba2c280" name="ad68e616af8334ef045a86b633ba2c280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68e616af8334ef045a86b633ba2c280">&#9670;&nbsp;</a></span>malloc_allocator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewpi_1_1memory.html#ad68e616af8334ef045a86b633ba2c280">wpi::memory::malloc_allocator</a> = typedef <a class="el" href="config_8hpp.html#ad9ce7c7a9b4f995a3af52e594bc43e8d">WPI_IMPL_DEFINED</a>(<a class="el" href="classwpi_1_1memory_1_1detail_1_1lowlevel__allocator.html">detail::lowlevel_allocator</a>&lt;<a class="el" href="structwpi_1_1memory_1_1detail_1_1malloc__allocator__impl.html">detail::malloc_allocator_impl</a>&gt;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7778578540eb33611902c32326c7e61" name="ac7778578540eb33611902c32326c7e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7778578540eb33611902c32326c7e61">&#9670;&nbsp;</a></span>new_allocator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewpi_1_1memory.html#ac7778578540eb33611902c32326c7e61">wpi::memory::new_allocator</a> = typedef <a class="el" href="config_8hpp.html#ad9ce7c7a9b4f995a3af52e594bc43e8d">WPI_IMPL_DEFINED</a>(<a class="el" href="classwpi_1_1memory_1_1detail_1_1lowlevel__allocator.html">detail::lowlevel_allocator</a>&lt;<a class="el" href="structwpi_1_1memory_1_1detail_1_1new__allocator__impl.html">detail::new_allocator_impl</a>&gt;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f754500044a675a6c2820cba487b394" name="a1f754500044a675a6c2820cba487b394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f754500044a675a6c2820cba487b394">&#9670;&nbsp;</a></span>segregatable_allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, class Segregator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewpi_1_1memory.html#a1f754500044a675a6c2820cba487b394">wpi::memory::segregatable_allocator_type</a> = typedef typename <a class="el" href="structwpi_1_1memory_1_1detail_1_1segregatable__type.html">detail::segregatable_type</a>&lt;I, Segregator&gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1ad71e94176eddd2fe4eab53c41fca57" name="a1ad71e94176eddd2fe4eab53c41fca57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad71e94176eddd2fe4eab53c41fca57">&#9670;&nbsp;</a></span>allocate_shared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; T &gt; wpi::memory::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">RawAllocator &amp;&amp;&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d229612a188065f737d428f97947653" name="a1d229612a188065f737d428f97947653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d229612a188065f737d428f97947653">&#9670;&nbsp;</a></span>allocate_unique() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::memory::allocate_unique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwpi_1_1memory_1_1any__allocator.html">any_allocator</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RawAllocator &amp;&amp;&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="utility_8hpp.html#a4c25ba24150b80a31b9cfd323d73e4b4">WPI_REQUIRES_RET</a>(!std::is_array&lt;T&gt;<a class="el" href="classvalue.html">::value</a>,
                                      std::unique_ptr&lt;T, <a class="el" href="classwpi_1_1memory_1_1allocator__deleter.html">allocator_deleter</a>&lt;T, <a class="el" href="structwpi_1_1memory_1_1any__allocator.html">any_allocator</a>&gt;&gt;)
        </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a839f3c73949039b496b4815fe51e9304" name="a839f3c73949039b496b4815fe51e9304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839f3c73949039b496b4815fe51e9304">&#9670;&nbsp;</a></span>allocate_unique() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::memory::allocate_unique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwpi_1_1memory_1_1any__allocator.html">any_allocator</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RawAllocator &amp;&amp;&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="utility_8hpp.html#a4c25ba24150b80a31b9cfd323d73e4b4">WPI_REQUIRES_RET</a>(std::is_array&lt;T&gt;<a class="el" href="classvalue.html">::value</a>,
                                      std::unique_ptr&lt;T, <a class="el" href="classwpi_1_1memory_1_1allocator__deleter.html">allocator_deleter</a>&lt;T, <a class="el" href="structwpi_1_1memory_1_1any__allocator.html">any_allocator</a>&gt;&gt;)
        </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9eb21e670ab68dc35ac728ccf62f6c34" name="a9eb21e670ab68dc35ac728ccf62f6c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb21e670ab68dc35ac728ccf62f6c34">&#9670;&nbsp;</a></span>allocate_unique() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::memory::allocate_unique </td>
          <td>(</td>
          <td class="paramtype">RawAllocator &amp;&amp;&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="utility_8hpp.html#a4c25ba24150b80a31b9cfd323d73e4b4">WPI_REQUIRES_RET</a>(
            !std::is_array&lt;T&gt;<a class="el" href="classvalue.html">::value</a>,
            std::unique_ptr&lt;T, <a class="el" href="classwpi_1_1memory_1_1allocator__deleter.html">allocator_deleter</a>&lt;T, typename std::decay&lt;RawAllocator&gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a>&gt;&gt;)
        </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac822d9f36329123c4192b68179f46be4" name="ac822d9f36329123c4192b68179f46be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac822d9f36329123c4192b68179f46be4">&#9670;&nbsp;</a></span>allocate_unique() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::memory::allocate_unique </td>
          <td>(</td>
          <td class="paramtype">RawAllocator &amp;&amp;&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="utility_8hpp.html#a4c25ba24150b80a31b9cfd323d73e4b4">WPI_REQUIRES_RET</a>(
            std::is_array&lt;T&gt;<a class="el" href="classvalue.html">::value</a>,
            std::unique_ptr&lt;T, <a class="el" href="classwpi_1_1memory_1_1allocator__deleter.html">allocator_deleter</a>&lt;T, typename std::decay&lt;RawAllocator&gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a>&gt;&gt;)
        </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2bc48c782d7e3799a9f4e8be8aa085b" name="ae2bc48c782d7e3799a9f4e8be8aa085b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2bc48c782d7e3799a9f4e8be8aa085b">&#9670;&nbsp;</a></span>get_fallback_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Segregator , class Fallback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::memory::get_fallback_allocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt; Segregator, Fallback &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespacewpi_1_1memory.html#a226f6df0ddd808d944452b8210987fb5">fallback_allocator_type</a>&lt;<a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt;Segregator, Fallback&gt;&gt;&amp;
        </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d1928bde45f651f7a9e6f02a76beb44" name="a5d1928bde45f651f7a9e6f02a76beb44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1928bde45f651f7a9e6f02a76beb44">&#9670;&nbsp;</a></span>get_fallback_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Segregator , class Fallback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::memory::get_fallback_allocator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt; Segregator, Fallback &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> -&gt; const <a class="el" href="namespacewpi_1_1memory.html#a226f6df0ddd808d944452b8210987fb5">fallback_allocator_type</a>&lt;<a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt;Segregator, Fallback&gt;&gt;&amp;
        </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ababd0351cf353d579a6bafab9aa8b29a" name="ababd0351cf353d579a6bafab9aa8b29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ababd0351cf353d579a6bafab9aa8b29a">&#9670;&nbsp;</a></span>get_segregatable_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, class Segregator , class Fallback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::memory::get_segregatable_allocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt; Segregator, Fallback &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespacewpi_1_1memory.html#a1f754500044a675a6c2820cba487b394">segregatable_allocator_type</a>&lt;I, <a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt;Segregator, Fallback&gt;&gt;&amp;
        </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77b62de1899448095fcf1a01b8d57ff4" name="a77b62de1899448095fcf1a01b8d57ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b62de1899448095fcf1a01b8d57ff4">&#9670;&nbsp;</a></span>get_segregatable_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, class Segregator , class Fallback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::memory::get_segregatable_allocator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt; Segregator, Fallback &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> -&gt; const <a class="el" href="namespacewpi_1_1memory.html#a1f754500044a675a6c2820cba487b394">segregatable_allocator_type</a>&lt;I, <a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt;Segregator, Fallback&gt;&gt;
        </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f311d60d4857926d16396fc6a3be15a" name="a7f311d60d4857926d16396fc6a3be15a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f311d60d4857926d16396fc6a3be15a">&#9670;&nbsp;</a></span>get_temporary_stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1memory_1_1temporary__stack.html">temporary_stack</a> &amp; get_temporary_stack </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>initial_size</em> = <code><a class="el" href="classwpi_1_1memory_1_1temporary__stack__initializer.html#a0865fd66d723b06d205efe6a295bfa0c">temporary_stack_initializer::default_stack_size</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>\effects Creates the per-thread <a class="el" href="classwpi_1_1memory_1_1temporary__stack.html">temporary_stack</a> with the given initial size, if it wasn't already created. </p>
<dl class="section return"><dt>Returns</dt><dd>The per-thread <a class="el" href="classwpi_1_1memory_1_1temporary__stack.html">temporary_stack</a>. \requires There must be a per-thread temporary stack (<a class="el" href="config__impl_8hpp.html#a1cf12a43d0d3af418c32a76a4572eb57">WPI_MEMORY_TEMPORARY_STACK_MODE</a> must not be equal to <code>0</code>). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <a class="el" href="config__impl_8hpp.html#a1cf12a43d0d3af418c32a76a4572eb57">WPI_MEMORY_TEMPORARY_STACK_MODE</a> is equal to <code>1</code>, this function can create the temporary stack. But if there is no <a class="el" href="classwpi_1_1memory_1_1temporary__stack__initializer.html">temporary_stack_initializer</a>, it won't be destroyed. </dd></dl>

</div>
</div>
<a id="aadbfe56850e983927e8a47d82b565f1e" name="aadbfe56850e983927e8a47d82b565f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadbfe56850e983927e8a47d82b565f1e">&#9670;&nbsp;</a></span>make_block_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockOrRawAllocator , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacewpi_1_1memory.html#af0f1bb450799856d89c262c855060ec8">make_block_allocator_t</a>&lt; BlockOrRawAllocator &gt; wpi::memory::make_block_allocator </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2818c818ef45e69d31b01b11e0e8bb7b" name="a2818c818ef45e69d31b01b11e0e8bb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2818c818ef45e69d31b01b11e0e8bb7b">&#9670;&nbsp;</a></span>make_block_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class... &gt; class BlockAllocator, class BlockOrRawAllocator , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacewpi_1_1memory.html#af0f1bb450799856d89c262c855060ec8">make_block_allocator_t</a>&lt; BlockOrRawAllocator, BlockAllocator &gt; wpi::memory::make_block_allocator </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a503c488b57684eb030d24c644b4d862a" name="a503c488b57684eb030d24c644b4d862a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503c488b57684eb030d24c644b4d862a">&#9670;&nbsp;</a></span>make_deeply_tracked_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RawAllocator , class Tracker , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::memory::make_deeply_tracked_allocator </td>
          <td>(</td>
          <td class="paramtype">Tracker&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; deeply_tracked_allocator&lt;Tracker, RawAllocator&gt;
        </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37f596862c12bf216230bf62df611014" name="a37f596862c12bf216230bf62df611014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f596862c12bf216230bf62df611014">&#9670;&nbsp;</a></span>make_priority_queue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator , class Container  = deque&lt;T, RawAllocator&gt;, class Compare  = std::less&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::priority_queue&lt; T, Container, Compare &gt; wpi::memory::make_priority_queue </td>
          <td>(</td>
          <td class="paramtype">RawAllocator &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ab060b6ef926a7d11d224db99f19bf708" name="ab060b6ef926a7d11d224db99f19bf708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab060b6ef926a7d11d224db99f19bf708">&#9670;&nbsp;</a></span>make_queue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator , class Container  = deque&lt;T, RawAllocator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::queue&lt; T, Container &gt; wpi::memory::make_queue </td>
          <td>(</td>
          <td class="paramtype">RawAllocator &amp;&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a1d38ee5d6a9b2d723f259c2c4607622f" name="a1d38ee5d6a9b2d723f259c2c4607622f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d38ee5d6a9b2d723f259c2c4607622f">&#9670;&nbsp;</a></span>make_stack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator , class Container  = deque&lt;T, RawAllocator&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::stack&lt; T, Container &gt; wpi::memory::make_stack </td>
          <td>(</td>
          <td class="paramtype">RawAllocator &amp;&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a23b25fd8dd24cad7eb49ad308f7d14fc" name="a23b25fd8dd24cad7eb49ad308f7d14fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b25fd8dd24cad7eb49ad308f7d14fc">&#9670;&nbsp;</a></span>make_tracked_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tracker , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::memory::make_tracked_allocator </td>
          <td>(</td>
          <td class="paramtype">Tracker&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RawAllocator &amp;&amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classwpi_1_1memory_1_1tracked__allocator.html">tracked_allocator</a>&lt;Tracker, typename std::decay&lt;RawAllocator&gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a>&gt;
        </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac1cd336eb08ccc5224fa69660fd47a6" name="aac1cd336eb08ccc5224fa69660fd47a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1cd336eb08ccc5224fa69660fd47a6">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="_array_cwise_unary_ops_8h.html#aa198852a6b380257ea3e34c8f7e6e250">wpi::memory::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1memory_1_1joint__allocator.html">joint_allocator</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1memory_1_1joint__allocator.html">joint_allocator</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3083c047d212b6d52b8ba27431d0d8e2" name="a3083c047d212b6d52b8ba27431d0d8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3083c047d212b6d52b8ba27431d0d8e2">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="_array_cwise_unary_ops_8h.html#aa198852a6b380257ea3e34c8f7e6e250">wpi::memory::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1memory_1_1memory__resource__allocator.html">memory_resource_allocator</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1memory_1_1memory__resource__allocator.html">memory_resource_allocator</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5264ae0d5d04ad3175df9f5063ecaa4" name="af5264ae0d5d04ad3175df9f5063ecaa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5264ae0d5d04ad3175df9f5063ecaa4">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="_array_cwise_unary_ops_8h.html#aa198852a6b380257ea3e34c8f7e6e250">wpi::memory::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf70288c708a52bf2cc49f97389179e1" name="abf70288c708a52bf2cc49f97389179e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf70288c708a52bf2cc49f97389179e1">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="_array_cwise_unary_ops_8h.html#aa198852a6b380257ea3e34c8f7e6e250">wpi::memory::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adc89098b5cf93bab9d2ec6629d0af4f6" name="adc89098b5cf93bab9d2ec6629d0af4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc89098b5cf93bab9d2ec6629d0af4f6">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::memory::operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9341e2480e1ebc5809c6e2e08fd48102" name="a9341e2480e1ebc5809c6e2e08fd48102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9341e2480e1ebc5809c6e2e08fd48102">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::memory::operator== </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24426d9ba265765e4762dd23e2a9f70a" name="a24426d9ba265765e4762dd23e2a9f70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24426d9ba265765e4762dd23e2a9f70a">&#9670;&nbsp;</a></span>threshold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1memory_1_1threshold__segregatable.html">threshold_segregatable</a>&lt; typename std::decay&lt; RawAllocator &gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a> &gt; wpi::memory::threshold </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RawAllocator &amp;&amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classwpi_1_1memory_1_1threshold__segregatable.html">threshold_segregatable</a> with the same parameter. </dd></dl>

</div>
</div>
<a id="a81c0b4bfaf4b7066043a77d9bf36da28" name="a81c0b4bfaf4b7066043a77d9bf36da28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c0b4bfaf4b7066043a77d9bf36da28">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[1/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">allocator_adapter&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a>&lt; <a class="el" href="classwpi_1_1memory_1_1direct__storage.html">direct_storage</a>&lt; RawAllocator &gt;, <a class="el" href="structwpi_1_1memory_1_1no__mutex.html">no_mutex</a> &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee98bf1c027ffa33eae0086d6385c33b" name="aee98bf1c027ffa33eae0086d6385c33b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee98bf1c027ffa33eae0086d6385c33b">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[2/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">any_std_allocator&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, <a class="el" href="structwpi_1_1memory_1_1any__allocator.html">any_allocator</a> &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ea1d3eceff768dc0fa3f074cef3970f" name="a7ea1d3eceff768dc0fa3f074cef3970f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea1d3eceff768dc0fa3f074cef3970f">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[3/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tracker , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">deeply_tracked_allocator&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1memory_1_1tracked__allocator.html">tracked_allocator</a>&lt; Tracker, <a class="el" href="namespacewpi_1_1memory_1_1detail.html#abfcc9a0a376d15210cca3deca1b242a8">detail::rebound_allocator</a>&lt; Tracker, RawAllocator &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a89dbeb32b6f6af9f6092efce4c0be0ec" name="a89dbeb32b6f6af9f6092efce4c0be0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89dbeb32b6f6af9f6092efce4c0be0ec">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[4/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">deque&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::deque&lt; T, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a23d3174f75a094039ffe76bc39eeb333" name="a23d3174f75a094039ffe76bc39eeb333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d3174f75a094039ffe76bc39eeb333">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[5/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">deque_scoped_alloc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::deque&lt; T, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a5f014318674394fca334aa05ab970a7a" name="a5f014318674394fca334aa05ab970a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f014318674394fca334aa05ab970a7a">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[6/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">forward_list&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_list&lt; T, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ad256dce3c10cf4d4280cc8375c52df5e" name="ad256dce3c10cf4d4280cc8375c52df5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad256dce3c10cf4d4280cc8375c52df5e">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[7/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">forward_list_scoped_alloc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_list&lt; T, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a51522d791dda7bbbe1f2679179e4afb2" name="a51522d791dda7bbbe1f2679179e4afb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51522d791dda7bbbe1f2679179e4afb2">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[8/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">list&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; T, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="aa1d6c96847fea79a44fbb389995128c8" name="aa1d6c96847fea79a44fbb389995128c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d6c96847fea79a44fbb389995128c8">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[9/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">list_scoped_alloc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; T, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a7faeb0f94d62ebb6d589ad21e4d13999" name="a7faeb0f94d62ebb6d589ad21e4d13999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7faeb0f94d62ebb6d589ad21e4d13999">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[10/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">map&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; Key, Value, std::less&lt; Key &gt;, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; std::pair&lt; const Key, Value &gt;, RawAllocator &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="aae0afaf9caf0b61137acff15ac6f0608" name="aae0afaf9caf0b61137acff15ac6f0608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0afaf9caf0b61137acff15ac6f0608">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[11/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">map_scoped_alloc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; Key, Value, std::less&lt; Key &gt;, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; std::pair&lt; const Key, Value &gt;, RawAllocator &gt; &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ae76d7787e9475cd39b4aa6899580a589" name="ae76d7787e9475cd39b4aa6899580a589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76d7787e9475cd39b4aa6899580a589">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[12/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">multimap&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::multimap&lt; Key, Value, std::less&lt; Key &gt;, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; std::pair&lt; const Key, Value &gt;, RawAllocator &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a10a47953bbabf90533f7b9b588324cd6" name="a10a47953bbabf90533f7b9b588324cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a47953bbabf90533f7b9b588324cd6">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[13/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">multimap_scoped_alloc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::multimap&lt; Key, Value, std::less&lt; Key &gt;, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; std::pair&lt; const Key, Value &gt;, RawAllocator &gt; &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ac6a5c3d0d19e4c6670fa5f0d11c78f61" name="ac6a5c3d0d19e4c6670fa5f0d11c78f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a5c3d0d19e4c6670fa5f0d11c78f61">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[14/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">multiset&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::multiset&lt; T, std::less&lt; T &gt;, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a9fa5f98f8edccf8219c7526d9873688e" name="a9fa5f98f8edccf8219c7526d9873688e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa5f98f8edccf8219c7526d9873688e">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[15/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">multiset_scoped_alloc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::multiset&lt; T, std::less&lt; T &gt;, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a2f4ea696b25374ce799c9b7298ca80c3" name="a2f4ea696b25374ce799c9b7298ca80c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4ea696b25374ce799c9b7298ca80c3">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[16/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1priority__queue.html">priority_queue</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::priority_queue&lt; T, deque&lt; T, RawAllocator &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a82cef9d2a42bfedef0c114e339a16a64" name="a82cef9d2a42bfedef0c114e339a16a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82cef9d2a42bfedef0c114e339a16a64">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[17/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">priority_queue_scoped_alloc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::priority_queue&lt; T, deque_scoped_alloc&lt; T, RawAllocator &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ada6f4868f2f82be8d176210465456797" name="ada6f4868f2f82be8d176210465456797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6f4868f2f82be8d176210465456797">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[18/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">queue&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::queue&lt; T, deque&lt; T, RawAllocator &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ab0171a2a19ecb2069fcd730ce25db1dc" name="ab0171a2a19ecb2069fcd730ce25db1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0171a2a19ecb2069fcd730ce25db1dc">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[19/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">queue_scoped_alloc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::queue&lt; T, deque_scoped_alloc&lt; T, RawAllocator &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a2e4ef5c795a91a60c48275e56259ceec" name="a2e4ef5c795a91a60c48275e56259ceec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4ef5c795a91a60c48275e56259ceec">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[20/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Allocators&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">segregator&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structwpi_1_1memory_1_1detail_1_1make__segregator__t.html">detail::make_segregator_t</a>&lt; Allocators... &gt;<a class="el" href="core_8h.html#a7aead736a07eaf25623ad7bfa1f0ee2d">::type</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb94f5c67d5b2ca82051c66205a1902d" name="abb94f5c67d5b2ca82051c66205a1902d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb94f5c67d5b2ca82051c66205a1902d">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[21/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">set&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; T, std::less&lt; T &gt;, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a93efe59f6da1620e668aff609c437e57" name="a93efe59f6da1620e668aff609c437e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93efe59f6da1620e668aff609c437e57">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[22/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">set_scoped_alloc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; T, std::less&lt; T &gt;, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a072b15e4e51dd97654f3792bb786912d" name="a072b15e4e51dd97654f3792bb786912d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072b15e4e51dd97654f3792bb786912d">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[23/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">stack&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::stack&lt; T, deque&lt; T, RawAllocator &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a8b88b2ea4adef34ef6edb6b7448b6a3a" name="a8b88b2ea4adef34ef6edb6b7448b6a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b88b2ea4adef34ef6edb6b7448b6a3a">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[24/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">stack_scoped_alloc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::stack&lt; T, deque_scoped_alloc&lt; T, RawAllocator &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a05a8779f77b2046839555575ba263041" name="a05a8779f77b2046839555575ba263041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a8779f77b2046839555575ba263041">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[25/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; char, std::char_traits&lt; char &gt;, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; char, RawAllocator &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a8e772ce8acf3ad961f92ae76df97cc77" name="a8e772ce8acf3ad961f92ae76df97cc77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e772ce8acf3ad961f92ae76df97cc77">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[26/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BaseType , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">unique_base_ptr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; BaseType, <a class="el" href="classwpi_1_1memory_1_1allocator__polymorphic__deleter.html">allocator_polymorphic_deleter</a>&lt; BaseType, RawAllocator &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0bb256351fc5b5791f7ec1d5adf492d" name="ac0bb256351fc5b5791f7ec1d5adf492d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0bb256351fc5b5791f7ec1d5adf492d">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[27/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">unique_ptr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; T, <a class="el" href="classwpi_1_1memory_1_1allocator__deleter.html">allocator_deleter</a>&lt; T, RawAllocator &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace913ef67456190aa2e0b953ca90cd38" name="ace913ef67456190aa2e0b953ca90cd38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace913ef67456190aa2e0b953ca90cd38">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[28/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">unordered_map&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; Key, Value, std::hash&lt; Key &gt;, std::equal_to&lt; Key &gt;, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; std::pair&lt; const Key, Value &gt;, RawAllocator &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a5b30ee88be0e8c3db3c8d9928eef82c9" name="a5b30ee88be0e8c3db3c8d9928eef82c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b30ee88be0e8c3db3c8d9928eef82c9">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[29/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">unordered_map_scoped_alloc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; Key, Value, std::hash&lt; Key &gt;, std::equal_to&lt; Key &gt;, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; std::pair&lt; const Key, Value &gt;, RawAllocator &gt; &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="af8321304a3f18feb490f1d0910f18d4a" name="af8321304a3f18feb490f1d0910f18d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8321304a3f18feb490f1d0910f18d4a">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[30/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">unordered_multimap&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_multimap&lt; Key, Value, std::hash&lt; Key &gt;, std::equal_to&lt; Key &gt;, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; std::pair&lt; const Key, Value &gt;, RawAllocator &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a75afbc771d3d27e65b491be16cab098b" name="a75afbc771d3d27e65b491be16cab098b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75afbc771d3d27e65b491be16cab098b">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[31/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">unordered_multimap_scoped_alloc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_multimap&lt; Key, Value, std::hash&lt; Key &gt;, std::equal_to&lt; Key &gt;, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; std::pair&lt; const Key, Value &gt;, RawAllocator &gt; &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ae2cfccf3bc6b8a1f26eb81fd96f2d8a3" name="ae2cfccf3bc6b8a1f26eb81fd96f2d8a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2cfccf3bc6b8a1f26eb81fd96f2d8a3">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[32/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">unordered_multiset&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_multiset&lt; T, std::hash&lt; T &gt;, std::equal_to&lt; T &gt;, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ab824087c1ee4957808700550288b483d" name="ab824087c1ee4957808700550288b483d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab824087c1ee4957808700550288b483d">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[33/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">unordered_multiset_scoped_alloc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_multiset&lt; T, std::hash&lt; T &gt;, std::equal_to&lt; T &gt;, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a408432bed2e39ec711f4758efe6c3cb7" name="a408432bed2e39ec711f4758efe6c3cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a408432bed2e39ec711f4758efe6c3cb7">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[34/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">unordered_set&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_set&lt; T, std::hash&lt; T &gt;, std::equal_to&lt; T &gt;, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a5b55eb3b6d648255448390e95c2322e6" name="a5b55eb3b6d648255448390e95c2322e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b55eb3b6d648255448390e95c2322e6">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[35/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">unordered_set_scoped_alloc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_set&lt; T, std::hash&lt; T &gt;, std::equal_to&lt; T &gt;, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a1e35a2b77ea2d9b624e4715645c2fefb" name="a1e35a2b77ea2d9b624e4715645c2fefb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e35a2b77ea2d9b624e4715645c2fefb">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[36/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">vector&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T, <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a309ebac122e14c87a53cf09929657aa4" name="a309ebac122e14c87a53cf09929657aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309ebac122e14c87a53cf09929657aa4">&#9670;&nbsp;</a></span>WPI_ALIAS_TEMPLATE() <span class="overload">[37/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::memory::WPI_ALIAS_TEMPLATE </td>
          <td>(</td>
          <td class="paramtype">vector_scoped_alloc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T, std::scoped_allocator_adaptor&lt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, RawAllocator &gt; &gt; &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above but uses <code>std::scoped_allocator_adaptor</code> so the allocator is inherited by all nested containers. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacewpi.html">wpi</a></li><li class="navelem"><a class="el" href="namespacewpi_1_1memory.html">memory</a></li>
    <li class="footer">Generated on Tue Oct 4 2022 19:41:10 for WPILibC++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
