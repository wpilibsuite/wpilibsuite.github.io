<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: frc::SwerveDriveKinematics&lt; NumModules &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">WPILibC++
   &#160;<span id="projectnumber">2021.2.2-69-g6e31230</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classfrc_1_1SwerveDriveKinematics.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classfrc_1_1SwerveDriveKinematics-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">frc::SwerveDriveKinematics&lt; NumModules &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Helper class that converts a chassis velocity (dx, dy, and dtheta components) into individual module states (speed and angle).  
 <a href="classfrc_1_1SwerveDriveKinematics.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SwerveDriveKinematics_8h_source.html">frc/kinematics/SwerveDriveKinematics.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab3e7aa018b138375414924e0493b73cd"><td class="memTemplParams" colspan="2">template&lt;typename... Wheels&gt; </td></tr>
<tr class="memitem:ab3e7aa018b138375414924e0493b73cd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfrc_1_1SwerveDriveKinematics.html#ab3e7aa018b138375414924e0493b73cd">SwerveDriveKinematics</a> (<a class="el" href="classfrc_1_1Translation2d.html">Translation2d</a> wheel, Wheels &amp;&amp;... wheels)</td></tr>
<tr class="memdesc:ab3e7aa018b138375414924e0493b73cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a swerve drive kinematics object.  <a href="classfrc_1_1SwerveDriveKinematics.html#ab3e7aa018b138375414924e0493b73cd">More...</a><br /></td></tr>
<tr class="separator:ab3e7aa018b138375414924e0493b73cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46290b6ab3b6ec99157876d5cc731a4"><td class="memItemLeft" align="right" valign="top"><a id="ae46290b6ab3b6ec99157876d5cc731a4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SwerveDriveKinematics</b> (const <a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; <a class="el" href="classfrc_1_1Translation2d.html">Translation2d</a>, NumModules &gt; &amp;wheels)</td></tr>
<tr class="separator:ae46290b6ab3b6ec99157876d5cc731a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16db9e36af1eb6ddf4c4dd2a49717fbd"><td class="memItemLeft" align="right" valign="top"><a id="a16db9e36af1eb6ddf4c4dd2a49717fbd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SwerveDriveKinematics</b> (const <a class="el" href="classfrc_1_1SwerveDriveKinematics.html">SwerveDriveKinematics</a> &amp;)=default</td></tr>
<tr class="separator:a16db9e36af1eb6ddf4c4dd2a49717fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7815723eede9892d0669a216be0f39d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; <a class="el" href="structfrc_1_1SwerveModuleState.html">SwerveModuleState</a>, NumModules &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1SwerveDriveKinematics.html#ac7815723eede9892d0669a216be0f39d">ToSwerveModuleStates</a> (const <a class="el" href="structfrc_1_1ChassisSpeeds.html">ChassisSpeeds</a> &amp;chassisSpeeds, const <a class="el" href="classfrc_1_1Translation2d.html">Translation2d</a> &amp;centerOfRotation=<a class="el" href="classfrc_1_1Translation2d.html">Translation2d</a>()) const</td></tr>
<tr class="memdesc:ac7815723eede9892d0669a216be0f39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs inverse kinematics to return the module states from a desired chassis velocity.  <a href="classfrc_1_1SwerveDriveKinematics.html#ac7815723eede9892d0669a216be0f39d">More...</a><br /></td></tr>
<tr class="separator:ac7815723eede9892d0669a216be0f39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8939ecc3902e895b0489b9eec7e78c"><td class="memTemplParams" colspan="2">template&lt;typename... ModuleStates&gt; </td></tr>
<tr class="memitem:a1b8939ecc3902e895b0489b9eec7e78c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structfrc_1_1ChassisSpeeds.html">ChassisSpeeds</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfrc_1_1SwerveDriveKinematics.html#a1b8939ecc3902e895b0489b9eec7e78c">ToChassisSpeeds</a> (ModuleStates &amp;&amp;... wheelStates) const</td></tr>
<tr class="memdesc:a1b8939ecc3902e895b0489b9eec7e78c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs forward kinematics to return the resulting chassis state from the given module states.  <a href="classfrc_1_1SwerveDriveKinematics.html#a1b8939ecc3902e895b0489b9eec7e78c">More...</a><br /></td></tr>
<tr class="separator:a1b8939ecc3902e895b0489b9eec7e78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523767a39928074a218f4d7ac30fa267"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfrc_1_1ChassisSpeeds.html">ChassisSpeeds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1SwerveDriveKinematics.html#a523767a39928074a218f4d7ac30fa267">ToChassisSpeeds</a> (<a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; <a class="el" href="structfrc_1_1SwerveModuleState.html">SwerveModuleState</a>, NumModules &gt; moduleStates) const</td></tr>
<tr class="memdesc:a523767a39928074a218f4d7ac30fa267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs forward kinematics to return the resulting chassis state from the given module states.  <a href="classfrc_1_1SwerveDriveKinematics.html#a523767a39928074a218f4d7ac30fa267">More...</a><br /></td></tr>
<tr class="separator:a523767a39928074a218f4d7ac30fa267"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a672ce4d8bb476e29b67d757f46eb14dc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1SwerveDriveKinematics.html#a672ce4d8bb476e29b67d757f46eb14dc">NormalizeWheelSpeeds</a> (<a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; <a class="el" href="structfrc_1_1SwerveModuleState.html">SwerveModuleState</a>, NumModules &gt; *moduleStates, units::meters_per_second_t attainableMaxSpeed)</td></tr>
<tr class="memdesc:a672ce4d8bb476e29b67d757f46eb14dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the wheel speeds using some max attainable speed.  <a href="classfrc_1_1SwerveDriveKinematics.html#a672ce4d8bb476e29b67d757f46eb14dc">More...</a><br /></td></tr>
<tr class="separator:a672ce4d8bb476e29b67d757f46eb14dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;size_t NumModules&gt;<br />
class frc::SwerveDriveKinematics&lt; NumModules &gt;</h3>

<p>Helper class that converts a chassis velocity (dx, dy, and dtheta components) into individual module states (speed and angle). </p>
<p>The inverse kinematics (converting from a desired chassis velocity to individual module states) uses the relative locations of the modules with respect to the center of rotation. The center of rotation for inverse kinematics is also variable. This means that you can set your set your center of rotation in a corner of the robot to perform special evasion maneuvers.</p>
<p>Forward kinematics (converting an array of module states into the overall chassis motion) is performs the exact opposite of what inverse kinematics does. Since this is an overdetermined system (more equations than variables), we use a least-squares approximation.</p>
<p>The inverse kinematics: [moduleStates] = [moduleLocations] * [chassisSpeeds] We take the Moore-Penrose pseudoinverse of [moduleLocations] and then multiply by [moduleStates] to get our chassis speeds.</p>
<p>Forward kinematics is also used for odometry &ndash; determining the position of the robot on the field using encoders and a gyro. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab3e7aa018b138375414924e0493b73cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e7aa018b138375414924e0493b73cd">&#9670;&nbsp;</a></span>SwerveDriveKinematics()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
<div class="memtemplate">
template&lt;typename... Wheels&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfrc_1_1SwerveDriveKinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::<a class="el" href="classfrc_1_1SwerveDriveKinematics.html">SwerveDriveKinematics</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfrc_1_1Translation2d.html">Translation2d</a>&#160;</td>
          <td class="paramname"><em>wheel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Wheels &amp;&amp;...&#160;</td>
          <td class="paramname"><em>wheels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a swerve drive kinematics object. </p>
<p>This takes in a variable number of wheel locations as Translation2ds. The order in which you pass in the wheel locations is the same order that you will receive the module states when performing inverse kinematics. It is also expected that you pass in the module states in the same order when calling the forward kinematics methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wheels</td><td>The locations of the wheels relative to the physical center of the robot. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a672ce4d8bb476e29b67d757f46eb14dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672ce4d8bb476e29b67d757f46eb14dc">&#9670;&nbsp;</a></span>NormalizeWheelSpeeds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfrc_1_1SwerveDriveKinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::NormalizeWheelSpeeds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; <a class="el" href="structfrc_1_1SwerveModuleState.html">SwerveModuleState</a>, NumModules &gt; *&#160;</td>
          <td class="paramname"><em>moduleStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">units::meters_per_second_t&#160;</td>
          <td class="paramname"><em>attainableMaxSpeed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalizes the wheel speeds using some max attainable speed. </p>
<p>Sometimes, after inverse kinematics, the requested speed from a/several modules may be above the max attainable speed for the driving motor on that module. To fix this issue, one can "normalize" all the wheel speeds to make sure that all requested module speeds are below the absolute threshold, while maintaining the ratio of speeds between modules.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleStates</td><td>Reference to array of module states. The array will be mutated with the normalized speeds! </td></tr>
    <tr><td class="paramname">attainableMaxSpeed</td><td>The absolute max speed that a module can reach. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b8939ecc3902e895b0489b9eec7e78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8939ecc3902e895b0489b9eec7e78c">&#9670;&nbsp;</a></span>ToChassisSpeeds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
<div class="memtemplate">
template&lt;typename... ModuleStates&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfrc_1_1ChassisSpeeds.html">ChassisSpeeds</a> <a class="el" href="classfrc_1_1SwerveDriveKinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::ToChassisSpeeds </td>
          <td>(</td>
          <td class="paramtype">ModuleStates &amp;&amp;...&#160;</td>
          <td class="paramname"><em>wheelStates</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs forward kinematics to return the resulting chassis state from the given module states. </p>
<p>This method is often used for odometry &ndash; determining the robot's position on the field using data from the real-world speed and angle of each module on the robot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wheelStates</td><td>The state of the modules (as a <a class="el" href="structfrc_1_1SwerveModuleState.html" title="Represents the state of one swerve module.">SwerveModuleState</a> type) as measured from respective encoders and gyros. The order of the swerve module states should be same as passed into the constructor of this class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting chassis speed. </dd></dl>

</div>
</div>
<a id="a523767a39928074a218f4d7ac30fa267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523767a39928074a218f4d7ac30fa267">&#9670;&nbsp;</a></span>ToChassisSpeeds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfrc_1_1ChassisSpeeds.html">ChassisSpeeds</a> <a class="el" href="classfrc_1_1SwerveDriveKinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::ToChassisSpeeds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; <a class="el" href="structfrc_1_1SwerveModuleState.html">SwerveModuleState</a>, NumModules &gt;&#160;</td>
          <td class="paramname"><em>moduleStates</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs forward kinematics to return the resulting chassis state from the given module states. </p>
<p>This method is often used for odometry &ndash; determining the robot's position on the field using data from the real-world speed and angle of each module on the robot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleStates</td><td>The state of the modules as an <a class="el" href="classwpi_1_1array.html" title="This class is a wrapper around std::array that does compile time size checking.">wpi::array</a> of type <a class="el" href="structfrc_1_1SwerveModuleState.html" title="Represents the state of one swerve module.">SwerveModuleState</a>, NumModules long as measured from respective encoders and gyros. The order of the swerve module states should be same as passed into the constructor of this class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting chassis speed. </dd></dl>

</div>
</div>
<a id="ac7815723eede9892d0669a216be0f39d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7815723eede9892d0669a216be0f39d">&#9670;&nbsp;</a></span>ToSwerveModuleStates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; <a class="el" href="structfrc_1_1SwerveModuleState.html">SwerveModuleState</a>, NumModules &gt; <a class="el" href="classfrc_1_1SwerveDriveKinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::ToSwerveModuleStates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfrc_1_1ChassisSpeeds.html">ChassisSpeeds</a> &amp;&#160;</td>
          <td class="paramname"><em>chassisSpeeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfrc_1_1Translation2d.html">Translation2d</a> &amp;&#160;</td>
          <td class="paramname"><em>centerOfRotation</em> = <code><a class="el" href="classfrc_1_1Translation2d.html">Translation2d</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs inverse kinematics to return the module states from a desired chassis velocity. </p>
<p>This method is often used to convert joystick values into module speeds and angles.</p>
<p>This function also supports variable centers of rotation. During normal operations, the center of rotation is usually the same as the physical center of the robot; therefore, the argument is defaulted to that use case. However, if you wish to change the center of rotation for evasive maneuvers, vision alignment, or for any other use case, you can do so.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chassisSpeeds</td><td>The desired chassis speed. </td></tr>
    <tr><td class="paramname">centerOfRotation</td><td>The center of rotation. For example, if you set the center of rotation at one corner of the robot and provide a chassis speed that only has a dtheta component, the robot will rotate around that corner.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array containing the module states. Use caution because these module states are not normalized. Sometimes, a user input may cause one of the module speeds to go above the attainable max velocity. Use the &lt;NormalizeWheelSpeeds&gt; function to rectify this issue. In addition, you can leverage the power of C++17 to directly assign the module states to variables:</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> [fl, fr, bl, br] = kinematics.ToSwerveModuleStates(chassisSpeeds);</div>
</div><!-- fragment --> 
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>frc/kinematics/<a class="el" href="SwerveDriveKinematics_8h_source.html">SwerveDriveKinematics.h</a></li>
<li>frc/kinematics/SwerveDriveKinematics.inc</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefrc.html">frc</a></li><li class="navelem"><a class="el" href="classfrc_1_1SwerveDriveKinematics.html">SwerveDriveKinematics</a></li>
    <li class="footer">Generated on Sun Apr 25 2021 03:09:20 for WPILibC++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
