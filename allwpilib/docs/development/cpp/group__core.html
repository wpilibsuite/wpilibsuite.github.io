<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: Core components</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="wpilib-128.png"/></td>
  <td id="projectalign">
   <div id="projectname">WPILibC++<span id="projectnumber">&#160;2023.1.1-beta-3-22-gd122e42</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__core.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#concepts">Concepts</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Core components</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1.html">wpi::memory::</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits that check whether a type models concept. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1for.html">wpi::memory::for</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory arena that manages huge memory blocks for a higher-level allocator. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1of.html">wpi::memory::of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">fixed size. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1br.html">wpi::memory::br</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits that check whether a type models concept&gt; It must either provide the necessary functions for the default traits specialization or has specialized it. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1and.html">wpi::memory::and</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a makes it a memory_resource. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1memory_1_1is.html">wpi::memory::is</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether or not a thread safe as-is. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1memory__block.html">wpi::memory::memory_block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory block.  <a href="structwpi_1_1memory_1_1memory__block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1allocator__is__raw__allocator_3_01std_1_1allocator_3_01_t_01_4_01_4.html">wpi::memory::allocator_is_raw_allocator&lt; std::allocator&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structwpi_1_1memory_1_1allocator__is__raw__allocator.html">allocator_is_raw_allocator</a> that allows <code>std::allocator</code> again.  <a href="structwpi_1_1memory_1_1allocator__is__raw__allocator_3_01std_1_1allocator_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1allocator__info.html">wpi::memory::allocator_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains information about an allocator.  <a href="structwpi_1_1memory_1_1allocator__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1out__of__memory.html">wpi::memory::out_of_memory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when a low level allocator runs out of memory.  <a href="classwpi_1_1memory_1_1out__of__memory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1out__of__fixed__memory.html">wpi::memory::out_of_fixed_memory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special case of <a class="el" href="classwpi_1_1memory_1_1out__of__memory.html">out_of_memory</a> errors thrown when a low-level allocator with a fixed size runs out of memory.  <a href="classwpi_1_1memory_1_1out__of__fixed__memory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1bad__allocation__size.html">wpi::memory::bad_allocation_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when an allocation size is bigger than the supported maximum.  <a href="classwpi_1_1memory_1_1bad__allocation__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1bad__node__size.html">wpi::memory::bad_node_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when the node size exceeds the supported maximum, i.e.  <a href="classwpi_1_1memory_1_1bad__node__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1bad__array__size.html">wpi::memory::bad_array_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when the array size exceeds the supported maximum, i.e.  <a href="classwpi_1_1memory_1_1bad__array__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1bad__alignment.html">wpi::memory::bad_alignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when the alignment exceeds the supported maximum, i.e.  <a href="classwpi_1_1memory_1_1bad__alignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1no__mutex.html">wpi::memory::no_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dummy <code>Mutex</code> class that does not lock anything.  <a href="structwpi_1_1memory_1_1no__mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa4b33e608d367597cf4f0a0e525999a7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">wpi::memory::leak_handler</a> = void(*)(const <a class="el" href="structwpi_1_1memory_1_1allocator__info.html">allocator_info</a> &amp;info, std::ptrdiff_t amount)</td></tr>
<tr class="memdesc:gaa4b33e608d367597cf4f0a0e525999a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the handler called when a memory leak is detected.  <a href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">More...</a><br /></td></tr>
<tr class="separator:gaa4b33e608d367597cf4f0a0e525999a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cab10357dccef1206a767c56cbbecb4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">wpi::memory::invalid_pointer_handler</a> = void(*)(const <a class="el" href="structwpi_1_1memory_1_1allocator__info.html">allocator_info</a> &amp;info, const void *<a class="el" href="format_8h.html#aa6ec2d4315570f27d9637ce3c770e787">ptr</a>)</td></tr>
<tr class="memdesc:ga5cab10357dccef1206a767c56cbbecb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the handler called when an invalid pointer is passed to a deallocation function.  <a href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">More...</a><br /></td></tr>
<tr class="separator:ga5cab10357dccef1206a767c56cbbecb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2838b189f63bb9505d4ec3ae9d572ee6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">wpi::memory::buffer_overflow_handler</a> = void(*)(const void *memory, std::size_t size, const void *<a class="el" href="format_8h.html#ab76a36e5b99a884b810fbd30211dd228">write_ptr</a>)</td></tr>
<tr class="memdesc:ga2838b189f63bb9505d4ec3ae9d572ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the handler called when a buffer under/overflow is detected.  <a href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">More...</a><br /></td></tr>
<tr class="separator:ga2838b189f63bb9505d4ec3ae9d572ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gadea26fb93affed8c409ec360412d762e"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gadea26fb93affed8c409ec360412d762e">wpi::memory::debug_magic</a> : unsigned char { <br />
&#160;&#160;<a class="el" href="group__core.html#ggadea26fb93affed8c409ec360412d762ea7bd4be20559c1a287369c8df4c117afe">wpi::memory::debug_magic::internal_memory</a> = 0xAB
, <a class="el" href="group__core.html#ggadea26fb93affed8c409ec360412d762eaa5c32a0fcc06d646d53c71b55c9cf5cb">wpi::memory::debug_magic::internal_freed_memory</a> = 0xFB
, <a class="el" href="group__core.html#ggadea26fb93affed8c409ec360412d762ea9e1988b82181dbe51272459a8ac8e0c0">wpi::memory::debug_magic::new_memory</a> = 0xCD
, <a class="el" href="group__core.html#ggadea26fb93affed8c409ec360412d762ea635e5f9da5635b909461fd93c09130ed">wpi::memory::debug_magic::freed_memory</a> = 0xDD
, <br />
&#160;&#160;<a class="el" href="group__core.html#ggadea26fb93affed8c409ec360412d762ea682318fff515ed43a48b718f46c21308">wpi::memory::debug_magic::alignment_memory</a> = 0xED
, <a class="el" href="group__core.html#ggadea26fb93affed8c409ec360412d762ea99ec421b05ddc9b5565897f6a0cfb360">wpi::memory::debug_magic::fence_memory</a> = 0xFD
<br />
 }</td></tr>
<tr class="memdesc:gadea26fb93affed8c409ec360412d762e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The magic values that are used for debug filling.  <a href="group__core.html#gadea26fb93affed8c409ec360412d762e">More...</a><br /></td></tr>
<tr class="separator:gadea26fb93affed8c409ec360412d762e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga834abe9622c747efdfa8619009d2e373"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">leak_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga834abe9622c747efdfa8619009d2e373">wpi::memory::set_leak_handler</a> (<a class="el" href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">leak_handler</a> h)</td></tr>
<tr class="memdesc:ga834abe9622c747efdfa8619009d2e373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the <a class="el" href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">leak_handler</a>.  <a href="group__core.html#ga834abe9622c747efdfa8619009d2e373">More...</a><br /></td></tr>
<tr class="separator:ga834abe9622c747efdfa8619009d2e373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa60befedaaf9af29fcf7ce4aa837cc6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">leak_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gaa60befedaaf9af29fcf7ce4aa837cc6e">wpi::memory::get_leak_handler</a> ()</td></tr>
<tr class="memdesc:gaa60befedaaf9af29fcf7ce4aa837cc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">leak_handler</a>.  <a href="group__core.html#gaa60befedaaf9af29fcf7ce4aa837cc6e">More...</a><br /></td></tr>
<tr class="separator:gaa60befedaaf9af29fcf7ce4aa837cc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8d5aef2a6a2d4e65cfcc0eeac06c02b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">invalid_pointer_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gab8d5aef2a6a2d4e65cfcc0eeac06c02b">wpi::memory::set_invalid_pointer_handler</a> (<a class="el" href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">invalid_pointer_handler</a> h)</td></tr>
<tr class="memdesc:gab8d5aef2a6a2d4e65cfcc0eeac06c02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the <a class="el" href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">invalid_pointer_handler</a>.  <a href="group__core.html#gab8d5aef2a6a2d4e65cfcc0eeac06c02b">More...</a><br /></td></tr>
<tr class="separator:gab8d5aef2a6a2d4e65cfcc0eeac06c02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34d9478573193d39208d340a6586f8a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">invalid_pointer_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga34d9478573193d39208d340a6586f8a1">wpi::memory::get_invalid_pointer_handler</a> ()</td></tr>
<tr class="memdesc:ga34d9478573193d39208d340a6586f8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">invalid_pointer_handler</a>.  <a href="group__core.html#ga34d9478573193d39208d340a6586f8a1">More...</a><br /></td></tr>
<tr class="separator:ga34d9478573193d39208d340a6586f8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93b00d2fd1d3cd1f85f5331cf843fac3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">buffer_overflow_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga93b00d2fd1d3cd1f85f5331cf843fac3">wpi::memory::set_buffer_overflow_handler</a> (<a class="el" href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">buffer_overflow_handler</a> h)</td></tr>
<tr class="memdesc:ga93b00d2fd1d3cd1f85f5331cf843fac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the <a class="el" href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">buffer_overflow_handler</a>.  <a href="group__core.html#ga93b00d2fd1d3cd1f85f5331cf843fac3">More...</a><br /></td></tr>
<tr class="separator:ga93b00d2fd1d3cd1f85f5331cf843fac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddb4989826b25f0f3d833c871cd74a0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">buffer_overflow_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gaddb4989826b25f0f3d833c871cd74a0d">wpi::memory::get_buffer_overflow_handler</a> ()</td></tr>
<tr class="memdesc:gaddb4989826b25f0f3d833c871cd74a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">buffer_overflow_handler</a>.  <a href="group__core.html#gaddb4989826b25f0f3d833c871cd74a0d">More...</a><br /></td></tr>
<tr class="separator:gaddb4989826b25f0f3d833c871cd74a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71ad064608460ad27607935f45a0ca69"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga71ad064608460ad27607935f45a0ca69">wpi::memory::cached_arena</a> = true</td></tr>
<tr class="separator:ga71ad064608460ad27607935f45a0ca69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad457e2d02a734d669ba2490d2e4b0ef8"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gad457e2d02a734d669ba2490d2e4b0ef8">wpi::memory::uncached_arena</a> = false</td></tr>
<tr class="separator:gad457e2d02a734d669ba2490d2e4b0ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad024a1083a2014e2ceeaf0f5bf50e2d0"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gad024a1083a2014e2ceeaf0f5bf50e2d0">wpi::memory::literals::operator&quot;&quot;_KiB</a> (unsigned long long <a class="el" href="classvalue.html">value</a>) noexcept</td></tr>
<tr class="memdesc:gad024a1083a2014e2ceeaf0f5bf50e2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntax sugar to express sizes with unit prefixes.  <a href="group__core.html#gad024a1083a2014e2ceeaf0f5bf50e2d0">More...</a><br /></td></tr>
<tr class="separator:gad024a1083a2014e2ceeaf0f5bf50e2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafae301e52377f80c766ea6f3c83d4918"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gafae301e52377f80c766ea6f3c83d4918">wpi::memory::literals::operator&quot;&quot;_KB</a> (unsigned long long <a class="el" href="classvalue.html">value</a>) noexcept</td></tr>
<tr class="separator:gafae301e52377f80c766ea6f3c83d4918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5d8d8e9590325637ae5bf332b803520"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gaf5d8d8e9590325637ae5bf332b803520">wpi::memory::literals::operator&quot;&quot;_MiB</a> (unsigned long long <a class="el" href="classvalue.html">value</a>) noexcept</td></tr>
<tr class="separator:gaf5d8d8e9590325637ae5bf332b803520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38794f6c4f6d8a8ff0a251e90a8aa747"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga38794f6c4f6d8a8ff0a251e90a8aa747">wpi::memory::literals::operator&quot;&quot;_MB</a> (unsigned long long <a class="el" href="classvalue.html">value</a>) noexcept</td></tr>
<tr class="separator:ga38794f6c4f6d8a8ff0a251e90a8aa747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed65b53071366fd13070b7776014863f"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gaed65b53071366fd13070b7776014863f">wpi::memory::literals::operator&quot;&quot;_GiB</a> (unsigned long long <a class="el" href="classvalue.html">value</a>) noexcept</td></tr>
<tr class="separator:gaed65b53071366fd13070b7776014863f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga258b6cbb4bf752e95ef0fc527a3e1961"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga258b6cbb4bf752e95ef0fc527a3e1961">wpi::memory::literals::operator&quot;&quot;_GB</a> (unsigned long long <a class="el" href="classvalue.html">value</a>) noexcept</td></tr>
<tr class="separator:ga258b6cbb4bf752e95ef0fc527a3e1961"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga2838b189f63bb9505d4ec3ae9d572ee6" name="ga2838b189f63bb9505d4ec3ae9d572ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2838b189f63bb9505d4ec3ae9d572ee6">&#9670;&nbsp;</a></span>buffer_overflow_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">wpi::memory::buffer_overflow_handler</a> = typedef void (*)(const void* memory, std::size_t size, const void* <a class="el" href="format_8h.html#ab76a36e5b99a884b810fbd30211dd228">write_ptr</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the handler called when a buffer under/overflow is detected. </p>
<p >If <a class="el" href="config__impl_8hpp.html#ac40b66a1885b7cf7afae0d2050c00abd">WPI_MEMORY_DEBUG_FILL</a> is <code>true</code> and <a class="el" href="config__impl_8hpp.html#a222a6578b1e094965c12acbc73fadf0a">WPI_MEMORY_DEBUG_FENCE</a> has a non-zero value the allocator classes check if a write into the fence has occured upon deallocation. The handler gets the memory block belonging to the corrupted fence, its size and the exact address. \requiredbe A buffer overflow handler shall terminate the program. It must not throw any exceptions since it me be called in the cleanup process. \defaultbe On a hosted implementation it logs the information to <code>stderr</code> and calls <code>std::abort()</code>. On a freestanding implementation it only calls <code>std::abort()</code>. </p>

</div>
</div>
<a id="ga5cab10357dccef1206a767c56cbbecb4" name="ga5cab10357dccef1206a767c56cbbecb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cab10357dccef1206a767c56cbbecb4">&#9670;&nbsp;</a></span>invalid_pointer_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">wpi::memory::invalid_pointer_handler</a> = typedef void (*)(const <a class="el" href="structwpi_1_1memory_1_1allocator__info.html">allocator_info</a>&amp; info, const void* <a class="el" href="format_8h.html#aa6ec2d4315570f27d9637ce3c770e787">ptr</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the handler called when an invalid pointer is passed to a deallocation function. </p>
<p >Pointer checking can be controlled via the options <a class="el" href="config__impl_8hpp.html#ac730449713e353efca2a2c98bd68c7bd">WPI_MEMORY_DEBUG_POINTER_CHECK</a> and <a class="el" href="config__impl_8hpp.html#a934af5f27120effddf902a7b7755706f">WPI_MEMORY_DEBUG_DOUBLE_DEALLOC_CHECK</a>. The handler gets the <a class="el" href="structwpi_1_1memory_1_1allocator__info.html">allocator_info</a> and the invalid pointer. \requiredbe An invalid pointer handler shall terminate the program. It must not throw any exceptions since it might be called in the cleanup process. \defaultbe On a hosted implementation it logs the information to <code>stderr</code> and calls <code>std::abort()</code>. On a freestanding implementation it only calls <code>std::abort()</code>. </p>

</div>
</div>
<a id="gaa4b33e608d367597cf4f0a0e525999a7" name="gaa4b33e608d367597cf4f0a0e525999a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4b33e608d367597cf4f0a0e525999a7">&#9670;&nbsp;</a></span>leak_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">wpi::memory::leak_handler</a> = typedef void (*)(const <a class="el" href="structwpi_1_1memory_1_1allocator__info.html">allocator_info</a>&amp; info, std::ptrdiff_t amount)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the handler called when a memory leak is detected. </p>
<p >Leak checking can be controlled via the option <a class="el" href="config__impl_8hpp.html#a16e0cfef5357f196ca782490f2803a88">WPI_MEMORY_DEBUG_LEAK_CHECK</a> and only affects calls through the allocator_traits, not direct calls. The handler gets the <a class="el" href="structwpi_1_1memory_1_1allocator__info.html">allocator_info</a> and the amount of memory leaked. This can also be negative, meaning that more memory has been freed than allocated. \requiredbe A leak handler shall log the leak, abort the program, do nothing or anything else that seems appropriate. It must not throw any exceptions since it is called in the cleanup process. \defaultbe On a hosted implementation it logs the leak to <code>stderr</code> and returns, continuing execution. On a freestanding implementation it does nothing. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gadea26fb93affed8c409ec360412d762e" name="gadea26fb93affed8c409ec360412d762e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadea26fb93affed8c409ec360412d762e">&#9670;&nbsp;</a></span>debug_magic</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="group__core.html#gadea26fb93affed8c409ec360412d762e">wpi::memory::debug_magic</a> : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The magic values that are used for debug filling. </p>
<p >If <a class="el" href="config__impl_8hpp.html#ac40b66a1885b7cf7afae0d2050c00abd">WPI_MEMORY_DEBUG_FILL</a> is <code>true</code>, memory will be filled to help detect use-after-free or missing initialization errors. These are the constants for the different types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadea26fb93affed8c409ec360412d762ea7bd4be20559c1a287369c8df4c117afe" name="ggadea26fb93affed8c409ec360412d762ea7bd4be20559c1a287369c8df4c117afe"></a>internal_memory&#160;</td><td class="fielddoc"><p >Marks internal memory used by the allocator - "allocated block". </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadea26fb93affed8c409ec360412d762eaa5c32a0fcc06d646d53c71b55c9cf5cb" name="ggadea26fb93affed8c409ec360412d762eaa5c32a0fcc06d646d53c71b55c9cf5cb"></a>internal_freed_memory&#160;</td><td class="fielddoc"><p >Marks internal memory currently not used by the allocator - "freed block". </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadea26fb93affed8c409ec360412d762ea9e1988b82181dbe51272459a8ac8e0c0" name="ggadea26fb93affed8c409ec360412d762ea9e1988b82181dbe51272459a8ac8e0c0"></a>new_memory&#160;</td><td class="fielddoc"><p >Marks allocated, but not yet used memory - "clean memory". </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadea26fb93affed8c409ec360412d762ea635e5f9da5635b909461fd93c09130ed" name="ggadea26fb93affed8c409ec360412d762ea635e5f9da5635b909461fd93c09130ed"></a>freed_memory&#160;</td><td class="fielddoc"><p >Marks freed memory - "dead memory". </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadea26fb93affed8c409ec360412d762ea682318fff515ed43a48b718f46c21308" name="ggadea26fb93affed8c409ec360412d762ea682318fff515ed43a48b718f46c21308"></a>alignment_memory&#160;</td><td class="fielddoc"><p >Marks buffer memory used to ensure proper alignment. </p>
<p >This memory can also serve as <a class="el" href="group__core.html#ggadea26fb93affed8c409ec360412d762ea99ec421b05ddc9b5565897f6a0cfb360">debug_magic::fence_memory</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadea26fb93affed8c409ec360412d762ea99ec421b05ddc9b5565897f6a0cfb360" name="ggadea26fb93affed8c409ec360412d762ea99ec421b05ddc9b5565897f6a0cfb360"></a>fence_memory&#160;</td><td class="fielddoc"><p >Marks buffer memory used to protect against overflow - "fence memory". </p>
<p >The option <a class="el" href="config__impl_8hpp.html#a222a6578b1e094965c12acbc73fadf0a">WPI_MEMORY_DEBUG_FENCE</a> controls the size of a memory fence that will be placed before or after a memory block. It helps catching buffer overflows. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaddb4989826b25f0f3d833c871cd74a0d" name="gaddb4989826b25f0f3d833c871cd74a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddb4989826b25f0f3d833c871cd74a0d">&#9670;&nbsp;</a></span>get_buffer_overflow_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">buffer_overflow_handler</a> wpi::memory::get_buffer_overflow_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">buffer_overflow_handler</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The current <a class="el" href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">buffer_overflow_handler</a>. This is never <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="ga34d9478573193d39208d340a6586f8a1" name="ga34d9478573193d39208d340a6586f8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34d9478573193d39208d340a6586f8a1">&#9670;&nbsp;</a></span>get_invalid_pointer_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">invalid_pointer_handler</a> wpi::memory::get_invalid_pointer_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">invalid_pointer_handler</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The current <a class="el" href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">invalid_pointer_handler</a>. This is never <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="gaa60befedaaf9af29fcf7ce4aa837cc6e" name="gaa60befedaaf9af29fcf7ce4aa837cc6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa60befedaaf9af29fcf7ce4aa837cc6e">&#9670;&nbsp;</a></span>get_leak_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">leak_handler</a> wpi::memory::get_leak_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">leak_handler</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The current <a class="el" href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">leak_handler</a>. This is never <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="ga258b6cbb4bf752e95ef0fc527a3e1961" name="ga258b6cbb4bf752e95ef0fc527a3e1961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga258b6cbb4bf752e95ef0fc527a3e1961">&#9670;&nbsp;</a></span>operator&quot;&quot;_GB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t wpi::memory::literals::operator&quot;&quot;_GB </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gaed65b53071366fd13070b7776014863f" name="gaed65b53071366fd13070b7776014863f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed65b53071366fd13070b7776014863f">&#9670;&nbsp;</a></span>operator&quot;&quot;_GiB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t wpi::memory::literals::operator&quot;&quot;_GiB </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gafae301e52377f80c766ea6f3c83d4918" name="gafae301e52377f80c766ea6f3c83d4918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafae301e52377f80c766ea6f3c83d4918">&#9670;&nbsp;</a></span>operator&quot;&quot;_KB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t wpi::memory::literals::operator&quot;&quot;_KB </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gad024a1083a2014e2ceeaf0f5bf50e2d0" name="gad024a1083a2014e2ceeaf0f5bf50e2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad024a1083a2014e2ceeaf0f5bf50e2d0">&#9670;&nbsp;</a></span>operator&quot;&quot;_KiB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t wpi::memory::literals::operator&quot;&quot;_KiB </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Syntax sugar to express sizes with unit prefixes. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes <code>value</code> is in the given unit. </dd></dl>

</div>
</div>
<a id="ga38794f6c4f6d8a8ff0a251e90a8aa747" name="ga38794f6c4f6d8a8ff0a251e90a8aa747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38794f6c4f6d8a8ff0a251e90a8aa747">&#9670;&nbsp;</a></span>operator&quot;&quot;_MB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t wpi::memory::literals::operator&quot;&quot;_MB </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf5d8d8e9590325637ae5bf332b803520" name="gaf5d8d8e9590325637ae5bf332b803520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5d8d8e9590325637ae5bf332b803520">&#9670;&nbsp;</a></span>operator&quot;&quot;_MiB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t wpi::memory::literals::operator&quot;&quot;_MiB </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga93b00d2fd1d3cd1f85f5331cf843fac3" name="ga93b00d2fd1d3cd1f85f5331cf843fac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93b00d2fd1d3cd1f85f5331cf843fac3">&#9670;&nbsp;</a></span>set_buffer_overflow_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">buffer_overflow_handler</a> wpi::memory::set_buffer_overflow_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">buffer_overflow_handler</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchanges the <a class="el" href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">buffer_overflow_handler</a>. </p>
<dl class="section user"><dt>Effects:</dt><dd>Sets <code>h</code> as the new <a class="el" href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">buffer_overflow_handler</a> in an atomic operation. A <code>nullptr</code> sets the default <a class="el" href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">buffer_overflow_handler</a>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The previous <a class="el" href="group__core.html#ga2838b189f63bb9505d4ec3ae9d572ee6">buffer_overflow_handler</a>. This is never <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="gab8d5aef2a6a2d4e65cfcc0eeac06c02b" name="gab8d5aef2a6a2d4e65cfcc0eeac06c02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8d5aef2a6a2d4e65cfcc0eeac06c02b">&#9670;&nbsp;</a></span>set_invalid_pointer_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">invalid_pointer_handler</a> wpi::memory::set_invalid_pointer_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">invalid_pointer_handler</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchanges the <a class="el" href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">invalid_pointer_handler</a>. </p>
<dl class="section user"><dt>Effects:</dt><dd>Sets <code>h</code> as the new <a class="el" href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">invalid_pointer_handler</a> in an atomic operation. A <code>nullptr</code> sets the default <a class="el" href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">invalid_pointer_handler</a>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The previous <a class="el" href="group__core.html#ga5cab10357dccef1206a767c56cbbecb4">invalid_pointer_handler</a>. This is never <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="ga834abe9622c747efdfa8619009d2e373" name="ga834abe9622c747efdfa8619009d2e373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga834abe9622c747efdfa8619009d2e373">&#9670;&nbsp;</a></span>set_leak_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">leak_handler</a> wpi::memory::set_leak_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">leak_handler</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchanges the <a class="el" href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">leak_handler</a>. </p>
<dl class="section user"><dt>Effects:</dt><dd>Sets <code>h</code> as the new <a class="el" href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">leak_handler</a> in an atomic operation. A <code>nullptr</code> sets the default <a class="el" href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">leak_handler</a>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The previous <a class="el" href="group__core.html#gaa4b33e608d367597cf4f0a0e525999a7">leak_handler</a>. This is never <code>nullptr</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga71ad064608460ad27607935f45a0ca69" name="ga71ad064608460ad27607935f45a0ca69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71ad064608460ad27607935f45a0ca69">&#9670;&nbsp;</a></span>cached_arena</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::memory::cached_arena = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Controls the caching of <a class="el" href="classwpi_1_1memory_1_1memory__arena.html">memory_arena</a>. By default, deallocated blocks are put onto a cache, so they can be reused later; this tag value enable/disable it..<br  />
 This can be useful, e.g. if there will never be blocks available for deallocation. The (tiny) overhead for the cache can then be disabled. An example is <a class="el" href="classwpi_1_1memory_1_1memory__pool.html">memory_pool</a>. </p>

</div>
</div>
<a id="gad457e2d02a734d669ba2490d2e4b0ef8" name="gad457e2d02a734d669ba2490d2e4b0ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad457e2d02a734d669ba2490d2e4b0ef8">&#9670;&nbsp;</a></span>uncached_arena</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wpi::memory::uncached_arena = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Nov 13 2022 22:11:35 for WPILibC++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
