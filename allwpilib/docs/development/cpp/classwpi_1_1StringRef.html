<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: wpi::StringRef Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">WPILibC++
   &#160;<span id="projectnumber">2022.0.0-alpha-1-46-g1873fbe</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classwpi_1_1StringRef.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classwpi_1_1StringRef-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">wpi::StringRef Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classwpi_1_1StringRef.html" title="StringRef - Represent a constant reference to a string, i.e.">StringRef</a> - Represent a constant reference to a string, i.e.  
 <a href="classwpi_1_1StringRef.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="StringRef_8h_source.html">wpi/StringRef.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for wpi::StringRef:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classwpi_1_1StringRef.png" usemap="#wpi::StringRef_map" alt=""/>
  <map id="wpi::StringRef_map" name="wpi::StringRef_map">
<area href="classwpi_1_1StringLiteral.html" title="A wrapper around a string literal that serves as a proxy for constructing global tables of StringRefs..." alt="wpi::StringLiteral" shape="rect" coords="0,56,105,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aba4a7dfe6e8662ae0207e5e21db5f71f"><td class="memItemLeft" align="right" valign="top"><a id="aba4a7dfe6e8662ae0207e5e21db5f71f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = const char *</td></tr>
<tr class="separator:aba4a7dfe6e8662ae0207e5e21db5f71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148cc66afebfced5bc0f5b18ca7f0965"><td class="memItemLeft" align="right" valign="top"><a id="a148cc66afebfced5bc0f5b18ca7f0965"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = const char *</td></tr>
<tr class="separator:a148cc66afebfced5bc0f5b18ca7f0965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa24c4bb48b11e49773f07e11461bf7"><td class="memItemLeft" align="right" valign="top"><a id="a4fa24c4bb48b11e49773f07e11461bf7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = size_t</td></tr>
<tr class="separator:a4fa24c4bb48b11e49773f07e11461bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr class="memitem:a9d33a827266a6e3e3401879eac780055"><td class="memItemLeft" align="right" valign="top"><a id="a9d33a827266a6e3e3401879eac780055"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const noexcept</td></tr>
<tr class="separator:a9d33a827266a6e3e3401879eac780055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c18571460fe69592ace16009f13a05"><td class="memItemLeft" align="right" valign="top"><a id="a46c18571460fe69592ace16009f13a05"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const noexcept</td></tr>
<tr class="separator:a46c18571460fe69592ace16009f13a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55415343c675a416ce71904b170b53f9"><td class="memItemLeft" align="right" valign="top"><a id="a55415343c675a416ce71904b170b53f9"></a>
const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><b>bytes_begin</b> () const noexcept</td></tr>
<tr class="separator:a55415343c675a416ce71904b170b53f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09493509316b4bc8f62221bd185c479c"><td class="memItemLeft" align="right" valign="top"><a id="a09493509316b4bc8f62221bd185c479c"></a>
const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><b>bytes_end</b> () const noexcept</td></tr>
<tr class="separator:a09493509316b4bc8f62221bd185c479c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34b0005770974bd0a9177a2e30d2753"><td class="memItemLeft" align="right" valign="top"><a id="ae34b0005770974bd0a9177a2e30d2753"></a>
<a class="el" href="classwpi_1_1iterator__range.html">iterator_range</a>&lt; const unsigned char * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>bytes</b> () const noexcept</td></tr>
<tr class="separator:ae34b0005770974bd0a9177a2e30d2753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">String Operations</div></td></tr>
<tr class="memitem:a3639987deb10240784a410a843c6df94"><td class="memItemLeft" align="right" valign="top"><a id="a3639987deb10240784a410a843c6df94"></a>
LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a3639987deb10240784a410a843c6df94">data</a> () const noexcept</td></tr>
<tr class="memdesc:a3639987deb10240784a410a843c6df94"><td class="mdescLeft">&#160;</td><td class="mdescRight">data - Get a pointer to the start of the string (which may not be null terminated). <br /></td></tr>
<tr class="separator:a3639987deb10240784a410a843c6df94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc6e1f6d4af6abc5c531df970943669"><td class="memItemLeft" align="right" valign="top"><a id="a1bc6e1f6d4af6abc5c531df970943669"></a>
LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a1bc6e1f6d4af6abc5c531df970943669">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a1bc6e1f6d4af6abc5c531df970943669"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty - Check if the string is empty. <br /></td></tr>
<tr class="separator:a1bc6e1f6d4af6abc5c531df970943669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9004ee0e815e1257a211073afc714d"><td class="memItemLeft" align="right" valign="top"><a id="a3f9004ee0e815e1257a211073afc714d"></a>
LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a3f9004ee0e815e1257a211073afc714d">size</a> () const noexcept</td></tr>
<tr class="memdesc:a3f9004ee0e815e1257a211073afc714d"><td class="mdescLeft">&#160;</td><td class="mdescRight">size - Get the string size. <br /></td></tr>
<tr class="separator:a3f9004ee0e815e1257a211073afc714d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3841be85c5af54e6c197cfbf6eaeb0c"><td class="memItemLeft" align="right" valign="top"><a id="ab3841be85c5af54e6c197cfbf6eaeb0c"></a>
LLVM_NODISCARD char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#ab3841be85c5af54e6c197cfbf6eaeb0c">front</a> () const noexcept</td></tr>
<tr class="memdesc:ab3841be85c5af54e6c197cfbf6eaeb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">front - Get the first character in the string. <br /></td></tr>
<tr class="separator:ab3841be85c5af54e6c197cfbf6eaeb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5256f8ff7c12debf8d57a9c988dcc332"><td class="memItemLeft" align="right" valign="top"><a id="a5256f8ff7c12debf8d57a9c988dcc332"></a>
LLVM_NODISCARD char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a5256f8ff7c12debf8d57a9c988dcc332">back</a> () const noexcept</td></tr>
<tr class="memdesc:a5256f8ff7c12debf8d57a9c988dcc332"><td class="mdescLeft">&#160;</td><td class="mdescRight">back - Get the last character in the string. <br /></td></tr>
<tr class="separator:a5256f8ff7c12debf8d57a9c988dcc332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5960bd97a68c59cc51b327801870036"><td class="memTemplParams" colspan="2"><a id="ac5960bd97a68c59cc51b327801870036"></a>
template&lt;typename Allocator &gt; </td></tr>
<tr class="memitem:ac5960bd97a68c59cc51b327801870036"><td class="memTemplItemLeft" align="right" valign="top">LLVM_NODISCARD <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy</b> (Allocator &amp;A) const</td></tr>
<tr class="separator:ac5960bd97a68c59cc51b327801870036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e824cd42a367f336f7368091a20dc7"><td class="memItemLeft" align="right" valign="top"><a id="a14e824cd42a367f336f7368091a20dc7"></a>
LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a14e824cd42a367f336f7368091a20dc7">equals</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> RHS) const noexcept</td></tr>
<tr class="memdesc:a14e824cd42a367f336f7368091a20dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">equals - Check for string equality, this is more efficient than <a class="el" href="classwpi_1_1StringRef.html#a42cecc84da81134e40aac672cfff7db3" title="compare - Compare two strings; the result is -1, 0, or 1 if this string is lexicographically less tha...">compare()</a> when the relative ordering of inequal strings isn't needed. <br /></td></tr>
<tr class="separator:a14e824cd42a367f336f7368091a20dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e5aea4f64bab5dc1abdc220e1d61f7"><td class="memItemLeft" align="right" valign="top"><a id="a36e5aea4f64bab5dc1abdc220e1d61f7"></a>
LLVM_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a36e5aea4f64bab5dc1abdc220e1d61f7">equals_lower</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> RHS) const noexcept</td></tr>
<tr class="memdesc:a36e5aea4f64bab5dc1abdc220e1d61f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">equals_lower - Check for string equality, ignoring case. <br /></td></tr>
<tr class="separator:a36e5aea4f64bab5dc1abdc220e1d61f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cecc84da81134e40aac672cfff7db3"><td class="memItemLeft" align="right" valign="top"><a id="a42cecc84da81134e40aac672cfff7db3"></a>
LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a42cecc84da81134e40aac672cfff7db3">compare</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> RHS) const noexcept</td></tr>
<tr class="memdesc:a42cecc84da81134e40aac672cfff7db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare - Compare two strings; the result is -1, 0, or 1 if this string is lexicographically less than, equal to, or greater than the <code>RHS</code>. <br /></td></tr>
<tr class="separator:a42cecc84da81134e40aac672cfff7db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49406996fd78c92d290a1338dc5c9ab"><td class="memItemLeft" align="right" valign="top"><a id="ab49406996fd78c92d290a1338dc5c9ab"></a>
LLVM_NODISCARD int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#ab49406996fd78c92d290a1338dc5c9ab">compare_lower</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> RHS) const noexcept</td></tr>
<tr class="memdesc:ab49406996fd78c92d290a1338dc5c9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare_lower - Compare two strings, ignoring case. <br /></td></tr>
<tr class="separator:ab49406996fd78c92d290a1338dc5c9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1f5aa183ea0b08ce29d7a4cbc76934"><td class="memItemLeft" align="right" valign="top"><a id="abe1f5aa183ea0b08ce29d7a4cbc76934"></a>
LLVM_NODISCARD int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#abe1f5aa183ea0b08ce29d7a4cbc76934">compare_numeric</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> RHS) const noexcept</td></tr>
<tr class="memdesc:abe1f5aa183ea0b08ce29d7a4cbc76934"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare_numeric - Compare two strings, treating sequences of digits as numbers. <br /></td></tr>
<tr class="separator:abe1f5aa183ea0b08ce29d7a4cbc76934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d6c1e5239b10cf882e16c9b90359bc"><td class="memItemLeft" align="right" valign="top"><a id="ae6d6c1e5239b10cf882e16c9b90359bc"></a>
LLVM_NODISCARD std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#ae6d6c1e5239b10cf882e16c9b90359bc">str</a> () const</td></tr>
<tr class="memdesc:ae6d6c1e5239b10cf882e16c9b90359bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">str - Get the contents as an std::string. <br /></td></tr>
<tr class="separator:ae6d6c1e5239b10cf882e16c9b90359bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99367c914cf3d29dfd12ae9d32445682"><td class="memItemLeft" align="right" valign="top"><a id="a99367c914cf3d29dfd12ae9d32445682"></a>
LLVM_NODISCARD std::string&#160;</td><td class="memItemRight" valign="bottom"><b>lower</b> () const</td></tr>
<tr class="separator:a99367c914cf3d29dfd12ae9d32445682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0652c4b440a550771436118f10975abc"><td class="memItemLeft" align="right" valign="top"><a id="a0652c4b440a550771436118f10975abc"></a>
LLVM_NODISCARD std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a0652c4b440a550771436118f10975abc">upper</a> () const</td></tr>
<tr class="memdesc:a0652c4b440a550771436118f10975abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given ASCII string to uppercase. <br /></td></tr>
<tr class="separator:a0652c4b440a550771436118f10975abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operator Overloads</div></td></tr>
<tr class="memitem:a78653d66f199c57593722f7dc64a8aab"><td class="memItemLeft" align="right" valign="top"><a id="a78653d66f199c57593722f7dc64a8aab"></a>
LLVM_NODISCARD char&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_t Index) const noexcept</td></tr>
<tr class="separator:a78653d66f199c57593722f7dc64a8aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91795d2d3202949289b358a701065c0d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91795d2d3202949289b358a701065c0d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; T, std::string &gt;::value, <a class="el" href="classwpi_1_1StringRef.html">StringRef</a> &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a91795d2d3202949289b358a701065c0d">operator=</a> (T &amp;&amp;Str)=delete</td></tr>
<tr class="memdesc:a91795d2d3202949289b358a701065c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallow accidental assignment from a temporary std::string.  <a href="classwpi_1_1StringRef.html#a91795d2d3202949289b358a701065c0d">More...</a><br /></td></tr>
<tr class="separator:a91795d2d3202949289b358a701065c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Type Conversions</div></td></tr>
<tr class="memitem:aa7fe6323057605cd51f150ef981cc5c4"><td class="memItemLeft" align="right" valign="top"><a id="aa7fe6323057605cd51f150ef981cc5c4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>operator std::string</b> () const</td></tr>
<tr class="separator:aa7fe6323057605cd51f150ef981cc5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">String Predicates</div></td></tr>
<tr class="memitem:aafd535c43143989eedd76cc77ea322f0"><td class="memItemLeft" align="right" valign="top"><a id="aafd535c43143989eedd76cc77ea322f0"></a>
LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#aafd535c43143989eedd76cc77ea322f0">startswith</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> Prefix) const noexcept</td></tr>
<tr class="memdesc:aafd535c43143989eedd76cc77ea322f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string starts with the given <code>Prefix</code>. <br /></td></tr>
<tr class="separator:aafd535c43143989eedd76cc77ea322f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe8f9e7a784ff7ae7a285e3346c2d90"><td class="memItemLeft" align="right" valign="top"><a id="acbe8f9e7a784ff7ae7a285e3346c2d90"></a>
LLVM_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#acbe8f9e7a784ff7ae7a285e3346c2d90">startswith_lower</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> Prefix) const noexcept</td></tr>
<tr class="memdesc:acbe8f9e7a784ff7ae7a285e3346c2d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string starts with the given <code>Prefix</code>, ignoring case. <br /></td></tr>
<tr class="separator:acbe8f9e7a784ff7ae7a285e3346c2d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3435f2ea688aac9c1d87690af1b22d"><td class="memItemLeft" align="right" valign="top"><a id="adc3435f2ea688aac9c1d87690af1b22d"></a>
LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#adc3435f2ea688aac9c1d87690af1b22d">endswith</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> Suffix) const noexcept</td></tr>
<tr class="memdesc:adc3435f2ea688aac9c1d87690af1b22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string ends with the given <code>Suffix</code>. <br /></td></tr>
<tr class="separator:adc3435f2ea688aac9c1d87690af1b22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c03bdb2967f5c94446de3c3459a525"><td class="memItemLeft" align="right" valign="top"><a id="ab4c03bdb2967f5c94446de3c3459a525"></a>
LLVM_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#ab4c03bdb2967f5c94446de3c3459a525">endswith_lower</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> Suffix) const noexcept</td></tr>
<tr class="memdesc:ab4c03bdb2967f5c94446de3c3459a525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string ends with the given <code>Suffix</code>, ignoring case. <br /></td></tr>
<tr class="separator:ab4c03bdb2967f5c94446de3c3459a525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">String Searching</div></td></tr>
<tr class="memitem:a589aa40b6d4b46bc6bc0ec10999515e9"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a589aa40b6d4b46bc6bc0ec10999515e9">find</a> (char C, size_t From=0) const noexcept</td></tr>
<tr class="memdesc:a589aa40b6d4b46bc6bc0ec10999515e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first character <code>C</code> in the string.  <a href="classwpi_1_1StringRef.html#a589aa40b6d4b46bc6bc0ec10999515e9">More...</a><br /></td></tr>
<tr class="separator:a589aa40b6d4b46bc6bc0ec10999515e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a6cabc97ad104fad1f3385a3db9e45"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#af5a6cabc97ad104fad1f3385a3db9e45">find_lower</a> (char C, size_t From=0) const noexcept</td></tr>
<tr class="memdesc:af5a6cabc97ad104fad1f3385a3db9e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first character <code>C</code> in the string, ignoring case.  <a href="classwpi_1_1StringRef.html#af5a6cabc97ad104fad1f3385a3db9e45">More...</a><br /></td></tr>
<tr class="separator:af5a6cabc97ad104fad1f3385a3db9e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fad2f308bf56ca01fdb379390abc90"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#ae2fad2f308bf56ca01fdb379390abc90">find_if</a> (<a class="el" href="classwpi_1_1function__ref.html">function_ref</a>&lt; bool(char)&gt; F, size_t From=0) const noexcept</td></tr>
<tr class="memdesc:ae2fad2f308bf56ca01fdb379390abc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first character satisfying the predicate <code>F</code>.  <a href="classwpi_1_1StringRef.html#ae2fad2f308bf56ca01fdb379390abc90">More...</a><br /></td></tr>
<tr class="separator:ae2fad2f308bf56ca01fdb379390abc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44296d03b4f1fbb07a4f4273e0667bcd"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a44296d03b4f1fbb07a4f4273e0667bcd">find_if_not</a> (<a class="el" href="classwpi_1_1function__ref.html">function_ref</a>&lt; bool(char)&gt; F, size_t From=0) const noexcept</td></tr>
<tr class="memdesc:a44296d03b4f1fbb07a4f4273e0667bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first character not satisfying the predicate <code>F</code>.  <a href="classwpi_1_1StringRef.html#a44296d03b4f1fbb07a4f4273e0667bcd">More...</a><br /></td></tr>
<tr class="separator:a44296d03b4f1fbb07a4f4273e0667bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37c528a2e72e8c4d94b4b4f93882752"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#af37c528a2e72e8c4d94b4b4f93882752">find</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> Str, size_t From=0) const noexcept</td></tr>
<tr class="memdesc:af37c528a2e72e8c4d94b4b4f93882752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first string <code>Str</code> in the string.  <a href="classwpi_1_1StringRef.html#af37c528a2e72e8c4d94b4b4f93882752">More...</a><br /></td></tr>
<tr class="separator:af37c528a2e72e8c4d94b4b4f93882752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd68110badc7a75e8666317a560bbd8"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a6dd68110badc7a75e8666317a560bbd8">find_lower</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> Str, size_t From=0) const noexcept</td></tr>
<tr class="memdesc:a6dd68110badc7a75e8666317a560bbd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first string <code>Str</code> in the string, ignoring case.  <a href="classwpi_1_1StringRef.html#a6dd68110badc7a75e8666317a560bbd8">More...</a><br /></td></tr>
<tr class="separator:a6dd68110badc7a75e8666317a560bbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b26de9e77c44da2d9db794070df64d"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a16b26de9e77c44da2d9db794070df64d">rfind</a> (char C, size_t From=npos) const noexcept</td></tr>
<tr class="memdesc:a16b26de9e77c44da2d9db794070df64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last character <code>C</code> in the string.  <a href="classwpi_1_1StringRef.html#a16b26de9e77c44da2d9db794070df64d">More...</a><br /></td></tr>
<tr class="separator:a16b26de9e77c44da2d9db794070df64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe5fe279dca9ac4e91c3218ea9d2f84"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#adfe5fe279dca9ac4e91c3218ea9d2f84">rfind_lower</a> (char C, size_t From=npos) const noexcept</td></tr>
<tr class="memdesc:adfe5fe279dca9ac4e91c3218ea9d2f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last character <code>C</code> in the string, ignoring case.  <a href="classwpi_1_1StringRef.html#adfe5fe279dca9ac4e91c3218ea9d2f84">More...</a><br /></td></tr>
<tr class="separator:adfe5fe279dca9ac4e91c3218ea9d2f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187bdc8885e5cf65911ef4d8f7f798c4"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a187bdc8885e5cf65911ef4d8f7f798c4">rfind</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> Str) const noexcept</td></tr>
<tr class="memdesc:a187bdc8885e5cf65911ef4d8f7f798c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last string <code>Str</code> in the string.  <a href="classwpi_1_1StringRef.html#a187bdc8885e5cf65911ef4d8f7f798c4">More...</a><br /></td></tr>
<tr class="separator:a187bdc8885e5cf65911ef4d8f7f798c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b4d518ac6e18ceee7732203ab5a2c8"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a60b4d518ac6e18ceee7732203ab5a2c8">rfind_lower</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> Str) const noexcept</td></tr>
<tr class="memdesc:a60b4d518ac6e18ceee7732203ab5a2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last string <code>Str</code> in the string, ignoring case.  <a href="classwpi_1_1StringRef.html#a60b4d518ac6e18ceee7732203ab5a2c8">More...</a><br /></td></tr>
<tr class="separator:a60b4d518ac6e18ceee7732203ab5a2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669a4f25e56bbde6206b9bc56ee7ddad"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a669a4f25e56bbde6206b9bc56ee7ddad">find_first_of</a> (char C, size_t From=0) const noexcept</td></tr>
<tr class="memdesc:a669a4f25e56bbde6206b9bc56ee7ddad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first character in the string that is <code>C</code>, or npos if not found.  <a href="classwpi_1_1StringRef.html#a669a4f25e56bbde6206b9bc56ee7ddad">More...</a><br /></td></tr>
<tr class="separator:a669a4f25e56bbde6206b9bc56ee7ddad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1997b52fc65a19540ad479e2927c531b"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a1997b52fc65a19540ad479e2927c531b">find_first_of</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> Chars, size_t From=0) const noexcept</td></tr>
<tr class="memdesc:a1997b52fc65a19540ad479e2927c531b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first character in the string that is in <code>Chars</code>, or npos if not found.  <a href="classwpi_1_1StringRef.html#a1997b52fc65a19540ad479e2927c531b">More...</a><br /></td></tr>
<tr class="separator:a1997b52fc65a19540ad479e2927c531b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa949b3fcd20ca44f56d313b7b27bbec3"><td class="memItemLeft" align="right" valign="top"><a id="aa949b3fcd20ca44f56d313b7b27bbec3"></a>
LLVM_NODISCARD size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#aa949b3fcd20ca44f56d313b7b27bbec3">find_first_not_of</a> (char C, size_t From=0) const noexcept</td></tr>
<tr class="memdesc:aa949b3fcd20ca44f56d313b7b27bbec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first character in the string that is not <code>C</code> or npos if not found. <br /></td></tr>
<tr class="separator:aa949b3fcd20ca44f56d313b7b27bbec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed58be9b631562b0ff87f851ed72fb3"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#abed58be9b631562b0ff87f851ed72fb3">find_first_not_of</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> Chars, size_t From=0) const noexcept</td></tr>
<tr class="memdesc:abed58be9b631562b0ff87f851ed72fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first character in the string that is not in the string <code>Chars</code>, or npos if not found.  <a href="classwpi_1_1StringRef.html#abed58be9b631562b0ff87f851ed72fb3">More...</a><br /></td></tr>
<tr class="separator:abed58be9b631562b0ff87f851ed72fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01f84fbe071873ad1e47e07023913b0"><td class="memItemLeft" align="right" valign="top"><a id="ad01f84fbe071873ad1e47e07023913b0"></a>
LLVM_NODISCARD size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#ad01f84fbe071873ad1e47e07023913b0">find_last_of</a> (char C, size_t From=npos) const noexcept</td></tr>
<tr class="memdesc:ad01f84fbe071873ad1e47e07023913b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last character in the string that is <code>C</code>, or npos if not found. <br /></td></tr>
<tr class="separator:ad01f84fbe071873ad1e47e07023913b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138722e01be2750461fb51bc654d0ac8"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a138722e01be2750461fb51bc654d0ac8">find_last_of</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> Chars, size_t From=npos) const noexcept</td></tr>
<tr class="memdesc:a138722e01be2750461fb51bc654d0ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last character in the string that is in <code>C</code>, or npos if not found.  <a href="classwpi_1_1StringRef.html#a138722e01be2750461fb51bc654d0ac8">More...</a><br /></td></tr>
<tr class="separator:a138722e01be2750461fb51bc654d0ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e71e48de329d3f8259cd228bdcd4e91"><td class="memItemLeft" align="right" valign="top"><a id="a2e71e48de329d3f8259cd228bdcd4e91"></a>
LLVM_NODISCARD size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a2e71e48de329d3f8259cd228bdcd4e91">find_last_not_of</a> (char C, size_t From=npos) const noexcept</td></tr>
<tr class="memdesc:a2e71e48de329d3f8259cd228bdcd4e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last character in the string that is not <code>C</code>, or npos if not found. <br /></td></tr>
<tr class="separator:a2e71e48de329d3f8259cd228bdcd4e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ad21b0b2067f8549a5d77c323917d7"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a44ad21b0b2067f8549a5d77c323917d7">find_last_not_of</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> Chars, size_t From=npos) const noexcept</td></tr>
<tr class="memdesc:a44ad21b0b2067f8549a5d77c323917d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last character in the string that is not in <code>Chars</code>, or npos if not found.  <a href="classwpi_1_1StringRef.html#a44ad21b0b2067f8549a5d77c323917d7">More...</a><br /></td></tr>
<tr class="separator:a44ad21b0b2067f8549a5d77c323917d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b09a1917d17ed6c97381adaad0be533"><td class="memItemLeft" align="right" valign="top"><a id="a4b09a1917d17ed6c97381adaad0be533"></a>
LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a4b09a1917d17ed6c97381adaad0be533">contains</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> Other) const noexcept</td></tr>
<tr class="memdesc:a4b09a1917d17ed6c97381adaad0be533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given string is a substring of *this, and false otherwise. <br /></td></tr>
<tr class="separator:a4b09a1917d17ed6c97381adaad0be533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45802b9a53d0c822ac71739807217cb0"><td class="memItemLeft" align="right" valign="top"><a id="a45802b9a53d0c822ac71739807217cb0"></a>
LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a45802b9a53d0c822ac71739807217cb0">contains</a> (char C) const noexcept</td></tr>
<tr class="memdesc:a45802b9a53d0c822ac71739807217cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given character is contained in *this, and false otherwise. <br /></td></tr>
<tr class="separator:a45802b9a53d0c822ac71739807217cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d05701e476778332ca2d82afe9ebc4"><td class="memItemLeft" align="right" valign="top"><a id="a41d05701e476778332ca2d82afe9ebc4"></a>
LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a41d05701e476778332ca2d82afe9ebc4">contains_lower</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> Other) const noexcept</td></tr>
<tr class="memdesc:a41d05701e476778332ca2d82afe9ebc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given string is a substring of *this, and false otherwise. <br /></td></tr>
<tr class="separator:a41d05701e476778332ca2d82afe9ebc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84debc719f539b5fd6895f599ccc0692"><td class="memItemLeft" align="right" valign="top"><a id="a84debc719f539b5fd6895f599ccc0692"></a>
LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a84debc719f539b5fd6895f599ccc0692">contains_lower</a> (char C) const noexcept</td></tr>
<tr class="memdesc:a84debc719f539b5fd6895f599ccc0692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given character is contained in *this, and false otherwise. <br /></td></tr>
<tr class="separator:a84debc719f539b5fd6895f599ccc0692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Helpful Algorithms</div></td></tr>
<tr class="memitem:a94042179e20fcd58a98aa682947da216"><td class="memItemLeft" align="right" valign="top"><a id="a94042179e20fcd58a98aa682947da216"></a>
LLVM_NODISCARD size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a94042179e20fcd58a98aa682947da216">count</a> (char C) const noexcept</td></tr>
<tr class="memdesc:a94042179e20fcd58a98aa682947da216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of occurrences of <code>C</code> in the string. <br /></td></tr>
<tr class="separator:a94042179e20fcd58a98aa682947da216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f458ab0f0ec9da03a5d7661d704126"><td class="memItemLeft" align="right" valign="top"><a id="a34f458ab0f0ec9da03a5d7661d704126"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a34f458ab0f0ec9da03a5d7661d704126">count</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> Str) const noexcept</td></tr>
<tr class="memdesc:a34f458ab0f0ec9da03a5d7661d704126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of non-overlapped occurrences of <code>Str</code> in the string. <br /></td></tr>
<tr class="separator:a34f458ab0f0ec9da03a5d7661d704126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422eca2ca2375a6a894d2dcf1fc1ccb7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a422eca2ca2375a6a894d2dcf1fc1ccb7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::numeric_limits&lt; T &gt;::is_signed, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a422eca2ca2375a6a894d2dcf1fc1ccb7">getAsInteger</a> (unsigned Radix, T &amp;Result) const noexcept</td></tr>
<tr class="memdesc:a422eca2ca2375a6a894d2dcf1fc1ccb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the current string as an integer of the specified radix.  <a href="classwpi_1_1StringRef.html#a422eca2ca2375a6a894d2dcf1fc1ccb7">More...</a><br /></td></tr>
<tr class="separator:a422eca2ca2375a6a894d2dcf1fc1ccb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6907f96479eeee9082a56a30fd575829"><td class="memTemplParams" colspan="2"><a id="a6907f96479eeee9082a56a30fd575829"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6907f96479eeee9082a56a30fd575829"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::numeric_limits&lt; T &gt;::is_signed, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getAsInteger</b> (unsigned Radix, T &amp;Result) const noexcept</td></tr>
<tr class="separator:a6907f96479eeee9082a56a30fd575829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acddf0e9ed05ab507762e7f050d54e43d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acddf0e9ed05ab507762e7f050d54e43d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::numeric_limits&lt; T &gt;::is_signed, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#acddf0e9ed05ab507762e7f050d54e43d">consumeInteger</a> (unsigned Radix, T &amp;Result) noexcept</td></tr>
<tr class="memdesc:acddf0e9ed05ab507762e7f050d54e43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the current string as an integer of the specified radix.  <a href="classwpi_1_1StringRef.html#acddf0e9ed05ab507762e7f050d54e43d">More...</a><br /></td></tr>
<tr class="separator:acddf0e9ed05ab507762e7f050d54e43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cfe80bcaa65d749c44cd329c0d7b69"><td class="memTemplParams" colspan="2"><a id="a93cfe80bcaa65d749c44cd329c0d7b69"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a93cfe80bcaa65d749c44cd329c0d7b69"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::numeric_limits&lt; T &gt;::is_signed, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>consumeInteger</b> (unsigned Radix, T &amp;Result) noexcept</td></tr>
<tr class="separator:a93cfe80bcaa65d749c44cd329c0d7b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Substring Operations</div></td></tr>
<tr class="memitem:a5a116a12b2b447f3fbce4aa3c7ef688e"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a5a116a12b2b447f3fbce4aa3c7ef688e">substr</a> (size_t Start, size_t N=npos) const noexcept</td></tr>
<tr class="memdesc:a5a116a12b2b447f3fbce4aa3c7ef688e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the substring from [Start, Start + N).  <a href="classwpi_1_1StringRef.html#a5a116a12b2b447f3fbce4aa3c7ef688e">More...</a><br /></td></tr>
<tr class="separator:a5a116a12b2b447f3fbce4aa3c7ef688e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae075a7620907ce3e46c9d53321fac324"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#ae075a7620907ce3e46c9d53321fac324">take_front</a> (size_t N=1) const noexcept</td></tr>
<tr class="memdesc:ae075a7620907ce3e46c9d53321fac324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classwpi_1_1StringRef.html" title="StringRef - Represent a constant reference to a string, i.e.">StringRef</a> equal to 'this' but with only the first <code>N</code> elements remaining.  <a href="classwpi_1_1StringRef.html#ae075a7620907ce3e46c9d53321fac324">More...</a><br /></td></tr>
<tr class="separator:ae075a7620907ce3e46c9d53321fac324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4da11e36b842c7a45f702815ecc8651"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#ad4da11e36b842c7a45f702815ecc8651">take_back</a> (size_t N=1) const noexcept</td></tr>
<tr class="memdesc:ad4da11e36b842c7a45f702815ecc8651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classwpi_1_1StringRef.html" title="StringRef - Represent a constant reference to a string, i.e.">StringRef</a> equal to 'this' but with only the last <code>N</code> elements remaining.  <a href="classwpi_1_1StringRef.html#ad4da11e36b842c7a45f702815ecc8651">More...</a><br /></td></tr>
<tr class="separator:ad4da11e36b842c7a45f702815ecc8651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0799036dbbaf6c3c35682a183e75da54"><td class="memItemLeft" align="right" valign="top"><a id="a0799036dbbaf6c3c35682a183e75da54"></a>
LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a0799036dbbaf6c3c35682a183e75da54">take_while</a> (<a class="el" href="classwpi_1_1function__ref.html">function_ref</a>&lt; bool(char)&gt; F) const noexcept</td></tr>
<tr class="memdesc:a0799036dbbaf6c3c35682a183e75da54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the longest prefix of 'this' such that every character in the prefix satisfies the given predicate. <br /></td></tr>
<tr class="separator:a0799036dbbaf6c3c35682a183e75da54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b88cd5a6716798f98cc3b1bea0c743d"><td class="memItemLeft" align="right" valign="top"><a id="a0b88cd5a6716798f98cc3b1bea0c743d"></a>
LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a0b88cd5a6716798f98cc3b1bea0c743d">take_until</a> (<a class="el" href="classwpi_1_1function__ref.html">function_ref</a>&lt; bool(char)&gt; F) const noexcept</td></tr>
<tr class="memdesc:a0b88cd5a6716798f98cc3b1bea0c743d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the longest prefix of 'this' such that no character in the prefix satisfies the given predicate. <br /></td></tr>
<tr class="separator:a0b88cd5a6716798f98cc3b1bea0c743d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae575e5a224d338ece4f7cd1f415892e3"><td class="memItemLeft" align="right" valign="top"><a id="ae575e5a224d338ece4f7cd1f415892e3"></a>
LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#ae575e5a224d338ece4f7cd1f415892e3">drop_front</a> (size_t N=1) const noexcept</td></tr>
<tr class="memdesc:ae575e5a224d338ece4f7cd1f415892e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classwpi_1_1StringRef.html" title="StringRef - Represent a constant reference to a string, i.e.">StringRef</a> equal to 'this' but with the first <code>N</code> elements dropped. <br /></td></tr>
<tr class="separator:ae575e5a224d338ece4f7cd1f415892e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a68d9feb3feb6548594a5d0c8460cd4"><td class="memItemLeft" align="right" valign="top"><a id="a4a68d9feb3feb6548594a5d0c8460cd4"></a>
LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a4a68d9feb3feb6548594a5d0c8460cd4">drop_back</a> (size_t N=1) const noexcept</td></tr>
<tr class="memdesc:a4a68d9feb3feb6548594a5d0c8460cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classwpi_1_1StringRef.html" title="StringRef - Represent a constant reference to a string, i.e.">StringRef</a> equal to 'this' but with the last <code>N</code> elements dropped. <br /></td></tr>
<tr class="separator:a4a68d9feb3feb6548594a5d0c8460cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53286328ead69105b0d7bf35d4cad3b"><td class="memItemLeft" align="right" valign="top"><a id="aa53286328ead69105b0d7bf35d4cad3b"></a>
LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#aa53286328ead69105b0d7bf35d4cad3b">drop_while</a> (<a class="el" href="classwpi_1_1function__ref.html">function_ref</a>&lt; bool(char)&gt; F) const noexcept</td></tr>
<tr class="memdesc:aa53286328ead69105b0d7bf35d4cad3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classwpi_1_1StringRef.html" title="StringRef - Represent a constant reference to a string, i.e.">StringRef</a> equal to 'this', but with all characters satisfying the given predicate dropped from the beginning of the string. <br /></td></tr>
<tr class="separator:aa53286328ead69105b0d7bf35d4cad3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0a489922a90585b7f720b719832205"><td class="memItemLeft" align="right" valign="top"><a id="afe0a489922a90585b7f720b719832205"></a>
LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#afe0a489922a90585b7f720b719832205">drop_until</a> (<a class="el" href="classwpi_1_1function__ref.html">function_ref</a>&lt; bool(char)&gt; F) const noexcept</td></tr>
<tr class="memdesc:afe0a489922a90585b7f720b719832205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classwpi_1_1StringRef.html" title="StringRef - Represent a constant reference to a string, i.e.">StringRef</a> equal to 'this', but with all characters not satisfying the given predicate dropped from the beginning of the string. <br /></td></tr>
<tr class="separator:afe0a489922a90585b7f720b719832205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaabb37429ac5a91cc2eb5335d0c3b07"><td class="memItemLeft" align="right" valign="top"><a id="aaaabb37429ac5a91cc2eb5335d0c3b07"></a>
LLVM_ATTRIBUTE_ALWAYS_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#aaaabb37429ac5a91cc2eb5335d0c3b07">consume_front</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> Prefix) noexcept</td></tr>
<tr class="memdesc:aaaabb37429ac5a91cc2eb5335d0c3b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this <a class="el" href="classwpi_1_1StringRef.html" title="StringRef - Represent a constant reference to a string, i.e.">StringRef</a> has the given prefix and removes that prefix. <br /></td></tr>
<tr class="separator:aaaabb37429ac5a91cc2eb5335d0c3b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fc1981efe7550c5a14bca62b22616d"><td class="memItemLeft" align="right" valign="top"><a id="a15fc1981efe7550c5a14bca62b22616d"></a>
LLVM_ATTRIBUTE_ALWAYS_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a15fc1981efe7550c5a14bca62b22616d">consume_back</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> Suffix) noexcept</td></tr>
<tr class="memdesc:a15fc1981efe7550c5a14bca62b22616d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this <a class="el" href="classwpi_1_1StringRef.html" title="StringRef - Represent a constant reference to a string, i.e.">StringRef</a> has the given suffix and removes that suffix. <br /></td></tr>
<tr class="separator:a15fc1981efe7550c5a14bca62b22616d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3351295715fb3ba0d746df7f710d99a"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#aa3351295715fb3ba0d746df7f710d99a">slice</a> (size_t Start, size_t End) const noexcept</td></tr>
<tr class="memdesc:aa3351295715fb3ba0d746df7f710d99a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the substring from [Start, End).  <a href="classwpi_1_1StringRef.html#aa3351295715fb3ba0d746df7f710d99a">More...</a><br /></td></tr>
<tr class="separator:aa3351295715fb3ba0d746df7f710d99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a500766ebe40757116bca047131d74"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD std::pair&lt; <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>, <a class="el" href="classwpi_1_1StringRef.html">StringRef</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a54a500766ebe40757116bca047131d74">split</a> (char Separator) const</td></tr>
<tr class="memdesc:a54a500766ebe40757116bca047131d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into two substrings around the first occurrence of a separator character.  <a href="classwpi_1_1StringRef.html#a54a500766ebe40757116bca047131d74">More...</a><br /></td></tr>
<tr class="separator:a54a500766ebe40757116bca047131d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94c621ee126a72a00c0ec765c06bcc1"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD std::pair&lt; <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>, <a class="el" href="classwpi_1_1StringRef.html">StringRef</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#ac94c621ee126a72a00c0ec765c06bcc1">split</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> Separator) const</td></tr>
<tr class="memdesc:ac94c621ee126a72a00c0ec765c06bcc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into two substrings around the first occurrence of a separator string.  <a href="classwpi_1_1StringRef.html#ac94c621ee126a72a00c0ec765c06bcc1">More...</a><br /></td></tr>
<tr class="separator:ac94c621ee126a72a00c0ec765c06bcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e081fea9b96cd729a06fbc7c8c233c5"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD std::pair&lt; <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>, <a class="el" href="classwpi_1_1StringRef.html">StringRef</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a3e081fea9b96cd729a06fbc7c8c233c5">rsplit</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> Separator) const</td></tr>
<tr class="memdesc:a3e081fea9b96cd729a06fbc7c8c233c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into two substrings around the last occurrence of a separator string.  <a href="classwpi_1_1StringRef.html#a3e081fea9b96cd729a06fbc7c8c233c5">More...</a><br /></td></tr>
<tr class="separator:a3e081fea9b96cd729a06fbc7c8c233c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927ec279d16b084402c286ff7b2e3e62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a927ec279d16b084402c286ff7b2e3e62">split</a> (<a class="el" href="classwpi_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classwpi_1_1StringRef.html">StringRef</a> &gt; &amp;A, <a class="el" href="classwpi_1_1StringRef.html">StringRef</a> Separator, int MaxSplit=-1, bool KeepEmpty=true) const</td></tr>
<tr class="memdesc:a927ec279d16b084402c286ff7b2e3e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into substrings around the occurrences of a separator string.  <a href="classwpi_1_1StringRef.html#a927ec279d16b084402c286ff7b2e3e62">More...</a><br /></td></tr>
<tr class="separator:a927ec279d16b084402c286ff7b2e3e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b83c07833494a1e4e874909e7d73ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#ab4b83c07833494a1e4e874909e7d73ef">split</a> (<a class="el" href="classwpi_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classwpi_1_1StringRef.html">StringRef</a> &gt; &amp;A, char Separator, int MaxSplit=-1, bool KeepEmpty=true) const</td></tr>
<tr class="memdesc:ab4b83c07833494a1e4e874909e7d73ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into substrings around the occurrences of a separator character.  <a href="classwpi_1_1StringRef.html#ab4b83c07833494a1e4e874909e7d73ef">More...</a><br /></td></tr>
<tr class="separator:ab4b83c07833494a1e4e874909e7d73ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef588a86434344f850e89a9585265e5"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD std::pair&lt; <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>, <a class="el" href="classwpi_1_1StringRef.html">StringRef</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a5ef588a86434344f850e89a9585265e5">rsplit</a> (char Separator) const</td></tr>
<tr class="memdesc:a5ef588a86434344f850e89a9585265e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into two substrings around the last occurrence of a separator character.  <a href="classwpi_1_1StringRef.html#a5ef588a86434344f850e89a9585265e5">More...</a><br /></td></tr>
<tr class="separator:a5ef588a86434344f850e89a9585265e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43489640f18850b7a52510498455549b"><td class="memItemLeft" align="right" valign="top"><a id="a43489640f18850b7a52510498455549b"></a>
LLVM_NODISCARD <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a43489640f18850b7a52510498455549b">ltrim</a> (char Char) const noexcept</td></tr>
<tr class="memdesc:a43489640f18850b7a52510498455549b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return string with consecutive <code>Char</code> characters starting from the the left removed. <br /></td></tr>
<tr class="separator:a43489640f18850b7a52510498455549b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8268fd2a9dd1a013f0defa744f816b7"><td class="memItemLeft" align="right" valign="top"><a id="af8268fd2a9dd1a013f0defa744f816b7"></a>
LLVM_NODISCARD <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#af8268fd2a9dd1a013f0defa744f816b7">ltrim</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> Chars=&quot; \t\n\v\f\r&quot;) const noexcept</td></tr>
<tr class="memdesc:af8268fd2a9dd1a013f0defa744f816b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return string with consecutive characters in <code>Chars</code> starting from the left removed. <br /></td></tr>
<tr class="separator:af8268fd2a9dd1a013f0defa744f816b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83eb4ffa6bc8e34fd61b65506d6e7090"><td class="memItemLeft" align="right" valign="top"><a id="a83eb4ffa6bc8e34fd61b65506d6e7090"></a>
LLVM_NODISCARD <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a83eb4ffa6bc8e34fd61b65506d6e7090">rtrim</a> (char Char) const noexcept</td></tr>
<tr class="memdesc:a83eb4ffa6bc8e34fd61b65506d6e7090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return string with consecutive <code>Char</code> characters starting from the right removed. <br /></td></tr>
<tr class="separator:a83eb4ffa6bc8e34fd61b65506d6e7090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8069c9050e8c8089d697e35e5e2f55"><td class="memItemLeft" align="right" valign="top"><a id="aae8069c9050e8c8089d697e35e5e2f55"></a>
LLVM_NODISCARD <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#aae8069c9050e8c8089d697e35e5e2f55">rtrim</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> Chars=&quot; \t\n\v\f\r&quot;) const noexcept</td></tr>
<tr class="memdesc:aae8069c9050e8c8089d697e35e5e2f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return string with consecutive characters in <code>Chars</code> starting from the right removed. <br /></td></tr>
<tr class="separator:aae8069c9050e8c8089d697e35e5e2f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2495c7f6816028bb741ae99a803c6f3"><td class="memItemLeft" align="right" valign="top"><a id="af2495c7f6816028bb741ae99a803c6f3"></a>
LLVM_NODISCARD <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#af2495c7f6816028bb741ae99a803c6f3">trim</a> (char Char) const noexcept</td></tr>
<tr class="memdesc:af2495c7f6816028bb741ae99a803c6f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return string with consecutive <code>Char</code> characters starting from the left and right removed. <br /></td></tr>
<tr class="separator:af2495c7f6816028bb741ae99a803c6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae870c975ea093eb1375a7360a8f0f780"><td class="memItemLeft" align="right" valign="top"><a id="ae870c975ea093eb1375a7360a8f0f780"></a>
LLVM_NODISCARD <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#ae870c975ea093eb1375a7360a8f0f780">trim</a> (<a class="el" href="classwpi_1_1StringRef.html">StringRef</a> Chars=&quot; \t\n\v\f\r&quot;) const noexcept</td></tr>
<tr class="memdesc:ae870c975ea093eb1375a7360a8f0f780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return string with consecutive characters in <code>Chars</code> starting from the left and right removed. <br /></td></tr>
<tr class="separator:ae870c975ea093eb1375a7360a8f0f780"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a5ab25bfb57b2f3fe2d3dff5f2ace29da"><td class="memItemLeft" align="right" valign="top"><a id="a5ab25bfb57b2f3fe2d3dff5f2ace29da"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><b>npos</b> = ~size_t(0)</td></tr>
<tr class="separator:a5ab25bfb57b2f3fe2d3dff5f2ace29da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Constructors</h2></td></tr>
<tr class="memitem:a5fc341725067f40f5d28e3ae15e22506"><td class="memItemLeft" align="right" valign="top"><a id="a5fc341725067f40f5d28e3ae15e22506"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a5fc341725067f40f5d28e3ae15e22506">StringRef</a> ()=default</td></tr>
<tr class="memdesc:a5fc341725067f40f5d28e3ae15e22506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty string ref. <br /></td></tr>
<tr class="separator:a5fc341725067f40f5d28e3ae15e22506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d876613f6faacbef5d86ff6696c717e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a1d876613f6faacbef5d86ff6696c717e">StringRef</a> (std::nullptr_t)=delete</td></tr>
<tr class="memdesc:a1d876613f6faacbef5d86ff6696c717e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable conversion from nullptr.  <a href="classwpi_1_1StringRef.html#a1d876613f6faacbef5d86ff6696c717e">More...</a><br /></td></tr>
<tr class="separator:a1d876613f6faacbef5d86ff6696c717e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e783da3d8b6437588fdad7045751ea"><td class="memItemLeft" align="right" valign="top"><a id="ac3e783da3d8b6437588fdad7045751ea"></a>
LLVM_ATTRIBUTE_ALWAYS_INLINE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#ac3e783da3d8b6437588fdad7045751ea">StringRef</a> (const char *Str) noexcept</td></tr>
<tr class="memdesc:ac3e783da3d8b6437588fdad7045751ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string ref from a cstring. <br /></td></tr>
<tr class="separator:ac3e783da3d8b6437588fdad7045751ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd7b5629008eb47fff52b243c3c315e"><td class="memItemLeft" align="right" valign="top"><a id="a8cd7b5629008eb47fff52b243c3c315e"></a>
constexpr LLVM_ATTRIBUTE_ALWAYS_INLINE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a8cd7b5629008eb47fff52b243c3c315e">StringRef</a> (const char *<a class="el" href="classwpi_1_1StringRef.html#a3639987deb10240784a410a843c6df94">data</a>, size_t length) noexcept</td></tr>
<tr class="memdesc:a8cd7b5629008eb47fff52b243c3c315e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string ref from a pointer and length. <br /></td></tr>
<tr class="separator:a8cd7b5629008eb47fff52b243c3c315e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f46f66bc087e1c7a0e3c5e94b07eeeb"><td class="memItemLeft" align="right" valign="top"><a id="a4f46f66bc087e1c7a0e3c5e94b07eeeb"></a>
LLVM_ATTRIBUTE_ALWAYS_INLINE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1StringRef.html#a4f46f66bc087e1c7a0e3c5e94b07eeeb">StringRef</a> (const std::string &amp;Str) noexcept</td></tr>
<tr class="memdesc:a4f46f66bc087e1c7a0e3c5e94b07eeeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string ref from an std::string. <br /></td></tr>
<tr class="separator:a4f46f66bc087e1c7a0e3c5e94b07eeeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df728fc5c667abfdbfd22e86c12d06c"><td class="memItemLeft" align="right" valign="top"><a id="a8df728fc5c667abfdbfd22e86c12d06c"></a>
static <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><b>withNullAsEmpty</b> (const char *<a class="el" href="classwpi_1_1StringRef.html#a3639987deb10240784a410a843c6df94">data</a>) noexcept</td></tr>
<tr class="separator:a8df728fc5c667abfdbfd22e86c12d06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classwpi_1_1StringRef.html" title="StringRef - Represent a constant reference to a string, i.e.">StringRef</a> - Represent a constant reference to a string, i.e. </p>
<p>a character array and a length, which need not be null terminated.</p>
<p>This class does not own the string data, it is expected to be used in situations where the character data resides in some other buffer, whose lifetime extends past that of the <a class="el" href="classwpi_1_1StringRef.html" title="StringRef - Represent a constant reference to a string, i.e.">StringRef</a>. For this reason, it is not in general safe to store a <a class="el" href="classwpi_1_1StringRef.html" title="StringRef - Represent a constant reference to a string, i.e.">StringRef</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1d876613f6faacbef5d86ff6696c717e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d876613f6faacbef5d86ff6696c717e">&#9670;&nbsp;</a></span>StringRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wpi::StringRef::StringRef </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable conversion from nullptr. </p>
<p>This prevents things like if (S == nullptr) </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acddf0e9ed05ab507762e7f050d54e43d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acddf0e9ed05ab507762e7f050d54e43d">&#9670;&nbsp;</a></span>consumeInteger()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::numeric_limits&lt;T&gt;::is_signed, bool&gt;::type wpi::StringRef::consumeInteger </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>Radix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the current string as an integer of the specified radix. </p>
<p>If <code>Radix</code> is specified as zero, this does radix autosensing using extended C rules: 0 is octal, 0x is hex, 0b is binary.</p>
<p>If the string does not begin with a number of the specified radix, this returns true to signify the error. The string is considered erroneous if empty or if it overflows T. The portion of the string representing the discovered numeric value is removed from the beginning of the string. </p>

</div>
</div>
<a id="a589aa40b6d4b46bc6bc0ec10999515e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589aa40b6d4b46bc6bc0ec10999515e9">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE size_t wpi::StringRef::find </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the first character <code>C</code> in the string. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first occurrence of <code>C</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="af37c528a2e72e8c4d94b4b4f93882752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37c528a2e72e8c4d94b4b4f93882752">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD size_t wpi::StringRef::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the first string <code>Str</code> in the string. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first occurrence of <code>Str</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="abed58be9b631562b0ff87f851ed72fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed58be9b631562b0ff87f851ed72fb3">&#9670;&nbsp;</a></span>find_first_not_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD size_t wpi::StringRef::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first character in the string that is not in the string <code>Chars</code>, or npos if not found. </p>
<p>Complexity: O(<a class="el" href="classwpi_1_1StringRef.html#a3f9004ee0e815e1257a211073afc714d" title="size - Get the string size.">size()</a> + Chars.size()) </p>

</div>
</div>
<a id="a669a4f25e56bbde6206b9bc56ee7ddad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669a4f25e56bbde6206b9bc56ee7ddad">&#9670;&nbsp;</a></span>find_first_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD size_t wpi::StringRef::find_first_of </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first character in the string that is <code>C</code>, or npos if not found. </p>
<p>Same as find. </p>

</div>
</div>
<a id="a1997b52fc65a19540ad479e2927c531b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1997b52fc65a19540ad479e2927c531b">&#9670;&nbsp;</a></span>find_first_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD size_t wpi::StringRef::find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first character in the string that is in <code>Chars</code>, or npos if not found. </p>
<p>Complexity: O(<a class="el" href="classwpi_1_1StringRef.html#a3f9004ee0e815e1257a211073afc714d" title="size - Get the string size.">size()</a> + Chars.size()) </p>

</div>
</div>
<a id="ae2fad2f308bf56ca01fdb379390abc90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2fad2f308bf56ca01fdb379390abc90">&#9670;&nbsp;</a></span>find_if()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE size_t wpi::StringRef::find_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1function__ref.html">function_ref</a>&lt; bool(char)&gt;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the first character satisfying the predicate <code>F</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first character satisfying <code>F</code> starting from <code>From</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="a44296d03b4f1fbb07a4f4273e0667bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44296d03b4f1fbb07a4f4273e0667bcd">&#9670;&nbsp;</a></span>find_if_not()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE size_t wpi::StringRef::find_if_not </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1function__ref.html">function_ref</a>&lt; bool(char)&gt;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the first character not satisfying the predicate <code>F</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first character not satisfying <code>F</code> starting from <code>From</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="a44ad21b0b2067f8549a5d77c323917d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ad21b0b2067f8549a5d77c323917d7">&#9670;&nbsp;</a></span>find_last_not_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD size_t wpi::StringRef::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last character in the string that is not in <code>Chars</code>, or npos if not found. </p>
<p>Complexity: O(<a class="el" href="classwpi_1_1StringRef.html#a3f9004ee0e815e1257a211073afc714d" title="size - Get the string size.">size()</a> + Chars.size()) </p>

</div>
</div>
<a id="a138722e01be2750461fb51bc654d0ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a138722e01be2750461fb51bc654d0ac8">&#9670;&nbsp;</a></span>find_last_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD size_t wpi::StringRef::find_last_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last character in the string that is in <code>C</code>, or npos if not found. </p>
<p>Complexity: O(<a class="el" href="classwpi_1_1StringRef.html#a3f9004ee0e815e1257a211073afc714d" title="size - Get the string size.">size()</a> + Chars.size()) </p>

</div>
</div>
<a id="af5a6cabc97ad104fad1f3385a3db9e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a6cabc97ad104fad1f3385a3db9e45">&#9670;&nbsp;</a></span>find_lower() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD size_t wpi::StringRef::find_lower </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the first character <code>C</code> in the string, ignoring case. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first occurrence of <code>C</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="a6dd68110badc7a75e8666317a560bbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd68110badc7a75e8666317a560bbd8">&#9670;&nbsp;</a></span>find_lower() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD size_t wpi::StringRef::find_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the first string <code>Str</code> in the string, ignoring case. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first occurrence of <code>Str</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="a422eca2ca2375a6a894d2dcf1fc1ccb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422eca2ca2375a6a894d2dcf1fc1ccb7">&#9670;&nbsp;</a></span>getAsInteger()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::numeric_limits&lt;T&gt;::is_signed, bool&gt;::type wpi::StringRef::getAsInteger </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>Radix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the current string as an integer of the specified radix. </p>
<p>If <code>Radix</code> is specified as zero, this does radix autosensing using extended C rules: 0 is octal, 0x is hex, 0b is binary.</p>
<p>If the string is invalid or if only a subset of the string is valid, this returns true to signify the error. The string is considered erroneous if empty or if it overflows T. </p>

</div>
</div>
<a id="a91795d2d3202949289b358a701065c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91795d2d3202949289b358a701065c0d">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_same&lt;T, std::string&gt;::value, <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&gt;::type&amp; wpi::StringRef::operator= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>Str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disallow accidental assignment from a temporary std::string. </p>
<p>The declaration here is extra complicated so that <code>stringRef = {}</code> and <code>stringRef = "abc"</code> continue to select the move assignment operator. </p>

</div>
</div>
<a id="a16b26de9e77c44da2d9db794070df64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b26de9e77c44da2d9db794070df64d">&#9670;&nbsp;</a></span>rfind() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD size_t wpi::StringRef::rfind </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the last character <code>C</code> in the string. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the last occurrence of <code>C</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="a187bdc8885e5cf65911ef4d8f7f798c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187bdc8885e5cf65911ef4d8f7f798c4">&#9670;&nbsp;</a></span>rfind() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD size_t wpi::StringRef::rfind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the last string <code>Str</code> in the string. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the last occurrence of <code>Str</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="adfe5fe279dca9ac4e91c3218ea9d2f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe5fe279dca9ac4e91c3218ea9d2f84">&#9670;&nbsp;</a></span>rfind_lower() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD size_t wpi::StringRef::rfind_lower </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the last character <code>C</code> in the string, ignoring case. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the last occurrence of <code>C</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="a60b4d518ac6e18ceee7732203ab5a2c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b4d518ac6e18ceee7732203ab5a2c8">&#9670;&nbsp;</a></span>rfind_lower() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD size_t wpi::StringRef::rfind_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the last string <code>Str</code> in the string, ignoring case. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the last occurrence of <code>Str</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="a5ef588a86434344f850e89a9585265e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef588a86434344f850e89a9585265e5">&#9670;&nbsp;</a></span>rsplit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD std::pair&lt;<a class="el" href="classwpi_1_1StringRef.html">StringRef</a>, <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&gt; wpi::StringRef::rsplit </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>Separator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split into two substrings around the last occurrence of a separator character. </p>
<p>If <code>Separator</code> is in the string, then the result is a pair (LHS, RHS) such that (*this == LHS + Separator + RHS) is true and RHS is minimal. If <code>Separator</code> is not in the string, then the result is a pair (LHS, RHS) where (*this == LHS) and (RHS == "").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Separator</td><td>- The character to split on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- The split substrings. </dd></dl>

</div>
</div>
<a id="a3e081fea9b96cd729a06fbc7c8c233c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e081fea9b96cd729a06fbc7c8c233c5">&#9670;&nbsp;</a></span>rsplit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD std::pair&lt;<a class="el" href="classwpi_1_1StringRef.html">StringRef</a>, <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&gt; wpi::StringRef::rsplit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Separator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split into two substrings around the last occurrence of a separator string. </p>
<p>If <code>Separator</code> is in the string, then the result is a pair (LHS, RHS) such that (*this == LHS + Separator + RHS) is true and RHS is minimal. If <code>Separator</code> is not in the string, then the result is a pair (LHS, RHS) where (*this == LHS) and (RHS == "").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Separator</td><td>- The string to split on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- The split substrings. </dd></dl>

</div>
</div>
<a id="aa3351295715fb3ba0d746df7f710d99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3351295715fb3ba0d746df7f710d99a">&#9670;&nbsp;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE <a class="el" href="classwpi_1_1StringRef.html">StringRef</a> wpi::StringRef::slice </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>End</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the substring from [Start, End). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Start</td><td>The index of the starting character in the substring; if the index is npos or greater than the length of the string then the empty substring will be returned.</td></tr>
    <tr><td class="paramname">End</td><td>The index following the last character to include in the substring. If this is npos or exceeds the number of characters remaining in the string, the string suffix (starting with <code>Start</code>) will be returned. If this is less than <code>Start</code>, an empty string will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54a500766ebe40757116bca047131d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a500766ebe40757116bca047131d74">&#9670;&nbsp;</a></span>split() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD std::pair&lt;<a class="el" href="classwpi_1_1StringRef.html">StringRef</a>, <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&gt; wpi::StringRef::split </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>Separator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split into two substrings around the first occurrence of a separator character. </p>
<p>If <code>Separator</code> is in the string, then the result is a pair (LHS, RHS) such that (*this == LHS + Separator + RHS) is true and RHS is maximal. If <code>Separator</code> is not in the string, then the result is a pair (LHS, RHS) where (*this == LHS) and (RHS == "").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Separator</td><td>The character to split on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The split substrings. </dd></dl>

</div>
</div>
<a id="ab4b83c07833494a1e4e874909e7d73ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b83c07833494a1e4e874909e7d73ef">&#9670;&nbsp;</a></span>split() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::StringRef::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classwpi_1_1StringRef.html">StringRef</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>Separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MaxSplit</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>KeepEmpty</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split into substrings around the occurrences of a separator character. </p>
<p>Each substring is stored in <code>A</code>. If <code>MaxSplit</code> is &gt;= 0, at most <code>MaxSplit</code> splits are done and consequently &lt;= <code>MaxSplit</code> + 1 elements are added to A. If <code>KeepEmpty</code> is false, empty strings are not added to <code>A</code>. They still count when considering <code>MaxSplit</code> An useful invariant is that Separator.join(A) == *this if MaxSplit == -1 and KeepEmpty == true</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- Where to put the substrings. </td></tr>
    <tr><td class="paramname">Separator</td><td>- The string to split on. </td></tr>
    <tr><td class="paramname">MaxSplit</td><td>- The maximum number of times the string is split. </td></tr>
    <tr><td class="paramname">KeepEmpty</td><td>- True if empty substring should be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a927ec279d16b084402c286ff7b2e3e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a927ec279d16b084402c286ff7b2e3e62">&#9670;&nbsp;</a></span>split() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::StringRef::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classwpi_1_1StringRef.html">StringRef</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MaxSplit</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>KeepEmpty</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split into substrings around the occurrences of a separator string. </p>
<p>Each substring is stored in <code>A</code>. If <code>MaxSplit</code> is &gt;= 0, at most <code>MaxSplit</code> splits are done and consequently &lt;= <code>MaxSplit</code> + 1 elements are added to A. If <code>KeepEmpty</code> is false, empty strings are not added to <code>A</code>. They still count when considering <code>MaxSplit</code> An useful invariant is that Separator.join(A) == *this if MaxSplit == -1 and KeepEmpty == true</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- Where to put the substrings. </td></tr>
    <tr><td class="paramname">Separator</td><td>- The string to split on. </td></tr>
    <tr><td class="paramname">MaxSplit</td><td>- The maximum number of times the string is split. </td></tr>
    <tr><td class="paramname">KeepEmpty</td><td>- True if empty substring should be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac94c621ee126a72a00c0ec765c06bcc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94c621ee126a72a00c0ec765c06bcc1">&#9670;&nbsp;</a></span>split() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD std::pair&lt;<a class="el" href="classwpi_1_1StringRef.html">StringRef</a>, <a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&gt; wpi::StringRef::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Separator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split into two substrings around the first occurrence of a separator string. </p>
<p>If <code>Separator</code> is in the string, then the result is a pair (LHS, RHS) such that (*this == LHS + Separator + RHS) is true and RHS is maximal. If <code>Separator</code> is not in the string, then the result is a pair (LHS, RHS) where (*this == LHS) and (RHS == "").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Separator</td><td>- The string to split on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- The split substrings. </dd></dl>

</div>
</div>
<a id="a5a116a12b2b447f3fbce4aa3c7ef688e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a116a12b2b447f3fbce4aa3c7ef688e">&#9670;&nbsp;</a></span>substr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE <a class="el" href="classwpi_1_1StringRef.html">StringRef</a> wpi::StringRef::substr </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the substring from [Start, Start + N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Start</td><td>The index of the starting character in the substring; if the index is npos or greater than the length of the string then the empty substring will be returned.</td></tr>
    <tr><td class="paramname">N</td><td>The number of characters to included in the substring. If N exceeds the number of characters remaining in the string, the string suffix (starting with <code>Start</code>) will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4da11e36b842c7a45f702815ecc8651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4da11e36b842c7a45f702815ecc8651">&#9670;&nbsp;</a></span>take_back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE <a class="el" href="classwpi_1_1StringRef.html">StringRef</a> wpi::StringRef::take_back </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em> = <code>1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a <a class="el" href="classwpi_1_1StringRef.html" title="StringRef - Represent a constant reference to a string, i.e.">StringRef</a> equal to 'this' but with only the last <code>N</code> elements remaining. </p>
<p>If <code>N</code> is greater than the length of the string, the entire string is returned. </p>

</div>
</div>
<a id="ae075a7620907ce3e46c9d53321fac324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae075a7620907ce3e46c9d53321fac324">&#9670;&nbsp;</a></span>take_front()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD LLVM_ATTRIBUTE_ALWAYS_INLINE <a class="el" href="classwpi_1_1StringRef.html">StringRef</a> wpi::StringRef::take_front </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em> = <code>1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a <a class="el" href="classwpi_1_1StringRef.html" title="StringRef - Represent a constant reference to a string, i.e.">StringRef</a> equal to 'this' but with only the first <code>N</code> elements remaining. </p>
<p>If <code>N</code> is greater than the length of the string, the entire string is returned. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>wpi/<a class="el" href="StringRef_8h_source.html">StringRef.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>wpi</b></li><li class="navelem"><a class="el" href="classwpi_1_1StringRef.html">StringRef</a></li>
    <li class="footer">Generated on Sun May 16 2021 04:41:00 for WPILibC++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
