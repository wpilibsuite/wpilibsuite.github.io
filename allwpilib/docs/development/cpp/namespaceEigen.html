<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: Eigen Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="wpilib-128.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">WPILibC++<span id="projectnumber">&#160;2022.1.1-alpha-3-14-g4647d09</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceEigen.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Eigen Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Namespace containing all symbols from the Eigen library.  
<a href="namespaceEigen.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceEigen_1_1indexing"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1indexing.html">indexing</a></td></tr>
<tr class="memdesc:namespaceEigen_1_1indexing"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sole purpose of this namespace is to be able to import all functions and symbols that are expected to be used within operator() for indexing and slicing. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceEigen_1_1symbolic"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1symbolic.html">symbolic</a></td></tr>
<tr class="memdesc:namespaceEigen_1_1symbolic"><td class="mdescLeft">&#160;</td><td class="mdescRight">This namespace defines a set of classes and functions to build and evaluate symbolic expressions of scalar type Index. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1aligned__allocator.html">aligned_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL compatible allocator to use with types requiring a non standrad alignment.  <a href="classEigen_1_1aligned__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1aligned__allocator__indirection.html">aligned_allocator_indirection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1AlignedBox.html">AlignedBox</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1AngleAxis.html">AngleAxis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ArithmeticSequence.html">ArithmeticSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an arithmetic progression \( a_0, a_1, a_2, ..., a_{n-1}\) defined by its <em>first</em> value \( a_0 \), its <em>size</em> (aka length) <em>n</em>, and the <em>increment</em> (aka stride) that is equal to \( a_{i+1}-a_{i}\) for any <em>i</em>.  <a href="classEigen_1_1ArithmeticSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Array.html">Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General-purpose arrays with easy API for coefficient-wise operations.  <a href="classEigen_1_1Array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ArrayBase.html">ArrayBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all 1D and 2D array, and related expressions.  <a href="classEigen_1_1ArrayBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ArrayWrapper.html">ArrayWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of a mathematical vector or matrix as an array object.  <a href="classEigen_1_1ArrayWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1ArrayXpr.html">ArrayXpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to identify an array expression.  <a href="structEigen_1_1ArrayXpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1AutoDiffJacobian.html">AutoDiffJacobian</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1AutoDiffScalar.html">AutoDiffScalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scalar type replacement with automatic differentiation capability.  <a href="classEigen_1_1AutoDiffScalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1AutoDiffVector.html">AutoDiffVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1BandShape.html">BandShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1BDCSVD.html">BDCSVD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class Bidiagonal Divide and Conquer SVD  <a href="classEigen_1_1BDCSVD.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1bfloat16.html">bfloat16</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Block.html">Block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of a fixed-size or dynamic-size block.  <a href="classEigen_1_1Block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1BlockImpl.html">BlockImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1BlockImpl_3_01XprType_00_01BlockRows_00_01BlockCols_00_01InnerPanel_00_01Dense_01_4.html">BlockImpl&lt; XprType, BlockRows, BlockCols, InnerPanel, Dense &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1CleanedUpDerType.html">CleanedUpDerType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ColPivHouseholderQR.html">ColPivHouseholderQR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Householder rank-revealing QR decomposition of a matrix with column-pivoting.  <a href="classEigen_1_1ColPivHouseholderQR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1CommaInitializer.html">CommaInitializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class used by the comma initializer operator.  <a href="structEigen_1_1CommaInitializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1CompleteOrthogonalDecomposition.html">CompleteOrthogonalDecomposition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete orthogonal decomposition (COD) of a matrix.  <a href="classEigen_1_1CompleteOrthogonalDecomposition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ComplexEigenSolver.html">ComplexEigenSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">\eigenvalues_module  <a href="classEigen_1_1ComplexEigenSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ComplexSchur.html">ComplexSchur</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">\eigenvalues_module  <a href="classEigen_1_1ComplexSchur.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Conjugate.html">Conjugate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Cross.html">Cross</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic expression where a coefficient-wise binary operator is applied to two expressions.  <a href="classEigen_1_1CwiseBinaryOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1CwiseBinaryOpImpl.html">CwiseBinaryOpImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic expression of a matrix where all coefficients are defined by a functor.  <a href="classEigen_1_1CwiseNullaryOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1CwiseTernaryOp.html">CwiseTernaryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic expression where a coefficient-wise ternary operator is applied to two expressions.  <a href="classEigen_1_1CwiseTernaryOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1CwiseTernaryOpImpl.html">CwiseTernaryOpImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic expression where a coefficient-wise unary operator is applied to an expression.  <a href="classEigen_1_1CwiseUnaryOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1CwiseUnaryOpImpl.html">CwiseUnaryOpImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1CwiseUnaryView.html">CwiseUnaryView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic lvalue expression of a coefficient-wise unary operator of a matrix or a vector.  <a href="classEigen_1_1CwiseUnaryView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1CwiseUnaryViewImpl.html">CwiseUnaryViewImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1CwiseUnaryViewImpl_3_01ViewOp_00_01MatrixType_00_01Dense_01_4.html">CwiseUnaryViewImpl&lt; ViewOp, MatrixType, Dense &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1Dense.html">Dense</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to identify a dense storage.  <a href="structEigen_1_1Dense.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all dense matrices, vectors, and arrays.  <a href="classEigen_1_1DenseBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase.html">DenseCoeffsBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectAccessors_01_4.html">DenseCoeffsBase&lt; Derived, DirectAccessors &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class providing direct read-only coefficient access to matrices and arrays.  <a href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectAccessors_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html">DenseCoeffsBase&lt; Derived, DirectWriteAccessors &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class providing direct read/write coefficient access to matrices and arrays.  <a href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01DirectWriteAccessors_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html">DenseCoeffsBase&lt; Derived, ReadOnlyAccessors &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class providing read-only coefficient access to matrices and arrays.  <a href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html">DenseCoeffsBase&lt; Derived, WriteAccessors &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class providing read/write coefficient access to matrices and arrays.  <a href="classEigen_1_1DenseCoeffsBase_3_01Derived_00_01WriteAccessors_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1DenseShape.html">DenseShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseStorage.html">DenseStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseStorage_3_01T_00_010_00_01__Rows_00_01__Cols_00_01__Options_01_4.html">DenseStorage&lt; T, 0, _Rows, _Cols, _Options &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseStorage_3_01T_00_010_00_01__Rows_00_01Dynamic_00_01__Options_01_4.html">DenseStorage&lt; T, 0, _Rows, Dynamic, _Options &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseStorage_3_01T_00_010_00_01Dynamic_00_01__Cols_00_01__Options_01_4.html">DenseStorage&lt; T, 0, Dynamic, _Cols, _Options &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseStorage_3_01T_00_010_00_01Dynamic_00_01Dynamic_00_01__Options_01_4.html">DenseStorage&lt; T, 0, Dynamic, Dynamic, _Options &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseStorage_3_01T_00_01Dynamic_00_01__Rows_00_01Dynamic_00_01__Options_01_4.html">DenseStorage&lt; T, Dynamic, _Rows, Dynamic, _Options &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseStorage_3_01T_00_01Dynamic_00_01Dynamic_00_01__Cols_00_01__Options_01_4.html">DenseStorage&lt; T, Dynamic, Dynamic, _Cols, _Options &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseStorage_3_01T_00_01Dynamic_00_01Dynamic_00_01Dynamic_00_01__Options_01_4.html">DenseStorage&lt; T, Dynamic, Dynamic, Dynamic, _Options &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseStorage_3_01T_00_01Size_00_01__Rows_00_01Dynamic_00_01__Options_01_4.html">DenseStorage&lt; T, Size, _Rows, Dynamic, _Options &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseStorage_3_01T_00_01Size_00_01Dynamic_00_01__Cols_00_01__Options_01_4.html">DenseStorage&lt; T, Size, Dynamic, _Cols, _Options &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseStorage_3_01T_00_01Size_00_01Dynamic_00_01Dynamic_00_01__Options_01_4.html">DenseStorage&lt; T, Size, Dynamic, Dynamic, _Options &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Diagonal.html">Diagonal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of a diagonal/subdiagonal/superdiagonal in a matrix.  <a href="classEigen_1_1Diagonal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DiagonalBase.html">DiagonalBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DiagonalMatrix.html">DiagonalMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a diagonal matrix with its storage.  <a href="classEigen_1_1DiagonalMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DiagonalProduct.html">DiagonalProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1DiagonalShape.html">DiagonalShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DiagonalWrapper.html">DiagonalWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of a diagonal matrix.  <a href="classEigen_1_1DiagonalWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class for all classes T such that <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions.">MatrixBase</a> has an operator=(T) and a constructor MatrixBase(T).  <a href="structEigen_1_1EigenBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1EigenSolver.html">EigenSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">\eigenvalues_module  <a href="classEigen_1_1EigenSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Flagged.html">Flagged</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ForceAlignedAccess.html">ForceAlignedAccess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enforce aligned packet loads and stores regardless of what is requested.  <a href="classEigen_1_1ForceAlignedAccess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1FullPivHouseholderQR.html">FullPivHouseholderQR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Householder rank-revealing QR decomposition of a matrix with full pivoting.  <a href="classEigen_1_1FullPivHouseholderQR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1FullPivLU.html">FullPivLU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LU decomposition of a matrix with complete pivoting, and related features.  <a href="classEigen_1_1FullPivLU.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1general__product__to__triangular__selector.html">general_product_to_triangular_selector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1general__product__to__triangular__selector_3_01MatrixType_00_01ProductType_00_01UpLo_00_01false_01_4.html">general_product_to_triangular_selector&lt; MatrixType, ProductType, UpLo, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1general__product__to__triangular__selector_3_01MatrixType_00_01ProductType_00_01UpLo_00_01true_01_4.html">general_product_to_triangular_selector&lt; MatrixType, ProductType, UpLo, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1GeneralizedEigenSolver.html">GeneralizedEigenSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">\eigenvalues_module  <a href="classEigen_1_1GeneralizedEigenSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1GeneralizedSelfAdjointEigenSolver.html">GeneralizedSelfAdjointEigenSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">\eigenvalues_module  <a href="classEigen_1_1GeneralizedSelfAdjointEigenSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1GenericNumTraits.html">GenericNumTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1half.html">half</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1HessenbergDecomposition.html">HessenbergDecomposition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">\eigenvalues_module  <a href="classEigen_1_1HessenbergDecomposition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Homogeneous.html">Homogeneous</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1HomogeneousShape.html">HomogeneousShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1HouseholderQR.html">HouseholderQR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Householder QR decomposition of a matrix.  <a href="classEigen_1_1HouseholderQR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1HouseholderSequence.html">HouseholderSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">\householder_module  <a href="classEigen_1_1HouseholderSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Hyperplane.html">Hyperplane</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1IndexedView.html">IndexedView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of a non-sequential sub-matrix defined by arbitrary sequences of row and column indices.  <a href="classEigen_1_1IndexedView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1IndexedViewImpl.html">IndexedViewImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1InnerIterator.html">InnerIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classEigen_1_1InnerIterator.html" title="An InnerIterator allows to loop over the element of any matrix expression.">InnerIterator</a> allows to loop over the element of any matrix expression.  <a href="classEigen_1_1InnerIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1InnerStride.html">InnerStride</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience specialization of <a class="el" href="classEigen_1_1Stride.html" title="Holds strides information for Map.">Stride</a> to specify only an inner stride See class <a class="el" href="classEigen_1_1Map.html" title="A matrix or vector expression mapping an existing array of data.">Map</a> for some examples.  <a href="classEigen_1_1InnerStride.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Inverse.html">Inverse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of the inverse of another expression.  <a href="classEigen_1_1Inverse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1InverseImpl.html">InverseImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1InverseImpl_3_01PermutationType_00_01PermutationStorage_01_4.html">InverseImpl&lt; PermutationType, PermutationStorage &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1IOFormat.html">IOFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a set of parameters controlling the way matrices are printed.  <a href="structEigen_1_1IOFormat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1JacobiRotation.html">JacobiRotation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">\jacobi_module  <a href="classEigen_1_1JacobiRotation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1JacobiSVD.html">JacobiSVD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two-sided Jacobi SVD decomposition of a rectangular matrix.  <a href="classEigen_1_1JacobiSVD.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1LazyProductReturnType.html">LazyProductReturnType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1LDLT.html">LDLT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Robust Cholesky decomposition of a matrix with pivoting.  <a href="classEigen_1_1LDLT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1LLT.html">LLT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard Cholesky decomposition (LL^T) of a matrix and associated features.  <a href="classEigen_1_1LLT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Map.html">Map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix or vector expression mapping an existing array of data.  <a href="classEigen_1_1Map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Map_3_01PermutationMatrix_3_01SizeAtCompileTime_00_01MaxSizeAtCompileTime_00_01__S612b1e75ea633e086cdce74f2566f005.html">Map&lt; PermutationMatrix&lt; SizeAtCompileTime, MaxSizeAtCompileTime, _StorageIndex &gt;, _PacketAccess &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Map_3_01Transpositions_3_01SizeAtCompileTime_00_01MaxSizeAtCompileTime_00_01__Stor791ee41d5b47f4ee71609b600f85e4ea.html">Map&lt; Transpositions&lt; SizeAtCompileTime, MaxSizeAtCompileTime, _StorageIndex &gt;, PacketAccess &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MapBase.html">MapBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MapBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html">MapBase&lt; Derived, ReadOnlyAccessors &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for dense <a class="el" href="classEigen_1_1Map.html" title="A matrix or vector expression mapping an existing array of data.">Map</a> and <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> expression with direct access.  <a href="classEigen_1_1MapBase_3_01Derived_00_01ReadOnlyAccessors_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MapBase_3_01Derived_00_01WriteAccessors_01_4.html">MapBase&lt; Derived, WriteAccessors &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for non-const dense <a class="el" href="classEigen_1_1Map.html" title="A matrix or vector expression mapping an existing array of data.">Map</a> and <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> expression with direct access.  <a href="classEigen_1_1MapBase_3_01Derived_00_01WriteAccessors_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Matrix.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix class, also used for vectors and row-vectors.  <a href="classEigen_1_1Matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all dense matrices, vectors, and expressions.  <a href="classEigen_1_1MatrixBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixComplexPowerReturnValue.html">MatrixComplexPowerReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix power of some matrix (expression).  <a href="classEigen_1_1MatrixComplexPowerReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1MatrixExponentialReturnValue.html">MatrixExponentialReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix exponential of some matrix (expression).  <a href="structEigen_1_1MatrixExponentialReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixFunctionReturnValue.html">MatrixFunctionReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix function of some matrix (expression).  <a href="classEigen_1_1MatrixFunctionReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixLogarithmReturnValue.html">MatrixLogarithmReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix logarithm of some matrix (expression).  <a href="classEigen_1_1MatrixLogarithmReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixPower.html">MatrixPower</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing matrix powers.  <a href="classEigen_1_1MatrixPower.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixPowerAtomic.html">MatrixPowerAtomic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing matrix powers.  <a href="classEigen_1_1MatrixPowerAtomic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixPowerParenthesesReturnValue.html">MatrixPowerParenthesesReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix power of some matrix.  <a href="classEigen_1_1MatrixPowerParenthesesReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixPowerReturnValue.html">MatrixPowerReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix power of some matrix (expression).  <a href="classEigen_1_1MatrixPowerReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixSquareRootReturnValue.html">MatrixSquareRootReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix square root of some matrix (expression).  <a href="classEigen_1_1MatrixSquareRootReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixWrapper.html">MatrixWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of an array as a mathematical vector or matrix.  <a href="classEigen_1_1MatrixWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1MatrixXpr.html">MatrixXpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to identify a matrix expression.  <a href="structEigen_1_1MatrixXpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1NestByValue.html">NestByValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression which must be nested by value.  <a href="classEigen_1_1NestByValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1NoAlias.html">NoAlias</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pseudo expression providing an operator = assuming no aliasing.  <a href="classEigen_1_1NoAlias.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds information about the various numeric (i.e.  <a href="structEigen_1_1NumTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1NumTraits_3_01Array_3_01Scalar_00_01Rows_00_01Cols_00_01Options_00_01MaxRows_00_01MaxCols_01_4_01_4.html">NumTraits&lt; Array&lt; Scalar, Rows, Cols, Options, MaxRows, MaxCols &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1NumTraits_3_01AutoDiffScalar_3_01DerType_01_4_01_4.html">NumTraits&lt; AutoDiffScalar&lt; DerType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1NumTraits_3_01bool_01_4.html">NumTraits&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1NumTraits_3_01double_01_4.html">NumTraits&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1NumTraits_3_01Eigen_1_1bfloat16_01_4.html">NumTraits&lt; Eigen::bfloat16 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1NumTraits_3_01Eigen_1_1half_01_4.html">NumTraits&lt; Eigen::half &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1NumTraits_3_01float_01_4.html">NumTraits&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1NumTraits_3_01long_01double_01_4.html">NumTraits&lt; long double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1NumTraits_3_01std_1_1complex_3_01__Real_01_4_01_4.html">NumTraits&lt; std::complex&lt; _Real &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1NumTraits_3_01std_1_1string_01_4.html">NumTraits&lt; std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1NumTraits_3_01void_01_4.html">NumTraits&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1OuterStride.html">OuterStride</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience specialization of <a class="el" href="classEigen_1_1Stride.html" title="Holds strides information for Map.">Stride</a> to specify only an outer stride See class <a class="el" href="classEigen_1_1Map.html" title="A matrix or vector expression mapping an existing array of data.">Map</a> for some examples.  <a href="classEigen_1_1OuterStride.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ParametrizedLine.html">ParametrizedLine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1partial__redux__dummy__func.html">partial_redux_dummy_func</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PartialPivLU.html">PartialPivLU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LU decomposition of a matrix with partial pivoting, and related features.  <a href="classEigen_1_1PartialPivLU.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PartialReduxExpr.html">PartialReduxExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic expression of a partially reduxed matrix.  <a href="classEigen_1_1PartialReduxExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PermutationBase.html">PermutationBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for permutations.  <a href="classEigen_1_1PermutationBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PermutationMatrix.html">PermutationMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutation matrix.  <a href="classEigen_1_1PermutationMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1PermutationShape.html">PermutationShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1PermutationStorage.html">PermutationStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to identify a permutation storage.  <a href="structEigen_1_1PermutationStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PermutationWrapper.html">PermutationWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to view a vector of integers as a permutation matrix.  <a href="classEigen_1_1PermutationWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PlainObjectBase.html">PlainObjectBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Product.html">Product</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of the product of two arbitrary matrices or vectors.  <a href="classEigen_1_1Product.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductImpl.html">ProductImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ProductImpl_3_01Lhs_00_01Rhs_00_01Option_00_01Dense_01_4.html">ProductImpl&lt; Lhs, Rhs, Option, Dense &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1ProductReturnType.html">ProductReturnType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Quaternion.html">Quaternion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1QuaternionBase.html">QuaternionBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1RealQZ.html">RealQZ</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">\eigenvalues_module  <a href="classEigen_1_1RealQZ.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1RealSchur.html">RealSchur</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">\eigenvalues_module  <a href="classEigen_1_1RealSchur.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Ref.html">Ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix or vector expression mapping an existing expression.  <a href="classEigen_1_1Ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Ref_3_01const_01TPlainObjectType_00_01Options_00_01StrideType_01_4.html">Ref&lt; const TPlainObjectType, Options, StrideType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1RefBase.html">RefBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Replicate.html">Replicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of the multiple replication of a matrix or vector.  <a href="classEigen_1_1Replicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Reshaped.html">Reshaped</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of a fixed-size or dynamic-size reshape.  <a href="classEigen_1_1Reshaped.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ReshapedImpl.html">ReshapedImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ReshapedImpl_3_01XprType_00_01Rows_00_01Cols_00_01Order_00_01Dense_01_4.html">ReshapedImpl&lt; XprType, Rows, Cols, Order, Dense &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1ReturnByValue.html">ReturnByValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Reverse.html">Reverse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of the reverse of a vector or matrix.  <a href="classEigen_1_1Reverse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Rotation2D.html">Rotation2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1RotationBase.html">RotationBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1ScalarBinaryOpTraits.html">ScalarBinaryOpTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given binary operation of two numeric types is allowed and what the scalar return type is.  <a href="structEigen_1_1ScalarBinaryOpTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1ScalarBinaryOpTraits_3_01AutoDiffScalar_3_01DerType_01_4_00_01typename_01DerType_1_1Scalar_00_01BinOp_01_4.html">ScalarBinaryOpTraits&lt; AutoDiffScalar&lt; DerType &gt;, typename DerType::Scalar, BinOp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1ScalarBinaryOpTraits_3_01T_00_01T_00_01BinaryOp_01_4.html">ScalarBinaryOpTraits&lt; T, T, BinaryOp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1ScalarBinaryOpTraits_3_01T_00_01typename_01NumTraits_3_01typename_01internal_1_1e56d7471d15e084cfef57c181a609e17b.html">ScalarBinaryOpTraits&lt; T, typename NumTraits&lt; typename internal::enable_if&lt; NumTraits&lt; T &gt;::IsComplex, T &gt;::type &gt;::Real, BinaryOp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1ScalarBinaryOpTraits_3_01T_00_01void_00_01BinaryOp_01_4.html">ScalarBinaryOpTraits&lt; T, void, BinaryOp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1ScalarBinaryOpTraits_3_01typename_01DerType_1_1Scalar_00_01AutoDiffScalar_3_01DerType_01_4_00_01BinOp_01_4.html">ScalarBinaryOpTraits&lt; typename DerType::Scalar, AutoDiffScalar&lt; DerType &gt;, BinOp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1ScalarBinaryOpTraits_3_01typename_01NumTraits_3_01typename_01internal_1_1enable__cb0e31770c68ef6e6bb9fa3dde8a23d7.html">ScalarBinaryOpTraits&lt; typename NumTraits&lt; typename internal::enable_if&lt; NumTraits&lt; T &gt;::IsComplex, T &gt;::type &gt;::Real, T, BinaryOp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1ScalarBinaryOpTraits_3_01void_00_01T_00_01BinaryOp_01_4.html">ScalarBinaryOpTraits&lt; void, T, BinaryOp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1ScalarBinaryOpTraits_3_01void_00_01void_00_01BinaryOp_01_4.html">ScalarBinaryOpTraits&lt; void, void, BinaryOp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Select.html">Select</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of a coefficient wise version of the C++ ternary operator ?:  <a href="classEigen_1_1Select.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1selfadjoint__product__selector.html">selfadjoint_product_selector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1selfadjoint__product__selector_3_01MatrixType_00_01OtherType_00_01UpLo_00_01false_01_4.html">selfadjoint_product_selector&lt; MatrixType, OtherType, UpLo, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1selfadjoint__product__selector_3_01MatrixType_00_01OtherType_00_01UpLo_00_01true_01_4.html">selfadjoint_product_selector&lt; MatrixType, OtherType, UpLo, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1selfadjoint__rank1__update.html">selfadjoint_rank1_update</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1selfadjoint__rank1__update_3_01Scalar_00_01Index_00_01ColMajor_00_01UpLo_00_01ConjLhs_00_01ConjRhs_01_4.html">selfadjoint_rank1_update&lt; Scalar, Index, ColMajor, UpLo, ConjLhs, ConjRhs &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1selfadjoint__rank1__update_3_01Scalar_00_01Index_00_01RowMajor_00_01UpLo_00_01ConjLhs_00_01ConjRhs_01_4.html">selfadjoint_rank1_update&lt; Scalar, Index, RowMajor, UpLo, ConjLhs, ConjRhs &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SelfAdjointEigenSolver.html">SelfAdjointEigenSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">\eigenvalues_module  <a href="classEigen_1_1SelfAdjointEigenSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1SelfAdjointShape.html">SelfAdjointShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SelfAdjointView.html">SelfAdjointView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of a selfadjoint matrix from a triangular part of a dense matrix.  <a href="classEigen_1_1SelfAdjointView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Solve.html">Solve</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pseudo expression representing a solving operation.  <a href="classEigen_1_1Solve.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SolveImpl.html">SolveImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SolveImpl_3_01Decomposition_00_01RhsType_00_01Dense_01_4.html">SolveImpl&lt; Decomposition, RhsType, Dense &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SolverBase.html">SolverBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for matrix decomposition and solvers.  <a href="classEigen_1_1SolverBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1SolverShape.html">SolverShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1SolverStorage.html">SolverStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to identify a general solver (factored) storage.  <a href="structEigen_1_1SolverStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1Sparse.html">Sparse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to identify a general sparse storage.  <a href="structEigen_1_1Sparse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseMatrixBase.html">SparseMatrixBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1SparseShape.html">SparseShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseView.html">SparseView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Stride.html">Stride</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds strides information for <a class="el" href="classEigen_1_1Map.html" title="A matrix or vector expression mapping an existing array of data.">Map</a>.  <a href="classEigen_1_1Stride.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SVDBase.html">SVDBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of SVD algorithms.  <a href="classEigen_1_1SVDBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SwapWrapper.html">SwapWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transform.html">Transform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Translation.html">Translation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transpose.html">Transpose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of the transpose of a matrix.  <a href="classEigen_1_1Transpose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transpose_3_01TranspositionsBase_3_01TranspositionsDerived_01_4_01_4.html">Transpose&lt; TranspositionsBase&lt; TranspositionsDerived &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TransposeImpl.html">TransposeImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TransposeImpl_3_01MatrixType_00_01Dense_01_4.html">TransposeImpl&lt; MatrixType, Dense &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Transpositions.html">Transpositions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a sequence of transpositions (row/column interchange)  <a href="classEigen_1_1Transpositions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TranspositionsBase.html">TranspositionsBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1TranspositionsShape.html">TranspositionsShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1TranspositionsStorage.html">TranspositionsStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to identify a permutation storage.  <a href="structEigen_1_1TranspositionsStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TranspositionsWrapper.html">TranspositionsWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TriangularBase.html">TriangularBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for triangular part in a matrix.  <a href="classEigen_1_1TriangularBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1TriangularShape.html">TriangularShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TriangularView.html">TriangularView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of a triangular part in a matrix.  <a href="classEigen_1_1TriangularView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TriangularViewImpl.html">TriangularViewImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TriangularViewImpl_3_01__MatrixType_00_01__Mode_00_01Dense_01_4.html">TriangularViewImpl&lt; _MatrixType, _Mode, Dense &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for a triangular part in a <b>dense</b> matrix.  <a href="classEigen_1_1TriangularViewImpl_3_01__MatrixType_00_01__Mode_00_01Dense_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Tridiagonalization.html">Tridiagonalization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">\eigenvalues_module  <a href="classEigen_1_1Tridiagonalization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1UniformScaling.html">UniformScaling</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorBlock.html">VectorBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of a fixed-size or dynamic-size sub-vector.  <a href="classEigen_1_1VectorBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html">VectorwiseOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pseudo expression providing broadcasting and partial reduction operations.  <a href="classEigen_1_1VectorwiseOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1WithFormat.html">WithFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pseudo expression providing matrix output with given format.  <a href="classEigen_1_1WithFormat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa06499c94936a19673e53deb516a1b76"><td class="memItemLeft" align="right" valign="top"><a id="aa06499c94936a19673e53deb516a1b76" name="aa06499c94936a19673e53deb516a1b76"></a>
typedef EIGEN_DEFAULT_DENSE_INDEX_TYPE&#160;</td><td class="memItemRight" valign="bottom"><b>DenseIndex</b></td></tr>
<tr class="separator:aa06499c94936a19673e53deb516a1b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e77e0933482dafde8fe197d9a2cfde"><td class="memItemLeft" align="right" valign="top">typedef EIGEN_DEFAULT_DENSE_INDEX_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td></tr>
<tr class="memdesc:a62e77e0933482dafde8fe197d9a2cfde"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Index type as used for the API.  <a href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">More...</a><br /></td></tr>
<tr class="separator:a62e77e0933482dafde8fe197d9a2cfde"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a04572776902ca4beebe54812ba697b2a"><td class="memItemLeft" align="right" valign="top"><a id="a04572776902ca4beebe54812ba697b2a" name="a04572776902ca4beebe54812ba697b2a"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>DontAlignCols</b> = 1
 }</td></tr>
<tr class="separator:a04572776902ca4beebe54812ba697b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b2e8bd3fe869b2692fc9d59918fe13"><td class="memItemLeft" align="right" valign="top"><a id="a17b2e8bd3fe869b2692fc9d59918fe13" name="a17b2e8bd3fe869b2692fc9d59918fe13"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>StreamPrecision</b> = -1
, <b>FullPrecision</b> = -2
 }</td></tr>
<tr class="separator:a17b2e8bd3fe869b2692fc9d59918fe13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968fc255933ad89c82e16f4ebfa7cb01"><td class="memItemLeft" align="right" valign="top"><a id="a968fc255933ad89c82e16f4ebfa7cb01" name="a968fc255933ad89c82e16f4ebfa7cb01"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>Large</b> = 2
, <b>Small</b> = 3
 }</td></tr>
<tr class="separator:a968fc255933ad89c82e16f4ebfa7cb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39e3366ff5554d731e7dc8bb642f83cd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#ga39e3366ff5554d731e7dc8bb642f83cd">UpLoType</a> { <br />
&#160;&#160;<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749">Lower</a> =0x1
, <a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1">Upper</a> =0x2
, <a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda2ef430bff6cc12c2d1e0ef01b95f7ff3">UnitDiag</a> =0x4
, <a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdac4dc554a61510151ddd5bafaf6040223">ZeroDiag</a> =0x8
, <br />
&#160;&#160;<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda8f40b928c10a71ba03e5f75ad2a72fda">UnitLower</a> =UnitDiag|Lower
, <a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdadd28224d7ea92689930be73c1b50b0ad">UnitUpper</a> =UnitDiag|Upper
, <a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda2424988b6fca98be70b595632753ba81">StrictlyLower</a> =ZeroDiag|Lower
, <a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda7b37877e0b9b0df28c9c2b669a633265">StrictlyUpper</a> =ZeroDiag|Upper
, <br />
&#160;&#160;<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdacf9ccb2016f8b9c0f3268f05a1e75821">SelfAdjoint</a> =0x10
, <a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdad5381b2d1c8973a08303c94e7da02333">Symmetric</a> =0x20
<br />
 }</td></tr>
<tr class="memdesc:ga39e3366ff5554d731e7dc8bb642f83cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum containing possible values for the <code>Mode</code> or <code>UpLo</code> parameter of MatrixBase::selfadjointView() and MatrixBase::triangularView(), and selfadjoint solvers.  <a href="group__enums.html#ga39e3366ff5554d731e7dc8bb642f83cd">More...</a><br /></td></tr>
<tr class="separator:ga39e3366ff5554d731e7dc8bb642f83cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45fe06e29902b7a2773de05ba27b47a1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#ga45fe06e29902b7a2773de05ba27b47a1">AlignmentType</a> { <br />
&#160;&#160;<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1a4e19dd09d5ff42295ba1d72d12a46686">Unaligned</a> =0
, <a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1a9d99d7a9ff1da5c949bec22733bfba14">Aligned8</a> =8
, <a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1ad0b140cd97bc74365b51843d28379655">Aligned16</a> =16
, <a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1a8a380b1cd0c3e5a6cceac06f8235157a">Aligned32</a> =32
, <br />
&#160;&#160;<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1a2639cfa1e8faac751556bc0009fe95a4">Aligned64</a> =64
, <a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1a60057da2408e499b5656244d0b26cc20">Aligned128</a> =128
, <b>AlignedMask</b> =255
, <a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1ae12d0f8f869c40c76128260af2242bc8">Aligned</a> =16
, <br />
&#160;&#160;<b>AlignedMax</b> = Unaligned
<br />
 }</td></tr>
<tr class="memdesc:ga45fe06e29902b7a2773de05ba27b47a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for indicating whether a buffer is aligned or not.  <a href="group__enums.html#ga45fe06e29902b7a2773de05ba27b47a1">More...</a><br /></td></tr>
<tr class="separator:ga45fe06e29902b7a2773de05ba27b47a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad49a7b3738e273eb00932271b36127f7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#gad49a7b3738e273eb00932271b36127f7">DirectionType</a> { <a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7ae2efac6e74ecab5e3b0b1561c5ddf83e">Vertical</a>
, <a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7a961c62410157b64033839488f4d7f7e4">Horizontal</a>
, <a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7a04fefd61992e941d509a57bc44c59794">BothDirections</a>
 }</td></tr>
<tr class="memdesc:gad49a7b3738e273eb00932271b36127f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum containing possible values for the <code>Direction</code> parameter of Reverse, PartialReduxExpr and VectorwiseOp.  <a href="group__enums.html#gad49a7b3738e273eb00932271b36127f7">More...</a><br /></td></tr>
<tr class="separator:gad49a7b3738e273eb00932271b36127f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2409f30bc18e288e66de7ac53f71e5"><td class="memItemLeft" align="right" valign="top"><a id="a3d2409f30bc18e288e66de7ac53f71e5" name="a3d2409f30bc18e288e66de7ac53f71e5"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>TraversalType</b> { <br />
&#160;&#160;<b>DefaultTraversal</b>
, <b>LinearTraversal</b>
, <b>InnerVectorizedTraversal</b>
, <b>LinearVectorizedTraversal</b>
, <br />
&#160;&#160;<b>SliceVectorizedTraversal</b>
, <b>InvalidTraversal</b>
, <b>AllAtOnceTraversal</b>
<br />
 }</td></tr>
<tr class="separator:a3d2409f30bc18e288e66de7ac53f71e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c7299b77156ae8c7827ba61787669d"><td class="memItemLeft" align="right" valign="top"><a id="ab8c7299b77156ae8c7827ba61787669d" name="ab8c7299b77156ae8c7827ba61787669d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>UnrollingType</b> { <b>NoUnrolling</b>
, <b>InnerUnrolling</b>
, <b>CompleteUnrolling</b>
 }</td></tr>
<tr class="separator:ab8c7299b77156ae8c7827ba61787669d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4ff3ed63ee9637dda3fedea4bba1ea"><td class="memItemLeft" align="right" valign="top"><a id="a8f4ff3ed63ee9637dda3fedea4bba1ea" name="a8f4ff3ed63ee9637dda3fedea4bba1ea"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>SpecializedType</b> { <b>Specialized</b>
, <b>BuiltIn</b>
 }</td></tr>
<tr class="separator:a8f4ff3ed63ee9637dda3fedea4bba1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacded1a18ae58b0f554751f6cdf9eb13"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#gaacded1a18ae58b0f554751f6cdf9eb13">StorageOptions</a> { <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62">ColMajor</a> = 0
, <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f">RowMajor</a> = 0x1
, <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13ad0e7f67d40bcde3d41c12849b16ce6ea">AutoAlign</a> = 0
, <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a56908522e51443a0aa0567f879c2e78a">DontAlign</a> = 0x2
 }</td></tr>
<tr class="memdesc:gaacded1a18ae58b0f554751f6cdf9eb13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum containing possible values for the <code>_Options</code> template parameter of Matrix, Array and BandMatrix.  <a href="group__enums.html#gaacded1a18ae58b0f554751f6cdf9eb13">More...</a><br /></td></tr>
<tr class="separator:gaacded1a18ae58b0f554751f6cdf9eb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac22de43beeac7a78b384f99bed5cee0b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#gac22de43beeac7a78b384f99bed5cee0b">SideType</a> { <a class="el" href="group__enums.html#ggac22de43beeac7a78b384f99bed5cee0ba21b30a61e9cb10c967aec17567804007">OnTheLeft</a> = 1
, <a class="el" href="group__enums.html#ggac22de43beeac7a78b384f99bed5cee0ba329fc3a54ceb2b6e0e73b400998b8a82">OnTheRight</a> = 2
 }</td></tr>
<tr class="memdesc:gac22de43beeac7a78b384f99bed5cee0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for specifying whether to apply or solve on the left or right.  <a href="group__enums.html#gac22de43beeac7a78b384f99bed5cee0b">More...</a><br /></td></tr>
<tr class="separator:gac22de43beeac7a78b384f99bed5cee0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f4e3f96895bdb325eab1a0b651e211f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#ga7f4e3f96895bdb325eab1a0b651e211f">NaNPropagationOptions</a> { <a class="el" href="group__enums.html#gga7f4e3f96895bdb325eab1a0b651e211fa917fa8982b7eb0cbb440d38ee50e0b9c">PropagateFast</a> = 0
, <a class="el" href="group__enums.html#gga7f4e3f96895bdb325eab1a0b651e211fa1d414f9966ecba69cd840b8def472c4a">PropagateNaN</a>
, <a class="el" href="group__enums.html#gga7f4e3f96895bdb325eab1a0b651e211fa5bfaff916ad4913fd04fe2e92c5c32ae">PropagateNumbers</a>
 }</td></tr>
<tr class="memdesc:ga7f4e3f96895bdb325eab1a0b651e211f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for specifying NaN-propagation behavior, e.g.  <a href="group__enums.html#ga7f4e3f96895bdb325eab1a0b651e211f">More...</a><br /></td></tr>
<tr class="separator:ga7f4e3f96895bdb325eab1a0b651e211f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fe75444f853cd2dd2b6b94e27dcac7"><td class="memItemLeft" align="right" valign="top"><a id="a57fe75444f853cd2dd2b6b94e27dcac7" name="a57fe75444f853cd2dd2b6b94e27dcac7"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>NoChange_t</b> { <b>NoChange</b>
 }</td></tr>
<tr class="separator:a57fe75444f853cd2dd2b6b94e27dcac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44c6508f8e204a03efbfd555a63a21f"><td class="memItemLeft" align="right" valign="top"><a id="ac44c6508f8e204a03efbfd555a63a21f" name="ac44c6508f8e204a03efbfd555a63a21f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>Sequential_t</b> { <b>Sequential</b>
 }</td></tr>
<tr class="separator:ac44c6508f8e204a03efbfd555a63a21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644c9489710c76e32bd3a9b15d83ca43"><td class="memItemLeft" align="right" valign="top"><a id="a644c9489710c76e32bd3a9b15d83ca43" name="a644c9489710c76e32bd3a9b15d83ca43"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>Default_t</b> { <b>Default</b>
 }</td></tr>
<tr class="separator:a644c9489710c76e32bd3a9b15d83ca43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b71c21bbdd3b0bb8a7a1dffd92e1bf"><td class="memItemLeft" align="right" valign="top"><a id="a59b71c21bbdd3b0bb8a7a1dffd92e1bf" name="a59b71c21bbdd3b0bb8a7a1dffd92e1bf"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>AmbiVectorMode</b> { <b>IsDense</b> = 0
, <b>IsSparse</b>
 }</td></tr>
<tr class="separator:a59b71c21bbdd3b0bb8a7a1dffd92e1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f93eac38eb83deb0e8dbd42ddf11d5d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#ga9f93eac38eb83deb0e8dbd42ddf11d5d">AccessorLevels</a> { <a class="el" href="group__enums.html#gga9f93eac38eb83deb0e8dbd42ddf11d5daa1f2b0e6a668b11f2958940965d2b572">ReadOnlyAccessors</a>
, <a class="el" href="group__enums.html#gga9f93eac38eb83deb0e8dbd42ddf11d5dabcadf08230fb1a5ef7b3195745d3a458">WriteAccessors</a>
, <a class="el" href="group__enums.html#gga9f93eac38eb83deb0e8dbd42ddf11d5da50108ad00095928de06228470ceab09e">DirectAccessors</a>
, <a class="el" href="group__enums.html#gga9f93eac38eb83deb0e8dbd42ddf11d5dacbe59d09ba2fdf8eac127bff1a1f0234">DirectWriteAccessors</a>
 }</td></tr>
<tr class="memdesc:ga9f93eac38eb83deb0e8dbd42ddf11d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used as template parameter in DenseCoeffBase and MapBase to indicate which accessors should be provided.  <a href="group__enums.html#ga9f93eac38eb83deb0e8dbd42ddf11d5d">More...</a><br /></td></tr>
<tr class="separator:ga9f93eac38eb83deb0e8dbd42ddf11d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3e239fb70022eb8747994cf5d68b4a9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#gae3e239fb70022eb8747994cf5d68b4a9">DecompositionOptions</a> { <br />
&#160;&#160;<b>Pivoting</b> = 0x01
, <b>NoPivoting</b> = 0x02
, <a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a9fa9302d510cee20c26311154937e23f">ComputeFullU</a> = 0x04
, <a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9aa7fb4e98834788d0b1b0f2b8467d2527">ComputeThinU</a> = 0x08
, <br />
&#160;&#160;<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a36581f7c662f7def31efd500c284f930">ComputeFullV</a> = 0x10
, <a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a540036417bfecf2e791a70948c227f47">ComputeThinV</a> = 0x20
, <a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9afd06633f270207c373875fd7ca03e906">EigenvaluesOnly</a> = 0x40
, <a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a7f7d17fba3c9bb92158e346d5979d0f4">ComputeEigenvectors</a> = 0x80
, <br />
&#160;&#160;<b>EigVecMask</b> = EigenvaluesOnly | ComputeEigenvectors
, <a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a5eb11a88a4bd445f58f1b24598d3848f">Ax_lBx</a> = 0x100
, <a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a9a7d9813cec527e299a36b749b0f7e1e">ABx_lx</a> = 0x200
, <a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a9870817d373c41ba0dc7f6b5ab0895b8">BAx_lx</a> = 0x400
, <br />
&#160;&#160;<b>GenEigMask</b> = Ax_lBx | ABx_lx | BAx_lx
<br />
 }</td></tr>
<tr class="memdesc:gae3e239fb70022eb8747994cf5d68b4a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum with options to give to various decompositions.  <a href="group__enums.html#gae3e239fb70022eb8747994cf5d68b4a9">More...</a><br /></td></tr>
<tr class="separator:gae3e239fb70022eb8747994cf5d68b4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46eba0d5c621f590b8cf1b53af31d56e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#ga46eba0d5c621f590b8cf1b53af31d56e">QRPreconditioners</a> { <a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56ea2e95bc818f975b19def01e93d240dece">NoQRPreconditioner</a>
, <a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56ea9c660eb3336bf8c77ce9d081ca07cbdd">HouseholderQRPreconditioner</a>
, <a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56eabd2e2f4875c5b4b6e602a433d90c4e5e">ColPivHouseholderQRPreconditioner</a>
, <a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56eabd745dcaff7019c5f918c68809e5ea50">FullPivHouseholderQRPreconditioner</a>
 }</td></tr>
<tr class="memdesc:ga46eba0d5c621f590b8cf1b53af31d56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible values for the <code>QRPreconditioner</code> template parameter of JacobiSVD.  <a href="group__enums.html#ga46eba0d5c621f590b8cf1b53af31d56e">More...</a><br /></td></tr>
<tr class="separator:ga46eba0d5c621f590b8cf1b53af31d56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85fad7b87587764e5cf6b513a9e0ee5e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#ga85fad7b87587764e5cf6b513a9e0ee5e">ComputationInfo</a> { <a class="el" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea671a2aeb0f527802806a441d58a80fcf">Success</a> = 0
, <a class="el" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea1c6e20706575a629b27a105f07f1883b">NumericalIssue</a> = 1
, <a class="el" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea6a68dfb88a8336108a30588bdf356c57">NoConvergence</a> = 2
, <a class="el" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea580b2a3cafe585691e789f768fb729bf">InvalidInput</a> = 3
 }</td></tr>
<tr class="memdesc:ga85fad7b87587764e5cf6b513a9e0ee5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for reporting the status of a computation.  <a href="group__enums.html#ga85fad7b87587764e5cf6b513a9e0ee5e">More...</a><br /></td></tr>
<tr class="separator:ga85fad7b87587764e5cf6b513a9e0ee5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee59a86102f150923b0cac6d4ff05107"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#gaee59a86102f150923b0cac6d4ff05107">TransformTraits</a> { <a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a84413028615d2d718bafd2dfb93dafef">Isometry</a> = 0x1
, <a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a0872f0a82453aaae40339c33acbb31fb">Affine</a> = 0x2
, <a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a8192e8fdb2ec3ec46d92956cc83ef490">AffineCompact</a> = 0x10 | Affine
, <a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a0f7338b8672884554e8642bce9e44183">Projective</a> = 0x20
 }</td></tr>
<tr class="memdesc:gaee59a86102f150923b0cac6d4ff05107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum used to specify how a particular transformation is stored in a matrix.  <a href="group__enums.html#gaee59a86102f150923b0cac6d4ff05107">More...</a><br /></td></tr>
<tr class="separator:gaee59a86102f150923b0cac6d4ff05107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a3e26ba06f3c60d2f2e46f56045f27"><td class="memItemLeft" align="right" valign="top"><a id="a15a3e26ba06f3c60d2f2e46f56045f27" name="a15a3e26ba06f3c60d2f2e46f56045f27"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ProductImplType</b> { <br />
&#160;&#160;<b>DefaultProduct</b> =0
, <b>LazyProduct</b>
, <b>AliasFreeProduct</b>
, <b>CoeffBasedProductMode</b>
, <br />
&#160;&#160;<b>LazyCoeffBasedProductMode</b>
, <b>OuterProduct</b>
, <b>InnerProduct</b>
, <b>GemvProduct</b>
, <br />
&#160;&#160;<b>GemmProduct</b>
<br />
 }</td></tr>
<tr class="separator:a15a3e26ba06f3c60d2f2e46f56045f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbc3ee52075935e7854d9f65c5a8e03"><td class="memItemLeft" align="right" valign="top"><a id="a3cbc3ee52075935e7854d9f65c5a8e03" name="a3cbc3ee52075935e7854d9f65c5a8e03"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>Action</b> { <b>GetAction</b>
, <b>SetAction</b>
 }</td></tr>
<tr class="separator:a3cbc3ee52075935e7854d9f65c5a8e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6641573852afb7812d40effdb102dc0"><td class="memItemLeft" align="right" valign="top"><a id="aa6641573852afb7812d40effdb102dc0" name="aa6641573852afb7812d40effdb102dc0"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>AutoSize_t</b> { <b>AutoSize</b>
 }</td></tr>
<tr class="separator:aa6641573852afb7812d40effdb102dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa0955f67302586c01ba67c4fa11ec3f4"><td class="memTemplParams" colspan="2"><a id="aa0955f67302586c01ba67c4fa11ec3f4" name="aa0955f67302586c01ba67c4fa11ec3f4"></a>
template&lt;typename NewDerType &gt; </td></tr>
<tr class="memitem:aa0955f67302586c01ba67c4fa11ec3f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1AutoDiffScalar.html">AutoDiffScalar</a>&lt; NewDerType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeAutoDiffScalar</b> (const typename NewDerType::Scalar &amp;<a class="el" href="classvalue.html">value</a>, const NewDerType &amp;der)</td></tr>
<tr class="separator:aa0955f67302586c01ba67c4fa11ec3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065d353fcbff30a8e902d2900a784d45"><td class="memTemplParams" colspan="2"><a id="a065d353fcbff30a8e902d2900a784d45" name="a065d353fcbff30a8e902d2900a784d45"></a>
template&lt;typename DerType &gt; </td></tr>
<tr class="memitem:a065d353fcbff30a8e902d2900a784d45"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1AutoDiffScalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conj</b> (const <a class="el" href="classEigen_1_1AutoDiffScalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;x)</td></tr>
<tr class="separator:a065d353fcbff30a8e902d2900a784d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71b5974e117d989a4e79f54ba65f460"><td class="memTemplParams" colspan="2"><a id="aa71b5974e117d989a4e79f54ba65f460" name="aa71b5974e117d989a4e79f54ba65f460"></a>
template&lt;typename DerType &gt; </td></tr>
<tr class="memitem:aa71b5974e117d989a4e79f54ba65f460"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1AutoDiffScalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>real</b> (const <a class="el" href="classEigen_1_1AutoDiffScalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;x)</td></tr>
<tr class="separator:aa71b5974e117d989a4e79f54ba65f460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524f2d0ae40cbbb4f55ea073c98a1c43"><td class="memTemplParams" colspan="2"><a id="a524f2d0ae40cbbb4f55ea073c98a1c43" name="a524f2d0ae40cbbb4f55ea073c98a1c43"></a>
template&lt;typename DerType &gt; </td></tr>
<tr class="memitem:a524f2d0ae40cbbb4f55ea073c98a1c43"><td class="memTemplItemLeft" align="right" valign="top">DerType::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><b>imag</b> (const <a class="el" href="classEigen_1_1AutoDiffScalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;)</td></tr>
<tr class="separator:a524f2d0ae40cbbb4f55ea073c98a1c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d3dd2a96b234e9e64fcc63ddb9fce2"><td class="memTemplParams" colspan="2"><a id="a34d3dd2a96b234e9e64fcc63ddb9fce2" name="a34d3dd2a96b234e9e64fcc63ddb9fce2"></a>
template&lt;typename DerType , typename T &gt; </td></tr>
<tr class="memitem:a34d3dd2a96b234e9e64fcc63ddb9fce2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1CleanedUpDerType.html">CleanedUpDerType</a>&lt; DerType &gt;::type()&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (const <a class="el" href="classEigen_1_1AutoDiffScalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:a34d3dd2a96b234e9e64fcc63ddb9fce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a672a343ad1bf7dda7eb58da2ff9c93"><td class="memTemplParams" colspan="2"><a id="a9a672a343ad1bf7dda7eb58da2ff9c93" name="a9a672a343ad1bf7dda7eb58da2ff9c93"></a>
template&lt;typename DerType , typename T &gt; </td></tr>
<tr class="memitem:a9a672a343ad1bf7dda7eb58da2ff9c93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1CleanedUpDerType.html">CleanedUpDerType</a>&lt; DerType &gt;::type()&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (const <a class="el" href="classEigen_1_1AutoDiffScalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:a9a672a343ad1bf7dda7eb58da2ff9c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdad9667362d17bff4b93cdd56ecfd1"><td class="memTemplParams" colspan="2"><a id="a7fdad9667362d17bff4b93cdd56ecfd1" name="a7fdad9667362d17bff4b93cdd56ecfd1"></a>
template&lt;typename DerType , typename T &gt; </td></tr>
<tr class="memitem:a7fdad9667362d17bff4b93cdd56ecfd1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1CleanedUpDerType.html">CleanedUpDerType</a>&lt; DerType &gt;::type()&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (const T &amp;x, const <a class="el" href="classEigen_1_1AutoDiffScalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;y)</td></tr>
<tr class="separator:a7fdad9667362d17bff4b93cdd56ecfd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af252a2e06b1c4ff8d5abb8faacc7410f"><td class="memTemplParams" colspan="2"><a id="af252a2e06b1c4ff8d5abb8faacc7410f" name="af252a2e06b1c4ff8d5abb8faacc7410f"></a>
template&lt;typename DerType , typename T &gt; </td></tr>
<tr class="memitem:af252a2e06b1c4ff8d5abb8faacc7410f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1CleanedUpDerType.html">CleanedUpDerType</a>&lt; DerType &gt;::type()&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (const T &amp;x, const <a class="el" href="classEigen_1_1AutoDiffScalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;y)</td></tr>
<tr class="separator:af252a2e06b1c4ff8d5abb8faacc7410f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f55390f11e2119d28514146066ddf22"><td class="memTemplParams" colspan="2"><a id="a2f55390f11e2119d28514146066ddf22" name="a2f55390f11e2119d28514146066ddf22"></a>
template&lt;typename DerType &gt; </td></tr>
<tr class="memitem:a2f55390f11e2119d28514146066ddf22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1CleanedUpDerType.html">CleanedUpDerType</a>&lt; DerType &gt;::type()&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (const <a class="el" href="classEigen_1_1AutoDiffScalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;x, const <a class="el" href="classEigen_1_1AutoDiffScalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;y)</td></tr>
<tr class="separator:a2f55390f11e2119d28514146066ddf22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283542203f436a754a0ffc68208646a8"><td class="memTemplParams" colspan="2"><a id="a283542203f436a754a0ffc68208646a8" name="a283542203f436a754a0ffc68208646a8"></a>
template&lt;typename DerType &gt; </td></tr>
<tr class="memitem:a283542203f436a754a0ffc68208646a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1CleanedUpDerType.html">CleanedUpDerType</a>&lt; DerType &gt;::type()&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (const <a class="el" href="classEigen_1_1AutoDiffScalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;x, const <a class="el" href="classEigen_1_1AutoDiffScalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;y)</td></tr>
<tr class="separator:a283542203f436a754a0ffc68208646a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade972f79dcb91f919a4a9939178e1024"><td class="memItemLeft" align="right" valign="top"><a id="ade972f79dcb91f919a4a9939178e1024" name="ade972f79dcb91f919a4a9939178e1024"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY</b> (abs, using std::abs;return Eigen::MakeAutoDiffScalar(abs(x.value()), x.derivatives() *(x.value()&lt; 0 ? -1 :1));) EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY(abs2</td></tr>
<tr class="separator:ade972f79dcb91f919a4a9939178e1024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14347a3d067977f2be8b1c258706ecb"><td class="memItemLeft" align="right" valign="top"><a id="ac14347a3d067977f2be8b1c258706ecb" name="ac14347a3d067977f2be8b1c258706ecb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY</b> (sqrt, using std::sqrt;Scalar sqrtx=sqrt(x.value());return Eigen::MakeAutoDiffScalar(sqrtx, x.derivatives() *(Scalar(0.5)/sqrtx));) EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY(cos</td></tr>
<tr class="separator:ac14347a3d067977f2be8b1c258706ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fe7d2b9e95853eb56a075380661309"><td class="memItemLeft" align="right" valign="top"><a id="a76fe7d2b9e95853eb56a075380661309" name="a76fe7d2b9e95853eb56a075380661309"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY</b> (sin, using std::sin;using std::cos;return Eigen::MakeAutoDiffScalar(sin(x.value()), x.derivatives() *cos(x.value()));) EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY(exp</td></tr>
<tr class="separator:a76fe7d2b9e95853eb56a075380661309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9772823dd0a8d24c98fbae45ca16802"><td class="memItemLeft" align="right" valign="top"><a id="aa9772823dd0a8d24c98fbae45ca16802" name="aa9772823dd0a8d24c98fbae45ca16802"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY</b> (log, using std::log;return Eigen::MakeAutoDiffScalar(log(x.value()), x.derivatives() *(Scalar(1)/x.value()));) template&lt; typename DerType &gt; inline const Eigen</td></tr>
<tr class="separator:aa9772823dd0a8d24c98fbae45ca16802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbac4a376874ce85e22f24da1845008"><td class="memTemplParams" colspan="2"><a id="aabbac4a376874ce85e22f24da1845008" name="aabbac4a376874ce85e22f24da1845008"></a>
template&lt;typename DerTypeA , typename DerTypeB &gt; </td></tr>
<tr class="memitem:aabbac4a376874ce85e22f24da1845008"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1AutoDiffScalar.html">AutoDiffScalar</a>&lt; <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; typename <a class="el" href="structEigen_1_1internal_1_1traits.html">internal::traits</a>&lt; typename <a class="el" href="structEigen_1_1internal_1_1remove__all.html">internal::remove_all</a>&lt; DerTypeA &gt;::type &gt;::Scalar, <a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>atan2</b> (const <a class="el" href="classEigen_1_1AutoDiffScalar.html">AutoDiffScalar</a>&lt; DerTypeA &gt; &amp;a, const <a class="el" href="classEigen_1_1AutoDiffScalar.html">AutoDiffScalar</a>&lt; DerTypeB &gt; &amp;b)</td></tr>
<tr class="separator:aabbac4a376874ce85e22f24da1845008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212ff33d56ffe0384059b78e7e8a8142"><td class="memItemLeft" align="right" valign="top"><a id="a212ff33d56ffe0384059b78e7e8a8142" name="a212ff33d56ffe0384059b78e7e8a8142"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY</b> (tan, using std::tan;using std::cos;return Eigen::MakeAutoDiffScalar(tan(x.value()), x.derivatives() *(Scalar(1)/numext::abs2(cos(x.value()))));) EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY(asin</td></tr>
<tr class="separator:a212ff33d56ffe0384059b78e7e8a8142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af291629130d7e1494b0c17b7413f86"><td class="memItemLeft" align="right" valign="top"><a id="a3af291629130d7e1494b0c17b7413f86" name="a3af291629130d7e1494b0c17b7413f86"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY</b> (acos, using std::sqrt;using std::acos;return Eigen::MakeAutoDiffScalar(acos(x.value()), x.derivatives() *(Scalar(-1)/sqrt(1-numext::abs2(x.value()))));) EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY(tanh</td></tr>
<tr class="separator:a3af291629130d7e1494b0c17b7413f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e5dd85fa549b012df73af4865f9b93"><td class="memItemLeft" align="right" valign="top"><a id="a77e5dd85fa549b012df73af4865f9b93" name="a77e5dd85fa549b012df73af4865f9b93"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY</b> (sinh, using std::sinh;using std::cosh;return Eigen::MakeAutoDiffScalar(sinh(x.value()), x.derivatives() *cosh(x.value()));) EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY(cosh</td></tr>
<tr class="separator:a77e5dd85fa549b012df73af4865f9b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f490197e16df831683018e383e29346"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename ResultType &gt; </td></tr>
<tr class="memitem:a2f490197e16df831683018e383e29346"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a2f490197e16df831683018e383e29346">matrix_sqrt_quasi_triangular</a> (const MatrixType &amp;arg, ResultType &amp;result)</td></tr>
<tr class="memdesc:a2f490197e16df831683018e383e29346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute matrix square root of quasi-triangular matrix.  <a href="namespaceEigen.html#a2f490197e16df831683018e383e29346">More...</a><br /></td></tr>
<tr class="separator:a2f490197e16df831683018e383e29346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51c91f920f6ea4a7f6f72caa1e8249f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename ResultType &gt; </td></tr>
<tr class="memitem:ae51c91f920f6ea4a7f6f72caa1e8249f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#ae51c91f920f6ea4a7f6f72caa1e8249f">matrix_sqrt_triangular</a> (const MatrixType &amp;arg, ResultType &amp;result)</td></tr>
<tr class="memdesc:ae51c91f920f6ea4a7f6f72caa1e8249f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute matrix square root of triangular matrix.  <a href="namespaceEigen.html#ae51c91f920f6ea4a7f6f72caa1e8249f">More...</a><br /></td></tr>
<tr class="separator:ae51c91f920f6ea4a7f6f72caa1e8249f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269a343c1771ac7d806f6f1dd7a7fa3c"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived , typename VectorsType , typename CoeffsType , int Side&gt; </td></tr>
<tr class="memitem:a269a343c1771ac7d806f6f1dd7a7fa3c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1matrix__type__times__scalar__type.html">internal::matrix_type_times_scalar_type</a>&lt; typenameVectorsType::Scalar, OtherDerived &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a269a343c1771ac7d806f6f1dd7a7fa3c">operator*</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other, const <a class="el" href="classEigen_1_1HouseholderSequence.html">HouseholderSequence</a>&lt; VectorsType, CoeffsType, Side &gt; &amp;h)</td></tr>
<tr class="memdesc:a269a343c1771ac7d806f6f1dd7a7fa3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the product of a matrix with a Householder sequence.  <a href="namespaceEigen.html#a269a343c1771ac7d806f6f1dd7a7fa3c">More...</a><br /></td></tr>
<tr class="separator:a269a343c1771ac7d806f6f1dd7a7fa3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd4b85120e014cf1125a054b02d4d92"><td class="memTemplParams" colspan="2">template&lt;typename VectorsType , typename CoeffsType &gt; </td></tr>
<tr class="memitem:a4bd4b85120e014cf1125a054b02d4d92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1HouseholderSequence.html">HouseholderSequence</a>&lt; VectorsType, CoeffsType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a4bd4b85120e014cf1125a054b02d4d92">householderSequence</a> (const VectorsType &amp;v, const CoeffsType &amp;h)</td></tr>
<tr class="memdesc:a4bd4b85120e014cf1125a054b02d4d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">\  <a href="namespaceEigen.html#a4bd4b85120e014cf1125a054b02d4d92">More...</a><br /></td></tr>
<tr class="separator:a4bd4b85120e014cf1125a054b02d4d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f16274f9e66f902f1a4b3f23e8b002"><td class="memTemplParams" colspan="2">template&lt;typename VectorsType , typename CoeffsType &gt; </td></tr>
<tr class="memitem:a59f16274f9e66f902f1a4b3f23e8b002"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1HouseholderSequence.html">HouseholderSequence</a>&lt; VectorsType, CoeffsType, <a class="el" href="group__enums.html#ggac22de43beeac7a78b384f99bed5cee0ba329fc3a54ceb2b6e0e73b400998b8a82">OnTheRight</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a59f16274f9e66f902f1a4b3f23e8b002">rightHouseholderSequence</a> (const VectorsType &amp;v, const CoeffsType &amp;h)</td></tr>
<tr class="memdesc:a59f16274f9e66f902f1a4b3f23e8b002"><td class="mdescLeft">&#160;</td><td class="mdescRight">\  <a href="namespaceEigen.html#a59f16274f9e66f902f1a4b3f23e8b002">More...</a><br /></td></tr>
<tr class="separator:a59f16274f9e66f902f1a4b3f23e8b002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3c346d2a61d1e8e86e6fb4cf57fbda"><td class="memTemplParams" colspan="2">template&lt;typename FirstType , typename SizeType , typename IncrType &gt; </td></tr>
<tr class="memitem:a3a3c346d2a61d1e8e86e6fb4cf57fbda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1ArithmeticSequence.html">ArithmeticSequence</a>&lt; typename <a class="el" href="structEigen_1_1internal_1_1cleanup__index__type.html">internal::cleanup_index_type</a>&lt; FirstType &gt;::type, typename <a class="el" href="structEigen_1_1internal_1_1cleanup__index__type.html">internal::cleanup_index_type</a>&lt; SizeType &gt;::type, typename <a class="el" href="structEigen_1_1internal_1_1cleanup__seq__incr.html">internal::cleanup_seq_incr</a>&lt; IncrType &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a3a3c346d2a61d1e8e86e6fb4cf57fbda">seqN</a> (FirstType first, SizeType size, IncrType incr)</td></tr>
<tr class="separator:a3a3c346d2a61d1e8e86e6fb4cf57fbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2b47604fbd83f8e88849a371eb0a8f"><td class="memTemplParams" colspan="2">template&lt;typename FirstType , typename SizeType &gt; </td></tr>
<tr class="memitem:a5e2b47604fbd83f8e88849a371eb0a8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1ArithmeticSequence.html">ArithmeticSequence</a>&lt; typename <a class="el" href="structEigen_1_1internal_1_1cleanup__index__type.html">internal::cleanup_index_type</a>&lt; FirstType &gt;::type, typename <a class="el" href="structEigen_1_1internal_1_1cleanup__index__type.html">internal::cleanup_index_type</a>&lt; SizeType &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a5e2b47604fbd83f8e88849a371eb0a8f">seqN</a> (FirstType first, SizeType size)</td></tr>
<tr class="separator:a5e2b47604fbd83f8e88849a371eb0a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db24b502633d158c17cb0677e7be4cb"><td class="memTemplParams" colspan="2"><a id="a6db24b502633d158c17cb0677e7be4cb" name="a6db24b502633d158c17cb0677e7be4cb"></a>
template&lt;typename FirstType , typename LastType &gt; </td></tr>
<tr class="memitem:a6db24b502633d158c17cb0677e7be4cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1enable__if.html">internal::enable_if</a>&lt;!(<a class="el" href="structEigen_1_1symbolic_1_1is__symbolic.html">symbolic::is_symbolic</a>&lt; FirstType &gt;::<a class="el" href="classvalue.html">value</a>||<a class="el" href="structEigen_1_1symbolic_1_1is__symbolic.html">symbolic::is_symbolic</a>&lt; LastType &gt;::<a class="el" href="classvalue.html">value</a>), <a class="el" href="classEigen_1_1ArithmeticSequence.html">ArithmeticSequence</a>&lt; typenameinternal::cleanup_index_type&lt; FirstType &gt;::type, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>seq</b> (FirstType f, LastType l)</td></tr>
<tr class="separator:a6db24b502633d158c17cb0677e7be4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968b0e1488dfbd11e30219faa76651f7"><td class="memTemplParams" colspan="2"><a id="a968b0e1488dfbd11e30219faa76651f7" name="a968b0e1488dfbd11e30219faa76651f7"></a>
template&lt;typename FirstTypeDerived , typename LastType &gt; </td></tr>
<tr class="memitem:a968b0e1488dfbd11e30219faa76651f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1enable__if.html">internal::enable_if</a>&lt;!<a class="el" href="structEigen_1_1symbolic_1_1is__symbolic.html">symbolic::is_symbolic</a>&lt; LastType &gt;::<a class="el" href="classvalue.html">value</a>, <a class="el" href="classEigen_1_1ArithmeticSequence.html">ArithmeticSequence</a>&lt; FirstTypeDerived, <a class="el" href="classEigen_1_1symbolic_1_1AddExpr.html">symbolic::AddExpr</a>&lt; <a class="el" href="classEigen_1_1symbolic_1_1AddExpr.html">symbolic::AddExpr</a>&lt; <a class="el" href="classEigen_1_1symbolic_1_1NegateExpr.html">symbolic::NegateExpr</a>&lt; FirstTypeDerived &gt;, <a class="el" href="classEigen_1_1symbolic_1_1ValueExpr.html">symbolic::ValueExpr</a>&lt;&gt; &gt;, <a class="el" href="classEigen_1_1symbolic_1_1ValueExpr.html">symbolic::ValueExpr</a>&lt; <a class="el" href="classEigen_1_1internal_1_1FixedInt.html">internal::FixedInt</a>&lt; 1 &gt; &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>seq</b> (const <a class="el" href="classEigen_1_1symbolic_1_1BaseExpr.html">symbolic::BaseExpr</a>&lt; FirstTypeDerived &gt; &amp;f, LastType l)</td></tr>
<tr class="separator:a968b0e1488dfbd11e30219faa76651f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42833b74c71083077968f3dd68f3b287"><td class="memTemplParams" colspan="2"><a id="a42833b74c71083077968f3dd68f3b287" name="a42833b74c71083077968f3dd68f3b287"></a>
template&lt;typename FirstType , typename LastTypeDerived &gt; </td></tr>
<tr class="memitem:a42833b74c71083077968f3dd68f3b287"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1enable__if.html">internal::enable_if</a>&lt;!<a class="el" href="structEigen_1_1symbolic_1_1is__symbolic.html">symbolic::is_symbolic</a>&lt; FirstType &gt;::<a class="el" href="classvalue.html">value</a>, <a class="el" href="classEigen_1_1ArithmeticSequence.html">ArithmeticSequence</a>&lt; typenameinternal::cleanup_index_type&lt; FirstType &gt;::type, <a class="el" href="classEigen_1_1symbolic_1_1AddExpr.html">symbolic::AddExpr</a>&lt; <a class="el" href="classEigen_1_1symbolic_1_1AddExpr.html">symbolic::AddExpr</a>&lt; LastTypeDerived, <a class="el" href="classEigen_1_1symbolic_1_1ValueExpr.html">symbolic::ValueExpr</a>&lt;&gt; &gt;, <a class="el" href="classEigen_1_1symbolic_1_1ValueExpr.html">symbolic::ValueExpr</a>&lt; <a class="el" href="classEigen_1_1internal_1_1FixedInt.html">internal::FixedInt</a>&lt; 1 &gt; &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>seq</b> (FirstType f, const <a class="el" href="classEigen_1_1symbolic_1_1BaseExpr.html">symbolic::BaseExpr</a>&lt; LastTypeDerived &gt; &amp;l)</td></tr>
<tr class="separator:a42833b74c71083077968f3dd68f3b287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ba07816c37e442cc305c6b2e0376af"><td class="memTemplParams" colspan="2"><a id="a61ba07816c37e442cc305c6b2e0376af" name="a61ba07816c37e442cc305c6b2e0376af"></a>
template&lt;typename FirstTypeDerived , typename LastTypeDerived &gt; </td></tr>
<tr class="memitem:a61ba07816c37e442cc305c6b2e0376af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1ArithmeticSequence.html">ArithmeticSequence</a>&lt; FirstTypeDerived, <a class="el" href="classEigen_1_1symbolic_1_1AddExpr.html">symbolic::AddExpr</a>&lt; <a class="el" href="classEigen_1_1symbolic_1_1AddExpr.html">symbolic::AddExpr</a>&lt; LastTypeDerived, <a class="el" href="classEigen_1_1symbolic_1_1NegateExpr.html">symbolic::NegateExpr</a>&lt; FirstTypeDerived &gt; &gt;, <a class="el" href="classEigen_1_1symbolic_1_1ValueExpr.html">symbolic::ValueExpr</a>&lt; <a class="el" href="classEigen_1_1internal_1_1FixedInt.html">internal::FixedInt</a>&lt; 1 &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>seq</b> (const <a class="el" href="classEigen_1_1symbolic_1_1BaseExpr.html">symbolic::BaseExpr</a>&lt; FirstTypeDerived &gt; &amp;f, const <a class="el" href="classEigen_1_1symbolic_1_1BaseExpr.html">symbolic::BaseExpr</a>&lt; LastTypeDerived &gt; &amp;l)</td></tr>
<tr class="separator:a61ba07816c37e442cc305c6b2e0376af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502e110d8fd08147e344f6de0428a89e"><td class="memTemplParams" colspan="2"><a id="a502e110d8fd08147e344f6de0428a89e" name="a502e110d8fd08147e344f6de0428a89e"></a>
template&lt;typename FirstType , typename LastType , typename IncrType &gt; </td></tr>
<tr class="memitem:a502e110d8fd08147e344f6de0428a89e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1enable__if.html">internal::enable_if</a>&lt;!(<a class="el" href="structEigen_1_1symbolic_1_1is__symbolic.html">symbolic::is_symbolic</a>&lt; FirstType &gt;::<a class="el" href="classvalue.html">value</a>||<a class="el" href="structEigen_1_1symbolic_1_1is__symbolic.html">symbolic::is_symbolic</a>&lt; LastType &gt;::<a class="el" href="classvalue.html">value</a>), <a class="el" href="classEigen_1_1ArithmeticSequence.html">ArithmeticSequence</a>&lt; typenameinternal::cleanup_index_type&lt; FirstType &gt;::type, <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>, typenameinternal::cleanup_seq_incr&lt; IncrType &gt;::type &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>seq</b> (FirstType f, LastType l, IncrType incr)</td></tr>
<tr class="separator:a502e110d8fd08147e344f6de0428a89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bfe5ad249459c8f9e1e8eb7751aebc"><td class="memTemplParams" colspan="2"><a id="ad9bfe5ad249459c8f9e1e8eb7751aebc" name="ad9bfe5ad249459c8f9e1e8eb7751aebc"></a>
template&lt;typename FirstTypeDerived , typename LastType , typename IncrType &gt; </td></tr>
<tr class="memitem:ad9bfe5ad249459c8f9e1e8eb7751aebc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1enable__if.html">internal::enable_if</a>&lt;!<a class="el" href="structEigen_1_1symbolic_1_1is__symbolic.html">symbolic::is_symbolic</a>&lt; LastType &gt;::<a class="el" href="classvalue.html">value</a>, <a class="el" href="classEigen_1_1ArithmeticSequence.html">ArithmeticSequence</a>&lt; FirstTypeDerived, <a class="el" href="classEigen_1_1symbolic_1_1QuotientExpr.html">symbolic::QuotientExpr</a>&lt; <a class="el" href="classEigen_1_1symbolic_1_1AddExpr.html">symbolic::AddExpr</a>&lt; <a class="el" href="classEigen_1_1symbolic_1_1AddExpr.html">symbolic::AddExpr</a>&lt; <a class="el" href="classEigen_1_1symbolic_1_1NegateExpr.html">symbolic::NegateExpr</a>&lt; FirstTypeDerived &gt;, <a class="el" href="classEigen_1_1symbolic_1_1ValueExpr.html">symbolic::ValueExpr</a>&lt;&gt; &gt;, <a class="el" href="classEigen_1_1symbolic_1_1ValueExpr.html">symbolic::ValueExpr</a>&lt; typenameinternal::cleanup_seq_incr&lt; IncrType &gt;::type &gt; &gt;, <a class="el" href="classEigen_1_1symbolic_1_1ValueExpr.html">symbolic::ValueExpr</a>&lt; typenameinternal::cleanup_seq_incr&lt; IncrType &gt;::type &gt; &gt;, typenameinternal::cleanup_seq_incr&lt; IncrType &gt;::type &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>seq</b> (const <a class="el" href="classEigen_1_1symbolic_1_1BaseExpr.html">symbolic::BaseExpr</a>&lt; FirstTypeDerived &gt; &amp;f, LastType l, IncrType incr)</td></tr>
<tr class="separator:ad9bfe5ad249459c8f9e1e8eb7751aebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bdc45785e9d7e001626eed2861e5c0f"><td class="memTemplParams" colspan="2"><a id="a8bdc45785e9d7e001626eed2861e5c0f" name="a8bdc45785e9d7e001626eed2861e5c0f"></a>
template&lt;typename FirstType , typename LastTypeDerived , typename IncrType &gt; </td></tr>
<tr class="memitem:a8bdc45785e9d7e001626eed2861e5c0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1internal_1_1enable__if.html">internal::enable_if</a>&lt;!<a class="el" href="structEigen_1_1symbolic_1_1is__symbolic.html">symbolic::is_symbolic</a>&lt; FirstType &gt;::<a class="el" href="classvalue.html">value</a>, <a class="el" href="classEigen_1_1ArithmeticSequence.html">ArithmeticSequence</a>&lt; typenameinternal::cleanup_index_type&lt; FirstType &gt;::type, <a class="el" href="classEigen_1_1symbolic_1_1QuotientExpr.html">symbolic::QuotientExpr</a>&lt; <a class="el" href="classEigen_1_1symbolic_1_1AddExpr.html">symbolic::AddExpr</a>&lt; <a class="el" href="classEigen_1_1symbolic_1_1AddExpr.html">symbolic::AddExpr</a>&lt; LastTypeDerived, <a class="el" href="classEigen_1_1symbolic_1_1ValueExpr.html">symbolic::ValueExpr</a>&lt;&gt; &gt;, <a class="el" href="classEigen_1_1symbolic_1_1ValueExpr.html">symbolic::ValueExpr</a>&lt; typenameinternal::cleanup_seq_incr&lt; IncrType &gt;::type &gt; &gt;, <a class="el" href="classEigen_1_1symbolic_1_1ValueExpr.html">symbolic::ValueExpr</a>&lt; typenameinternal::cleanup_seq_incr&lt; IncrType &gt;::type &gt; &gt;, typenameinternal::cleanup_seq_incr&lt; IncrType &gt;::type &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>seq</b> (FirstType f, const <a class="el" href="classEigen_1_1symbolic_1_1BaseExpr.html">symbolic::BaseExpr</a>&lt; LastTypeDerived &gt; &amp;l, IncrType incr)</td></tr>
<tr class="separator:a8bdc45785e9d7e001626eed2861e5c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f59f08c5212cbc45fa12402a69673c5"><td class="memTemplParams" colspan="2"><a id="a9f59f08c5212cbc45fa12402a69673c5" name="a9f59f08c5212cbc45fa12402a69673c5"></a>
template&lt;typename FirstTypeDerived , typename LastTypeDerived , typename IncrType &gt; </td></tr>
<tr class="memitem:a9f59f08c5212cbc45fa12402a69673c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1ArithmeticSequence.html">ArithmeticSequence</a>&lt; FirstTypeDerived, <a class="el" href="classEigen_1_1symbolic_1_1QuotientExpr.html">symbolic::QuotientExpr</a>&lt; <a class="el" href="classEigen_1_1symbolic_1_1AddExpr.html">symbolic::AddExpr</a>&lt; <a class="el" href="classEigen_1_1symbolic_1_1AddExpr.html">symbolic::AddExpr</a>&lt; LastTypeDerived, <a class="el" href="classEigen_1_1symbolic_1_1NegateExpr.html">symbolic::NegateExpr</a>&lt; FirstTypeDerived &gt; &gt;, <a class="el" href="classEigen_1_1symbolic_1_1ValueExpr.html">symbolic::ValueExpr</a>&lt; typename <a class="el" href="structEigen_1_1internal_1_1cleanup__seq__incr.html">internal::cleanup_seq_incr</a>&lt; IncrType &gt;::type &gt; &gt;, <a class="el" href="classEigen_1_1symbolic_1_1ValueExpr.html">symbolic::ValueExpr</a>&lt; typename <a class="el" href="structEigen_1_1internal_1_1cleanup__seq__incr.html">internal::cleanup_seq_incr</a>&lt; IncrType &gt;::type &gt; &gt;, typename <a class="el" href="structEigen_1_1internal_1_1cleanup__seq__incr.html">internal::cleanup_seq_incr</a>&lt; IncrType &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>seq</b> (const <a class="el" href="classEigen_1_1symbolic_1_1BaseExpr.html">symbolic::BaseExpr</a>&lt; FirstTypeDerived &gt; &amp;f, const <a class="el" href="classEigen_1_1symbolic_1_1BaseExpr.html">symbolic::BaseExpr</a>&lt; LastTypeDerived &gt; &amp;l, IncrType incr)</td></tr>
<tr class="separator:a9f59f08c5212cbc45fa12402a69673c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32970f7eb62fe31eeefee72d24a046d0"><td class="memTemplParams" colspan="2">template&lt;typename MatrixDerived , typename PermutationDerived &gt; </td></tr>
<tr class="memitem:a32970f7eb62fe31eeefee72d24a046d0"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1Product.html">Product</a>&lt; MatrixDerived, PermutationDerived, AliasFreeProduct &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a32970f7eb62fe31eeefee72d24a046d0">operator*</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; MatrixDerived &gt; &amp;matrix, const <a class="el" href="classEigen_1_1PermutationBase.html">PermutationBase</a>&lt; PermutationDerived &gt; &amp;permutation)</td></tr>
<tr class="separator:a32970f7eb62fe31eeefee72d24a046d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5954e0288e506706e8d2c8cd5ff5b7d2"><td class="memTemplParams" colspan="2">template&lt;typename PermutationDerived , typename MatrixDerived &gt; </td></tr>
<tr class="memitem:a5954e0288e506706e8d2c8cd5ff5b7d2"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1Product.html">Product</a>&lt; PermutationDerived, MatrixDerived, AliasFreeProduct &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a5954e0288e506706e8d2c8cd5ff5b7d2">operator*</a> (const <a class="el" href="classEigen_1_1PermutationBase.html">PermutationBase</a>&lt; PermutationDerived &gt; &amp;permutation, const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; MatrixDerived &gt; &amp;matrix)</td></tr>
<tr class="separator:a5954e0288e506706e8d2c8cd5ff5b7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b493da0816bfa75429961b75f21d780"><td class="memTemplParams" colspan="2">template&lt;typename MatrixDerived , typename TranspositionsDerived &gt; </td></tr>
<tr class="memitem:a8b493da0816bfa75429961b75f21d780"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1Product.html">Product</a>&lt; MatrixDerived, TranspositionsDerived, AliasFreeProduct &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a8b493da0816bfa75429961b75f21d780">operator*</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; MatrixDerived &gt; &amp;matrix, const <a class="el" href="classEigen_1_1TranspositionsBase.html">TranspositionsBase</a>&lt; TranspositionsDerived &gt; &amp;transpositions)</td></tr>
<tr class="separator:a8b493da0816bfa75429961b75f21d780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c63a9e3b8c513835a3b5551d98bd0c3"><td class="memTemplParams" colspan="2">template&lt;typename TranspositionsDerived , typename MatrixDerived &gt; </td></tr>
<tr class="memitem:a4c63a9e3b8c513835a3b5551d98bd0c3"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1Product.html">Product</a>&lt; TranspositionsDerived, MatrixDerived, AliasFreeProduct &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a4c63a9e3b8c513835a3b5551d98bd0c3">operator*</a> (const <a class="el" href="classEigen_1_1TranspositionsBase.html">TranspositionsBase</a>&lt; TranspositionsDerived &gt; &amp;transpositions, const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; MatrixDerived &gt; &amp;matrix)</td></tr>
<tr class="separator:a4c63a9e3b8c513835a3b5551d98bd0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820c0e0460934cc17eb6dacbad54a9f5"><td class="memItemLeft" align="right" valign="top"><a id="a820c0e0460934cc17eb6dacbad54a9f5" name="a820c0e0460934cc17eb6dacbad54a9f5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initParallel</b> ()</td></tr>
<tr class="memdesc:a820c0e0460934cc17eb6dacbad54a9f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be call first when calling <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> from multiple threads. <br /></td></tr>
<tr class="separator:a820c0e0460934cc17eb6dacbad54a9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aca97d83e21b91a04ec079360dfffeb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a9aca97d83e21b91a04ec079360dfffeb">nbThreads</a> ()</td></tr>
<tr class="separator:a9aca97d83e21b91a04ec079360dfffeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cd17c2fe18204239cd11c88c120b50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#af9cd17c2fe18204239cd11c88c120b50">setNbThreads</a> (int v)</td></tr>
<tr class="memdesc:af9cd17c2fe18204239cd11c88c120b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the max number of threads reserved for <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a>.  <a href="namespaceEigen.html#af9cd17c2fe18204239cd11c88c120b50">More...</a><br /></td></tr>
<tr class="separator:af9cd17c2fe18204239cd11c88c120b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2669f89ff38296a38e6d973552eb4e33"><td class="memItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a2669f89ff38296a38e6d973552eb4e33">l1CacheSize</a> ()</td></tr>
<tr class="separator:a2669f89ff38296a38e6d973552eb4e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfc0330ba567d63a496be1cac8427ae"><td class="memItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a2cfc0330ba567d63a496be1cac8427ae">l2CacheSize</a> ()</td></tr>
<tr class="separator:a2cfc0330ba567d63a496be1cac8427ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2efa4852ea90c2d47b7dcec5b40ba2b"><td class="memItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#ae2efa4852ea90c2d47b7dcec5b40ba2b">l3CacheSize</a> ()</td></tr>
<tr class="separator:ae2efa4852ea90c2d47b7dcec5b40ba2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64421554aa0a4bf9258bafe3170102b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#ae64421554aa0a4bf9258bafe3170102b">setCpuCacheSizes</a> (std::ptrdiff_t l1, std::ptrdiff_t l2, std::ptrdiff_t l3)</td></tr>
<tr class="memdesc:ae64421554aa0a4bf9258bafe3170102b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cpu L1 and L2 cache sizes (in bytes).  <a href="namespaceEigen.html#ae64421554aa0a4bf9258bafe3170102b">More...</a><br /></td></tr>
<tr class="separator:ae64421554aa0a4bf9258bafe3170102b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5651354106b1a3b6a5499fec343c8d1d"><td class="memItemLeft" align="right" valign="top"><a id="a5651354106b1a3b6a5499fec343c8d1d" name="a5651354106b1a3b6a5499fec343c8d1d"></a>
static const <a class="el" href="classEigen_1_1symbolic_1_1AddExpr.html">symbolic::AddExpr</a>&lt; <a class="el" href="classEigen_1_1symbolic_1_1SymbolExpr.html">symbolic::SymbolExpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1symbolic__last__tag.html">internal::symbolic_last_tag</a> &gt;, <a class="el" href="classEigen_1_1symbolic_1_1ValueExpr.html">symbolic::ValueExpr</a>&lt; <a class="el" href="classEigen_1_1internal_1_1FixedInt.html">Eigen::internal::FixedInt</a>&lt; 1 &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>lastp1</b> (<a class="el" href="namespaceEigen.html#a2dd8b20d08336af23947e054a17415ee">last</a>+fix&lt; 1 &gt;())</td></tr>
<tr class="separator:a5651354106b1a3b6a5499fec343c8d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8636241003a5d035f1832765ba8e5418"><td class="memTemplParams" colspan="2"><a id="a8636241003a5d035f1832765ba8e5418" name="a8636241003a5d035f1832765ba8e5418"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:a8636241003a5d035f1832765ba8e5418"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1internal_1_1FixedInt.html">internal::FixedInt</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fix</b> ()</td></tr>
<tr class="separator:a8636241003a5d035f1832765ba8e5418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea5b600d99da1dba258125bb31f68a3"><td class="memTemplParams" colspan="2"><a id="afea5b600d99da1dba258125bb31f68a3" name="afea5b600d99da1dba258125bb31f68a3"></a>
template&lt;int N, typename T &gt; </td></tr>
<tr class="memitem:afea5b600d99da1dba258125bb31f68a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1internal_1_1VariableAndFixedInt.html">internal::VariableAndFixedInt</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fix</b> (T val)</td></tr>
<tr class="separator:afea5b600d99da1dba258125bb31f68a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd9a26113d5fae6c6aaa31cc38da4bb"><td class="memItemLeft" align="right" valign="top"><a id="a2cd9a26113d5fae6c6aaa31cc38da4bb" name="a2cd9a26113d5fae6c6aaa31cc38da4bb"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>SimdInstructionSetsInUse</b> (void)</td></tr>
<tr class="separator:a2cd9a26113d5fae6c6aaa31cc38da4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab63002a89341ef7158fe60fa7570e88c"><td class="memItemLeft" align="right" valign="top"><a id="ab63002a89341ef7158fe60fa7570e88c" name="ab63002a89341ef7158fe60fa7570e88c"></a>
Scalar&#160;</td><td class="memItemRight" valign="bottom"><b>expx</b> = exp(x.value())</td></tr>
<tr class="separator:ab63002a89341ef7158fe60fa7570e88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd2d46df7e6d1ffb14367adbe008bfd"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#aebd2d46df7e6d1ffb14367adbe008bfd">exponents</a></td></tr>
<tr class="separator:aebd2d46df7e6d1ffb14367adbe008bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd8b20d08336af23947e054a17415ee"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1symbolic_1_1SymbolExpr.html">symbolic::SymbolExpr</a>&lt; <a class="el" href="structEigen_1_1internal_1_1symbolic__last__tag.html">internal::symbolic_last_tag</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a2dd8b20d08336af23947e054a17415ee">last</a></td></tr>
<tr class="memdesc:a2dd8b20d08336af23947e054a17415ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used as a parameter to Eigen::seq and <a class="el" href="namespaceEigen.html#a3a3c346d2a61d1e8e86e6fb4cf57fbda">Eigen::seqN</a> functions to symbolically reference the last element/row/columns of the underlying vector or matrix once passed to DenseBase::operator()(const RowIndices&amp;, const ColIndices&amp;).  <a href="namespaceEigen.html#a2dd8b20d08336af23947e054a17415ee">More...</a><br /></td></tr>
<tr class="separator:a2dd8b20d08336af23947e054a17415ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790ab6c4226ef5f678b9eb532a3eab14"><td class="memItemLeft" align="right" valign="top"><a id="a790ab6c4226ef5f678b9eb532a3eab14" name="a790ab6c4226ef5f678b9eb532a3eab14"></a>
static const <a class="el" href="structEigen_1_1internal_1_1all__t.html">Eigen::internal::all_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>all</b></td></tr>
<tr class="memdesc:a790ab6c4226ef5f678b9eb532a3eab14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used as a parameter to DenseBase::operator()(const RowIndices&amp;, const ColIndices&amp;) to index all rows or columns. <br /></td></tr>
<tr class="separator:a790ab6c4226ef5f678b9eb532a3eab14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81fa7195215a0ce30017dfac309f0b2"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a> = -1</td></tr>
<tr class="memdesc:ad81fa7195215a0ce30017dfac309f0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value means that a positive quantity (e.g., a size) is not known at compile-time, and that instead the value is stored in some runtime variable.  <a href="namespaceEigen.html#ad81fa7195215a0ce30017dfac309f0b2">More...</a><br /></td></tr>
<tr class="separator:ad81fa7195215a0ce30017dfac309f0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c597189a4a99127175e8167c456fff"><td class="memItemLeft" align="right" valign="top"><a id="a73c597189a4a99127175e8167c456fff" name="a73c597189a4a99127175e8167c456fff"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>DynamicIndex</b> = 0xffffff</td></tr>
<tr class="memdesc:a73c597189a4a99127175e8167c456fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value means that a signed quantity (e.g., a signed index) is not known at compile-time, and that instead its value has to be specified at runtime. <br /></td></tr>
<tr class="separator:a73c597189a4a99127175e8167c456fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06808a853a9baa38b23a5368e7491abd"><td class="memItemLeft" align="right" valign="top"><a id="a06808a853a9baa38b23a5368e7491abd" name="a06808a853a9baa38b23a5368e7491abd"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>UndefinedIncr</b> = 0xfffffe</td></tr>
<tr class="memdesc:a06808a853a9baa38b23a5368e7491abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value means that the increment to go from one value to another in a sequence is not constant for each step. <br /></td></tr>
<tr class="separator:a06808a853a9baa38b23a5368e7491abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7951593b031e13d90223c83d022ce99e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a7951593b031e13d90223c83d022ce99e">Infinity</a> = -1</td></tr>
<tr class="memdesc:a7951593b031e13d90223c83d022ce99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value means +Infinity; it is currently used only as the p parameter to MatrixBase::lpNorm&lt;int&gt;().  <a href="namespaceEigen.html#a7951593b031e13d90223c83d022ce99e">More...</a><br /></td></tr>
<tr class="separator:a7951593b031e13d90223c83d022ce99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3163430a1c13173faffde69016b48aaf"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a3163430a1c13173faffde69016b48aaf">HugeCost</a> = 10000</td></tr>
<tr class="memdesc:a3163430a1c13173faffde69016b48aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value means that the cost to evaluate an expression coefficient is either very expensive or cannot be known at compile time.  <a href="namespaceEigen.html#a3163430a1c13173faffde69016b48aaf">More...</a><br /></td></tr>
<tr class="separator:a3163430a1c13173faffde69016b48aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4f56c2a60bbe4bd2e44c5b19cbe8762"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flags.html#gae4f56c2a60bbe4bd2e44c5b19cbe8762">RowMajorBit</a> = 0x1</td></tr>
<tr class="memdesc:gae4f56c2a60bbe4bd2e44c5b19cbe8762"><td class="mdescLeft">&#160;</td><td class="mdescRight">for a matrix, this means that the storage order is row-major.  <a href="group__flags.html#gae4f56c2a60bbe4bd2e44c5b19cbe8762">More...</a><br /></td></tr>
<tr class="separator:gae4f56c2a60bbe4bd2e44c5b19cbe8762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa34e83bae46a8eeae4e69ebe3aaecbed"><td class="memItemLeft" align="right" valign="top">
const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>EvalBeforeNestingBit</b> = 0x2</td></tr>
<tr class="memdesc:gaa34e83bae46a8eeae4e69ebe3aaecbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">means the expression should be evaluated by the calling expression <br /></td></tr>
<tr class="separator:gaa34e83bae46a8eeae4e69ebe3aaecbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0972b20dc004d13984e642b3bd12532e"><td class="memItemLeft" align="right" valign="top">EIGEN_DEPRECATED const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flags.html#ga0972b20dc004d13984e642b3bd12532e">EvalBeforeAssigningBit</a> = 0x4</td></tr>
<tr class="separator:ga0972b20dc004d13984e642b3bd12532e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a306a438e1ab074e8be59512e887b9f"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flags.html#ga1a306a438e1ab074e8be59512e887b9f">PacketAccessBit</a> = 0x8</td></tr>
<tr class="memdesc:ga1a306a438e1ab074e8be59512e887b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short version: means the expression might be vectorized.  <a href="group__flags.html#ga1a306a438e1ab074e8be59512e887b9f">More...</a><br /></td></tr>
<tr class="separator:ga1a306a438e1ab074e8be59512e887b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020f88dc24a123b9afbd756c4b220db2"><td class="memItemLeft" align="right" valign="top"><a id="a020f88dc24a123b9afbd756c4b220db2" name="a020f88dc24a123b9afbd756c4b220db2"></a>
const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>ActualPacketAccessBit</b> = 0x0</td></tr>
<tr class="separator:a020f88dc24a123b9afbd756c4b220db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b983a15d57cd55806df618ac544d09e"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flags.html#ga4b983a15d57cd55806df618ac544d09e">LinearAccessBit</a> = 0x10</td></tr>
<tr class="memdesc:ga4b983a15d57cd55806df618ac544d09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short version: means the expression can be seen as 1D vector.  <a href="group__flags.html#ga4b983a15d57cd55806df618ac544d09e">More...</a><br /></td></tr>
<tr class="separator:ga4b983a15d57cd55806df618ac544d09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2c323957f20dfdc6cb8f44428eaec1a"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flags.html#gae2c323957f20dfdc6cb8f44428eaec1a">LvalueBit</a> = 0x20</td></tr>
<tr class="memdesc:gae2c323957f20dfdc6cb8f44428eaec1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Means the expression has a coeffRef() method, i.e.  <a href="group__flags.html#gae2c323957f20dfdc6cb8f44428eaec1a">More...</a><br /></td></tr>
<tr class="separator:gae2c323957f20dfdc6cb8f44428eaec1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf1e9d0516a933445a4c307ad8f14915"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flags.html#gabf1e9d0516a933445a4c307ad8f14915">DirectAccessBit</a> = 0x40</td></tr>
<tr class="memdesc:gabf1e9d0516a933445a4c307ad8f14915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Means that the underlying array of coefficients can be directly accessed as a plain strided array.  <a href="group__flags.html#gabf1e9d0516a933445a4c307ad8f14915">More...</a><br /></td></tr>
<tr class="separator:gabf1e9d0516a933445a4c307ad8f14915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5795adacd266512a26890973503ed88"><td class="memItemLeft" align="right" valign="top">EIGEN_DEPRECATED const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flags.html#gac5795adacd266512a26890973503ed88">AlignedBit</a> = 0x80</td></tr>
<tr class="separator:gac5795adacd266512a26890973503ed88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314e8c179d85f480cbaa25558e2a649f"><td class="memItemLeft" align="right" valign="top"><a id="a314e8c179d85f480cbaa25558e2a649f" name="a314e8c179d85f480cbaa25558e2a649f"></a>
const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>NestByRefBit</b> = 0x100</td></tr>
<tr class="separator:a314e8c179d85f480cbaa25558e2a649f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c186ad80ddcf5e2ed3d7ee31cca1860"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flags.html#ga3c186ad80ddcf5e2ed3d7ee31cca1860">NoPreferredStorageOrderBit</a> = 0x200</td></tr>
<tr class="memdesc:ga3c186ad80ddcf5e2ed3d7ee31cca1860"><td class="mdescLeft">&#160;</td><td class="mdescRight">for an expression, this means that the storage order can be either row-major or column-major.  <a href="group__flags.html#ga3c186ad80ddcf5e2ed3d7ee31cca1860">More...</a><br /></td></tr>
<tr class="separator:ga3c186ad80ddcf5e2ed3d7ee31cca1860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed0244284da47a2b8661261431173caf"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flags.html#gaed0244284da47a2b8661261431173caf">CompressedAccessBit</a> = 0x400</td></tr>
<tr class="memdesc:gaed0244284da47a2b8661261431173caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Means that the underlying coefficients can be accessed through pointers to the sparse (un)compressed storage format, that is, the expression provides:  <a href="group__flags.html#gaed0244284da47a2b8661261431173caf">More...</a><br /></td></tr>
<tr class="separator:gaed0244284da47a2b8661261431173caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297729d26fa056b10e9d8d5d088b12e6"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a297729d26fa056b10e9d8d5d088b12e6">HereditaryBits</a></td></tr>
<tr class="separator:a297729d26fa056b10e9d8d5d088b12e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbdfe304a8319af94184bc781f583be"><td class="memItemLeft" align="right" valign="top"><a id="a7cbdfe304a8319af94184bc781f583be" name="a7cbdfe304a8319af94184bc781f583be"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>AutoOrder</b> = 2</td></tr>
<tr class="separator:a7cbdfe304a8319af94184bc781f583be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Namespace containing all symbols from the Eigen library. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a62e77e0933482dafde8fe197d9a2cfde" name="a62e77e0933482dafde8fe197d9a2cfde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e77e0933482dafde8fe197d9a2cfde">&#9670;&nbsp;</a></span>Index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef EIGEN_DEFAULT_DENSE_INDEX_TYPE <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Index type as used for the API. </p>
<p >To change this, <code>#define</code> the preprocessor symbol <code>EIGEN_DEFAULT_DENSE_INDEX_TYPE</code>. </p><dl class="section see"><dt>See also</dt><dd>\blank TopicPreprocessorDirectives, StorageIndex. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4bd4b85120e014cf1125a054b02d4d92" name="a4bd4b85120e014cf1125a054b02d4d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd4b85120e014cf1125a054b02d4d92">&#9670;&nbsp;</a></span>householderSequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorsType , typename CoeffsType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1HouseholderSequence.html">HouseholderSequence</a>&lt; VectorsType, CoeffsType &gt; Eigen::householderSequence </td>
          <td>(</td>
          <td class="paramtype">const VectorsType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoeffsType &amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>\ </p>
<p >Convenience function for constructing a Householder sequence. </p><dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classEigen_1_1HouseholderSequence.html" title="\householder_module">HouseholderSequence</a> constructed from the specified arguments. </dd></dl>

</div>
</div>
<a id="a2669f89ff38296a38e6d973552eb4e33" name="a2669f89ff38296a38e6d973552eb4e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2669f89ff38296a38e6d973552eb4e33">&#9670;&nbsp;</a></span>l1CacheSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t Eigen::l1CacheSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the currently set level 1 cpu cache size (in bytes) used to estimate the ideal blocking size parameters. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>setCpuCacheSize </dd></dl>

</div>
</div>
<a id="a2cfc0330ba567d63a496be1cac8427ae" name="a2cfc0330ba567d63a496be1cac8427ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cfc0330ba567d63a496be1cac8427ae">&#9670;&nbsp;</a></span>l2CacheSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t Eigen::l2CacheSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the currently set level 2 cpu cache size (in bytes) used to estimate the ideal blocking size parameters. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>setCpuCacheSize </dd></dl>

</div>
</div>
<a id="ae2efa4852ea90c2d47b7dcec5b40ba2b" name="ae2efa4852ea90c2d47b7dcec5b40ba2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2efa4852ea90c2d47b7dcec5b40ba2b">&#9670;&nbsp;</a></span>l3CacheSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t Eigen::l3CacheSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the currently set level 3 cpu cache size (in bytes) used to estimate the ideal blocking size paramete\ rs. <br  />
 </dd></dl>
<dl class="section see"><dt>See also</dt><dd>setCpuCacheSize </dd></dl>

</div>
</div>
<a id="a2f490197e16df831683018e383e29346" name="a2f490197e16df831683018e383e29346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f490197e16df831683018e383e29346">&#9670;&nbsp;</a></span>matrix_sqrt_quasi_triangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename ResultType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::matrix_sqrt_quasi_triangular </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute matrix square root of quasi-triangular matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>type of <code>arg</code>, the argument of matrix square root, expected to be an instantiation of the <a class="el" href="classEigen_1_1Matrix.html" title="The matrix class, also used for vectors and row-vectors.">Matrix</a> class template. </td></tr>
    <tr><td class="paramname">ResultType</td><td>type of <code>result</code>, where result is to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>argument of matrix square root. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>matrix square root of upper Hessenberg part of <code>arg</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function computes the square root of the upper quasi-triangular matrix stored in the upper Hessenberg part of <code>arg</code>. Only the upper Hessenberg part of <code>result</code> is updated, the rest is not touched. See <a class="el" href="group__UnitMath.html#gae52f60a9e2a9e7ad1018a846bcf49140" title="computes the square root of value">MatrixBase::sqrt()</a> for details on how this computation is implemented.</p>
<dl class="section see"><dt>See also</dt><dd>MatrixSquareRoot, MatrixSquareRootQuasiTriangular </dd></dl>

</div>
</div>
<a id="ae51c91f920f6ea4a7f6f72caa1e8249f" name="ae51c91f920f6ea4a7f6f72caa1e8249f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51c91f920f6ea4a7f6f72caa1e8249f">&#9670;&nbsp;</a></span>matrix_sqrt_triangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename ResultType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::matrix_sqrt_triangular </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute matrix square root of triangular matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>type of <code>arg</code>, the argument of matrix square root, expected to be an instantiation of the <a class="el" href="classEigen_1_1Matrix.html" title="The matrix class, also used for vectors and row-vectors.">Matrix</a> class template. </td></tr>
    <tr><td class="paramname">ResultType</td><td>type of <code>result</code>, where result is to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>argument of matrix square root. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>matrix square root of upper triangular part of <code>arg</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Only the upper triangular part (including the diagonal) of <code>result</code> is updated, the rest is not touched. See <a class="el" href="group__UnitMath.html#gae52f60a9e2a9e7ad1018a846bcf49140" title="computes the square root of value">MatrixBase::sqrt()</a> for details on how this computation is implemented.</p>
<dl class="section see"><dt>See also</dt><dd>MatrixSquareRoot, MatrixSquareRootQuasiTriangular </dd></dl>

</div>
</div>
<a id="a9aca97d83e21b91a04ec079360dfffeb" name="a9aca97d83e21b91a04ec079360dfffeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aca97d83e21b91a04ec079360dfffeb">&#9670;&nbsp;</a></span>nbThreads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Eigen::nbThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the max number of threads reserved for <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceEigen.html#af9cd17c2fe18204239cd11c88c120b50" title="Sets the max number of threads reserved for Eigen.">setNbThreads</a> </dd></dl>

</div>
</div>
<a id="a32970f7eb62fe31eeefee72d24a046d0" name="a32970f7eb62fe31eeefee72d24a046d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32970f7eb62fe31eeefee72d24a046d0">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixDerived , typename PermutationDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1Product.html">Product</a>&lt; MatrixDerived, PermutationDerived, AliasFreeProduct &gt; Eigen::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; MatrixDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1PermutationBase.html">PermutationBase</a>&lt; PermutationDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the matrix with the permutation applied to the columns. </dd></dl>

</div>
</div>
<a id="a8b493da0816bfa75429961b75f21d780" name="a8b493da0816bfa75429961b75f21d780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b493da0816bfa75429961b75f21d780">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixDerived , typename TranspositionsDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1Product.html">Product</a>&lt; MatrixDerived, TranspositionsDerived, AliasFreeProduct &gt; Eigen::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; MatrixDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1TranspositionsBase.html">TranspositionsBase</a>&lt; TranspositionsDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>transpositions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <em>matrix</em> with the <em>transpositions</em> applied to the columns. </dd></dl>

</div>
</div>
<a id="a269a343c1771ac7d806f6f1dd7a7fa3c" name="a269a343c1771ac7d806f6f1dd7a7fa3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269a343c1771ac7d806f6f1dd7a7fa3c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherDerived , typename VectorsType , typename CoeffsType , int Side&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEigen_1_1internal_1_1matrix__type__times__scalar__type.html">internal::matrix_type_times_scalar_type</a>&lt; typenameVectorsType::Scalar, OtherDerived &gt;::Type Eigen::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1HouseholderSequence.html">HouseholderSequence</a>&lt; VectorsType, CoeffsType, Side &gt; &amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the product of a matrix with a Householder sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Matrix being multiplied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>HouseholderSequence being multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Expression object representing the product.</dd></dl>
<p>This function computes \( MH \) where \( M \) is the matrix <code>other</code> and \( H \) is the Householder sequence represented by <code>h</code>. </p>

</div>
</div>
<a id="a5954e0288e506706e8d2c8cd5ff5b7d2" name="a5954e0288e506706e8d2c8cd5ff5b7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5954e0288e506706e8d2c8cd5ff5b7d2">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PermutationDerived , typename MatrixDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1Product.html">Product</a>&lt; PermutationDerived, MatrixDerived, AliasFreeProduct &gt; Eigen::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1PermutationBase.html">PermutationBase</a>&lt; PermutationDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; MatrixDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the matrix with the permutation applied to the rows. </dd></dl>

</div>
</div>
<a id="a4c63a9e3b8c513835a3b5551d98bd0c3" name="a4c63a9e3b8c513835a3b5551d98bd0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c63a9e3b8c513835a3b5551d98bd0c3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TranspositionsDerived , typename MatrixDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1Product.html">Product</a>&lt; TranspositionsDerived, MatrixDerived, AliasFreeProduct &gt; Eigen::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1TranspositionsBase.html">TranspositionsBase</a>&lt; TranspositionsDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>transpositions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; MatrixDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <em>matrix</em> with the <em>transpositions</em> applied to the rows. </dd></dl>

</div>
</div>
<a id="a59f16274f9e66f902f1a4b3f23e8b002" name="a59f16274f9e66f902f1a4b3f23e8b002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f16274f9e66f902f1a4b3f23e8b002">&#9670;&nbsp;</a></span>rightHouseholderSequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorsType , typename CoeffsType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1HouseholderSequence.html">HouseholderSequence</a>&lt; VectorsType, CoeffsType, <a class="el" href="group__enums.html#ggac22de43beeac7a78b384f99bed5cee0ba329fc3a54ceb2b6e0e73b400998b8a82">OnTheRight</a> &gt; Eigen::rightHouseholderSequence </td>
          <td>(</td>
          <td class="paramtype">const VectorsType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoeffsType &amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>\ </p>
<p >Convenience function for constructing a Householder sequence. </p><dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classEigen_1_1HouseholderSequence.html" title="\householder_module">HouseholderSequence</a> constructed from the specified arguments.</dd></dl>
<p>This function differs from <a class="el" href="namespaceEigen.html#a4bd4b85120e014cf1125a054b02d4d92" title="\">householderSequence()</a> in that the template argument <code>OnTheSide</code> of the constructed <a class="el" href="classEigen_1_1HouseholderSequence.html" title="\householder_module">HouseholderSequence</a> is set to OnTheRight, instead of the default OnTheLeft. </p>

</div>
</div>
<a id="a5e2b47604fbd83f8e88849a371eb0a8f" name="a5e2b47604fbd83f8e88849a371eb0a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2b47604fbd83f8e88849a371eb0a8f">&#9670;&nbsp;</a></span>seqN() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FirstType , typename SizeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1ArithmeticSequence.html">ArithmeticSequence</a>&lt; typename <a class="el" href="structEigen_1_1internal_1_1cleanup__index__type.html">internal::cleanup_index_type</a>&lt; FirstType &gt;::type, typename <a class="el" href="structEigen_1_1internal_1_1cleanup__index__type.html">internal::cleanup_index_type</a>&lt; SizeType &gt;::type &gt; Eigen::seqN </td>
          <td>(</td>
          <td class="paramtype">FirstType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeType&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classEigen_1_1ArithmeticSequence.html" title="This class represents an arithmetic progression  defined by its first value , its size (aka length) n...">ArithmeticSequence</a> starting at <em>first</em>, of length <em>size</em>, and unit increment</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceEigen.html#a3a3c346d2a61d1e8e86e6fb4cf57fbda">seqN(FirstType,SizeType,IncrType)</a>, seq(FirstType,LastType) </dd></dl>

</div>
</div>
<a id="a3a3c346d2a61d1e8e86e6fb4cf57fbda" name="a3a3c346d2a61d1e8e86e6fb4cf57fbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3c346d2a61d1e8e86e6fb4cf57fbda">&#9670;&nbsp;</a></span>seqN() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FirstType , typename SizeType , typename IncrType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1ArithmeticSequence.html">ArithmeticSequence</a>&lt; typename <a class="el" href="structEigen_1_1internal_1_1cleanup__index__type.html">internal::cleanup_index_type</a>&lt; FirstType &gt;::type, typename <a class="el" href="structEigen_1_1internal_1_1cleanup__index__type.html">internal::cleanup_index_type</a>&lt; SizeType &gt;::type, typename <a class="el" href="structEigen_1_1internal_1_1cleanup__seq__incr.html">internal::cleanup_seq_incr</a>&lt; IncrType &gt;::type &gt; Eigen::seqN </td>
          <td>(</td>
          <td class="paramtype">FirstType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeType&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IncrType&#160;</td>
          <td class="paramname"><em>incr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classEigen_1_1ArithmeticSequence.html" title="This class represents an arithmetic progression  defined by its first value , its size (aka length) n...">ArithmeticSequence</a> starting at <em>first</em>, of length <em>size</em>, and increment <em>incr</em> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceEigen.html#a5e2b47604fbd83f8e88849a371eb0a8f">seqN(FirstType,SizeType)</a>, seq(FirstType,LastType,IncrType) </dd></dl>

</div>
</div>
<a id="ae64421554aa0a4bf9258bafe3170102b" name="ae64421554aa0a4bf9258bafe3170102b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64421554aa0a4bf9258bafe3170102b">&#9670;&nbsp;</a></span>setCpuCacheSizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::setCpuCacheSizes </td>
          <td>(</td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>l2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>l3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the cpu L1 and L2 cache sizes (in bytes). </p>
<p >These values are use to adjust the size of the blocks for the algorithms working per blocks.</p>
<dl class="section see"><dt>See also</dt><dd>computeProductBlockingSizes </dd></dl>

</div>
</div>
<a id="af9cd17c2fe18204239cd11c88c120b50" name="af9cd17c2fe18204239cd11c88c120b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9cd17c2fe18204239cd11c88c120b50">&#9670;&nbsp;</a></span>setNbThreads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::setNbThreads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the max number of threads reserved for <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceEigen.html#a9aca97d83e21b91a04ec079360dfffeb">nbThreads</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad81fa7195215a0ce30017dfac309f0b2" name="ad81fa7195215a0ce30017dfac309f0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81fa7195215a0ce30017dfac309f0b2">&#9670;&nbsp;</a></span>Dynamic</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Eigen::Dynamic = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This value means that a positive quantity (e.g., a size) is not known at compile-time, and that instead the value is stored in some runtime variable. </p>
<p >Changing the value of Dynamic breaks the ABI, as Dynamic is often used as a template parameter for <a class="el" href="classEigen_1_1Matrix.html" title="The matrix class, also used for vectors and row-vectors.">Matrix</a>. </p>

</div>
</div>
<a id="aebd2d46df7e6d1ffb14367adbe008bfd" name="aebd2d46df7e6d1ffb14367adbe008bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd2d46df7e6d1ffb14367adbe008bfd">&#9670;&nbsp;</a></span>exponents</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1ArrayBase.html">Eigen::ArrayBase</a>&lt;Derived&gt;&amp; Eigen::exponents</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code hl_struct" href="structEigen_1_1internal_1_1promote__scalar__arg.html">internal::promote_scalar_arg</a>&lt;<span class="keyword">typename</span> Derived::Scalar,Scalar,</div>
<div class="line">                                                  EIGEN_SCALAR_BINARY_SUPPORTED(<a class="code hl_function" href="classEigen_1_1ArrayBase.html#acb769e1ab1d809abb77c7ab98021ad81">pow</a>,Scalar,<span class="keyword">typename</span> Derived::Scalar)&gt;::type PromotedScalar</div>
<div class="ttc" id="aclassEigen_1_1ArrayBase_html_acb769e1ab1d809abb77c7ab98021ad81"><div class="ttname"><a href="classEigen_1_1ArrayBase.html#acb769e1ab1d809abb77c7ab98021ad81">Eigen::ArrayBase::pow</a></div><div class="ttdeci">const Eigen::CwiseBinaryOp&lt; Eigen::internal::scalar_pow_op&lt; typename Derived::Scalar, typename ExponentDerived::Scalar &gt;, const Derived, const ExponentDerived &gt; pow(const Eigen::ArrayBase&lt; Derived &gt; &amp;x, const Eigen::ArrayBase&lt; ExponentDerived &gt; &amp;exponents)</div><div class="ttdef"><b>Definition:</b> GlobalFunctions.h:143</div></div>
<div class="ttc" id="astructEigen_1_1internal_1_1promote__scalar__arg_html"><div class="ttname"><a href="structEigen_1_1internal_1_1promote__scalar__arg.html">Eigen::internal::promote_scalar_arg</a></div><div class="ttdef"><b>Definition:</b> XprHelper.h:68</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a297729d26fa056b10e9d8d5d088b12e6" name="a297729d26fa056b10e9d8d5d088b12e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297729d26fa056b10e9d8d5d088b12e6">&#9670;&nbsp;</a></span>HereditaryBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int Eigen::HereditaryBits</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code hl_variable" href="group__flags.html#gae4f56c2a60bbe4bd2e44c5b19cbe8762">RowMajorBit</a></div>
<div class="line">                                  | <a class="code hl_variable" href="group__flags.html#gaa34e83bae46a8eeae4e69ebe3aaecbed">EvalBeforeNestingBit</a></div>
<div class="ttc" id="agroup__flags_html_gaa34e83bae46a8eeae4e69ebe3aaecbed"><div class="ttname"><a href="group__flags.html#gaa34e83bae46a8eeae4e69ebe3aaecbed">Eigen::EvalBeforeNestingBit</a></div><div class="ttdeci">const unsigned int EvalBeforeNestingBit</div><div class="ttdoc">means the expression should be evaluated by the calling expression</div><div class="ttdef"><b>Definition:</b> Constants.h:70</div></div>
<div class="ttc" id="agroup__flags_html_gae4f56c2a60bbe4bd2e44c5b19cbe8762"><div class="ttname"><a href="group__flags.html#gae4f56c2a60bbe4bd2e44c5b19cbe8762">Eigen::RowMajorBit</a></div><div class="ttdeci">const unsigned int RowMajorBit</div><div class="ttdoc">for a matrix, this means that the storage order is row-major.</div><div class="ttdef"><b>Definition:</b> Constants.h:66</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3163430a1c13173faffde69016b48aaf" name="a3163430a1c13173faffde69016b48aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3163430a1c13173faffde69016b48aaf">&#9670;&nbsp;</a></span>HugeCost</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Eigen::HugeCost = 10000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This value means that the cost to evaluate an expression coefficient is either very expensive or cannot be known at compile time. </p>
<p >This value has to be positive to (1) simplify cost computation, and (2) allow to distinguish between a very expensive and very very expensive expressions. It thus must also be large enough to make sure unrolling won't happen and that sub expressions will be evaluated, but not too large to avoid overflow. </p>

</div>
</div>
<a id="a7951593b031e13d90223c83d022ce99e" name="a7951593b031e13d90223c83d022ce99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7951593b031e13d90223c83d022ce99e">&#9670;&nbsp;</a></span>Infinity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Eigen::Infinity = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This value means +Infinity; it is currently used only as the p parameter to MatrixBase::lpNorm&lt;int&gt;(). </p>
<p >The value Infinity there means the L-infinity norm. </p>

</div>
</div>
<a id="a2dd8b20d08336af23947e054a17415ee" name="a2dd8b20d08336af23947e054a17415ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd8b20d08336af23947e054a17415ee">&#9670;&nbsp;</a></span>last</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::last</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can be used as a parameter to Eigen::seq and <a class="el" href="namespaceEigen.html#a3a3c346d2a61d1e8e86e6fb4cf57fbda">Eigen::seqN</a> functions to symbolically reference the last element/row/columns of the underlying vector or matrix once passed to DenseBase::operator()(const RowIndices&amp;, const ColIndices&amp;). </p>
<p >This symbolic placeholder supports standard arithmetic operations.</p>
<p >A typical usage example would be: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceEigen.html">Eigen</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code hl_variable" href="namespaceEigen.html#a2dd8b20d08336af23947e054a17415ee">Eigen::last</a>;</div>
<div class="line">VectorXd v(n);</div>
<div class="line">v(seq(2,<a class="code hl_variable" href="namespaceEigen.html#a2dd8b20d08336af23947e054a17415ee">last</a>-2)).setOnes();</div>
<div class="ttc" id="anamespaceEigen_html"><div class="ttname"><a href="namespaceEigen.html">Eigen</a></div><div class="ttdoc">Namespace containing all symbols from the Eigen library.</div><div class="ttdef"><b>Definition:</b> AutoDiffJacobian.h:14</div></div>
<div class="ttc" id="anamespaceEigen_html_a2dd8b20d08336af23947e054a17415ee"><div class="ttname"><a href="namespaceEigen.html#a2dd8b20d08336af23947e054a17415ee">Eigen::last</a></div><div class="ttdeci">static const symbolic::SymbolExpr&lt; internal::symbolic_last_tag &gt; last</div><div class="ttdoc">Can be used as a parameter to Eigen::seq and Eigen::seqN functions to symbolically reference the last...</div><div class="ttdef"><b>Definition:</b> IndexedViewHelper.h:38</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>end </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceEigen.html">Eigen</a></li>
    <li class="footer">Generated on Fri Oct 15 2021 01:13:01 for WPILibC++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
