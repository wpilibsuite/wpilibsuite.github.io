<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>Source code</title>
<meta name="description" content="source: package: org.opencv.calib3d, class: Calib3d">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
</head>
<body class="source">
<main role="main">
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span><a id="line.1">//</a>
<span class="sourceLineNo">002</span><a id="line.2">// This file is auto-generated. Please don't modify it!</a>
<span class="sourceLineNo">003</span><a id="line.3">//</a>
<span class="sourceLineNo">004</span><a id="line.4">package org.opencv.calib3d;</a>
<span class="sourceLineNo">005</span><a id="line.5"></a>
<span class="sourceLineNo">006</span><a id="line.6">import java.util.ArrayList;</a>
<span class="sourceLineNo">007</span><a id="line.7">import java.util.List;</a>
<span class="sourceLineNo">008</span><a id="line.8">import org.opencv.calib3d.UsacParams;</a>
<span class="sourceLineNo">009</span><a id="line.9">import org.opencv.core.Mat;</a>
<span class="sourceLineNo">010</span><a id="line.10">import org.opencv.core.MatOfDouble;</a>
<span class="sourceLineNo">011</span><a id="line.11">import org.opencv.core.MatOfPoint2f;</a>
<span class="sourceLineNo">012</span><a id="line.12">import org.opencv.core.MatOfPoint3f;</a>
<span class="sourceLineNo">013</span><a id="line.13">import org.opencv.core.Point;</a>
<span class="sourceLineNo">014</span><a id="line.14">import org.opencv.core.Rect;</a>
<span class="sourceLineNo">015</span><a id="line.15">import org.opencv.core.Scalar;</a>
<span class="sourceLineNo">016</span><a id="line.16">import org.opencv.core.Size;</a>
<span class="sourceLineNo">017</span><a id="line.17">import org.opencv.core.TermCriteria;</a>
<span class="sourceLineNo">018</span><a id="line.18">import org.opencv.utils.Converters;</a>
<span class="sourceLineNo">019</span><a id="line.19"></a>
<span class="sourceLineNo">020</span><a id="line.20">// C++: class Calib3d</a>
<span class="sourceLineNo">021</span><a id="line.21"></a>
<span class="sourceLineNo">022</span><a id="line.22">public class Calib3d {</a>
<span class="sourceLineNo">023</span><a id="line.23"></a>
<span class="sourceLineNo">024</span><a id="line.24">    // C++: enum &lt;unnamed&gt;</a>
<span class="sourceLineNo">025</span><a id="line.25">    public static final int</a>
<span class="sourceLineNo">026</span><a id="line.26">            CV_ITERATIVE = 0,</a>
<span class="sourceLineNo">027</span><a id="line.27">            CV_EPNP = 1,</a>
<span class="sourceLineNo">028</span><a id="line.28">            CV_P3P = 2,</a>
<span class="sourceLineNo">029</span><a id="line.29">            CV_DLS = 3,</a>
<span class="sourceLineNo">030</span><a id="line.30">            CvLevMarq_DONE = 0,</a>
<span class="sourceLineNo">031</span><a id="line.31">            CvLevMarq_STARTED = 1,</a>
<span class="sourceLineNo">032</span><a id="line.32">            CvLevMarq_CALC_J = 2,</a>
<span class="sourceLineNo">033</span><a id="line.33">            CvLevMarq_CHECK_ERR = 3,</a>
<span class="sourceLineNo">034</span><a id="line.34">            LMEDS = 4,</a>
<span class="sourceLineNo">035</span><a id="line.35">            RANSAC = 8,</a>
<span class="sourceLineNo">036</span><a id="line.36">            RHO = 16,</a>
<span class="sourceLineNo">037</span><a id="line.37">            USAC_DEFAULT = 32,</a>
<span class="sourceLineNo">038</span><a id="line.38">            USAC_PARALLEL = 33,</a>
<span class="sourceLineNo">039</span><a id="line.39">            USAC_FM_8PTS = 34,</a>
<span class="sourceLineNo">040</span><a id="line.40">            USAC_FAST = 35,</a>
<span class="sourceLineNo">041</span><a id="line.41">            USAC_ACCURATE = 36,</a>
<span class="sourceLineNo">042</span><a id="line.42">            USAC_PROSAC = 37,</a>
<span class="sourceLineNo">043</span><a id="line.43">            USAC_MAGSAC = 38,</a>
<span class="sourceLineNo">044</span><a id="line.44">            CALIB_CB_ADAPTIVE_THRESH = 1,</a>
<span class="sourceLineNo">045</span><a id="line.45">            CALIB_CB_NORMALIZE_IMAGE = 2,</a>
<span class="sourceLineNo">046</span><a id="line.46">            CALIB_CB_FILTER_QUADS = 4,</a>
<span class="sourceLineNo">047</span><a id="line.47">            CALIB_CB_FAST_CHECK = 8,</a>
<span class="sourceLineNo">048</span><a id="line.48">            CALIB_CB_EXHAUSTIVE = 16,</a>
<span class="sourceLineNo">049</span><a id="line.49">            CALIB_CB_ACCURACY = 32,</a>
<span class="sourceLineNo">050</span><a id="line.50">            CALIB_CB_LARGER = 64,</a>
<span class="sourceLineNo">051</span><a id="line.51">            CALIB_CB_MARKER = 128,</a>
<span class="sourceLineNo">052</span><a id="line.52">            CALIB_CB_SYMMETRIC_GRID = 1,</a>
<span class="sourceLineNo">053</span><a id="line.53">            CALIB_CB_ASYMMETRIC_GRID = 2,</a>
<span class="sourceLineNo">054</span><a id="line.54">            CALIB_CB_CLUSTERING = 4,</a>
<span class="sourceLineNo">055</span><a id="line.55">            CALIB_NINTRINSIC = 18,</a>
<span class="sourceLineNo">056</span><a id="line.56">            CALIB_USE_INTRINSIC_GUESS = 0x00001,</a>
<span class="sourceLineNo">057</span><a id="line.57">            CALIB_FIX_ASPECT_RATIO = 0x00002,</a>
<span class="sourceLineNo">058</span><a id="line.58">            CALIB_FIX_PRINCIPAL_POINT = 0x00004,</a>
<span class="sourceLineNo">059</span><a id="line.59">            CALIB_ZERO_TANGENT_DIST = 0x00008,</a>
<span class="sourceLineNo">060</span><a id="line.60">            CALIB_FIX_FOCAL_LENGTH = 0x00010,</a>
<span class="sourceLineNo">061</span><a id="line.61">            CALIB_FIX_K1 = 0x00020,</a>
<span class="sourceLineNo">062</span><a id="line.62">            CALIB_FIX_K2 = 0x00040,</a>
<span class="sourceLineNo">063</span><a id="line.63">            CALIB_FIX_K3 = 0x00080,</a>
<span class="sourceLineNo">064</span><a id="line.64">            CALIB_FIX_K4 = 0x00800,</a>
<span class="sourceLineNo">065</span><a id="line.65">            CALIB_FIX_K5 = 0x01000,</a>
<span class="sourceLineNo">066</span><a id="line.66">            CALIB_FIX_K6 = 0x02000,</a>
<span class="sourceLineNo">067</span><a id="line.67">            CALIB_RATIONAL_MODEL = 0x04000,</a>
<span class="sourceLineNo">068</span><a id="line.68">            CALIB_THIN_PRISM_MODEL = 0x08000,</a>
<span class="sourceLineNo">069</span><a id="line.69">            CALIB_FIX_S1_S2_S3_S4 = 0x10000,</a>
<span class="sourceLineNo">070</span><a id="line.70">            CALIB_TILTED_MODEL = 0x40000,</a>
<span class="sourceLineNo">071</span><a id="line.71">            CALIB_FIX_TAUX_TAUY = 0x80000,</a>
<span class="sourceLineNo">072</span><a id="line.72">            CALIB_USE_QR = 0x100000,</a>
<span class="sourceLineNo">073</span><a id="line.73">            CALIB_FIX_TANGENT_DIST = 0x200000,</a>
<span class="sourceLineNo">074</span><a id="line.74">            CALIB_FIX_INTRINSIC = 0x00100,</a>
<span class="sourceLineNo">075</span><a id="line.75">            CALIB_SAME_FOCAL_LENGTH = 0x00200,</a>
<span class="sourceLineNo">076</span><a id="line.76">            CALIB_ZERO_DISPARITY = 0x00400,</a>
<span class="sourceLineNo">077</span><a id="line.77">            CALIB_USE_LU = (1 &lt;&lt; 17),</a>
<span class="sourceLineNo">078</span><a id="line.78">            CALIB_USE_EXTRINSIC_GUESS = (1 &lt;&lt; 22),</a>
<span class="sourceLineNo">079</span><a id="line.79">            FM_7POINT = 1,</a>
<span class="sourceLineNo">080</span><a id="line.80">            FM_8POINT = 2,</a>
<span class="sourceLineNo">081</span><a id="line.81">            FM_LMEDS = 4,</a>
<span class="sourceLineNo">082</span><a id="line.82">            FM_RANSAC = 8,</a>
<span class="sourceLineNo">083</span><a id="line.83">            fisheye_CALIB_USE_INTRINSIC_GUESS = 1 &lt;&lt; 0,</a>
<span class="sourceLineNo">084</span><a id="line.84">            fisheye_CALIB_RECOMPUTE_EXTRINSIC = 1 &lt;&lt; 1,</a>
<span class="sourceLineNo">085</span><a id="line.85">            fisheye_CALIB_CHECK_COND = 1 &lt;&lt; 2,</a>
<span class="sourceLineNo">086</span><a id="line.86">            fisheye_CALIB_FIX_SKEW = 1 &lt;&lt; 3,</a>
<span class="sourceLineNo">087</span><a id="line.87">            fisheye_CALIB_FIX_K1 = 1 &lt;&lt; 4,</a>
<span class="sourceLineNo">088</span><a id="line.88">            fisheye_CALIB_FIX_K2 = 1 &lt;&lt; 5,</a>
<span class="sourceLineNo">089</span><a id="line.89">            fisheye_CALIB_FIX_K3 = 1 &lt;&lt; 6,</a>
<span class="sourceLineNo">090</span><a id="line.90">            fisheye_CALIB_FIX_K4 = 1 &lt;&lt; 7,</a>
<span class="sourceLineNo">091</span><a id="line.91">            fisheye_CALIB_FIX_INTRINSIC = 1 &lt;&lt; 8,</a>
<span class="sourceLineNo">092</span><a id="line.92">            fisheye_CALIB_FIX_PRINCIPAL_POINT = 1 &lt;&lt; 9,</a>
<span class="sourceLineNo">093</span><a id="line.93">            fisheye_CALIB_ZERO_DISPARITY = 1 &lt;&lt; 10,</a>
<span class="sourceLineNo">094</span><a id="line.94">            fisheye_CALIB_FIX_FOCAL_LENGTH = 1 &lt;&lt; 11;</a>
<span class="sourceLineNo">095</span><a id="line.95"></a>
<span class="sourceLineNo">096</span><a id="line.96"></a>
<span class="sourceLineNo">097</span><a id="line.97">    // C++: enum GridType (cv.CirclesGridFinderParameters.GridType)</a>
<span class="sourceLineNo">098</span><a id="line.98">    public static final int</a>
<span class="sourceLineNo">099</span><a id="line.99">            CirclesGridFinderParameters_SYMMETRIC_GRID = 0,</a>
<span class="sourceLineNo">100</span><a id="line.100">            CirclesGridFinderParameters_ASYMMETRIC_GRID = 1;</a>
<span class="sourceLineNo">101</span><a id="line.101"></a>
<span class="sourceLineNo">102</span><a id="line.102"></a>
<span class="sourceLineNo">103</span><a id="line.103">    // C++: enum HandEyeCalibrationMethod (cv.HandEyeCalibrationMethod)</a>
<span class="sourceLineNo">104</span><a id="line.104">    public static final int</a>
<span class="sourceLineNo">105</span><a id="line.105">            CALIB_HAND_EYE_TSAI = 0,</a>
<span class="sourceLineNo">106</span><a id="line.106">            CALIB_HAND_EYE_PARK = 1,</a>
<span class="sourceLineNo">107</span><a id="line.107">            CALIB_HAND_EYE_HORAUD = 2,</a>
<span class="sourceLineNo">108</span><a id="line.108">            CALIB_HAND_EYE_ANDREFF = 3,</a>
<span class="sourceLineNo">109</span><a id="line.109">            CALIB_HAND_EYE_DANIILIDIS = 4;</a>
<span class="sourceLineNo">110</span><a id="line.110"></a>
<span class="sourceLineNo">111</span><a id="line.111"></a>
<span class="sourceLineNo">112</span><a id="line.112">    // C++: enum LocalOptimMethod (cv.LocalOptimMethod)</a>
<span class="sourceLineNo">113</span><a id="line.113">    public static final int</a>
<span class="sourceLineNo">114</span><a id="line.114">            LOCAL_OPTIM_NULL = 0,</a>
<span class="sourceLineNo">115</span><a id="line.115">            LOCAL_OPTIM_INNER_LO = 1,</a>
<span class="sourceLineNo">116</span><a id="line.116">            LOCAL_OPTIM_INNER_AND_ITER_LO = 2,</a>
<span class="sourceLineNo">117</span><a id="line.117">            LOCAL_OPTIM_GC = 3,</a>
<span class="sourceLineNo">118</span><a id="line.118">            LOCAL_OPTIM_SIGMA = 4;</a>
<span class="sourceLineNo">119</span><a id="line.119"></a>
<span class="sourceLineNo">120</span><a id="line.120"></a>
<span class="sourceLineNo">121</span><a id="line.121">    // C++: enum NeighborSearchMethod (cv.NeighborSearchMethod)</a>
<span class="sourceLineNo">122</span><a id="line.122">    public static final int</a>
<span class="sourceLineNo">123</span><a id="line.123">            NEIGH_FLANN_KNN = 0,</a>
<span class="sourceLineNo">124</span><a id="line.124">            NEIGH_GRID = 1,</a>
<span class="sourceLineNo">125</span><a id="line.125">            NEIGH_FLANN_RADIUS = 2;</a>
<span class="sourceLineNo">126</span><a id="line.126"></a>
<span class="sourceLineNo">127</span><a id="line.127"></a>
<span class="sourceLineNo">128</span><a id="line.128">    // C++: enum RobotWorldHandEyeCalibrationMethod (cv.RobotWorldHandEyeCalibrationMethod)</a>
<span class="sourceLineNo">129</span><a id="line.129">    public static final int</a>
<span class="sourceLineNo">130</span><a id="line.130">            CALIB_ROBOT_WORLD_HAND_EYE_SHAH = 0,</a>
<span class="sourceLineNo">131</span><a id="line.131">            CALIB_ROBOT_WORLD_HAND_EYE_LI = 1;</a>
<span class="sourceLineNo">132</span><a id="line.132"></a>
<span class="sourceLineNo">133</span><a id="line.133"></a>
<span class="sourceLineNo">134</span><a id="line.134">    // C++: enum SamplingMethod (cv.SamplingMethod)</a>
<span class="sourceLineNo">135</span><a id="line.135">    public static final int</a>
<span class="sourceLineNo">136</span><a id="line.136">            SAMPLING_UNIFORM = 0,</a>
<span class="sourceLineNo">137</span><a id="line.137">            SAMPLING_PROGRESSIVE_NAPSAC = 1,</a>
<span class="sourceLineNo">138</span><a id="line.138">            SAMPLING_NAPSAC = 2,</a>
<span class="sourceLineNo">139</span><a id="line.139">            SAMPLING_PROSAC = 3;</a>
<span class="sourceLineNo">140</span><a id="line.140"></a>
<span class="sourceLineNo">141</span><a id="line.141"></a>
<span class="sourceLineNo">142</span><a id="line.142">    // C++: enum ScoreMethod (cv.ScoreMethod)</a>
<span class="sourceLineNo">143</span><a id="line.143">    public static final int</a>
<span class="sourceLineNo">144</span><a id="line.144">            SCORE_METHOD_RANSAC = 0,</a>
<span class="sourceLineNo">145</span><a id="line.145">            SCORE_METHOD_MSAC = 1,</a>
<span class="sourceLineNo">146</span><a id="line.146">            SCORE_METHOD_MAGSAC = 2,</a>
<span class="sourceLineNo">147</span><a id="line.147">            SCORE_METHOD_LMEDS = 3;</a>
<span class="sourceLineNo">148</span><a id="line.148"></a>
<span class="sourceLineNo">149</span><a id="line.149"></a>
<span class="sourceLineNo">150</span><a id="line.150">    // C++: enum SolvePnPMethod (cv.SolvePnPMethod)</a>
<span class="sourceLineNo">151</span><a id="line.151">    public static final int</a>
<span class="sourceLineNo">152</span><a id="line.152">            SOLVEPNP_ITERATIVE = 0,</a>
<span class="sourceLineNo">153</span><a id="line.153">            SOLVEPNP_EPNP = 1,</a>
<span class="sourceLineNo">154</span><a id="line.154">            SOLVEPNP_P3P = 2,</a>
<span class="sourceLineNo">155</span><a id="line.155">            SOLVEPNP_DLS = 3,</a>
<span class="sourceLineNo">156</span><a id="line.156">            SOLVEPNP_UPNP = 4,</a>
<span class="sourceLineNo">157</span><a id="line.157">            SOLVEPNP_AP3P = 5,</a>
<span class="sourceLineNo">158</span><a id="line.158">            SOLVEPNP_IPPE = 6,</a>
<span class="sourceLineNo">159</span><a id="line.159">            SOLVEPNP_IPPE_SQUARE = 7,</a>
<span class="sourceLineNo">160</span><a id="line.160">            SOLVEPNP_SQPNP = 8,</a>
<span class="sourceLineNo">161</span><a id="line.161">            SOLVEPNP_MAX_COUNT = 8+1;</a>
<span class="sourceLineNo">162</span><a id="line.162"></a>
<span class="sourceLineNo">163</span><a id="line.163"></a>
<span class="sourceLineNo">164</span><a id="line.164">    // C++: enum UndistortTypes (cv.UndistortTypes)</a>
<span class="sourceLineNo">165</span><a id="line.165">    public static final int</a>
<span class="sourceLineNo">166</span><a id="line.166">            PROJ_SPHERICAL_ORTHO = 0,</a>
<span class="sourceLineNo">167</span><a id="line.167">            PROJ_SPHERICAL_EQRECT = 1;</a>
<span class="sourceLineNo">168</span><a id="line.168"></a>
<span class="sourceLineNo">169</span><a id="line.169"></a>
<span class="sourceLineNo">170</span><a id="line.170">    //</a>
<span class="sourceLineNo">171</span><a id="line.171">    // C++:  void cv::Rodrigues(Mat src, Mat&amp; dst, Mat&amp; jacobian = Mat())</a>
<span class="sourceLineNo">172</span><a id="line.172">    //</a>
<span class="sourceLineNo">173</span><a id="line.173"></a>
<span class="sourceLineNo">174</span><a id="line.174">    /**</a>
<span class="sourceLineNo">175</span><a id="line.175">     * Converts a rotation matrix to a rotation vector or vice versa.</a>
<span class="sourceLineNo">176</span><a id="line.176">     *</a>
<span class="sourceLineNo">177</span><a id="line.177">     * @param src Input rotation vector (3x1 or 1x3) or rotation matrix (3x3).</a>
<span class="sourceLineNo">178</span><a id="line.178">     * @param dst Output rotation matrix (3x3) or rotation vector (3x1 or 1x3), respectively.</a>
<span class="sourceLineNo">179</span><a id="line.179">     * @param jacobian Optional output Jacobian matrix, 3x9 or 9x3, which is a matrix of partial</a>
<span class="sourceLineNo">180</span><a id="line.180">     * derivatives of the output array components with respect to the input array components.</a>
<span class="sourceLineNo">181</span><a id="line.181">     *</a>
<span class="sourceLineNo">182</span><a id="line.182">     * \(\begin{array}{l} \theta \leftarrow norm(r) \\ r  \leftarrow r/ \theta \\ R =  \cos(\theta) I + (1- \cos{\theta} ) r r^T +  \sin(\theta) \vecthreethree{0}{-r_z}{r_y}{r_z}{0}{-r_x}{-r_y}{r_x}{0} \end{array}\)</a>
<span class="sourceLineNo">183</span><a id="line.183">     *</a>
<span class="sourceLineNo">184</span><a id="line.184">     * Inverse transformation can be also done easily, since</a>
<span class="sourceLineNo">185</span><a id="line.185">     *</a>
<span class="sourceLineNo">186</span><a id="line.186">     * \(\sin ( \theta ) \vecthreethree{0}{-r_z}{r_y}{r_z}{0}{-r_x}{-r_y}{r_x}{0} = \frac{R - R^T}{2}\)</a>
<span class="sourceLineNo">187</span><a id="line.187">     *</a>
<span class="sourceLineNo">188</span><a id="line.188">     * A rotation vector is a convenient and most compact representation of a rotation matrix (since any</a>
<span class="sourceLineNo">189</span><a id="line.189">     * rotation matrix has just 3 degrees of freedom). The representation is used in the global 3D geometry</a>
<span class="sourceLineNo">190</span><a id="line.190">     * optimization procedures like REF: calibrateCamera, REF: stereoCalibrate, or REF: solvePnP .</a>
<span class="sourceLineNo">191</span><a id="line.191">     *</a>
<span class="sourceLineNo">192</span><a id="line.192">     * &lt;b&gt;Note:&lt;/b&gt; More information about the computation of the derivative of a 3D rotation matrix with respect to its exponential coordinate</a>
<span class="sourceLineNo">193</span><a id="line.193">     * can be found in:</a>
<span class="sourceLineNo">194</span><a id="line.194">     * &lt;ul&gt;</a>
<span class="sourceLineNo">195</span><a id="line.195">     *   &lt;li&gt;</a>
<span class="sourceLineNo">196</span><a id="line.196">     *      A Compact Formula for the Derivative of a 3-D Rotation in Exponential Coordinates, Guillermo Gallego, Anthony J. Yezzi CITE: Gallego2014ACF</a>
<span class="sourceLineNo">197</span><a id="line.197">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">198</span><a id="line.198">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">199</span><a id="line.199">     *</a>
<span class="sourceLineNo">200</span><a id="line.200">     * &lt;b&gt;Note:&lt;/b&gt; Useful information on SE(3) and Lie Groups can be found in:</a>
<span class="sourceLineNo">201</span><a id="line.201">     * &lt;ul&gt;</a>
<span class="sourceLineNo">202</span><a id="line.202">     *   &lt;li&gt;</a>
<span class="sourceLineNo">203</span><a id="line.203">     *      A tutorial on SE(3) transformation parameterizations and on-manifold optimization, Jose-Luis Blanco CITE: blanco2010tutorial</a>
<span class="sourceLineNo">204</span><a id="line.204">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">205</span><a id="line.205">     *   &lt;li&gt;</a>
<span class="sourceLineNo">206</span><a id="line.206">     *      Lie Groups for 2D and 3D Transformation, Ethan Eade CITE: Eade17</a>
<span class="sourceLineNo">207</span><a id="line.207">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">208</span><a id="line.208">     *   &lt;li&gt;</a>
<span class="sourceLineNo">209</span><a id="line.209">     *      A micro Lie theory for state estimation in robotics, Joan Solà, Jérémie Deray, Dinesh Atchuthan CITE: Sol2018AML</a>
<span class="sourceLineNo">210</span><a id="line.210">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">211</span><a id="line.211">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">212</span><a id="line.212">     */</a>
<span class="sourceLineNo">213</span><a id="line.213">    public static void Rodrigues(Mat src, Mat dst, Mat jacobian) {</a>
<span class="sourceLineNo">214</span><a id="line.214">        Rodrigues_0(src.nativeObj, dst.nativeObj, jacobian.nativeObj);</a>
<span class="sourceLineNo">215</span><a id="line.215">    }</a>
<span class="sourceLineNo">216</span><a id="line.216"></a>
<span class="sourceLineNo">217</span><a id="line.217">    /**</a>
<span class="sourceLineNo">218</span><a id="line.218">     * Converts a rotation matrix to a rotation vector or vice versa.</a>
<span class="sourceLineNo">219</span><a id="line.219">     *</a>
<span class="sourceLineNo">220</span><a id="line.220">     * @param src Input rotation vector (3x1 or 1x3) or rotation matrix (3x3).</a>
<span class="sourceLineNo">221</span><a id="line.221">     * @param dst Output rotation matrix (3x3) or rotation vector (3x1 or 1x3), respectively.</a>
<span class="sourceLineNo">222</span><a id="line.222">     * derivatives of the output array components with respect to the input array components.</a>
<span class="sourceLineNo">223</span><a id="line.223">     *</a>
<span class="sourceLineNo">224</span><a id="line.224">     * \(\begin{array}{l} \theta \leftarrow norm(r) \\ r  \leftarrow r/ \theta \\ R =  \cos(\theta) I + (1- \cos{\theta} ) r r^T +  \sin(\theta) \vecthreethree{0}{-r_z}{r_y}{r_z}{0}{-r_x}{-r_y}{r_x}{0} \end{array}\)</a>
<span class="sourceLineNo">225</span><a id="line.225">     *</a>
<span class="sourceLineNo">226</span><a id="line.226">     * Inverse transformation can be also done easily, since</a>
<span class="sourceLineNo">227</span><a id="line.227">     *</a>
<span class="sourceLineNo">228</span><a id="line.228">     * \(\sin ( \theta ) \vecthreethree{0}{-r_z}{r_y}{r_z}{0}{-r_x}{-r_y}{r_x}{0} = \frac{R - R^T}{2}\)</a>
<span class="sourceLineNo">229</span><a id="line.229">     *</a>
<span class="sourceLineNo">230</span><a id="line.230">     * A rotation vector is a convenient and most compact representation of a rotation matrix (since any</a>
<span class="sourceLineNo">231</span><a id="line.231">     * rotation matrix has just 3 degrees of freedom). The representation is used in the global 3D geometry</a>
<span class="sourceLineNo">232</span><a id="line.232">     * optimization procedures like REF: calibrateCamera, REF: stereoCalibrate, or REF: solvePnP .</a>
<span class="sourceLineNo">233</span><a id="line.233">     *</a>
<span class="sourceLineNo">234</span><a id="line.234">     * &lt;b&gt;Note:&lt;/b&gt; More information about the computation of the derivative of a 3D rotation matrix with respect to its exponential coordinate</a>
<span class="sourceLineNo">235</span><a id="line.235">     * can be found in:</a>
<span class="sourceLineNo">236</span><a id="line.236">     * &lt;ul&gt;</a>
<span class="sourceLineNo">237</span><a id="line.237">     *   &lt;li&gt;</a>
<span class="sourceLineNo">238</span><a id="line.238">     *      A Compact Formula for the Derivative of a 3-D Rotation in Exponential Coordinates, Guillermo Gallego, Anthony J. Yezzi CITE: Gallego2014ACF</a>
<span class="sourceLineNo">239</span><a id="line.239">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">240</span><a id="line.240">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">241</span><a id="line.241">     *</a>
<span class="sourceLineNo">242</span><a id="line.242">     * &lt;b&gt;Note:&lt;/b&gt; Useful information on SE(3) and Lie Groups can be found in:</a>
<span class="sourceLineNo">243</span><a id="line.243">     * &lt;ul&gt;</a>
<span class="sourceLineNo">244</span><a id="line.244">     *   &lt;li&gt;</a>
<span class="sourceLineNo">245</span><a id="line.245">     *      A tutorial on SE(3) transformation parameterizations and on-manifold optimization, Jose-Luis Blanco CITE: blanco2010tutorial</a>
<span class="sourceLineNo">246</span><a id="line.246">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">247</span><a id="line.247">     *   &lt;li&gt;</a>
<span class="sourceLineNo">248</span><a id="line.248">     *      Lie Groups for 2D and 3D Transformation, Ethan Eade CITE: Eade17</a>
<span class="sourceLineNo">249</span><a id="line.249">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">250</span><a id="line.250">     *   &lt;li&gt;</a>
<span class="sourceLineNo">251</span><a id="line.251">     *      A micro Lie theory for state estimation in robotics, Joan Solà, Jérémie Deray, Dinesh Atchuthan CITE: Sol2018AML</a>
<span class="sourceLineNo">252</span><a id="line.252">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">253</span><a id="line.253">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">254</span><a id="line.254">     */</a>
<span class="sourceLineNo">255</span><a id="line.255">    public static void Rodrigues(Mat src, Mat dst) {</a>
<span class="sourceLineNo">256</span><a id="line.256">        Rodrigues_1(src.nativeObj, dst.nativeObj);</a>
<span class="sourceLineNo">257</span><a id="line.257">    }</a>
<span class="sourceLineNo">258</span><a id="line.258"></a>
<span class="sourceLineNo">259</span><a id="line.259"></a>
<span class="sourceLineNo">260</span><a id="line.260">    //</a>
<span class="sourceLineNo">261</span><a id="line.261">    // C++:  Mat cv::findHomography(vector_Point2f srcPoints, vector_Point2f dstPoints, int method = 0, double ransacReprojThreshold = 3, Mat&amp; mask = Mat(), int maxIters = 2000, double confidence = 0.995)</a>
<span class="sourceLineNo">262</span><a id="line.262">    //</a>
<span class="sourceLineNo">263</span><a id="line.263"></a>
<span class="sourceLineNo">264</span><a id="line.264">    /**</a>
<span class="sourceLineNo">265</span><a id="line.265">     * Finds a perspective transformation between two planes.</a>
<span class="sourceLineNo">266</span><a id="line.266">     *</a>
<span class="sourceLineNo">267</span><a id="line.267">     * @param srcPoints Coordinates of the points in the original plane, a matrix of the type CV_32FC2</a>
<span class="sourceLineNo">268</span><a id="line.268">     * or vector&amp;lt;Point2f&amp;gt; .</a>
<span class="sourceLineNo">269</span><a id="line.269">     * @param dstPoints Coordinates of the points in the target plane, a matrix of the type CV_32FC2 or</a>
<span class="sourceLineNo">270</span><a id="line.270">     * a vector&amp;lt;Point2f&amp;gt; .</a>
<span class="sourceLineNo">271</span><a id="line.271">     * @param method Method used to compute a homography matrix. The following methods are possible:</a>
<span class="sourceLineNo">272</span><a id="line.272">     * &lt;ul&gt;</a>
<span class="sourceLineNo">273</span><a id="line.273">     *   &lt;li&gt;</a>
<span class="sourceLineNo">274</span><a id="line.274">     *    &lt;b&gt;0&lt;/b&gt; - a regular method using all the points, i.e., the least squares method</a>
<span class="sourceLineNo">275</span><a id="line.275">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">276</span><a id="line.276">     *   &lt;li&gt;</a>
<span class="sourceLineNo">277</span><a id="line.277">     *    REF: RANSAC - RANSAC-based robust method</a>
<span class="sourceLineNo">278</span><a id="line.278">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">279</span><a id="line.279">     *   &lt;li&gt;</a>
<span class="sourceLineNo">280</span><a id="line.280">     *    REF: LMEDS - Least-Median robust method</a>
<span class="sourceLineNo">281</span><a id="line.281">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">282</span><a id="line.282">     *   &lt;li&gt;</a>
<span class="sourceLineNo">283</span><a id="line.283">     *    REF: RHO - PROSAC-based robust method</a>
<span class="sourceLineNo">284</span><a id="line.284">     * @param ransacReprojThreshold Maximum allowed reprojection error to treat a point pair as an inlier</a>
<span class="sourceLineNo">285</span><a id="line.285">     * (used in the RANSAC and RHO methods only). That is, if</a>
<span class="sourceLineNo">286</span><a id="line.286">     * \(\| \texttt{dstPoints} _i -  \texttt{convertPointsHomogeneous} ( \texttt{H} * \texttt{srcPoints} _i) \|_2  &amp;gt;  \texttt{ransacReprojThreshold}\)</a>
<span class="sourceLineNo">287</span><a id="line.287">     * then the point \(i\) is considered as an outlier. If srcPoints and dstPoints are measured in pixels,</a>
<span class="sourceLineNo">288</span><a id="line.288">     * it usually makes sense to set this parameter somewhere in the range of 1 to 10.</a>
<span class="sourceLineNo">289</span><a id="line.289">     * @param mask Optional output mask set by a robust method ( RANSAC or LMeDS ). Note that the input</a>
<span class="sourceLineNo">290</span><a id="line.290">     * mask values are ignored.</a>
<span class="sourceLineNo">291</span><a id="line.291">     * @param maxIters The maximum number of RANSAC iterations.</a>
<span class="sourceLineNo">292</span><a id="line.292">     * @param confidence Confidence level, between 0 and 1.</a>
<span class="sourceLineNo">293</span><a id="line.293">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">294</span><a id="line.294">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">295</span><a id="line.295">     *</a>
<span class="sourceLineNo">296</span><a id="line.296">     * The function finds and returns the perspective transformation \(H\) between the source and the</a>
<span class="sourceLineNo">297</span><a id="line.297">     * destination planes:</a>
<span class="sourceLineNo">298</span><a id="line.298">     *</a>
<span class="sourceLineNo">299</span><a id="line.299">     * \(s_i  \vecthree{x'_i}{y'_i}{1} \sim H  \vecthree{x_i}{y_i}{1}\)</a>
<span class="sourceLineNo">300</span><a id="line.300">     *</a>
<span class="sourceLineNo">301</span><a id="line.301">     * so that the back-projection error</a>
<span class="sourceLineNo">302</span><a id="line.302">     *</a>
<span class="sourceLineNo">303</span><a id="line.303">     * \(\sum _i \left ( x'_i- \frac{h_{11} x_i + h_{12} y_i + h_{13}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2+ \left ( y'_i- \frac{h_{21} x_i + h_{22} y_i + h_{23}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2\)</a>
<span class="sourceLineNo">304</span><a id="line.304">     *</a>
<span class="sourceLineNo">305</span><a id="line.305">     * is minimized. If the parameter method is set to the default value 0, the function uses all the point</a>
<span class="sourceLineNo">306</span><a id="line.306">     * pairs to compute an initial homography estimate with a simple least-squares scheme.</a>
<span class="sourceLineNo">307</span><a id="line.307">     *</a>
<span class="sourceLineNo">308</span><a id="line.308">     * However, if not all of the point pairs ( \(srcPoints_i\), \(dstPoints_i\) ) fit the rigid perspective</a>
<span class="sourceLineNo">309</span><a id="line.309">     * transformation (that is, there are some outliers), this initial estimate will be poor. In this case,</a>
<span class="sourceLineNo">310</span><a id="line.310">     * you can use one of the three robust methods. The methods RANSAC, LMeDS and RHO try many different</a>
<span class="sourceLineNo">311</span><a id="line.311">     * random subsets of the corresponding point pairs (of four pairs each, collinear pairs are discarded), estimate the homography matrix</a>
<span class="sourceLineNo">312</span><a id="line.312">     * using this subset and a simple least-squares algorithm, and then compute the quality/goodness of the</a>
<span class="sourceLineNo">313</span><a id="line.313">     * computed homography (which is the number of inliers for RANSAC or the least median re-projection error for</a>
<span class="sourceLineNo">314</span><a id="line.314">     * LMeDS). The best subset is then used to produce the initial estimate of the homography matrix and</a>
<span class="sourceLineNo">315</span><a id="line.315">     * the mask of inliers/outliers.</a>
<span class="sourceLineNo">316</span><a id="line.316">     *</a>
<span class="sourceLineNo">317</span><a id="line.317">     * Regardless of the method, robust or not, the computed homography matrix is refined further (using</a>
<span class="sourceLineNo">318</span><a id="line.318">     * inliers only in case of a robust method) with the Levenberg-Marquardt method to reduce the</a>
<span class="sourceLineNo">319</span><a id="line.319">     * re-projection error even more.</a>
<span class="sourceLineNo">320</span><a id="line.320">     *</a>
<span class="sourceLineNo">321</span><a id="line.321">     * The methods RANSAC and RHO can handle practically any ratio of outliers but need a threshold to</a>
<span class="sourceLineNo">322</span><a id="line.322">     * distinguish inliers from outliers. The method LMeDS does not need any threshold but it works</a>
<span class="sourceLineNo">323</span><a id="line.323">     * correctly only when there are more than 50% of inliers. Finally, if there are no outliers and the</a>
<span class="sourceLineNo">324</span><a id="line.324">     * noise is rather small, use the default method (method=0).</a>
<span class="sourceLineNo">325</span><a id="line.325">     *</a>
<span class="sourceLineNo">326</span><a id="line.326">     * The function is used to find initial intrinsic and extrinsic matrices. Homography matrix is</a>
<span class="sourceLineNo">327</span><a id="line.327">     * determined up to a scale. Thus, it is normalized so that \(h_{33}=1\). Note that whenever an \(H\) matrix</a>
<span class="sourceLineNo">328</span><a id="line.328">     * cannot be estimated, an empty one will be returned.</a>
<span class="sourceLineNo">329</span><a id="line.329">     *</a>
<span class="sourceLineNo">330</span><a id="line.330">     * SEE:</a>
<span class="sourceLineNo">331</span><a id="line.331">     * getAffineTransform, estimateAffine2D, estimateAffinePartial2D, getPerspectiveTransform, warpPerspective,</a>
<span class="sourceLineNo">332</span><a id="line.332">     * perspectiveTransform</a>
<span class="sourceLineNo">333</span><a id="line.333">     * @return automatically generated</a>
<span class="sourceLineNo">334</span><a id="line.334">     */</a>
<span class="sourceLineNo">335</span><a id="line.335">    public static Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints, int method, double ransacReprojThreshold, Mat mask, int maxIters, double confidence) {</a>
<span class="sourceLineNo">336</span><a id="line.336">        Mat srcPoints_mat = srcPoints;</a>
<span class="sourceLineNo">337</span><a id="line.337">        Mat dstPoints_mat = dstPoints;</a>
<span class="sourceLineNo">338</span><a id="line.338">        return new Mat(findHomography_0(srcPoints_mat.nativeObj, dstPoints_mat.nativeObj, method, ransacReprojThreshold, mask.nativeObj, maxIters, confidence));</a>
<span class="sourceLineNo">339</span><a id="line.339">    }</a>
<span class="sourceLineNo">340</span><a id="line.340"></a>
<span class="sourceLineNo">341</span><a id="line.341">    /**</a>
<span class="sourceLineNo">342</span><a id="line.342">     * Finds a perspective transformation between two planes.</a>
<span class="sourceLineNo">343</span><a id="line.343">     *</a>
<span class="sourceLineNo">344</span><a id="line.344">     * @param srcPoints Coordinates of the points in the original plane, a matrix of the type CV_32FC2</a>
<span class="sourceLineNo">345</span><a id="line.345">     * or vector&amp;lt;Point2f&amp;gt; .</a>
<span class="sourceLineNo">346</span><a id="line.346">     * @param dstPoints Coordinates of the points in the target plane, a matrix of the type CV_32FC2 or</a>
<span class="sourceLineNo">347</span><a id="line.347">     * a vector&amp;lt;Point2f&amp;gt; .</a>
<span class="sourceLineNo">348</span><a id="line.348">     * @param method Method used to compute a homography matrix. The following methods are possible:</a>
<span class="sourceLineNo">349</span><a id="line.349">     * &lt;ul&gt;</a>
<span class="sourceLineNo">350</span><a id="line.350">     *   &lt;li&gt;</a>
<span class="sourceLineNo">351</span><a id="line.351">     *    &lt;b&gt;0&lt;/b&gt; - a regular method using all the points, i.e., the least squares method</a>
<span class="sourceLineNo">352</span><a id="line.352">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">353</span><a id="line.353">     *   &lt;li&gt;</a>
<span class="sourceLineNo">354</span><a id="line.354">     *    REF: RANSAC - RANSAC-based robust method</a>
<span class="sourceLineNo">355</span><a id="line.355">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">356</span><a id="line.356">     *   &lt;li&gt;</a>
<span class="sourceLineNo">357</span><a id="line.357">     *    REF: LMEDS - Least-Median robust method</a>
<span class="sourceLineNo">358</span><a id="line.358">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">359</span><a id="line.359">     *   &lt;li&gt;</a>
<span class="sourceLineNo">360</span><a id="line.360">     *    REF: RHO - PROSAC-based robust method</a>
<span class="sourceLineNo">361</span><a id="line.361">     * @param ransacReprojThreshold Maximum allowed reprojection error to treat a point pair as an inlier</a>
<span class="sourceLineNo">362</span><a id="line.362">     * (used in the RANSAC and RHO methods only). That is, if</a>
<span class="sourceLineNo">363</span><a id="line.363">     * \(\| \texttt{dstPoints} _i -  \texttt{convertPointsHomogeneous} ( \texttt{H} * \texttt{srcPoints} _i) \|_2  &amp;gt;  \texttt{ransacReprojThreshold}\)</a>
<span class="sourceLineNo">364</span><a id="line.364">     * then the point \(i\) is considered as an outlier. If srcPoints and dstPoints are measured in pixels,</a>
<span class="sourceLineNo">365</span><a id="line.365">     * it usually makes sense to set this parameter somewhere in the range of 1 to 10.</a>
<span class="sourceLineNo">366</span><a id="line.366">     * @param mask Optional output mask set by a robust method ( RANSAC or LMeDS ). Note that the input</a>
<span class="sourceLineNo">367</span><a id="line.367">     * mask values are ignored.</a>
<span class="sourceLineNo">368</span><a id="line.368">     * @param maxIters The maximum number of RANSAC iterations.</a>
<span class="sourceLineNo">369</span><a id="line.369">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">370</span><a id="line.370">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">371</span><a id="line.371">     *</a>
<span class="sourceLineNo">372</span><a id="line.372">     * The function finds and returns the perspective transformation \(H\) between the source and the</a>
<span class="sourceLineNo">373</span><a id="line.373">     * destination planes:</a>
<span class="sourceLineNo">374</span><a id="line.374">     *</a>
<span class="sourceLineNo">375</span><a id="line.375">     * \(s_i  \vecthree{x'_i}{y'_i}{1} \sim H  \vecthree{x_i}{y_i}{1}\)</a>
<span class="sourceLineNo">376</span><a id="line.376">     *</a>
<span class="sourceLineNo">377</span><a id="line.377">     * so that the back-projection error</a>
<span class="sourceLineNo">378</span><a id="line.378">     *</a>
<span class="sourceLineNo">379</span><a id="line.379">     * \(\sum _i \left ( x'_i- \frac{h_{11} x_i + h_{12} y_i + h_{13}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2+ \left ( y'_i- \frac{h_{21} x_i + h_{22} y_i + h_{23}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2\)</a>
<span class="sourceLineNo">380</span><a id="line.380">     *</a>
<span class="sourceLineNo">381</span><a id="line.381">     * is minimized. If the parameter method is set to the default value 0, the function uses all the point</a>
<span class="sourceLineNo">382</span><a id="line.382">     * pairs to compute an initial homography estimate with a simple least-squares scheme.</a>
<span class="sourceLineNo">383</span><a id="line.383">     *</a>
<span class="sourceLineNo">384</span><a id="line.384">     * However, if not all of the point pairs ( \(srcPoints_i\), \(dstPoints_i\) ) fit the rigid perspective</a>
<span class="sourceLineNo">385</span><a id="line.385">     * transformation (that is, there are some outliers), this initial estimate will be poor. In this case,</a>
<span class="sourceLineNo">386</span><a id="line.386">     * you can use one of the three robust methods. The methods RANSAC, LMeDS and RHO try many different</a>
<span class="sourceLineNo">387</span><a id="line.387">     * random subsets of the corresponding point pairs (of four pairs each, collinear pairs are discarded), estimate the homography matrix</a>
<span class="sourceLineNo">388</span><a id="line.388">     * using this subset and a simple least-squares algorithm, and then compute the quality/goodness of the</a>
<span class="sourceLineNo">389</span><a id="line.389">     * computed homography (which is the number of inliers for RANSAC or the least median re-projection error for</a>
<span class="sourceLineNo">390</span><a id="line.390">     * LMeDS). The best subset is then used to produce the initial estimate of the homography matrix and</a>
<span class="sourceLineNo">391</span><a id="line.391">     * the mask of inliers/outliers.</a>
<span class="sourceLineNo">392</span><a id="line.392">     *</a>
<span class="sourceLineNo">393</span><a id="line.393">     * Regardless of the method, robust or not, the computed homography matrix is refined further (using</a>
<span class="sourceLineNo">394</span><a id="line.394">     * inliers only in case of a robust method) with the Levenberg-Marquardt method to reduce the</a>
<span class="sourceLineNo">395</span><a id="line.395">     * re-projection error even more.</a>
<span class="sourceLineNo">396</span><a id="line.396">     *</a>
<span class="sourceLineNo">397</span><a id="line.397">     * The methods RANSAC and RHO can handle practically any ratio of outliers but need a threshold to</a>
<span class="sourceLineNo">398</span><a id="line.398">     * distinguish inliers from outliers. The method LMeDS does not need any threshold but it works</a>
<span class="sourceLineNo">399</span><a id="line.399">     * correctly only when there are more than 50% of inliers. Finally, if there are no outliers and the</a>
<span class="sourceLineNo">400</span><a id="line.400">     * noise is rather small, use the default method (method=0).</a>
<span class="sourceLineNo">401</span><a id="line.401">     *</a>
<span class="sourceLineNo">402</span><a id="line.402">     * The function is used to find initial intrinsic and extrinsic matrices. Homography matrix is</a>
<span class="sourceLineNo">403</span><a id="line.403">     * determined up to a scale. Thus, it is normalized so that \(h_{33}=1\). Note that whenever an \(H\) matrix</a>
<span class="sourceLineNo">404</span><a id="line.404">     * cannot be estimated, an empty one will be returned.</a>
<span class="sourceLineNo">405</span><a id="line.405">     *</a>
<span class="sourceLineNo">406</span><a id="line.406">     * SEE:</a>
<span class="sourceLineNo">407</span><a id="line.407">     * getAffineTransform, estimateAffine2D, estimateAffinePartial2D, getPerspectiveTransform, warpPerspective,</a>
<span class="sourceLineNo">408</span><a id="line.408">     * perspectiveTransform</a>
<span class="sourceLineNo">409</span><a id="line.409">     * @return automatically generated</a>
<span class="sourceLineNo">410</span><a id="line.410">     */</a>
<span class="sourceLineNo">411</span><a id="line.411">    public static Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints, int method, double ransacReprojThreshold, Mat mask, int maxIters) {</a>
<span class="sourceLineNo">412</span><a id="line.412">        Mat srcPoints_mat = srcPoints;</a>
<span class="sourceLineNo">413</span><a id="line.413">        Mat dstPoints_mat = dstPoints;</a>
<span class="sourceLineNo">414</span><a id="line.414">        return new Mat(findHomography_1(srcPoints_mat.nativeObj, dstPoints_mat.nativeObj, method, ransacReprojThreshold, mask.nativeObj, maxIters));</a>
<span class="sourceLineNo">415</span><a id="line.415">    }</a>
<span class="sourceLineNo">416</span><a id="line.416"></a>
<span class="sourceLineNo">417</span><a id="line.417">    /**</a>
<span class="sourceLineNo">418</span><a id="line.418">     * Finds a perspective transformation between two planes.</a>
<span class="sourceLineNo">419</span><a id="line.419">     *</a>
<span class="sourceLineNo">420</span><a id="line.420">     * @param srcPoints Coordinates of the points in the original plane, a matrix of the type CV_32FC2</a>
<span class="sourceLineNo">421</span><a id="line.421">     * or vector&amp;lt;Point2f&amp;gt; .</a>
<span class="sourceLineNo">422</span><a id="line.422">     * @param dstPoints Coordinates of the points in the target plane, a matrix of the type CV_32FC2 or</a>
<span class="sourceLineNo">423</span><a id="line.423">     * a vector&amp;lt;Point2f&amp;gt; .</a>
<span class="sourceLineNo">424</span><a id="line.424">     * @param method Method used to compute a homography matrix. The following methods are possible:</a>
<span class="sourceLineNo">425</span><a id="line.425">     * &lt;ul&gt;</a>
<span class="sourceLineNo">426</span><a id="line.426">     *   &lt;li&gt;</a>
<span class="sourceLineNo">427</span><a id="line.427">     *    &lt;b&gt;0&lt;/b&gt; - a regular method using all the points, i.e., the least squares method</a>
<span class="sourceLineNo">428</span><a id="line.428">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">429</span><a id="line.429">     *   &lt;li&gt;</a>
<span class="sourceLineNo">430</span><a id="line.430">     *    REF: RANSAC - RANSAC-based robust method</a>
<span class="sourceLineNo">431</span><a id="line.431">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">432</span><a id="line.432">     *   &lt;li&gt;</a>
<span class="sourceLineNo">433</span><a id="line.433">     *    REF: LMEDS - Least-Median robust method</a>
<span class="sourceLineNo">434</span><a id="line.434">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">435</span><a id="line.435">     *   &lt;li&gt;</a>
<span class="sourceLineNo">436</span><a id="line.436">     *    REF: RHO - PROSAC-based robust method</a>
<span class="sourceLineNo">437</span><a id="line.437">     * @param ransacReprojThreshold Maximum allowed reprojection error to treat a point pair as an inlier</a>
<span class="sourceLineNo">438</span><a id="line.438">     * (used in the RANSAC and RHO methods only). That is, if</a>
<span class="sourceLineNo">439</span><a id="line.439">     * \(\| \texttt{dstPoints} _i -  \texttt{convertPointsHomogeneous} ( \texttt{H} * \texttt{srcPoints} _i) \|_2  &amp;gt;  \texttt{ransacReprojThreshold}\)</a>
<span class="sourceLineNo">440</span><a id="line.440">     * then the point \(i\) is considered as an outlier. If srcPoints and dstPoints are measured in pixels,</a>
<span class="sourceLineNo">441</span><a id="line.441">     * it usually makes sense to set this parameter somewhere in the range of 1 to 10.</a>
<span class="sourceLineNo">442</span><a id="line.442">     * @param mask Optional output mask set by a robust method ( RANSAC or LMeDS ). Note that the input</a>
<span class="sourceLineNo">443</span><a id="line.443">     * mask values are ignored.</a>
<span class="sourceLineNo">444</span><a id="line.444">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">445</span><a id="line.445">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">446</span><a id="line.446">     *</a>
<span class="sourceLineNo">447</span><a id="line.447">     * The function finds and returns the perspective transformation \(H\) between the source and the</a>
<span class="sourceLineNo">448</span><a id="line.448">     * destination planes:</a>
<span class="sourceLineNo">449</span><a id="line.449">     *</a>
<span class="sourceLineNo">450</span><a id="line.450">     * \(s_i  \vecthree{x'_i}{y'_i}{1} \sim H  \vecthree{x_i}{y_i}{1}\)</a>
<span class="sourceLineNo">451</span><a id="line.451">     *</a>
<span class="sourceLineNo">452</span><a id="line.452">     * so that the back-projection error</a>
<span class="sourceLineNo">453</span><a id="line.453">     *</a>
<span class="sourceLineNo">454</span><a id="line.454">     * \(\sum _i \left ( x'_i- \frac{h_{11} x_i + h_{12} y_i + h_{13}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2+ \left ( y'_i- \frac{h_{21} x_i + h_{22} y_i + h_{23}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2\)</a>
<span class="sourceLineNo">455</span><a id="line.455">     *</a>
<span class="sourceLineNo">456</span><a id="line.456">     * is minimized. If the parameter method is set to the default value 0, the function uses all the point</a>
<span class="sourceLineNo">457</span><a id="line.457">     * pairs to compute an initial homography estimate with a simple least-squares scheme.</a>
<span class="sourceLineNo">458</span><a id="line.458">     *</a>
<span class="sourceLineNo">459</span><a id="line.459">     * However, if not all of the point pairs ( \(srcPoints_i\), \(dstPoints_i\) ) fit the rigid perspective</a>
<span class="sourceLineNo">460</span><a id="line.460">     * transformation (that is, there are some outliers), this initial estimate will be poor. In this case,</a>
<span class="sourceLineNo">461</span><a id="line.461">     * you can use one of the three robust methods. The methods RANSAC, LMeDS and RHO try many different</a>
<span class="sourceLineNo">462</span><a id="line.462">     * random subsets of the corresponding point pairs (of four pairs each, collinear pairs are discarded), estimate the homography matrix</a>
<span class="sourceLineNo">463</span><a id="line.463">     * using this subset and a simple least-squares algorithm, and then compute the quality/goodness of the</a>
<span class="sourceLineNo">464</span><a id="line.464">     * computed homography (which is the number of inliers for RANSAC or the least median re-projection error for</a>
<span class="sourceLineNo">465</span><a id="line.465">     * LMeDS). The best subset is then used to produce the initial estimate of the homography matrix and</a>
<span class="sourceLineNo">466</span><a id="line.466">     * the mask of inliers/outliers.</a>
<span class="sourceLineNo">467</span><a id="line.467">     *</a>
<span class="sourceLineNo">468</span><a id="line.468">     * Regardless of the method, robust or not, the computed homography matrix is refined further (using</a>
<span class="sourceLineNo">469</span><a id="line.469">     * inliers only in case of a robust method) with the Levenberg-Marquardt method to reduce the</a>
<span class="sourceLineNo">470</span><a id="line.470">     * re-projection error even more.</a>
<span class="sourceLineNo">471</span><a id="line.471">     *</a>
<span class="sourceLineNo">472</span><a id="line.472">     * The methods RANSAC and RHO can handle practically any ratio of outliers but need a threshold to</a>
<span class="sourceLineNo">473</span><a id="line.473">     * distinguish inliers from outliers. The method LMeDS does not need any threshold but it works</a>
<span class="sourceLineNo">474</span><a id="line.474">     * correctly only when there are more than 50% of inliers. Finally, if there are no outliers and the</a>
<span class="sourceLineNo">475</span><a id="line.475">     * noise is rather small, use the default method (method=0).</a>
<span class="sourceLineNo">476</span><a id="line.476">     *</a>
<span class="sourceLineNo">477</span><a id="line.477">     * The function is used to find initial intrinsic and extrinsic matrices. Homography matrix is</a>
<span class="sourceLineNo">478</span><a id="line.478">     * determined up to a scale. Thus, it is normalized so that \(h_{33}=1\). Note that whenever an \(H\) matrix</a>
<span class="sourceLineNo">479</span><a id="line.479">     * cannot be estimated, an empty one will be returned.</a>
<span class="sourceLineNo">480</span><a id="line.480">     *</a>
<span class="sourceLineNo">481</span><a id="line.481">     * SEE:</a>
<span class="sourceLineNo">482</span><a id="line.482">     * getAffineTransform, estimateAffine2D, estimateAffinePartial2D, getPerspectiveTransform, warpPerspective,</a>
<span class="sourceLineNo">483</span><a id="line.483">     * perspectiveTransform</a>
<span class="sourceLineNo">484</span><a id="line.484">     * @return automatically generated</a>
<span class="sourceLineNo">485</span><a id="line.485">     */</a>
<span class="sourceLineNo">486</span><a id="line.486">    public static Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints, int method, double ransacReprojThreshold, Mat mask) {</a>
<span class="sourceLineNo">487</span><a id="line.487">        Mat srcPoints_mat = srcPoints;</a>
<span class="sourceLineNo">488</span><a id="line.488">        Mat dstPoints_mat = dstPoints;</a>
<span class="sourceLineNo">489</span><a id="line.489">        return new Mat(findHomography_2(srcPoints_mat.nativeObj, dstPoints_mat.nativeObj, method, ransacReprojThreshold, mask.nativeObj));</a>
<span class="sourceLineNo">490</span><a id="line.490">    }</a>
<span class="sourceLineNo">491</span><a id="line.491"></a>
<span class="sourceLineNo">492</span><a id="line.492">    /**</a>
<span class="sourceLineNo">493</span><a id="line.493">     * Finds a perspective transformation between two planes.</a>
<span class="sourceLineNo">494</span><a id="line.494">     *</a>
<span class="sourceLineNo">495</span><a id="line.495">     * @param srcPoints Coordinates of the points in the original plane, a matrix of the type CV_32FC2</a>
<span class="sourceLineNo">496</span><a id="line.496">     * or vector&amp;lt;Point2f&amp;gt; .</a>
<span class="sourceLineNo">497</span><a id="line.497">     * @param dstPoints Coordinates of the points in the target plane, a matrix of the type CV_32FC2 or</a>
<span class="sourceLineNo">498</span><a id="line.498">     * a vector&amp;lt;Point2f&amp;gt; .</a>
<span class="sourceLineNo">499</span><a id="line.499">     * @param method Method used to compute a homography matrix. The following methods are possible:</a>
<span class="sourceLineNo">500</span><a id="line.500">     * &lt;ul&gt;</a>
<span class="sourceLineNo">501</span><a id="line.501">     *   &lt;li&gt;</a>
<span class="sourceLineNo">502</span><a id="line.502">     *    &lt;b&gt;0&lt;/b&gt; - a regular method using all the points, i.e., the least squares method</a>
<span class="sourceLineNo">503</span><a id="line.503">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">504</span><a id="line.504">     *   &lt;li&gt;</a>
<span class="sourceLineNo">505</span><a id="line.505">     *    REF: RANSAC - RANSAC-based robust method</a>
<span class="sourceLineNo">506</span><a id="line.506">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">507</span><a id="line.507">     *   &lt;li&gt;</a>
<span class="sourceLineNo">508</span><a id="line.508">     *    REF: LMEDS - Least-Median robust method</a>
<span class="sourceLineNo">509</span><a id="line.509">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">510</span><a id="line.510">     *   &lt;li&gt;</a>
<span class="sourceLineNo">511</span><a id="line.511">     *    REF: RHO - PROSAC-based robust method</a>
<span class="sourceLineNo">512</span><a id="line.512">     * @param ransacReprojThreshold Maximum allowed reprojection error to treat a point pair as an inlier</a>
<span class="sourceLineNo">513</span><a id="line.513">     * (used in the RANSAC and RHO methods only). That is, if</a>
<span class="sourceLineNo">514</span><a id="line.514">     * \(\| \texttt{dstPoints} _i -  \texttt{convertPointsHomogeneous} ( \texttt{H} * \texttt{srcPoints} _i) \|_2  &amp;gt;  \texttt{ransacReprojThreshold}\)</a>
<span class="sourceLineNo">515</span><a id="line.515">     * then the point \(i\) is considered as an outlier. If srcPoints and dstPoints are measured in pixels,</a>
<span class="sourceLineNo">516</span><a id="line.516">     * it usually makes sense to set this parameter somewhere in the range of 1 to 10.</a>
<span class="sourceLineNo">517</span><a id="line.517">     * mask values are ignored.</a>
<span class="sourceLineNo">518</span><a id="line.518">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">519</span><a id="line.519">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">520</span><a id="line.520">     *</a>
<span class="sourceLineNo">521</span><a id="line.521">     * The function finds and returns the perspective transformation \(H\) between the source and the</a>
<span class="sourceLineNo">522</span><a id="line.522">     * destination planes:</a>
<span class="sourceLineNo">523</span><a id="line.523">     *</a>
<span class="sourceLineNo">524</span><a id="line.524">     * \(s_i  \vecthree{x'_i}{y'_i}{1} \sim H  \vecthree{x_i}{y_i}{1}\)</a>
<span class="sourceLineNo">525</span><a id="line.525">     *</a>
<span class="sourceLineNo">526</span><a id="line.526">     * so that the back-projection error</a>
<span class="sourceLineNo">527</span><a id="line.527">     *</a>
<span class="sourceLineNo">528</span><a id="line.528">     * \(\sum _i \left ( x'_i- \frac{h_{11} x_i + h_{12} y_i + h_{13}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2+ \left ( y'_i- \frac{h_{21} x_i + h_{22} y_i + h_{23}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2\)</a>
<span class="sourceLineNo">529</span><a id="line.529">     *</a>
<span class="sourceLineNo">530</span><a id="line.530">     * is minimized. If the parameter method is set to the default value 0, the function uses all the point</a>
<span class="sourceLineNo">531</span><a id="line.531">     * pairs to compute an initial homography estimate with a simple least-squares scheme.</a>
<span class="sourceLineNo">532</span><a id="line.532">     *</a>
<span class="sourceLineNo">533</span><a id="line.533">     * However, if not all of the point pairs ( \(srcPoints_i\), \(dstPoints_i\) ) fit the rigid perspective</a>
<span class="sourceLineNo">534</span><a id="line.534">     * transformation (that is, there are some outliers), this initial estimate will be poor. In this case,</a>
<span class="sourceLineNo">535</span><a id="line.535">     * you can use one of the three robust methods. The methods RANSAC, LMeDS and RHO try many different</a>
<span class="sourceLineNo">536</span><a id="line.536">     * random subsets of the corresponding point pairs (of four pairs each, collinear pairs are discarded), estimate the homography matrix</a>
<span class="sourceLineNo">537</span><a id="line.537">     * using this subset and a simple least-squares algorithm, and then compute the quality/goodness of the</a>
<span class="sourceLineNo">538</span><a id="line.538">     * computed homography (which is the number of inliers for RANSAC or the least median re-projection error for</a>
<span class="sourceLineNo">539</span><a id="line.539">     * LMeDS). The best subset is then used to produce the initial estimate of the homography matrix and</a>
<span class="sourceLineNo">540</span><a id="line.540">     * the mask of inliers/outliers.</a>
<span class="sourceLineNo">541</span><a id="line.541">     *</a>
<span class="sourceLineNo">542</span><a id="line.542">     * Regardless of the method, robust or not, the computed homography matrix is refined further (using</a>
<span class="sourceLineNo">543</span><a id="line.543">     * inliers only in case of a robust method) with the Levenberg-Marquardt method to reduce the</a>
<span class="sourceLineNo">544</span><a id="line.544">     * re-projection error even more.</a>
<span class="sourceLineNo">545</span><a id="line.545">     *</a>
<span class="sourceLineNo">546</span><a id="line.546">     * The methods RANSAC and RHO can handle practically any ratio of outliers but need a threshold to</a>
<span class="sourceLineNo">547</span><a id="line.547">     * distinguish inliers from outliers. The method LMeDS does not need any threshold but it works</a>
<span class="sourceLineNo">548</span><a id="line.548">     * correctly only when there are more than 50% of inliers. Finally, if there are no outliers and the</a>
<span class="sourceLineNo">549</span><a id="line.549">     * noise is rather small, use the default method (method=0).</a>
<span class="sourceLineNo">550</span><a id="line.550">     *</a>
<span class="sourceLineNo">551</span><a id="line.551">     * The function is used to find initial intrinsic and extrinsic matrices. Homography matrix is</a>
<span class="sourceLineNo">552</span><a id="line.552">     * determined up to a scale. Thus, it is normalized so that \(h_{33}=1\). Note that whenever an \(H\) matrix</a>
<span class="sourceLineNo">553</span><a id="line.553">     * cannot be estimated, an empty one will be returned.</a>
<span class="sourceLineNo">554</span><a id="line.554">     *</a>
<span class="sourceLineNo">555</span><a id="line.555">     * SEE:</a>
<span class="sourceLineNo">556</span><a id="line.556">     * getAffineTransform, estimateAffine2D, estimateAffinePartial2D, getPerspectiveTransform, warpPerspective,</a>
<span class="sourceLineNo">557</span><a id="line.557">     * perspectiveTransform</a>
<span class="sourceLineNo">558</span><a id="line.558">     * @return automatically generated</a>
<span class="sourceLineNo">559</span><a id="line.559">     */</a>
<span class="sourceLineNo">560</span><a id="line.560">    public static Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints, int method, double ransacReprojThreshold) {</a>
<span class="sourceLineNo">561</span><a id="line.561">        Mat srcPoints_mat = srcPoints;</a>
<span class="sourceLineNo">562</span><a id="line.562">        Mat dstPoints_mat = dstPoints;</a>
<span class="sourceLineNo">563</span><a id="line.563">        return new Mat(findHomography_3(srcPoints_mat.nativeObj, dstPoints_mat.nativeObj, method, ransacReprojThreshold));</a>
<span class="sourceLineNo">564</span><a id="line.564">    }</a>
<span class="sourceLineNo">565</span><a id="line.565"></a>
<span class="sourceLineNo">566</span><a id="line.566">    /**</a>
<span class="sourceLineNo">567</span><a id="line.567">     * Finds a perspective transformation between two planes.</a>
<span class="sourceLineNo">568</span><a id="line.568">     *</a>
<span class="sourceLineNo">569</span><a id="line.569">     * @param srcPoints Coordinates of the points in the original plane, a matrix of the type CV_32FC2</a>
<span class="sourceLineNo">570</span><a id="line.570">     * or vector&amp;lt;Point2f&amp;gt; .</a>
<span class="sourceLineNo">571</span><a id="line.571">     * @param dstPoints Coordinates of the points in the target plane, a matrix of the type CV_32FC2 or</a>
<span class="sourceLineNo">572</span><a id="line.572">     * a vector&amp;lt;Point2f&amp;gt; .</a>
<span class="sourceLineNo">573</span><a id="line.573">     * @param method Method used to compute a homography matrix. The following methods are possible:</a>
<span class="sourceLineNo">574</span><a id="line.574">     * &lt;ul&gt;</a>
<span class="sourceLineNo">575</span><a id="line.575">     *   &lt;li&gt;</a>
<span class="sourceLineNo">576</span><a id="line.576">     *    &lt;b&gt;0&lt;/b&gt; - a regular method using all the points, i.e., the least squares method</a>
<span class="sourceLineNo">577</span><a id="line.577">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">578</span><a id="line.578">     *   &lt;li&gt;</a>
<span class="sourceLineNo">579</span><a id="line.579">     *    REF: RANSAC - RANSAC-based robust method</a>
<span class="sourceLineNo">580</span><a id="line.580">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">581</span><a id="line.581">     *   &lt;li&gt;</a>
<span class="sourceLineNo">582</span><a id="line.582">     *    REF: LMEDS - Least-Median robust method</a>
<span class="sourceLineNo">583</span><a id="line.583">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">584</span><a id="line.584">     *   &lt;li&gt;</a>
<span class="sourceLineNo">585</span><a id="line.585">     *    REF: RHO - PROSAC-based robust method</a>
<span class="sourceLineNo">586</span><a id="line.586">     * (used in the RANSAC and RHO methods only). That is, if</a>
<span class="sourceLineNo">587</span><a id="line.587">     * \(\| \texttt{dstPoints} _i -  \texttt{convertPointsHomogeneous} ( \texttt{H} * \texttt{srcPoints} _i) \|_2  &amp;gt;  \texttt{ransacReprojThreshold}\)</a>
<span class="sourceLineNo">588</span><a id="line.588">     * then the point \(i\) is considered as an outlier. If srcPoints and dstPoints are measured in pixels,</a>
<span class="sourceLineNo">589</span><a id="line.589">     * it usually makes sense to set this parameter somewhere in the range of 1 to 10.</a>
<span class="sourceLineNo">590</span><a id="line.590">     * mask values are ignored.</a>
<span class="sourceLineNo">591</span><a id="line.591">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">592</span><a id="line.592">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">593</span><a id="line.593">     *</a>
<span class="sourceLineNo">594</span><a id="line.594">     * The function finds and returns the perspective transformation \(H\) between the source and the</a>
<span class="sourceLineNo">595</span><a id="line.595">     * destination planes:</a>
<span class="sourceLineNo">596</span><a id="line.596">     *</a>
<span class="sourceLineNo">597</span><a id="line.597">     * \(s_i  \vecthree{x'_i}{y'_i}{1} \sim H  \vecthree{x_i}{y_i}{1}\)</a>
<span class="sourceLineNo">598</span><a id="line.598">     *</a>
<span class="sourceLineNo">599</span><a id="line.599">     * so that the back-projection error</a>
<span class="sourceLineNo">600</span><a id="line.600">     *</a>
<span class="sourceLineNo">601</span><a id="line.601">     * \(\sum _i \left ( x'_i- \frac{h_{11} x_i + h_{12} y_i + h_{13}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2+ \left ( y'_i- \frac{h_{21} x_i + h_{22} y_i + h_{23}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2\)</a>
<span class="sourceLineNo">602</span><a id="line.602">     *</a>
<span class="sourceLineNo">603</span><a id="line.603">     * is minimized. If the parameter method is set to the default value 0, the function uses all the point</a>
<span class="sourceLineNo">604</span><a id="line.604">     * pairs to compute an initial homography estimate with a simple least-squares scheme.</a>
<span class="sourceLineNo">605</span><a id="line.605">     *</a>
<span class="sourceLineNo">606</span><a id="line.606">     * However, if not all of the point pairs ( \(srcPoints_i\), \(dstPoints_i\) ) fit the rigid perspective</a>
<span class="sourceLineNo">607</span><a id="line.607">     * transformation (that is, there are some outliers), this initial estimate will be poor. In this case,</a>
<span class="sourceLineNo">608</span><a id="line.608">     * you can use one of the three robust methods. The methods RANSAC, LMeDS and RHO try many different</a>
<span class="sourceLineNo">609</span><a id="line.609">     * random subsets of the corresponding point pairs (of four pairs each, collinear pairs are discarded), estimate the homography matrix</a>
<span class="sourceLineNo">610</span><a id="line.610">     * using this subset and a simple least-squares algorithm, and then compute the quality/goodness of the</a>
<span class="sourceLineNo">611</span><a id="line.611">     * computed homography (which is the number of inliers for RANSAC or the least median re-projection error for</a>
<span class="sourceLineNo">612</span><a id="line.612">     * LMeDS). The best subset is then used to produce the initial estimate of the homography matrix and</a>
<span class="sourceLineNo">613</span><a id="line.613">     * the mask of inliers/outliers.</a>
<span class="sourceLineNo">614</span><a id="line.614">     *</a>
<span class="sourceLineNo">615</span><a id="line.615">     * Regardless of the method, robust or not, the computed homography matrix is refined further (using</a>
<span class="sourceLineNo">616</span><a id="line.616">     * inliers only in case of a robust method) with the Levenberg-Marquardt method to reduce the</a>
<span class="sourceLineNo">617</span><a id="line.617">     * re-projection error even more.</a>
<span class="sourceLineNo">618</span><a id="line.618">     *</a>
<span class="sourceLineNo">619</span><a id="line.619">     * The methods RANSAC and RHO can handle practically any ratio of outliers but need a threshold to</a>
<span class="sourceLineNo">620</span><a id="line.620">     * distinguish inliers from outliers. The method LMeDS does not need any threshold but it works</a>
<span class="sourceLineNo">621</span><a id="line.621">     * correctly only when there are more than 50% of inliers. Finally, if there are no outliers and the</a>
<span class="sourceLineNo">622</span><a id="line.622">     * noise is rather small, use the default method (method=0).</a>
<span class="sourceLineNo">623</span><a id="line.623">     *</a>
<span class="sourceLineNo">624</span><a id="line.624">     * The function is used to find initial intrinsic and extrinsic matrices. Homography matrix is</a>
<span class="sourceLineNo">625</span><a id="line.625">     * determined up to a scale. Thus, it is normalized so that \(h_{33}=1\). Note that whenever an \(H\) matrix</a>
<span class="sourceLineNo">626</span><a id="line.626">     * cannot be estimated, an empty one will be returned.</a>
<span class="sourceLineNo">627</span><a id="line.627">     *</a>
<span class="sourceLineNo">628</span><a id="line.628">     * SEE:</a>
<span class="sourceLineNo">629</span><a id="line.629">     * getAffineTransform, estimateAffine2D, estimateAffinePartial2D, getPerspectiveTransform, warpPerspective,</a>
<span class="sourceLineNo">630</span><a id="line.630">     * perspectiveTransform</a>
<span class="sourceLineNo">631</span><a id="line.631">     * @return automatically generated</a>
<span class="sourceLineNo">632</span><a id="line.632">     */</a>
<span class="sourceLineNo">633</span><a id="line.633">    public static Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints, int method) {</a>
<span class="sourceLineNo">634</span><a id="line.634">        Mat srcPoints_mat = srcPoints;</a>
<span class="sourceLineNo">635</span><a id="line.635">        Mat dstPoints_mat = dstPoints;</a>
<span class="sourceLineNo">636</span><a id="line.636">        return new Mat(findHomography_4(srcPoints_mat.nativeObj, dstPoints_mat.nativeObj, method));</a>
<span class="sourceLineNo">637</span><a id="line.637">    }</a>
<span class="sourceLineNo">638</span><a id="line.638"></a>
<span class="sourceLineNo">639</span><a id="line.639">    /**</a>
<span class="sourceLineNo">640</span><a id="line.640">     * Finds a perspective transformation between two planes.</a>
<span class="sourceLineNo">641</span><a id="line.641">     *</a>
<span class="sourceLineNo">642</span><a id="line.642">     * @param srcPoints Coordinates of the points in the original plane, a matrix of the type CV_32FC2</a>
<span class="sourceLineNo">643</span><a id="line.643">     * or vector&amp;lt;Point2f&amp;gt; .</a>
<span class="sourceLineNo">644</span><a id="line.644">     * @param dstPoints Coordinates of the points in the target plane, a matrix of the type CV_32FC2 or</a>
<span class="sourceLineNo">645</span><a id="line.645">     * a vector&amp;lt;Point2f&amp;gt; .</a>
<span class="sourceLineNo">646</span><a id="line.646">     * &lt;ul&gt;</a>
<span class="sourceLineNo">647</span><a id="line.647">     *   &lt;li&gt;</a>
<span class="sourceLineNo">648</span><a id="line.648">     *    &lt;b&gt;0&lt;/b&gt; - a regular method using all the points, i.e., the least squares method</a>
<span class="sourceLineNo">649</span><a id="line.649">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">650</span><a id="line.650">     *   &lt;li&gt;</a>
<span class="sourceLineNo">651</span><a id="line.651">     *    REF: RANSAC - RANSAC-based robust method</a>
<span class="sourceLineNo">652</span><a id="line.652">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">653</span><a id="line.653">     *   &lt;li&gt;</a>
<span class="sourceLineNo">654</span><a id="line.654">     *    REF: LMEDS - Least-Median robust method</a>
<span class="sourceLineNo">655</span><a id="line.655">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">656</span><a id="line.656">     *   &lt;li&gt;</a>
<span class="sourceLineNo">657</span><a id="line.657">     *    REF: RHO - PROSAC-based robust method</a>
<span class="sourceLineNo">658</span><a id="line.658">     * (used in the RANSAC and RHO methods only). That is, if</a>
<span class="sourceLineNo">659</span><a id="line.659">     * \(\| \texttt{dstPoints} _i -  \texttt{convertPointsHomogeneous} ( \texttt{H} * \texttt{srcPoints} _i) \|_2  &amp;gt;  \texttt{ransacReprojThreshold}\)</a>
<span class="sourceLineNo">660</span><a id="line.660">     * then the point \(i\) is considered as an outlier. If srcPoints and dstPoints are measured in pixels,</a>
<span class="sourceLineNo">661</span><a id="line.661">     * it usually makes sense to set this parameter somewhere in the range of 1 to 10.</a>
<span class="sourceLineNo">662</span><a id="line.662">     * mask values are ignored.</a>
<span class="sourceLineNo">663</span><a id="line.663">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">664</span><a id="line.664">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">665</span><a id="line.665">     *</a>
<span class="sourceLineNo">666</span><a id="line.666">     * The function finds and returns the perspective transformation \(H\) between the source and the</a>
<span class="sourceLineNo">667</span><a id="line.667">     * destination planes:</a>
<span class="sourceLineNo">668</span><a id="line.668">     *</a>
<span class="sourceLineNo">669</span><a id="line.669">     * \(s_i  \vecthree{x'_i}{y'_i}{1} \sim H  \vecthree{x_i}{y_i}{1}\)</a>
<span class="sourceLineNo">670</span><a id="line.670">     *</a>
<span class="sourceLineNo">671</span><a id="line.671">     * so that the back-projection error</a>
<span class="sourceLineNo">672</span><a id="line.672">     *</a>
<span class="sourceLineNo">673</span><a id="line.673">     * \(\sum _i \left ( x'_i- \frac{h_{11} x_i + h_{12} y_i + h_{13}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2+ \left ( y'_i- \frac{h_{21} x_i + h_{22} y_i + h_{23}}{h_{31} x_i + h_{32} y_i + h_{33}} \right )^2\)</a>
<span class="sourceLineNo">674</span><a id="line.674">     *</a>
<span class="sourceLineNo">675</span><a id="line.675">     * is minimized. If the parameter method is set to the default value 0, the function uses all the point</a>
<span class="sourceLineNo">676</span><a id="line.676">     * pairs to compute an initial homography estimate with a simple least-squares scheme.</a>
<span class="sourceLineNo">677</span><a id="line.677">     *</a>
<span class="sourceLineNo">678</span><a id="line.678">     * However, if not all of the point pairs ( \(srcPoints_i\), \(dstPoints_i\) ) fit the rigid perspective</a>
<span class="sourceLineNo">679</span><a id="line.679">     * transformation (that is, there are some outliers), this initial estimate will be poor. In this case,</a>
<span class="sourceLineNo">680</span><a id="line.680">     * you can use one of the three robust methods. The methods RANSAC, LMeDS and RHO try many different</a>
<span class="sourceLineNo">681</span><a id="line.681">     * random subsets of the corresponding point pairs (of four pairs each, collinear pairs are discarded), estimate the homography matrix</a>
<span class="sourceLineNo">682</span><a id="line.682">     * using this subset and a simple least-squares algorithm, and then compute the quality/goodness of the</a>
<span class="sourceLineNo">683</span><a id="line.683">     * computed homography (which is the number of inliers for RANSAC or the least median re-projection error for</a>
<span class="sourceLineNo">684</span><a id="line.684">     * LMeDS). The best subset is then used to produce the initial estimate of the homography matrix and</a>
<span class="sourceLineNo">685</span><a id="line.685">     * the mask of inliers/outliers.</a>
<span class="sourceLineNo">686</span><a id="line.686">     *</a>
<span class="sourceLineNo">687</span><a id="line.687">     * Regardless of the method, robust or not, the computed homography matrix is refined further (using</a>
<span class="sourceLineNo">688</span><a id="line.688">     * inliers only in case of a robust method) with the Levenberg-Marquardt method to reduce the</a>
<span class="sourceLineNo">689</span><a id="line.689">     * re-projection error even more.</a>
<span class="sourceLineNo">690</span><a id="line.690">     *</a>
<span class="sourceLineNo">691</span><a id="line.691">     * The methods RANSAC and RHO can handle practically any ratio of outliers but need a threshold to</a>
<span class="sourceLineNo">692</span><a id="line.692">     * distinguish inliers from outliers. The method LMeDS does not need any threshold but it works</a>
<span class="sourceLineNo">693</span><a id="line.693">     * correctly only when there are more than 50% of inliers. Finally, if there are no outliers and the</a>
<span class="sourceLineNo">694</span><a id="line.694">     * noise is rather small, use the default method (method=0).</a>
<span class="sourceLineNo">695</span><a id="line.695">     *</a>
<span class="sourceLineNo">696</span><a id="line.696">     * The function is used to find initial intrinsic and extrinsic matrices. Homography matrix is</a>
<span class="sourceLineNo">697</span><a id="line.697">     * determined up to a scale. Thus, it is normalized so that \(h_{33}=1\). Note that whenever an \(H\) matrix</a>
<span class="sourceLineNo">698</span><a id="line.698">     * cannot be estimated, an empty one will be returned.</a>
<span class="sourceLineNo">699</span><a id="line.699">     *</a>
<span class="sourceLineNo">700</span><a id="line.700">     * SEE:</a>
<span class="sourceLineNo">701</span><a id="line.701">     * getAffineTransform, estimateAffine2D, estimateAffinePartial2D, getPerspectiveTransform, warpPerspective,</a>
<span class="sourceLineNo">702</span><a id="line.702">     * perspectiveTransform</a>
<span class="sourceLineNo">703</span><a id="line.703">     * @return automatically generated</a>
<span class="sourceLineNo">704</span><a id="line.704">     */</a>
<span class="sourceLineNo">705</span><a id="line.705">    public static Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints) {</a>
<span class="sourceLineNo">706</span><a id="line.706">        Mat srcPoints_mat = srcPoints;</a>
<span class="sourceLineNo">707</span><a id="line.707">        Mat dstPoints_mat = dstPoints;</a>
<span class="sourceLineNo">708</span><a id="line.708">        return new Mat(findHomography_5(srcPoints_mat.nativeObj, dstPoints_mat.nativeObj));</a>
<span class="sourceLineNo">709</span><a id="line.709">    }</a>
<span class="sourceLineNo">710</span><a id="line.710"></a>
<span class="sourceLineNo">711</span><a id="line.711"></a>
<span class="sourceLineNo">712</span><a id="line.712">    //</a>
<span class="sourceLineNo">713</span><a id="line.713">    // C++:  Mat cv::findHomography(vector_Point2f srcPoints, vector_Point2f dstPoints, Mat&amp; mask, UsacParams params)</a>
<span class="sourceLineNo">714</span><a id="line.714">    //</a>
<span class="sourceLineNo">715</span><a id="line.715"></a>
<span class="sourceLineNo">716</span><a id="line.716">    public static Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints, Mat mask, UsacParams params) {</a>
<span class="sourceLineNo">717</span><a id="line.717">        Mat srcPoints_mat = srcPoints;</a>
<span class="sourceLineNo">718</span><a id="line.718">        Mat dstPoints_mat = dstPoints;</a>
<span class="sourceLineNo">719</span><a id="line.719">        return new Mat(findHomography_6(srcPoints_mat.nativeObj, dstPoints_mat.nativeObj, mask.nativeObj, params.nativeObj));</a>
<span class="sourceLineNo">720</span><a id="line.720">    }</a>
<span class="sourceLineNo">721</span><a id="line.721"></a>
<span class="sourceLineNo">722</span><a id="line.722"></a>
<span class="sourceLineNo">723</span><a id="line.723">    //</a>
<span class="sourceLineNo">724</span><a id="line.724">    // C++:  Vec3d cv::RQDecomp3x3(Mat src, Mat&amp; mtxR, Mat&amp; mtxQ, Mat&amp; Qx = Mat(), Mat&amp; Qy = Mat(), Mat&amp; Qz = Mat())</a>
<span class="sourceLineNo">725</span><a id="line.725">    //</a>
<span class="sourceLineNo">726</span><a id="line.726"></a>
<span class="sourceLineNo">727</span><a id="line.727">    /**</a>
<span class="sourceLineNo">728</span><a id="line.728">     * Computes an RQ decomposition of 3x3 matrices.</a>
<span class="sourceLineNo">729</span><a id="line.729">     *</a>
<span class="sourceLineNo">730</span><a id="line.730">     * @param src 3x3 input matrix.</a>
<span class="sourceLineNo">731</span><a id="line.731">     * @param mtxR Output 3x3 upper-triangular matrix.</a>
<span class="sourceLineNo">732</span><a id="line.732">     * @param mtxQ Output 3x3 orthogonal matrix.</a>
<span class="sourceLineNo">733</span><a id="line.733">     * @param Qx Optional output 3x3 rotation matrix around x-axis.</a>
<span class="sourceLineNo">734</span><a id="line.734">     * @param Qy Optional output 3x3 rotation matrix around y-axis.</a>
<span class="sourceLineNo">735</span><a id="line.735">     * @param Qz Optional output 3x3 rotation matrix around z-axis.</a>
<span class="sourceLineNo">736</span><a id="line.736">     *</a>
<span class="sourceLineNo">737</span><a id="line.737">     * The function computes a RQ decomposition using the given rotations. This function is used in</a>
<span class="sourceLineNo">738</span><a id="line.738">     * decomposeProjectionMatrix to decompose the left 3x3 submatrix of a projection matrix into a camera</a>
<span class="sourceLineNo">739</span><a id="line.739">     * and a rotation matrix.</a>
<span class="sourceLineNo">740</span><a id="line.740">     *</a>
<span class="sourceLineNo">741</span><a id="line.741">     * It optionally returns three rotation matrices, one for each axis, and the three Euler angles in</a>
<span class="sourceLineNo">742</span><a id="line.742">     * degrees (as the return value) that could be used in OpenGL. Note, there is always more than one</a>
<span class="sourceLineNo">743</span><a id="line.743">     * sequence of rotations about the three principal axes that results in the same orientation of an</a>
<span class="sourceLineNo">744</span><a id="line.744">     * object, e.g. see CITE: Slabaugh . Returned tree rotation matrices and corresponding three Euler angles</a>
<span class="sourceLineNo">745</span><a id="line.745">     * are only one of the possible solutions.</a>
<span class="sourceLineNo">746</span><a id="line.746">     * @return automatically generated</a>
<span class="sourceLineNo">747</span><a id="line.747">     */</a>
<span class="sourceLineNo">748</span><a id="line.748">    public static double[] RQDecomp3x3(Mat src, Mat mtxR, Mat mtxQ, Mat Qx, Mat Qy, Mat Qz) {</a>
<span class="sourceLineNo">749</span><a id="line.749">        return RQDecomp3x3_0(src.nativeObj, mtxR.nativeObj, mtxQ.nativeObj, Qx.nativeObj, Qy.nativeObj, Qz.nativeObj);</a>
<span class="sourceLineNo">750</span><a id="line.750">    }</a>
<span class="sourceLineNo">751</span><a id="line.751"></a>
<span class="sourceLineNo">752</span><a id="line.752">    /**</a>
<span class="sourceLineNo">753</span><a id="line.753">     * Computes an RQ decomposition of 3x3 matrices.</a>
<span class="sourceLineNo">754</span><a id="line.754">     *</a>
<span class="sourceLineNo">755</span><a id="line.755">     * @param src 3x3 input matrix.</a>
<span class="sourceLineNo">756</span><a id="line.756">     * @param mtxR Output 3x3 upper-triangular matrix.</a>
<span class="sourceLineNo">757</span><a id="line.757">     * @param mtxQ Output 3x3 orthogonal matrix.</a>
<span class="sourceLineNo">758</span><a id="line.758">     * @param Qx Optional output 3x3 rotation matrix around x-axis.</a>
<span class="sourceLineNo">759</span><a id="line.759">     * @param Qy Optional output 3x3 rotation matrix around y-axis.</a>
<span class="sourceLineNo">760</span><a id="line.760">     *</a>
<span class="sourceLineNo">761</span><a id="line.761">     * The function computes a RQ decomposition using the given rotations. This function is used in</a>
<span class="sourceLineNo">762</span><a id="line.762">     * decomposeProjectionMatrix to decompose the left 3x3 submatrix of a projection matrix into a camera</a>
<span class="sourceLineNo">763</span><a id="line.763">     * and a rotation matrix.</a>
<span class="sourceLineNo">764</span><a id="line.764">     *</a>
<span class="sourceLineNo">765</span><a id="line.765">     * It optionally returns three rotation matrices, one for each axis, and the three Euler angles in</a>
<span class="sourceLineNo">766</span><a id="line.766">     * degrees (as the return value) that could be used in OpenGL. Note, there is always more than one</a>
<span class="sourceLineNo">767</span><a id="line.767">     * sequence of rotations about the three principal axes that results in the same orientation of an</a>
<span class="sourceLineNo">768</span><a id="line.768">     * object, e.g. see CITE: Slabaugh . Returned tree rotation matrices and corresponding three Euler angles</a>
<span class="sourceLineNo">769</span><a id="line.769">     * are only one of the possible solutions.</a>
<span class="sourceLineNo">770</span><a id="line.770">     * @return automatically generated</a>
<span class="sourceLineNo">771</span><a id="line.771">     */</a>
<span class="sourceLineNo">772</span><a id="line.772">    public static double[] RQDecomp3x3(Mat src, Mat mtxR, Mat mtxQ, Mat Qx, Mat Qy) {</a>
<span class="sourceLineNo">773</span><a id="line.773">        return RQDecomp3x3_1(src.nativeObj, mtxR.nativeObj, mtxQ.nativeObj, Qx.nativeObj, Qy.nativeObj);</a>
<span class="sourceLineNo">774</span><a id="line.774">    }</a>
<span class="sourceLineNo">775</span><a id="line.775"></a>
<span class="sourceLineNo">776</span><a id="line.776">    /**</a>
<span class="sourceLineNo">777</span><a id="line.777">     * Computes an RQ decomposition of 3x3 matrices.</a>
<span class="sourceLineNo">778</span><a id="line.778">     *</a>
<span class="sourceLineNo">779</span><a id="line.779">     * @param src 3x3 input matrix.</a>
<span class="sourceLineNo">780</span><a id="line.780">     * @param mtxR Output 3x3 upper-triangular matrix.</a>
<span class="sourceLineNo">781</span><a id="line.781">     * @param mtxQ Output 3x3 orthogonal matrix.</a>
<span class="sourceLineNo">782</span><a id="line.782">     * @param Qx Optional output 3x3 rotation matrix around x-axis.</a>
<span class="sourceLineNo">783</span><a id="line.783">     *</a>
<span class="sourceLineNo">784</span><a id="line.784">     * The function computes a RQ decomposition using the given rotations. This function is used in</a>
<span class="sourceLineNo">785</span><a id="line.785">     * decomposeProjectionMatrix to decompose the left 3x3 submatrix of a projection matrix into a camera</a>
<span class="sourceLineNo">786</span><a id="line.786">     * and a rotation matrix.</a>
<span class="sourceLineNo">787</span><a id="line.787">     *</a>
<span class="sourceLineNo">788</span><a id="line.788">     * It optionally returns three rotation matrices, one for each axis, and the three Euler angles in</a>
<span class="sourceLineNo">789</span><a id="line.789">     * degrees (as the return value) that could be used in OpenGL. Note, there is always more than one</a>
<span class="sourceLineNo">790</span><a id="line.790">     * sequence of rotations about the three principal axes that results in the same orientation of an</a>
<span class="sourceLineNo">791</span><a id="line.791">     * object, e.g. see CITE: Slabaugh . Returned tree rotation matrices and corresponding three Euler angles</a>
<span class="sourceLineNo">792</span><a id="line.792">     * are only one of the possible solutions.</a>
<span class="sourceLineNo">793</span><a id="line.793">     * @return automatically generated</a>
<span class="sourceLineNo">794</span><a id="line.794">     */</a>
<span class="sourceLineNo">795</span><a id="line.795">    public static double[] RQDecomp3x3(Mat src, Mat mtxR, Mat mtxQ, Mat Qx) {</a>
<span class="sourceLineNo">796</span><a id="line.796">        return RQDecomp3x3_2(src.nativeObj, mtxR.nativeObj, mtxQ.nativeObj, Qx.nativeObj);</a>
<span class="sourceLineNo">797</span><a id="line.797">    }</a>
<span class="sourceLineNo">798</span><a id="line.798"></a>
<span class="sourceLineNo">799</span><a id="line.799">    /**</a>
<span class="sourceLineNo">800</span><a id="line.800">     * Computes an RQ decomposition of 3x3 matrices.</a>
<span class="sourceLineNo">801</span><a id="line.801">     *</a>
<span class="sourceLineNo">802</span><a id="line.802">     * @param src 3x3 input matrix.</a>
<span class="sourceLineNo">803</span><a id="line.803">     * @param mtxR Output 3x3 upper-triangular matrix.</a>
<span class="sourceLineNo">804</span><a id="line.804">     * @param mtxQ Output 3x3 orthogonal matrix.</a>
<span class="sourceLineNo">805</span><a id="line.805">     *</a>
<span class="sourceLineNo">806</span><a id="line.806">     * The function computes a RQ decomposition using the given rotations. This function is used in</a>
<span class="sourceLineNo">807</span><a id="line.807">     * decomposeProjectionMatrix to decompose the left 3x3 submatrix of a projection matrix into a camera</a>
<span class="sourceLineNo">808</span><a id="line.808">     * and a rotation matrix.</a>
<span class="sourceLineNo">809</span><a id="line.809">     *</a>
<span class="sourceLineNo">810</span><a id="line.810">     * It optionally returns three rotation matrices, one for each axis, and the three Euler angles in</a>
<span class="sourceLineNo">811</span><a id="line.811">     * degrees (as the return value) that could be used in OpenGL. Note, there is always more than one</a>
<span class="sourceLineNo">812</span><a id="line.812">     * sequence of rotations about the three principal axes that results in the same orientation of an</a>
<span class="sourceLineNo">813</span><a id="line.813">     * object, e.g. see CITE: Slabaugh . Returned tree rotation matrices and corresponding three Euler angles</a>
<span class="sourceLineNo">814</span><a id="line.814">     * are only one of the possible solutions.</a>
<span class="sourceLineNo">815</span><a id="line.815">     * @return automatically generated</a>
<span class="sourceLineNo">816</span><a id="line.816">     */</a>
<span class="sourceLineNo">817</span><a id="line.817">    public static double[] RQDecomp3x3(Mat src, Mat mtxR, Mat mtxQ) {</a>
<span class="sourceLineNo">818</span><a id="line.818">        return RQDecomp3x3_3(src.nativeObj, mtxR.nativeObj, mtxQ.nativeObj);</a>
<span class="sourceLineNo">819</span><a id="line.819">    }</a>
<span class="sourceLineNo">820</span><a id="line.820"></a>
<span class="sourceLineNo">821</span><a id="line.821"></a>
<span class="sourceLineNo">822</span><a id="line.822">    //</a>
<span class="sourceLineNo">823</span><a id="line.823">    // C++:  void cv::decomposeProjectionMatrix(Mat projMatrix, Mat&amp; cameraMatrix, Mat&amp; rotMatrix, Mat&amp; transVect, Mat&amp; rotMatrixX = Mat(), Mat&amp; rotMatrixY = Mat(), Mat&amp; rotMatrixZ = Mat(), Mat&amp; eulerAngles = Mat())</a>
<span class="sourceLineNo">824</span><a id="line.824">    //</a>
<span class="sourceLineNo">825</span><a id="line.825"></a>
<span class="sourceLineNo">826</span><a id="line.826">    /**</a>
<span class="sourceLineNo">827</span><a id="line.827">     * Decomposes a projection matrix into a rotation matrix and a camera intrinsic matrix.</a>
<span class="sourceLineNo">828</span><a id="line.828">     *</a>
<span class="sourceLineNo">829</span><a id="line.829">     * @param projMatrix 3x4 input projection matrix P.</a>
<span class="sourceLineNo">830</span><a id="line.830">     * @param cameraMatrix Output 3x3 camera intrinsic matrix \(\cameramatrix{A}\).</a>
<span class="sourceLineNo">831</span><a id="line.831">     * @param rotMatrix Output 3x3 external rotation matrix R.</a>
<span class="sourceLineNo">832</span><a id="line.832">     * @param transVect Output 4x1 translation vector T.</a>
<span class="sourceLineNo">833</span><a id="line.833">     * @param rotMatrixX Optional 3x3 rotation matrix around x-axis.</a>
<span class="sourceLineNo">834</span><a id="line.834">     * @param rotMatrixY Optional 3x3 rotation matrix around y-axis.</a>
<span class="sourceLineNo">835</span><a id="line.835">     * @param rotMatrixZ Optional 3x3 rotation matrix around z-axis.</a>
<span class="sourceLineNo">836</span><a id="line.836">     * @param eulerAngles Optional three-element vector containing three Euler angles of rotation in</a>
<span class="sourceLineNo">837</span><a id="line.837">     * degrees.</a>
<span class="sourceLineNo">838</span><a id="line.838">     *</a>
<span class="sourceLineNo">839</span><a id="line.839">     * The function computes a decomposition of a projection matrix into a calibration and a rotation</a>
<span class="sourceLineNo">840</span><a id="line.840">     * matrix and the position of a camera.</a>
<span class="sourceLineNo">841</span><a id="line.841">     *</a>
<span class="sourceLineNo">842</span><a id="line.842">     * It optionally returns three rotation matrices, one for each axis, and three Euler angles that could</a>
<span class="sourceLineNo">843</span><a id="line.843">     * be used in OpenGL. Note, there is always more than one sequence of rotations about the three</a>
<span class="sourceLineNo">844</span><a id="line.844">     * principal axes that results in the same orientation of an object, e.g. see CITE: Slabaugh . Returned</a>
<span class="sourceLineNo">845</span><a id="line.845">     * tree rotation matrices and corresponding three Euler angles are only one of the possible solutions.</a>
<span class="sourceLineNo">846</span><a id="line.846">     *</a>
<span class="sourceLineNo">847</span><a id="line.847">     * The function is based on RQDecomp3x3 .</a>
<span class="sourceLineNo">848</span><a id="line.848">     */</a>
<span class="sourceLineNo">849</span><a id="line.849">    public static void decomposeProjectionMatrix(Mat projMatrix, Mat cameraMatrix, Mat rotMatrix, Mat transVect, Mat rotMatrixX, Mat rotMatrixY, Mat rotMatrixZ, Mat eulerAngles) {</a>
<span class="sourceLineNo">850</span><a id="line.850">        decomposeProjectionMatrix_0(projMatrix.nativeObj, cameraMatrix.nativeObj, rotMatrix.nativeObj, transVect.nativeObj, rotMatrixX.nativeObj, rotMatrixY.nativeObj, rotMatrixZ.nativeObj, eulerAngles.nativeObj);</a>
<span class="sourceLineNo">851</span><a id="line.851">    }</a>
<span class="sourceLineNo">852</span><a id="line.852"></a>
<span class="sourceLineNo">853</span><a id="line.853">    /**</a>
<span class="sourceLineNo">854</span><a id="line.854">     * Decomposes a projection matrix into a rotation matrix and a camera intrinsic matrix.</a>
<span class="sourceLineNo">855</span><a id="line.855">     *</a>
<span class="sourceLineNo">856</span><a id="line.856">     * @param projMatrix 3x4 input projection matrix P.</a>
<span class="sourceLineNo">857</span><a id="line.857">     * @param cameraMatrix Output 3x3 camera intrinsic matrix \(\cameramatrix{A}\).</a>
<span class="sourceLineNo">858</span><a id="line.858">     * @param rotMatrix Output 3x3 external rotation matrix R.</a>
<span class="sourceLineNo">859</span><a id="line.859">     * @param transVect Output 4x1 translation vector T.</a>
<span class="sourceLineNo">860</span><a id="line.860">     * @param rotMatrixX Optional 3x3 rotation matrix around x-axis.</a>
<span class="sourceLineNo">861</span><a id="line.861">     * @param rotMatrixY Optional 3x3 rotation matrix around y-axis.</a>
<span class="sourceLineNo">862</span><a id="line.862">     * @param rotMatrixZ Optional 3x3 rotation matrix around z-axis.</a>
<span class="sourceLineNo">863</span><a id="line.863">     * degrees.</a>
<span class="sourceLineNo">864</span><a id="line.864">     *</a>
<span class="sourceLineNo">865</span><a id="line.865">     * The function computes a decomposition of a projection matrix into a calibration and a rotation</a>
<span class="sourceLineNo">866</span><a id="line.866">     * matrix and the position of a camera.</a>
<span class="sourceLineNo">867</span><a id="line.867">     *</a>
<span class="sourceLineNo">868</span><a id="line.868">     * It optionally returns three rotation matrices, one for each axis, and three Euler angles that could</a>
<span class="sourceLineNo">869</span><a id="line.869">     * be used in OpenGL. Note, there is always more than one sequence of rotations about the three</a>
<span class="sourceLineNo">870</span><a id="line.870">     * principal axes that results in the same orientation of an object, e.g. see CITE: Slabaugh . Returned</a>
<span class="sourceLineNo">871</span><a id="line.871">     * tree rotation matrices and corresponding three Euler angles are only one of the possible solutions.</a>
<span class="sourceLineNo">872</span><a id="line.872">     *</a>
<span class="sourceLineNo">873</span><a id="line.873">     * The function is based on RQDecomp3x3 .</a>
<span class="sourceLineNo">874</span><a id="line.874">     */</a>
<span class="sourceLineNo">875</span><a id="line.875">    public static void decomposeProjectionMatrix(Mat projMatrix, Mat cameraMatrix, Mat rotMatrix, Mat transVect, Mat rotMatrixX, Mat rotMatrixY, Mat rotMatrixZ) {</a>
<span class="sourceLineNo">876</span><a id="line.876">        decomposeProjectionMatrix_1(projMatrix.nativeObj, cameraMatrix.nativeObj, rotMatrix.nativeObj, transVect.nativeObj, rotMatrixX.nativeObj, rotMatrixY.nativeObj, rotMatrixZ.nativeObj);</a>
<span class="sourceLineNo">877</span><a id="line.877">    }</a>
<span class="sourceLineNo">878</span><a id="line.878"></a>
<span class="sourceLineNo">879</span><a id="line.879">    /**</a>
<span class="sourceLineNo">880</span><a id="line.880">     * Decomposes a projection matrix into a rotation matrix and a camera intrinsic matrix.</a>
<span class="sourceLineNo">881</span><a id="line.881">     *</a>
<span class="sourceLineNo">882</span><a id="line.882">     * @param projMatrix 3x4 input projection matrix P.</a>
<span class="sourceLineNo">883</span><a id="line.883">     * @param cameraMatrix Output 3x3 camera intrinsic matrix \(\cameramatrix{A}\).</a>
<span class="sourceLineNo">884</span><a id="line.884">     * @param rotMatrix Output 3x3 external rotation matrix R.</a>
<span class="sourceLineNo">885</span><a id="line.885">     * @param transVect Output 4x1 translation vector T.</a>
<span class="sourceLineNo">886</span><a id="line.886">     * @param rotMatrixX Optional 3x3 rotation matrix around x-axis.</a>
<span class="sourceLineNo">887</span><a id="line.887">     * @param rotMatrixY Optional 3x3 rotation matrix around y-axis.</a>
<span class="sourceLineNo">888</span><a id="line.888">     * degrees.</a>
<span class="sourceLineNo">889</span><a id="line.889">     *</a>
<span class="sourceLineNo">890</span><a id="line.890">     * The function computes a decomposition of a projection matrix into a calibration and a rotation</a>
<span class="sourceLineNo">891</span><a id="line.891">     * matrix and the position of a camera.</a>
<span class="sourceLineNo">892</span><a id="line.892">     *</a>
<span class="sourceLineNo">893</span><a id="line.893">     * It optionally returns three rotation matrices, one for each axis, and three Euler angles that could</a>
<span class="sourceLineNo">894</span><a id="line.894">     * be used in OpenGL. Note, there is always more than one sequence of rotations about the three</a>
<span class="sourceLineNo">895</span><a id="line.895">     * principal axes that results in the same orientation of an object, e.g. see CITE: Slabaugh . Returned</a>
<span class="sourceLineNo">896</span><a id="line.896">     * tree rotation matrices and corresponding three Euler angles are only one of the possible solutions.</a>
<span class="sourceLineNo">897</span><a id="line.897">     *</a>
<span class="sourceLineNo">898</span><a id="line.898">     * The function is based on RQDecomp3x3 .</a>
<span class="sourceLineNo">899</span><a id="line.899">     */</a>
<span class="sourceLineNo">900</span><a id="line.900">    public static void decomposeProjectionMatrix(Mat projMatrix, Mat cameraMatrix, Mat rotMatrix, Mat transVect, Mat rotMatrixX, Mat rotMatrixY) {</a>
<span class="sourceLineNo">901</span><a id="line.901">        decomposeProjectionMatrix_2(projMatrix.nativeObj, cameraMatrix.nativeObj, rotMatrix.nativeObj, transVect.nativeObj, rotMatrixX.nativeObj, rotMatrixY.nativeObj);</a>
<span class="sourceLineNo">902</span><a id="line.902">    }</a>
<span class="sourceLineNo">903</span><a id="line.903"></a>
<span class="sourceLineNo">904</span><a id="line.904">    /**</a>
<span class="sourceLineNo">905</span><a id="line.905">     * Decomposes a projection matrix into a rotation matrix and a camera intrinsic matrix.</a>
<span class="sourceLineNo">906</span><a id="line.906">     *</a>
<span class="sourceLineNo">907</span><a id="line.907">     * @param projMatrix 3x4 input projection matrix P.</a>
<span class="sourceLineNo">908</span><a id="line.908">     * @param cameraMatrix Output 3x3 camera intrinsic matrix \(\cameramatrix{A}\).</a>
<span class="sourceLineNo">909</span><a id="line.909">     * @param rotMatrix Output 3x3 external rotation matrix R.</a>
<span class="sourceLineNo">910</span><a id="line.910">     * @param transVect Output 4x1 translation vector T.</a>
<span class="sourceLineNo">911</span><a id="line.911">     * @param rotMatrixX Optional 3x3 rotation matrix around x-axis.</a>
<span class="sourceLineNo">912</span><a id="line.912">     * degrees.</a>
<span class="sourceLineNo">913</span><a id="line.913">     *</a>
<span class="sourceLineNo">914</span><a id="line.914">     * The function computes a decomposition of a projection matrix into a calibration and a rotation</a>
<span class="sourceLineNo">915</span><a id="line.915">     * matrix and the position of a camera.</a>
<span class="sourceLineNo">916</span><a id="line.916">     *</a>
<span class="sourceLineNo">917</span><a id="line.917">     * It optionally returns three rotation matrices, one for each axis, and three Euler angles that could</a>
<span class="sourceLineNo">918</span><a id="line.918">     * be used in OpenGL. Note, there is always more than one sequence of rotations about the three</a>
<span class="sourceLineNo">919</span><a id="line.919">     * principal axes that results in the same orientation of an object, e.g. see CITE: Slabaugh . Returned</a>
<span class="sourceLineNo">920</span><a id="line.920">     * tree rotation matrices and corresponding three Euler angles are only one of the possible solutions.</a>
<span class="sourceLineNo">921</span><a id="line.921">     *</a>
<span class="sourceLineNo">922</span><a id="line.922">     * The function is based on RQDecomp3x3 .</a>
<span class="sourceLineNo">923</span><a id="line.923">     */</a>
<span class="sourceLineNo">924</span><a id="line.924">    public static void decomposeProjectionMatrix(Mat projMatrix, Mat cameraMatrix, Mat rotMatrix, Mat transVect, Mat rotMatrixX) {</a>
<span class="sourceLineNo">925</span><a id="line.925">        decomposeProjectionMatrix_3(projMatrix.nativeObj, cameraMatrix.nativeObj, rotMatrix.nativeObj, transVect.nativeObj, rotMatrixX.nativeObj);</a>
<span class="sourceLineNo">926</span><a id="line.926">    }</a>
<span class="sourceLineNo">927</span><a id="line.927"></a>
<span class="sourceLineNo">928</span><a id="line.928">    /**</a>
<span class="sourceLineNo">929</span><a id="line.929">     * Decomposes a projection matrix into a rotation matrix and a camera intrinsic matrix.</a>
<span class="sourceLineNo">930</span><a id="line.930">     *</a>
<span class="sourceLineNo">931</span><a id="line.931">     * @param projMatrix 3x4 input projection matrix P.</a>
<span class="sourceLineNo">932</span><a id="line.932">     * @param cameraMatrix Output 3x3 camera intrinsic matrix \(\cameramatrix{A}\).</a>
<span class="sourceLineNo">933</span><a id="line.933">     * @param rotMatrix Output 3x3 external rotation matrix R.</a>
<span class="sourceLineNo">934</span><a id="line.934">     * @param transVect Output 4x1 translation vector T.</a>
<span class="sourceLineNo">935</span><a id="line.935">     * degrees.</a>
<span class="sourceLineNo">936</span><a id="line.936">     *</a>
<span class="sourceLineNo">937</span><a id="line.937">     * The function computes a decomposition of a projection matrix into a calibration and a rotation</a>
<span class="sourceLineNo">938</span><a id="line.938">     * matrix and the position of a camera.</a>
<span class="sourceLineNo">939</span><a id="line.939">     *</a>
<span class="sourceLineNo">940</span><a id="line.940">     * It optionally returns three rotation matrices, one for each axis, and three Euler angles that could</a>
<span class="sourceLineNo">941</span><a id="line.941">     * be used in OpenGL. Note, there is always more than one sequence of rotations about the three</a>
<span class="sourceLineNo">942</span><a id="line.942">     * principal axes that results in the same orientation of an object, e.g. see CITE: Slabaugh . Returned</a>
<span class="sourceLineNo">943</span><a id="line.943">     * tree rotation matrices and corresponding three Euler angles are only one of the possible solutions.</a>
<span class="sourceLineNo">944</span><a id="line.944">     *</a>
<span class="sourceLineNo">945</span><a id="line.945">     * The function is based on RQDecomp3x3 .</a>
<span class="sourceLineNo">946</span><a id="line.946">     */</a>
<span class="sourceLineNo">947</span><a id="line.947">    public static void decomposeProjectionMatrix(Mat projMatrix, Mat cameraMatrix, Mat rotMatrix, Mat transVect) {</a>
<span class="sourceLineNo">948</span><a id="line.948">        decomposeProjectionMatrix_4(projMatrix.nativeObj, cameraMatrix.nativeObj, rotMatrix.nativeObj, transVect.nativeObj);</a>
<span class="sourceLineNo">949</span><a id="line.949">    }</a>
<span class="sourceLineNo">950</span><a id="line.950"></a>
<span class="sourceLineNo">951</span><a id="line.951"></a>
<span class="sourceLineNo">952</span><a id="line.952">    //</a>
<span class="sourceLineNo">953</span><a id="line.953">    // C++:  void cv::matMulDeriv(Mat A, Mat B, Mat&amp; dABdA, Mat&amp; dABdB)</a>
<span class="sourceLineNo">954</span><a id="line.954">    //</a>
<span class="sourceLineNo">955</span><a id="line.955"></a>
<span class="sourceLineNo">956</span><a id="line.956">    /**</a>
<span class="sourceLineNo">957</span><a id="line.957">     * Computes partial derivatives of the matrix product for each multiplied matrix.</a>
<span class="sourceLineNo">958</span><a id="line.958">     *</a>
<span class="sourceLineNo">959</span><a id="line.959">     * @param A First multiplied matrix.</a>
<span class="sourceLineNo">960</span><a id="line.960">     * @param B Second multiplied matrix.</a>
<span class="sourceLineNo">961</span><a id="line.961">     * @param dABdA First output derivative matrix d(A\*B)/dA of size</a>
<span class="sourceLineNo">962</span><a id="line.962">     * \(\texttt{A.rows*B.cols} \times {A.rows*A.cols}\) .</a>
<span class="sourceLineNo">963</span><a id="line.963">     * @param dABdB Second output derivative matrix d(A\*B)/dB of size</a>
<span class="sourceLineNo">964</span><a id="line.964">     * \(\texttt{A.rows*B.cols} \times {B.rows*B.cols}\) .</a>
<span class="sourceLineNo">965</span><a id="line.965">     *</a>
<span class="sourceLineNo">966</span><a id="line.966">     * The function computes partial derivatives of the elements of the matrix product \(A*B\) with regard to</a>
<span class="sourceLineNo">967</span><a id="line.967">     * the elements of each of the two input matrices. The function is used to compute the Jacobian</a>
<span class="sourceLineNo">968</span><a id="line.968">     * matrices in stereoCalibrate but can also be used in any other similar optimization function.</a>
<span class="sourceLineNo">969</span><a id="line.969">     */</a>
<span class="sourceLineNo">970</span><a id="line.970">    public static void matMulDeriv(Mat A, Mat B, Mat dABdA, Mat dABdB) {</a>
<span class="sourceLineNo">971</span><a id="line.971">        matMulDeriv_0(A.nativeObj, B.nativeObj, dABdA.nativeObj, dABdB.nativeObj);</a>
<span class="sourceLineNo">972</span><a id="line.972">    }</a>
<span class="sourceLineNo">973</span><a id="line.973"></a>
<span class="sourceLineNo">974</span><a id="line.974"></a>
<span class="sourceLineNo">975</span><a id="line.975">    //</a>
<span class="sourceLineNo">976</span><a id="line.976">    // C++:  void cv::composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat&amp; rvec3, Mat&amp; tvec3, Mat&amp; dr3dr1 = Mat(), Mat&amp; dr3dt1 = Mat(), Mat&amp; dr3dr2 = Mat(), Mat&amp; dr3dt2 = Mat(), Mat&amp; dt3dr1 = Mat(), Mat&amp; dt3dt1 = Mat(), Mat&amp; dt3dr2 = Mat(), Mat&amp; dt3dt2 = Mat())</a>
<span class="sourceLineNo">977</span><a id="line.977">    //</a>
<span class="sourceLineNo">978</span><a id="line.978"></a>
<span class="sourceLineNo">979</span><a id="line.979">    /**</a>
<span class="sourceLineNo">980</span><a id="line.980">     * Combines two rotation-and-shift transformations.</a>
<span class="sourceLineNo">981</span><a id="line.981">     *</a>
<span class="sourceLineNo">982</span><a id="line.982">     * @param rvec1 First rotation vector.</a>
<span class="sourceLineNo">983</span><a id="line.983">     * @param tvec1 First translation vector.</a>
<span class="sourceLineNo">984</span><a id="line.984">     * @param rvec2 Second rotation vector.</a>
<span class="sourceLineNo">985</span><a id="line.985">     * @param tvec2 Second translation vector.</a>
<span class="sourceLineNo">986</span><a id="line.986">     * @param rvec3 Output rotation vector of the superposition.</a>
<span class="sourceLineNo">987</span><a id="line.987">     * @param tvec3 Output translation vector of the superposition.</a>
<span class="sourceLineNo">988</span><a id="line.988">     * @param dr3dr1 Optional output derivative of rvec3 with regard to rvec1</a>
<span class="sourceLineNo">989</span><a id="line.989">     * @param dr3dt1 Optional output derivative of rvec3 with regard to tvec1</a>
<span class="sourceLineNo">990</span><a id="line.990">     * @param dr3dr2 Optional output derivative of rvec3 with regard to rvec2</a>
<span class="sourceLineNo">991</span><a id="line.991">     * @param dr3dt2 Optional output derivative of rvec3 with regard to tvec2</a>
<span class="sourceLineNo">992</span><a id="line.992">     * @param dt3dr1 Optional output derivative of tvec3 with regard to rvec1</a>
<span class="sourceLineNo">993</span><a id="line.993">     * @param dt3dt1 Optional output derivative of tvec3 with regard to tvec1</a>
<span class="sourceLineNo">994</span><a id="line.994">     * @param dt3dr2 Optional output derivative of tvec3 with regard to rvec2</a>
<span class="sourceLineNo">995</span><a id="line.995">     * @param dt3dt2 Optional output derivative of tvec3 with regard to tvec2</a>
<span class="sourceLineNo">996</span><a id="line.996">     *</a>
<span class="sourceLineNo">997</span><a id="line.997">     * The functions compute:</a>
<span class="sourceLineNo">998</span><a id="line.998">     *</a>
<span class="sourceLineNo">999</span><a id="line.999">     * \(\begin{array}{l} \texttt{rvec3} =  \mathrm{rodrigues} ^{-1} \left ( \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \mathrm{rodrigues} ( \texttt{rvec1} ) \right )  \\ \texttt{tvec3} =  \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \texttt{tvec1} +  \texttt{tvec2} \end{array} ,\)</a>
<span class="sourceLineNo">1000</span><a id="line.1000">     *</a>
<span class="sourceLineNo">1001</span><a id="line.1001">     * where \(\mathrm{rodrigues}\) denotes a rotation vector to a rotation matrix transformation, and</a>
<span class="sourceLineNo">1002</span><a id="line.1002">     * \(\mathrm{rodrigues}^{-1}\) denotes the inverse transformation. See Rodrigues for details.</a>
<span class="sourceLineNo">1003</span><a id="line.1003">     *</a>
<span class="sourceLineNo">1004</span><a id="line.1004">     * Also, the functions can compute the derivatives of the output vectors with regards to the input</a>
<span class="sourceLineNo">1005</span><a id="line.1005">     * vectors (see matMulDeriv ). The functions are used inside stereoCalibrate but can also be used in</a>
<span class="sourceLineNo">1006</span><a id="line.1006">     * your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a</a>
<span class="sourceLineNo">1007</span><a id="line.1007">     * function that contains a matrix multiplication.</a>
<span class="sourceLineNo">1008</span><a id="line.1008">     */</a>
<span class="sourceLineNo">1009</span><a id="line.1009">    public static void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2, Mat dr3dt2, Mat dt3dr1, Mat dt3dt1, Mat dt3dr2, Mat dt3dt2) {</a>
<span class="sourceLineNo">1010</span><a id="line.1010">        composeRT_0(rvec1.nativeObj, tvec1.nativeObj, rvec2.nativeObj, tvec2.nativeObj, rvec3.nativeObj, tvec3.nativeObj, dr3dr1.nativeObj, dr3dt1.nativeObj, dr3dr2.nativeObj, dr3dt2.nativeObj, dt3dr1.nativeObj, dt3dt1.nativeObj, dt3dr2.nativeObj, dt3dt2.nativeObj);</a>
<span class="sourceLineNo">1011</span><a id="line.1011">    }</a>
<span class="sourceLineNo">1012</span><a id="line.1012"></a>
<span class="sourceLineNo">1013</span><a id="line.1013">    /**</a>
<span class="sourceLineNo">1014</span><a id="line.1014">     * Combines two rotation-and-shift transformations.</a>
<span class="sourceLineNo">1015</span><a id="line.1015">     *</a>
<span class="sourceLineNo">1016</span><a id="line.1016">     * @param rvec1 First rotation vector.</a>
<span class="sourceLineNo">1017</span><a id="line.1017">     * @param tvec1 First translation vector.</a>
<span class="sourceLineNo">1018</span><a id="line.1018">     * @param rvec2 Second rotation vector.</a>
<span class="sourceLineNo">1019</span><a id="line.1019">     * @param tvec2 Second translation vector.</a>
<span class="sourceLineNo">1020</span><a id="line.1020">     * @param rvec3 Output rotation vector of the superposition.</a>
<span class="sourceLineNo">1021</span><a id="line.1021">     * @param tvec3 Output translation vector of the superposition.</a>
<span class="sourceLineNo">1022</span><a id="line.1022">     * @param dr3dr1 Optional output derivative of rvec3 with regard to rvec1</a>
<span class="sourceLineNo">1023</span><a id="line.1023">     * @param dr3dt1 Optional output derivative of rvec3 with regard to tvec1</a>
<span class="sourceLineNo">1024</span><a id="line.1024">     * @param dr3dr2 Optional output derivative of rvec3 with regard to rvec2</a>
<span class="sourceLineNo">1025</span><a id="line.1025">     * @param dr3dt2 Optional output derivative of rvec3 with regard to tvec2</a>
<span class="sourceLineNo">1026</span><a id="line.1026">     * @param dt3dr1 Optional output derivative of tvec3 with regard to rvec1</a>
<span class="sourceLineNo">1027</span><a id="line.1027">     * @param dt3dt1 Optional output derivative of tvec3 with regard to tvec1</a>
<span class="sourceLineNo">1028</span><a id="line.1028">     * @param dt3dr2 Optional output derivative of tvec3 with regard to rvec2</a>
<span class="sourceLineNo">1029</span><a id="line.1029">     *</a>
<span class="sourceLineNo">1030</span><a id="line.1030">     * The functions compute:</a>
<span class="sourceLineNo">1031</span><a id="line.1031">     *</a>
<span class="sourceLineNo">1032</span><a id="line.1032">     * \(\begin{array}{l} \texttt{rvec3} =  \mathrm{rodrigues} ^{-1} \left ( \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \mathrm{rodrigues} ( \texttt{rvec1} ) \right )  \\ \texttt{tvec3} =  \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \texttt{tvec1} +  \texttt{tvec2} \end{array} ,\)</a>
<span class="sourceLineNo">1033</span><a id="line.1033">     *</a>
<span class="sourceLineNo">1034</span><a id="line.1034">     * where \(\mathrm{rodrigues}\) denotes a rotation vector to a rotation matrix transformation, and</a>
<span class="sourceLineNo">1035</span><a id="line.1035">     * \(\mathrm{rodrigues}^{-1}\) denotes the inverse transformation. See Rodrigues for details.</a>
<span class="sourceLineNo">1036</span><a id="line.1036">     *</a>
<span class="sourceLineNo">1037</span><a id="line.1037">     * Also, the functions can compute the derivatives of the output vectors with regards to the input</a>
<span class="sourceLineNo">1038</span><a id="line.1038">     * vectors (see matMulDeriv ). The functions are used inside stereoCalibrate but can also be used in</a>
<span class="sourceLineNo">1039</span><a id="line.1039">     * your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a</a>
<span class="sourceLineNo">1040</span><a id="line.1040">     * function that contains a matrix multiplication.</a>
<span class="sourceLineNo">1041</span><a id="line.1041">     */</a>
<span class="sourceLineNo">1042</span><a id="line.1042">    public static void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2, Mat dr3dt2, Mat dt3dr1, Mat dt3dt1, Mat dt3dr2) {</a>
<span class="sourceLineNo">1043</span><a id="line.1043">        composeRT_1(rvec1.nativeObj, tvec1.nativeObj, rvec2.nativeObj, tvec2.nativeObj, rvec3.nativeObj, tvec3.nativeObj, dr3dr1.nativeObj, dr3dt1.nativeObj, dr3dr2.nativeObj, dr3dt2.nativeObj, dt3dr1.nativeObj, dt3dt1.nativeObj, dt3dr2.nativeObj);</a>
<span class="sourceLineNo">1044</span><a id="line.1044">    }</a>
<span class="sourceLineNo">1045</span><a id="line.1045"></a>
<span class="sourceLineNo">1046</span><a id="line.1046">    /**</a>
<span class="sourceLineNo">1047</span><a id="line.1047">     * Combines two rotation-and-shift transformations.</a>
<span class="sourceLineNo">1048</span><a id="line.1048">     *</a>
<span class="sourceLineNo">1049</span><a id="line.1049">     * @param rvec1 First rotation vector.</a>
<span class="sourceLineNo">1050</span><a id="line.1050">     * @param tvec1 First translation vector.</a>
<span class="sourceLineNo">1051</span><a id="line.1051">     * @param rvec2 Second rotation vector.</a>
<span class="sourceLineNo">1052</span><a id="line.1052">     * @param tvec2 Second translation vector.</a>
<span class="sourceLineNo">1053</span><a id="line.1053">     * @param rvec3 Output rotation vector of the superposition.</a>
<span class="sourceLineNo">1054</span><a id="line.1054">     * @param tvec3 Output translation vector of the superposition.</a>
<span class="sourceLineNo">1055</span><a id="line.1055">     * @param dr3dr1 Optional output derivative of rvec3 with regard to rvec1</a>
<span class="sourceLineNo">1056</span><a id="line.1056">     * @param dr3dt1 Optional output derivative of rvec3 with regard to tvec1</a>
<span class="sourceLineNo">1057</span><a id="line.1057">     * @param dr3dr2 Optional output derivative of rvec3 with regard to rvec2</a>
<span class="sourceLineNo">1058</span><a id="line.1058">     * @param dr3dt2 Optional output derivative of rvec3 with regard to tvec2</a>
<span class="sourceLineNo">1059</span><a id="line.1059">     * @param dt3dr1 Optional output derivative of tvec3 with regard to rvec1</a>
<span class="sourceLineNo">1060</span><a id="line.1060">     * @param dt3dt1 Optional output derivative of tvec3 with regard to tvec1</a>
<span class="sourceLineNo">1061</span><a id="line.1061">     *</a>
<span class="sourceLineNo">1062</span><a id="line.1062">     * The functions compute:</a>
<span class="sourceLineNo">1063</span><a id="line.1063">     *</a>
<span class="sourceLineNo">1064</span><a id="line.1064">     * \(\begin{array}{l} \texttt{rvec3} =  \mathrm{rodrigues} ^{-1} \left ( \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \mathrm{rodrigues} ( \texttt{rvec1} ) \right )  \\ \texttt{tvec3} =  \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \texttt{tvec1} +  \texttt{tvec2} \end{array} ,\)</a>
<span class="sourceLineNo">1065</span><a id="line.1065">     *</a>
<span class="sourceLineNo">1066</span><a id="line.1066">     * where \(\mathrm{rodrigues}\) denotes a rotation vector to a rotation matrix transformation, and</a>
<span class="sourceLineNo">1067</span><a id="line.1067">     * \(\mathrm{rodrigues}^{-1}\) denotes the inverse transformation. See Rodrigues for details.</a>
<span class="sourceLineNo">1068</span><a id="line.1068">     *</a>
<span class="sourceLineNo">1069</span><a id="line.1069">     * Also, the functions can compute the derivatives of the output vectors with regards to the input</a>
<span class="sourceLineNo">1070</span><a id="line.1070">     * vectors (see matMulDeriv ). The functions are used inside stereoCalibrate but can also be used in</a>
<span class="sourceLineNo">1071</span><a id="line.1071">     * your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a</a>
<span class="sourceLineNo">1072</span><a id="line.1072">     * function that contains a matrix multiplication.</a>
<span class="sourceLineNo">1073</span><a id="line.1073">     */</a>
<span class="sourceLineNo">1074</span><a id="line.1074">    public static void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2, Mat dr3dt2, Mat dt3dr1, Mat dt3dt1) {</a>
<span class="sourceLineNo">1075</span><a id="line.1075">        composeRT_2(rvec1.nativeObj, tvec1.nativeObj, rvec2.nativeObj, tvec2.nativeObj, rvec3.nativeObj, tvec3.nativeObj, dr3dr1.nativeObj, dr3dt1.nativeObj, dr3dr2.nativeObj, dr3dt2.nativeObj, dt3dr1.nativeObj, dt3dt1.nativeObj);</a>
<span class="sourceLineNo">1076</span><a id="line.1076">    }</a>
<span class="sourceLineNo">1077</span><a id="line.1077"></a>
<span class="sourceLineNo">1078</span><a id="line.1078">    /**</a>
<span class="sourceLineNo">1079</span><a id="line.1079">     * Combines two rotation-and-shift transformations.</a>
<span class="sourceLineNo">1080</span><a id="line.1080">     *</a>
<span class="sourceLineNo">1081</span><a id="line.1081">     * @param rvec1 First rotation vector.</a>
<span class="sourceLineNo">1082</span><a id="line.1082">     * @param tvec1 First translation vector.</a>
<span class="sourceLineNo">1083</span><a id="line.1083">     * @param rvec2 Second rotation vector.</a>
<span class="sourceLineNo">1084</span><a id="line.1084">     * @param tvec2 Second translation vector.</a>
<span class="sourceLineNo">1085</span><a id="line.1085">     * @param rvec3 Output rotation vector of the superposition.</a>
<span class="sourceLineNo">1086</span><a id="line.1086">     * @param tvec3 Output translation vector of the superposition.</a>
<span class="sourceLineNo">1087</span><a id="line.1087">     * @param dr3dr1 Optional output derivative of rvec3 with regard to rvec1</a>
<span class="sourceLineNo">1088</span><a id="line.1088">     * @param dr3dt1 Optional output derivative of rvec3 with regard to tvec1</a>
<span class="sourceLineNo">1089</span><a id="line.1089">     * @param dr3dr2 Optional output derivative of rvec3 with regard to rvec2</a>
<span class="sourceLineNo">1090</span><a id="line.1090">     * @param dr3dt2 Optional output derivative of rvec3 with regard to tvec2</a>
<span class="sourceLineNo">1091</span><a id="line.1091">     * @param dt3dr1 Optional output derivative of tvec3 with regard to rvec1</a>
<span class="sourceLineNo">1092</span><a id="line.1092">     *</a>
<span class="sourceLineNo">1093</span><a id="line.1093">     * The functions compute:</a>
<span class="sourceLineNo">1094</span><a id="line.1094">     *</a>
<span class="sourceLineNo">1095</span><a id="line.1095">     * \(\begin{array}{l} \texttt{rvec3} =  \mathrm{rodrigues} ^{-1} \left ( \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \mathrm{rodrigues} ( \texttt{rvec1} ) \right )  \\ \texttt{tvec3} =  \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \texttt{tvec1} +  \texttt{tvec2} \end{array} ,\)</a>
<span class="sourceLineNo">1096</span><a id="line.1096">     *</a>
<span class="sourceLineNo">1097</span><a id="line.1097">     * where \(\mathrm{rodrigues}\) denotes a rotation vector to a rotation matrix transformation, and</a>
<span class="sourceLineNo">1098</span><a id="line.1098">     * \(\mathrm{rodrigues}^{-1}\) denotes the inverse transformation. See Rodrigues for details.</a>
<span class="sourceLineNo">1099</span><a id="line.1099">     *</a>
<span class="sourceLineNo">1100</span><a id="line.1100">     * Also, the functions can compute the derivatives of the output vectors with regards to the input</a>
<span class="sourceLineNo">1101</span><a id="line.1101">     * vectors (see matMulDeriv ). The functions are used inside stereoCalibrate but can also be used in</a>
<span class="sourceLineNo">1102</span><a id="line.1102">     * your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a</a>
<span class="sourceLineNo">1103</span><a id="line.1103">     * function that contains a matrix multiplication.</a>
<span class="sourceLineNo">1104</span><a id="line.1104">     */</a>
<span class="sourceLineNo">1105</span><a id="line.1105">    public static void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2, Mat dr3dt2, Mat dt3dr1) {</a>
<span class="sourceLineNo">1106</span><a id="line.1106">        composeRT_3(rvec1.nativeObj, tvec1.nativeObj, rvec2.nativeObj, tvec2.nativeObj, rvec3.nativeObj, tvec3.nativeObj, dr3dr1.nativeObj, dr3dt1.nativeObj, dr3dr2.nativeObj, dr3dt2.nativeObj, dt3dr1.nativeObj);</a>
<span class="sourceLineNo">1107</span><a id="line.1107">    }</a>
<span class="sourceLineNo">1108</span><a id="line.1108"></a>
<span class="sourceLineNo">1109</span><a id="line.1109">    /**</a>
<span class="sourceLineNo">1110</span><a id="line.1110">     * Combines two rotation-and-shift transformations.</a>
<span class="sourceLineNo">1111</span><a id="line.1111">     *</a>
<span class="sourceLineNo">1112</span><a id="line.1112">     * @param rvec1 First rotation vector.</a>
<span class="sourceLineNo">1113</span><a id="line.1113">     * @param tvec1 First translation vector.</a>
<span class="sourceLineNo">1114</span><a id="line.1114">     * @param rvec2 Second rotation vector.</a>
<span class="sourceLineNo">1115</span><a id="line.1115">     * @param tvec2 Second translation vector.</a>
<span class="sourceLineNo">1116</span><a id="line.1116">     * @param rvec3 Output rotation vector of the superposition.</a>
<span class="sourceLineNo">1117</span><a id="line.1117">     * @param tvec3 Output translation vector of the superposition.</a>
<span class="sourceLineNo">1118</span><a id="line.1118">     * @param dr3dr1 Optional output derivative of rvec3 with regard to rvec1</a>
<span class="sourceLineNo">1119</span><a id="line.1119">     * @param dr3dt1 Optional output derivative of rvec3 with regard to tvec1</a>
<span class="sourceLineNo">1120</span><a id="line.1120">     * @param dr3dr2 Optional output derivative of rvec3 with regard to rvec2</a>
<span class="sourceLineNo">1121</span><a id="line.1121">     * @param dr3dt2 Optional output derivative of rvec3 with regard to tvec2</a>
<span class="sourceLineNo">1122</span><a id="line.1122">     *</a>
<span class="sourceLineNo">1123</span><a id="line.1123">     * The functions compute:</a>
<span class="sourceLineNo">1124</span><a id="line.1124">     *</a>
<span class="sourceLineNo">1125</span><a id="line.1125">     * \(\begin{array}{l} \texttt{rvec3} =  \mathrm{rodrigues} ^{-1} \left ( \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \mathrm{rodrigues} ( \texttt{rvec1} ) \right )  \\ \texttt{tvec3} =  \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \texttt{tvec1} +  \texttt{tvec2} \end{array} ,\)</a>
<span class="sourceLineNo">1126</span><a id="line.1126">     *</a>
<span class="sourceLineNo">1127</span><a id="line.1127">     * where \(\mathrm{rodrigues}\) denotes a rotation vector to a rotation matrix transformation, and</a>
<span class="sourceLineNo">1128</span><a id="line.1128">     * \(\mathrm{rodrigues}^{-1}\) denotes the inverse transformation. See Rodrigues for details.</a>
<span class="sourceLineNo">1129</span><a id="line.1129">     *</a>
<span class="sourceLineNo">1130</span><a id="line.1130">     * Also, the functions can compute the derivatives of the output vectors with regards to the input</a>
<span class="sourceLineNo">1131</span><a id="line.1131">     * vectors (see matMulDeriv ). The functions are used inside stereoCalibrate but can also be used in</a>
<span class="sourceLineNo">1132</span><a id="line.1132">     * your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a</a>
<span class="sourceLineNo">1133</span><a id="line.1133">     * function that contains a matrix multiplication.</a>
<span class="sourceLineNo">1134</span><a id="line.1134">     */</a>
<span class="sourceLineNo">1135</span><a id="line.1135">    public static void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2, Mat dr3dt2) {</a>
<span class="sourceLineNo">1136</span><a id="line.1136">        composeRT_4(rvec1.nativeObj, tvec1.nativeObj, rvec2.nativeObj, tvec2.nativeObj, rvec3.nativeObj, tvec3.nativeObj, dr3dr1.nativeObj, dr3dt1.nativeObj, dr3dr2.nativeObj, dr3dt2.nativeObj);</a>
<span class="sourceLineNo">1137</span><a id="line.1137">    }</a>
<span class="sourceLineNo">1138</span><a id="line.1138"></a>
<span class="sourceLineNo">1139</span><a id="line.1139">    /**</a>
<span class="sourceLineNo">1140</span><a id="line.1140">     * Combines two rotation-and-shift transformations.</a>
<span class="sourceLineNo">1141</span><a id="line.1141">     *</a>
<span class="sourceLineNo">1142</span><a id="line.1142">     * @param rvec1 First rotation vector.</a>
<span class="sourceLineNo">1143</span><a id="line.1143">     * @param tvec1 First translation vector.</a>
<span class="sourceLineNo">1144</span><a id="line.1144">     * @param rvec2 Second rotation vector.</a>
<span class="sourceLineNo">1145</span><a id="line.1145">     * @param tvec2 Second translation vector.</a>
<span class="sourceLineNo">1146</span><a id="line.1146">     * @param rvec3 Output rotation vector of the superposition.</a>
<span class="sourceLineNo">1147</span><a id="line.1147">     * @param tvec3 Output translation vector of the superposition.</a>
<span class="sourceLineNo">1148</span><a id="line.1148">     * @param dr3dr1 Optional output derivative of rvec3 with regard to rvec1</a>
<span class="sourceLineNo">1149</span><a id="line.1149">     * @param dr3dt1 Optional output derivative of rvec3 with regard to tvec1</a>
<span class="sourceLineNo">1150</span><a id="line.1150">     * @param dr3dr2 Optional output derivative of rvec3 with regard to rvec2</a>
<span class="sourceLineNo">1151</span><a id="line.1151">     *</a>
<span class="sourceLineNo">1152</span><a id="line.1152">     * The functions compute:</a>
<span class="sourceLineNo">1153</span><a id="line.1153">     *</a>
<span class="sourceLineNo">1154</span><a id="line.1154">     * \(\begin{array}{l} \texttt{rvec3} =  \mathrm{rodrigues} ^{-1} \left ( \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \mathrm{rodrigues} ( \texttt{rvec1} ) \right )  \\ \texttt{tvec3} =  \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \texttt{tvec1} +  \texttt{tvec2} \end{array} ,\)</a>
<span class="sourceLineNo">1155</span><a id="line.1155">     *</a>
<span class="sourceLineNo">1156</span><a id="line.1156">     * where \(\mathrm{rodrigues}\) denotes a rotation vector to a rotation matrix transformation, and</a>
<span class="sourceLineNo">1157</span><a id="line.1157">     * \(\mathrm{rodrigues}^{-1}\) denotes the inverse transformation. See Rodrigues for details.</a>
<span class="sourceLineNo">1158</span><a id="line.1158">     *</a>
<span class="sourceLineNo">1159</span><a id="line.1159">     * Also, the functions can compute the derivatives of the output vectors with regards to the input</a>
<span class="sourceLineNo">1160</span><a id="line.1160">     * vectors (see matMulDeriv ). The functions are used inside stereoCalibrate but can also be used in</a>
<span class="sourceLineNo">1161</span><a id="line.1161">     * your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a</a>
<span class="sourceLineNo">1162</span><a id="line.1162">     * function that contains a matrix multiplication.</a>
<span class="sourceLineNo">1163</span><a id="line.1163">     */</a>
<span class="sourceLineNo">1164</span><a id="line.1164">    public static void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2) {</a>
<span class="sourceLineNo">1165</span><a id="line.1165">        composeRT_5(rvec1.nativeObj, tvec1.nativeObj, rvec2.nativeObj, tvec2.nativeObj, rvec3.nativeObj, tvec3.nativeObj, dr3dr1.nativeObj, dr3dt1.nativeObj, dr3dr2.nativeObj);</a>
<span class="sourceLineNo">1166</span><a id="line.1166">    }</a>
<span class="sourceLineNo">1167</span><a id="line.1167"></a>
<span class="sourceLineNo">1168</span><a id="line.1168">    /**</a>
<span class="sourceLineNo">1169</span><a id="line.1169">     * Combines two rotation-and-shift transformations.</a>
<span class="sourceLineNo">1170</span><a id="line.1170">     *</a>
<span class="sourceLineNo">1171</span><a id="line.1171">     * @param rvec1 First rotation vector.</a>
<span class="sourceLineNo">1172</span><a id="line.1172">     * @param tvec1 First translation vector.</a>
<span class="sourceLineNo">1173</span><a id="line.1173">     * @param rvec2 Second rotation vector.</a>
<span class="sourceLineNo">1174</span><a id="line.1174">     * @param tvec2 Second translation vector.</a>
<span class="sourceLineNo">1175</span><a id="line.1175">     * @param rvec3 Output rotation vector of the superposition.</a>
<span class="sourceLineNo">1176</span><a id="line.1176">     * @param tvec3 Output translation vector of the superposition.</a>
<span class="sourceLineNo">1177</span><a id="line.1177">     * @param dr3dr1 Optional output derivative of rvec3 with regard to rvec1</a>
<span class="sourceLineNo">1178</span><a id="line.1178">     * @param dr3dt1 Optional output derivative of rvec3 with regard to tvec1</a>
<span class="sourceLineNo">1179</span><a id="line.1179">     *</a>
<span class="sourceLineNo">1180</span><a id="line.1180">     * The functions compute:</a>
<span class="sourceLineNo">1181</span><a id="line.1181">     *</a>
<span class="sourceLineNo">1182</span><a id="line.1182">     * \(\begin{array}{l} \texttt{rvec3} =  \mathrm{rodrigues} ^{-1} \left ( \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \mathrm{rodrigues} ( \texttt{rvec1} ) \right )  \\ \texttt{tvec3} =  \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \texttt{tvec1} +  \texttt{tvec2} \end{array} ,\)</a>
<span class="sourceLineNo">1183</span><a id="line.1183">     *</a>
<span class="sourceLineNo">1184</span><a id="line.1184">     * where \(\mathrm{rodrigues}\) denotes a rotation vector to a rotation matrix transformation, and</a>
<span class="sourceLineNo">1185</span><a id="line.1185">     * \(\mathrm{rodrigues}^{-1}\) denotes the inverse transformation. See Rodrigues for details.</a>
<span class="sourceLineNo">1186</span><a id="line.1186">     *</a>
<span class="sourceLineNo">1187</span><a id="line.1187">     * Also, the functions can compute the derivatives of the output vectors with regards to the input</a>
<span class="sourceLineNo">1188</span><a id="line.1188">     * vectors (see matMulDeriv ). The functions are used inside stereoCalibrate but can also be used in</a>
<span class="sourceLineNo">1189</span><a id="line.1189">     * your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a</a>
<span class="sourceLineNo">1190</span><a id="line.1190">     * function that contains a matrix multiplication.</a>
<span class="sourceLineNo">1191</span><a id="line.1191">     */</a>
<span class="sourceLineNo">1192</span><a id="line.1192">    public static void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1) {</a>
<span class="sourceLineNo">1193</span><a id="line.1193">        composeRT_6(rvec1.nativeObj, tvec1.nativeObj, rvec2.nativeObj, tvec2.nativeObj, rvec3.nativeObj, tvec3.nativeObj, dr3dr1.nativeObj, dr3dt1.nativeObj);</a>
<span class="sourceLineNo">1194</span><a id="line.1194">    }</a>
<span class="sourceLineNo">1195</span><a id="line.1195"></a>
<span class="sourceLineNo">1196</span><a id="line.1196">    /**</a>
<span class="sourceLineNo">1197</span><a id="line.1197">     * Combines two rotation-and-shift transformations.</a>
<span class="sourceLineNo">1198</span><a id="line.1198">     *</a>
<span class="sourceLineNo">1199</span><a id="line.1199">     * @param rvec1 First rotation vector.</a>
<span class="sourceLineNo">1200</span><a id="line.1200">     * @param tvec1 First translation vector.</a>
<span class="sourceLineNo">1201</span><a id="line.1201">     * @param rvec2 Second rotation vector.</a>
<span class="sourceLineNo">1202</span><a id="line.1202">     * @param tvec2 Second translation vector.</a>
<span class="sourceLineNo">1203</span><a id="line.1203">     * @param rvec3 Output rotation vector of the superposition.</a>
<span class="sourceLineNo">1204</span><a id="line.1204">     * @param tvec3 Output translation vector of the superposition.</a>
<span class="sourceLineNo">1205</span><a id="line.1205">     * @param dr3dr1 Optional output derivative of rvec3 with regard to rvec1</a>
<span class="sourceLineNo">1206</span><a id="line.1206">     *</a>
<span class="sourceLineNo">1207</span><a id="line.1207">     * The functions compute:</a>
<span class="sourceLineNo">1208</span><a id="line.1208">     *</a>
<span class="sourceLineNo">1209</span><a id="line.1209">     * \(\begin{array}{l} \texttt{rvec3} =  \mathrm{rodrigues} ^{-1} \left ( \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \mathrm{rodrigues} ( \texttt{rvec1} ) \right )  \\ \texttt{tvec3} =  \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \texttt{tvec1} +  \texttt{tvec2} \end{array} ,\)</a>
<span class="sourceLineNo">1210</span><a id="line.1210">     *</a>
<span class="sourceLineNo">1211</span><a id="line.1211">     * where \(\mathrm{rodrigues}\) denotes a rotation vector to a rotation matrix transformation, and</a>
<span class="sourceLineNo">1212</span><a id="line.1212">     * \(\mathrm{rodrigues}^{-1}\) denotes the inverse transformation. See Rodrigues for details.</a>
<span class="sourceLineNo">1213</span><a id="line.1213">     *</a>
<span class="sourceLineNo">1214</span><a id="line.1214">     * Also, the functions can compute the derivatives of the output vectors with regards to the input</a>
<span class="sourceLineNo">1215</span><a id="line.1215">     * vectors (see matMulDeriv ). The functions are used inside stereoCalibrate but can also be used in</a>
<span class="sourceLineNo">1216</span><a id="line.1216">     * your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a</a>
<span class="sourceLineNo">1217</span><a id="line.1217">     * function that contains a matrix multiplication.</a>
<span class="sourceLineNo">1218</span><a id="line.1218">     */</a>
<span class="sourceLineNo">1219</span><a id="line.1219">    public static void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1) {</a>
<span class="sourceLineNo">1220</span><a id="line.1220">        composeRT_7(rvec1.nativeObj, tvec1.nativeObj, rvec2.nativeObj, tvec2.nativeObj, rvec3.nativeObj, tvec3.nativeObj, dr3dr1.nativeObj);</a>
<span class="sourceLineNo">1221</span><a id="line.1221">    }</a>
<span class="sourceLineNo">1222</span><a id="line.1222"></a>
<span class="sourceLineNo">1223</span><a id="line.1223">    /**</a>
<span class="sourceLineNo">1224</span><a id="line.1224">     * Combines two rotation-and-shift transformations.</a>
<span class="sourceLineNo">1225</span><a id="line.1225">     *</a>
<span class="sourceLineNo">1226</span><a id="line.1226">     * @param rvec1 First rotation vector.</a>
<span class="sourceLineNo">1227</span><a id="line.1227">     * @param tvec1 First translation vector.</a>
<span class="sourceLineNo">1228</span><a id="line.1228">     * @param rvec2 Second rotation vector.</a>
<span class="sourceLineNo">1229</span><a id="line.1229">     * @param tvec2 Second translation vector.</a>
<span class="sourceLineNo">1230</span><a id="line.1230">     * @param rvec3 Output rotation vector of the superposition.</a>
<span class="sourceLineNo">1231</span><a id="line.1231">     * @param tvec3 Output translation vector of the superposition.</a>
<span class="sourceLineNo">1232</span><a id="line.1232">     *</a>
<span class="sourceLineNo">1233</span><a id="line.1233">     * The functions compute:</a>
<span class="sourceLineNo">1234</span><a id="line.1234">     *</a>
<span class="sourceLineNo">1235</span><a id="line.1235">     * \(\begin{array}{l} \texttt{rvec3} =  \mathrm{rodrigues} ^{-1} \left ( \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \mathrm{rodrigues} ( \texttt{rvec1} ) \right )  \\ \texttt{tvec3} =  \mathrm{rodrigues} ( \texttt{rvec2} )  \cdot \texttt{tvec1} +  \texttt{tvec2} \end{array} ,\)</a>
<span class="sourceLineNo">1236</span><a id="line.1236">     *</a>
<span class="sourceLineNo">1237</span><a id="line.1237">     * where \(\mathrm{rodrigues}\) denotes a rotation vector to a rotation matrix transformation, and</a>
<span class="sourceLineNo">1238</span><a id="line.1238">     * \(\mathrm{rodrigues}^{-1}\) denotes the inverse transformation. See Rodrigues for details.</a>
<span class="sourceLineNo">1239</span><a id="line.1239">     *</a>
<span class="sourceLineNo">1240</span><a id="line.1240">     * Also, the functions can compute the derivatives of the output vectors with regards to the input</a>
<span class="sourceLineNo">1241</span><a id="line.1241">     * vectors (see matMulDeriv ). The functions are used inside stereoCalibrate but can also be used in</a>
<span class="sourceLineNo">1242</span><a id="line.1242">     * your own code where Levenberg-Marquardt or another gradient-based solver is used to optimize a</a>
<span class="sourceLineNo">1243</span><a id="line.1243">     * function that contains a matrix multiplication.</a>
<span class="sourceLineNo">1244</span><a id="line.1244">     */</a>
<span class="sourceLineNo">1245</span><a id="line.1245">    public static void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3) {</a>
<span class="sourceLineNo">1246</span><a id="line.1246">        composeRT_8(rvec1.nativeObj, tvec1.nativeObj, rvec2.nativeObj, tvec2.nativeObj, rvec3.nativeObj, tvec3.nativeObj);</a>
<span class="sourceLineNo">1247</span><a id="line.1247">    }</a>
<span class="sourceLineNo">1248</span><a id="line.1248"></a>
<span class="sourceLineNo">1249</span><a id="line.1249"></a>
<span class="sourceLineNo">1250</span><a id="line.1250">    //</a>
<span class="sourceLineNo">1251</span><a id="line.1251">    // C++:  void cv::projectPoints(vector_Point3f objectPoints, Mat rvec, Mat tvec, Mat cameraMatrix, vector_double distCoeffs, vector_Point2f&amp; imagePoints, Mat&amp; jacobian = Mat(), double aspectRatio = 0)</a>
<span class="sourceLineNo">1252</span><a id="line.1252">    //</a>
<span class="sourceLineNo">1253</span><a id="line.1253"></a>
<span class="sourceLineNo">1254</span><a id="line.1254">    /**</a>
<span class="sourceLineNo">1255</span><a id="line.1255">     * Projects 3D points to an image plane.</a>
<span class="sourceLineNo">1256</span><a id="line.1256">     *</a>
<span class="sourceLineNo">1257</span><a id="line.1257">     * @param objectPoints Array of object points expressed wrt. the world coordinate frame. A 3xN/Nx3</a>
<span class="sourceLineNo">1258</span><a id="line.1258">     * 1-channel or 1xN/Nx1 3-channel (or vector&amp;lt;Point3f&amp;gt; ), where N is the number of points in the view.</a>
<span class="sourceLineNo">1259</span><a id="line.1259">     * @param rvec The rotation vector (REF: Rodrigues) that, together with tvec, performs a change of</a>
<span class="sourceLineNo">1260</span><a id="line.1260">     * basis from world to camera coordinate system, see REF: calibrateCamera for details.</a>
<span class="sourceLineNo">1261</span><a id="line.1261">     * @param tvec The translation vector, see parameter description above.</a>
<span class="sourceLineNo">1262</span><a id="line.1262">     * @param cameraMatrix Camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">1263</span><a id="line.1263">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">1264</span><a id="line.1264">     * \(\distcoeffs\) . If the vector is empty, the zero distortion coefficients are assumed.</a>
<span class="sourceLineNo">1265</span><a id="line.1265">     * @param imagePoints Output array of image points, 1xN/Nx1 2-channel, or</a>
<span class="sourceLineNo">1266</span><a id="line.1266">     * vector&amp;lt;Point2f&amp;gt; .</a>
<span class="sourceLineNo">1267</span><a id="line.1267">     * @param jacobian Optional output 2Nx(10+&amp;lt;numDistCoeffs&amp;gt;) jacobian matrix of derivatives of image</a>
<span class="sourceLineNo">1268</span><a id="line.1268">     * points with respect to components of the rotation vector, translation vector, focal lengths,</a>
<span class="sourceLineNo">1269</span><a id="line.1269">     * coordinates of the principal point and the distortion coefficients. In the old interface different</a>
<span class="sourceLineNo">1270</span><a id="line.1270">     * components of the jacobian are returned via different output parameters.</a>
<span class="sourceLineNo">1271</span><a id="line.1271">     * @param aspectRatio Optional "fixed aspect ratio" parameter. If the parameter is not 0, the</a>
<span class="sourceLineNo">1272</span><a id="line.1272">     * function assumes that the aspect ratio (\(f_x / f_y\)) is fixed and correspondingly adjusts the</a>
<span class="sourceLineNo">1273</span><a id="line.1273">     * jacobian matrix.</a>
<span class="sourceLineNo">1274</span><a id="line.1274">     *</a>
<span class="sourceLineNo">1275</span><a id="line.1275">     * The function computes the 2D projections of 3D points to the image plane, given intrinsic and</a>
<span class="sourceLineNo">1276</span><a id="line.1276">     * extrinsic camera parameters. Optionally, the function computes Jacobians -matrices of partial</a>
<span class="sourceLineNo">1277</span><a id="line.1277">     * derivatives of image points coordinates (as functions of all the input parameters) with respect to</a>
<span class="sourceLineNo">1278</span><a id="line.1278">     * the particular parameters, intrinsic and/or extrinsic. The Jacobians are used during the global</a>
<span class="sourceLineNo">1279</span><a id="line.1279">     * optimization in REF: calibrateCamera, REF: solvePnP, and REF: stereoCalibrate. The function itself</a>
<span class="sourceLineNo">1280</span><a id="line.1280">     * can also be used to compute a re-projection error, given the current intrinsic and extrinsic</a>
<span class="sourceLineNo">1281</span><a id="line.1281">     * parameters.</a>
<span class="sourceLineNo">1282</span><a id="line.1282">     *</a>
<span class="sourceLineNo">1283</span><a id="line.1283">     * &lt;b&gt;Note:&lt;/b&gt; By setting rvec = tvec = \([0, 0, 0]\), or by setting cameraMatrix to a 3x3 identity matrix,</a>
<span class="sourceLineNo">1284</span><a id="line.1284">     * or by passing zero distortion coefficients, one can get various useful partial cases of the</a>
<span class="sourceLineNo">1285</span><a id="line.1285">     * function. This means, one can compute the distorted coordinates for a sparse set of points or apply</a>
<span class="sourceLineNo">1286</span><a id="line.1286">     * a perspective transformation (and also compute the derivatives) in the ideal zero-distortion setup.</a>
<span class="sourceLineNo">1287</span><a id="line.1287">     */</a>
<span class="sourceLineNo">1288</span><a id="line.1288">    public static void projectPoints(MatOfPoint3f objectPoints, Mat rvec, Mat tvec, Mat cameraMatrix, MatOfDouble distCoeffs, MatOfPoint2f imagePoints, Mat jacobian, double aspectRatio) {</a>
<span class="sourceLineNo">1289</span><a id="line.1289">        Mat objectPoints_mat = objectPoints;</a>
<span class="sourceLineNo">1290</span><a id="line.1290">        Mat distCoeffs_mat = distCoeffs;</a>
<span class="sourceLineNo">1291</span><a id="line.1291">        Mat imagePoints_mat = imagePoints;</a>
<span class="sourceLineNo">1292</span><a id="line.1292">        projectPoints_0(objectPoints_mat.nativeObj, rvec.nativeObj, tvec.nativeObj, cameraMatrix.nativeObj, distCoeffs_mat.nativeObj, imagePoints_mat.nativeObj, jacobian.nativeObj, aspectRatio);</a>
<span class="sourceLineNo">1293</span><a id="line.1293">    }</a>
<span class="sourceLineNo">1294</span><a id="line.1294"></a>
<span class="sourceLineNo">1295</span><a id="line.1295">    /**</a>
<span class="sourceLineNo">1296</span><a id="line.1296">     * Projects 3D points to an image plane.</a>
<span class="sourceLineNo">1297</span><a id="line.1297">     *</a>
<span class="sourceLineNo">1298</span><a id="line.1298">     * @param objectPoints Array of object points expressed wrt. the world coordinate frame. A 3xN/Nx3</a>
<span class="sourceLineNo">1299</span><a id="line.1299">     * 1-channel or 1xN/Nx1 3-channel (or vector&amp;lt;Point3f&amp;gt; ), where N is the number of points in the view.</a>
<span class="sourceLineNo">1300</span><a id="line.1300">     * @param rvec The rotation vector (REF: Rodrigues) that, together with tvec, performs a change of</a>
<span class="sourceLineNo">1301</span><a id="line.1301">     * basis from world to camera coordinate system, see REF: calibrateCamera for details.</a>
<span class="sourceLineNo">1302</span><a id="line.1302">     * @param tvec The translation vector, see parameter description above.</a>
<span class="sourceLineNo">1303</span><a id="line.1303">     * @param cameraMatrix Camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">1304</span><a id="line.1304">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">1305</span><a id="line.1305">     * \(\distcoeffs\) . If the vector is empty, the zero distortion coefficients are assumed.</a>
<span class="sourceLineNo">1306</span><a id="line.1306">     * @param imagePoints Output array of image points, 1xN/Nx1 2-channel, or</a>
<span class="sourceLineNo">1307</span><a id="line.1307">     * vector&amp;lt;Point2f&amp;gt; .</a>
<span class="sourceLineNo">1308</span><a id="line.1308">     * @param jacobian Optional output 2Nx(10+&amp;lt;numDistCoeffs&amp;gt;) jacobian matrix of derivatives of image</a>
<span class="sourceLineNo">1309</span><a id="line.1309">     * points with respect to components of the rotation vector, translation vector, focal lengths,</a>
<span class="sourceLineNo">1310</span><a id="line.1310">     * coordinates of the principal point and the distortion coefficients. In the old interface different</a>
<span class="sourceLineNo">1311</span><a id="line.1311">     * components of the jacobian are returned via different output parameters.</a>
<span class="sourceLineNo">1312</span><a id="line.1312">     * function assumes that the aspect ratio (\(f_x / f_y\)) is fixed and correspondingly adjusts the</a>
<span class="sourceLineNo">1313</span><a id="line.1313">     * jacobian matrix.</a>
<span class="sourceLineNo">1314</span><a id="line.1314">     *</a>
<span class="sourceLineNo">1315</span><a id="line.1315">     * The function computes the 2D projections of 3D points to the image plane, given intrinsic and</a>
<span class="sourceLineNo">1316</span><a id="line.1316">     * extrinsic camera parameters. Optionally, the function computes Jacobians -matrices of partial</a>
<span class="sourceLineNo">1317</span><a id="line.1317">     * derivatives of image points coordinates (as functions of all the input parameters) with respect to</a>
<span class="sourceLineNo">1318</span><a id="line.1318">     * the particular parameters, intrinsic and/or extrinsic. The Jacobians are used during the global</a>
<span class="sourceLineNo">1319</span><a id="line.1319">     * optimization in REF: calibrateCamera, REF: solvePnP, and REF: stereoCalibrate. The function itself</a>
<span class="sourceLineNo">1320</span><a id="line.1320">     * can also be used to compute a re-projection error, given the current intrinsic and extrinsic</a>
<span class="sourceLineNo">1321</span><a id="line.1321">     * parameters.</a>
<span class="sourceLineNo">1322</span><a id="line.1322">     *</a>
<span class="sourceLineNo">1323</span><a id="line.1323">     * &lt;b&gt;Note:&lt;/b&gt; By setting rvec = tvec = \([0, 0, 0]\), or by setting cameraMatrix to a 3x3 identity matrix,</a>
<span class="sourceLineNo">1324</span><a id="line.1324">     * or by passing zero distortion coefficients, one can get various useful partial cases of the</a>
<span class="sourceLineNo">1325</span><a id="line.1325">     * function. This means, one can compute the distorted coordinates for a sparse set of points or apply</a>
<span class="sourceLineNo">1326</span><a id="line.1326">     * a perspective transformation (and also compute the derivatives) in the ideal zero-distortion setup.</a>
<span class="sourceLineNo">1327</span><a id="line.1327">     */</a>
<span class="sourceLineNo">1328</span><a id="line.1328">    public static void projectPoints(MatOfPoint3f objectPoints, Mat rvec, Mat tvec, Mat cameraMatrix, MatOfDouble distCoeffs, MatOfPoint2f imagePoints, Mat jacobian) {</a>
<span class="sourceLineNo">1329</span><a id="line.1329">        Mat objectPoints_mat = objectPoints;</a>
<span class="sourceLineNo">1330</span><a id="line.1330">        Mat distCoeffs_mat = distCoeffs;</a>
<span class="sourceLineNo">1331</span><a id="line.1331">        Mat imagePoints_mat = imagePoints;</a>
<span class="sourceLineNo">1332</span><a id="line.1332">        projectPoints_1(objectPoints_mat.nativeObj, rvec.nativeObj, tvec.nativeObj, cameraMatrix.nativeObj, distCoeffs_mat.nativeObj, imagePoints_mat.nativeObj, jacobian.nativeObj);</a>
<span class="sourceLineNo">1333</span><a id="line.1333">    }</a>
<span class="sourceLineNo">1334</span><a id="line.1334"></a>
<span class="sourceLineNo">1335</span><a id="line.1335">    /**</a>
<span class="sourceLineNo">1336</span><a id="line.1336">     * Projects 3D points to an image plane.</a>
<span class="sourceLineNo">1337</span><a id="line.1337">     *</a>
<span class="sourceLineNo">1338</span><a id="line.1338">     * @param objectPoints Array of object points expressed wrt. the world coordinate frame. A 3xN/Nx3</a>
<span class="sourceLineNo">1339</span><a id="line.1339">     * 1-channel or 1xN/Nx1 3-channel (or vector&amp;lt;Point3f&amp;gt; ), where N is the number of points in the view.</a>
<span class="sourceLineNo">1340</span><a id="line.1340">     * @param rvec The rotation vector (REF: Rodrigues) that, together with tvec, performs a change of</a>
<span class="sourceLineNo">1341</span><a id="line.1341">     * basis from world to camera coordinate system, see REF: calibrateCamera for details.</a>
<span class="sourceLineNo">1342</span><a id="line.1342">     * @param tvec The translation vector, see parameter description above.</a>
<span class="sourceLineNo">1343</span><a id="line.1343">     * @param cameraMatrix Camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">1344</span><a id="line.1344">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">1345</span><a id="line.1345">     * \(\distcoeffs\) . If the vector is empty, the zero distortion coefficients are assumed.</a>
<span class="sourceLineNo">1346</span><a id="line.1346">     * @param imagePoints Output array of image points, 1xN/Nx1 2-channel, or</a>
<span class="sourceLineNo">1347</span><a id="line.1347">     * vector&amp;lt;Point2f&amp;gt; .</a>
<span class="sourceLineNo">1348</span><a id="line.1348">     * points with respect to components of the rotation vector, translation vector, focal lengths,</a>
<span class="sourceLineNo">1349</span><a id="line.1349">     * coordinates of the principal point and the distortion coefficients. In the old interface different</a>
<span class="sourceLineNo">1350</span><a id="line.1350">     * components of the jacobian are returned via different output parameters.</a>
<span class="sourceLineNo">1351</span><a id="line.1351">     * function assumes that the aspect ratio (\(f_x / f_y\)) is fixed and correspondingly adjusts the</a>
<span class="sourceLineNo">1352</span><a id="line.1352">     * jacobian matrix.</a>
<span class="sourceLineNo">1353</span><a id="line.1353">     *</a>
<span class="sourceLineNo">1354</span><a id="line.1354">     * The function computes the 2D projections of 3D points to the image plane, given intrinsic and</a>
<span class="sourceLineNo">1355</span><a id="line.1355">     * extrinsic camera parameters. Optionally, the function computes Jacobians -matrices of partial</a>
<span class="sourceLineNo">1356</span><a id="line.1356">     * derivatives of image points coordinates (as functions of all the input parameters) with respect to</a>
<span class="sourceLineNo">1357</span><a id="line.1357">     * the particular parameters, intrinsic and/or extrinsic. The Jacobians are used during the global</a>
<span class="sourceLineNo">1358</span><a id="line.1358">     * optimization in REF: calibrateCamera, REF: solvePnP, and REF: stereoCalibrate. The function itself</a>
<span class="sourceLineNo">1359</span><a id="line.1359">     * can also be used to compute a re-projection error, given the current intrinsic and extrinsic</a>
<span class="sourceLineNo">1360</span><a id="line.1360">     * parameters.</a>
<span class="sourceLineNo">1361</span><a id="line.1361">     *</a>
<span class="sourceLineNo">1362</span><a id="line.1362">     * &lt;b&gt;Note:&lt;/b&gt; By setting rvec = tvec = \([0, 0, 0]\), or by setting cameraMatrix to a 3x3 identity matrix,</a>
<span class="sourceLineNo">1363</span><a id="line.1363">     * or by passing zero distortion coefficients, one can get various useful partial cases of the</a>
<span class="sourceLineNo">1364</span><a id="line.1364">     * function. This means, one can compute the distorted coordinates for a sparse set of points or apply</a>
<span class="sourceLineNo">1365</span><a id="line.1365">     * a perspective transformation (and also compute the derivatives) in the ideal zero-distortion setup.</a>
<span class="sourceLineNo">1366</span><a id="line.1366">     */</a>
<span class="sourceLineNo">1367</span><a id="line.1367">    public static void projectPoints(MatOfPoint3f objectPoints, Mat rvec, Mat tvec, Mat cameraMatrix, MatOfDouble distCoeffs, MatOfPoint2f imagePoints) {</a>
<span class="sourceLineNo">1368</span><a id="line.1368">        Mat objectPoints_mat = objectPoints;</a>
<span class="sourceLineNo">1369</span><a id="line.1369">        Mat distCoeffs_mat = distCoeffs;</a>
<span class="sourceLineNo">1370</span><a id="line.1370">        Mat imagePoints_mat = imagePoints;</a>
<span class="sourceLineNo">1371</span><a id="line.1371">        projectPoints_2(objectPoints_mat.nativeObj, rvec.nativeObj, tvec.nativeObj, cameraMatrix.nativeObj, distCoeffs_mat.nativeObj, imagePoints_mat.nativeObj);</a>
<span class="sourceLineNo">1372</span><a id="line.1372">    }</a>
<span class="sourceLineNo">1373</span><a id="line.1373"></a>
<span class="sourceLineNo">1374</span><a id="line.1374"></a>
<span class="sourceLineNo">1375</span><a id="line.1375">    //</a>
<span class="sourceLineNo">1376</span><a id="line.1376">    // C++:  bool cv::solvePnP(vector_Point3f objectPoints, vector_Point2f imagePoints, Mat cameraMatrix, vector_double distCoeffs, Mat&amp; rvec, Mat&amp; tvec, bool useExtrinsicGuess = false, int flags = SOLVEPNP_ITERATIVE)</a>
<span class="sourceLineNo">1377</span><a id="line.1377">    //</a>
<span class="sourceLineNo">1378</span><a id="line.1378"></a>
<span class="sourceLineNo">1379</span><a id="line.1379">    /**</a>
<span class="sourceLineNo">1380</span><a id="line.1380">     * Finds an object pose from 3D-2D point correspondences.</a>
<span class="sourceLineNo">1381</span><a id="line.1381">     * This function returns the rotation and the translation vectors that transform a 3D point expressed in the object</a>
<span class="sourceLineNo">1382</span><a id="line.1382">     * coordinate frame to the camera coordinate frame, using different methods:</a>
<span class="sourceLineNo">1383</span><a id="line.1383">     * &lt;ul&gt;</a>
<span class="sourceLineNo">1384</span><a id="line.1384">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1385</span><a id="line.1385">     *  P3P methods (REF: SOLVEPNP_P3P, REF: SOLVEPNP_AP3P): need 4 input points to return a unique solution.</a>
<span class="sourceLineNo">1386</span><a id="line.1386">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1387</span><a id="line.1387">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1388</span><a id="line.1388">     *  REF: SOLVEPNP_IPPE Input points must be &amp;gt;= 4 and object points must be coplanar.</a>
<span class="sourceLineNo">1389</span><a id="line.1389">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1390</span><a id="line.1390">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1391</span><a id="line.1391">     *  REF: SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.</a>
<span class="sourceLineNo">1392</span><a id="line.1392">     * Number of input points must be 4. Object points must be defined in the following order:</a>
<span class="sourceLineNo">1393</span><a id="line.1393">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">1394</span><a id="line.1394">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1395</span><a id="line.1395">     *    point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">1396</span><a id="line.1396">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1397</span><a id="line.1397">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1398</span><a id="line.1398">     *    point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">1399</span><a id="line.1399">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1400</span><a id="line.1400">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1401</span><a id="line.1401">     *    point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">1402</span><a id="line.1402">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1403</span><a id="line.1403">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1404</span><a id="line.1404">     *    point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">1405</span><a id="line.1405">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1406</span><a id="line.1406">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">1407</span><a id="line.1407">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1408</span><a id="line.1408">     *  for all the other flags, number of input points must be &amp;gt;= 4 and object points can be in any configuration.</a>
<span class="sourceLineNo">1409</span><a id="line.1409">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1410</span><a id="line.1410">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">1411</span><a id="line.1411">     *</a>
<span class="sourceLineNo">1412</span><a id="line.1412">     * @param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or</a>
<span class="sourceLineNo">1413</span><a id="line.1413">     * 1xN/Nx1 3-channel, where N is the number of points. vector&amp;lt;Point3d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">1414</span><a id="line.1414">     * @param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,</a>
<span class="sourceLineNo">1415</span><a id="line.1415">     * where N is the number of points. vector&amp;lt;Point2d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">1416</span><a id="line.1416">     * @param cameraMatrix Input camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">1417</span><a id="line.1417">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">1418</span><a id="line.1418">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">1419</span><a id="line.1419">     * assumed.</a>
<span class="sourceLineNo">1420</span><a id="line.1420">     * @param rvec Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from</a>
<span class="sourceLineNo">1421</span><a id="line.1421">     * the model coordinate system to the camera coordinate system.</a>
<span class="sourceLineNo">1422</span><a id="line.1422">     * @param tvec Output translation vector.</a>
<span class="sourceLineNo">1423</span><a id="line.1423">     * @param useExtrinsicGuess Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses</a>
<span class="sourceLineNo">1424</span><a id="line.1424">     * the provided rvec and tvec values as initial approximations of the rotation and translation</a>
<span class="sourceLineNo">1425</span><a id="line.1425">     * vectors, respectively, and further optimizes them.</a>
<span class="sourceLineNo">1426</span><a id="line.1426">     * @param flags Method for solving a PnP problem:</a>
<span class="sourceLineNo">1427</span><a id="line.1427">     * &lt;ul&gt;</a>
<span class="sourceLineNo">1428</span><a id="line.1428">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1429</span><a id="line.1429">     *    REF: SOLVEPNP_ITERATIVE Iterative method is based on a Levenberg-Marquardt optimization. In</a>
<span class="sourceLineNo">1430</span><a id="line.1430">     * this case the function finds such a pose that minimizes reprojection error, that is the sum</a>
<span class="sourceLineNo">1431</span><a id="line.1431">     * of squared distances between the observed projections imagePoints and the projected (using</a>
<span class="sourceLineNo">1432</span><a id="line.1432">     * REF: projectPoints ) objectPoints .</a>
<span class="sourceLineNo">1433</span><a id="line.1433">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1434</span><a id="line.1434">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1435</span><a id="line.1435">     *    REF: SOLVEPNP_P3P Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang</a>
<span class="sourceLineNo">1436</span><a id="line.1436">     * "Complete Solution Classification for the Perspective-Three-Point Problem" (CITE: gao2003complete).</a>
<span class="sourceLineNo">1437</span><a id="line.1437">     * In this case the function requires exactly four object and image points.</a>
<span class="sourceLineNo">1438</span><a id="line.1438">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1439</span><a id="line.1439">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1440</span><a id="line.1440">     *    REF: SOLVEPNP_AP3P Method is based on the paper of T. Ke, S. Roumeliotis</a>
<span class="sourceLineNo">1441</span><a id="line.1441">     * "An Efficient Algebraic Solution to the Perspective-Three-Point Problem" (CITE: Ke17).</a>
<span class="sourceLineNo">1442</span><a id="line.1442">     * In this case the function requires exactly four object and image points.</a>
<span class="sourceLineNo">1443</span><a id="line.1443">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1444</span><a id="line.1444">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1445</span><a id="line.1445">     *    REF: SOLVEPNP_EPNP Method has been introduced by F. Moreno-Noguer, V. Lepetit and P. Fua in the</a>
<span class="sourceLineNo">1446</span><a id="line.1446">     * paper "EPnP: Efficient Perspective-n-Point Camera Pose Estimation" (CITE: lepetit2009epnp).</a>
<span class="sourceLineNo">1447</span><a id="line.1447">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1448</span><a id="line.1448">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1449</span><a id="line.1449">     *    REF: SOLVEPNP_DLS &lt;b&gt;Broken implementation. Using this flag will fallback to EPnP.&lt;/b&gt; \n</a>
<span class="sourceLineNo">1450</span><a id="line.1450">     * Method is based on the paper of J. Hesch and S. Roumeliotis.</a>
<span class="sourceLineNo">1451</span><a id="line.1451">     * "A Direct Least-Squares (DLS) Method for PnP" (CITE: hesch2011direct).</a>
<span class="sourceLineNo">1452</span><a id="line.1452">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1453</span><a id="line.1453">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1454</span><a id="line.1454">     *    REF: SOLVEPNP_UPNP &lt;b&gt;Broken implementation. Using this flag will fallback to EPnP.&lt;/b&gt; \n</a>
<span class="sourceLineNo">1455</span><a id="line.1455">     * Method is based on the paper of A. Penate-Sanchez, J. Andrade-Cetto,</a>
<span class="sourceLineNo">1456</span><a id="line.1456">     * F. Moreno-Noguer. "Exhaustive Linearization for Robust Camera Pose and Focal Length</a>
<span class="sourceLineNo">1457</span><a id="line.1457">     * Estimation" (CITE: penate2013exhaustive). In this case the function also estimates the parameters \(f_x\) and \(f_y\)</a>
<span class="sourceLineNo">1458</span><a id="line.1458">     * assuming that both have the same value. Then the cameraMatrix is updated with the estimated</a>
<span class="sourceLineNo">1459</span><a id="line.1459">     * focal length.</a>
<span class="sourceLineNo">1460</span><a id="line.1460">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1461</span><a id="line.1461">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1462</span><a id="line.1462">     *    REF: SOLVEPNP_IPPE Method is based on the paper of T. Collins and A. Bartoli.</a>
<span class="sourceLineNo">1463</span><a id="line.1463">     * "Infinitesimal Plane-Based Pose Estimation" (CITE: Collins14). This method requires coplanar object points.</a>
<span class="sourceLineNo">1464</span><a id="line.1464">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1465</span><a id="line.1465">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1466</span><a id="line.1466">     *    REF: SOLVEPNP_IPPE_SQUARE Method is based on the paper of Toby Collins and Adrien Bartoli.</a>
<span class="sourceLineNo">1467</span><a id="line.1467">     * "Infinitesimal Plane-Based Pose Estimation" (CITE: Collins14). This method is suitable for marker pose estimation.</a>
<span class="sourceLineNo">1468</span><a id="line.1468">     * It requires 4 coplanar object points defined in the following order:</a>
<span class="sourceLineNo">1469</span><a id="line.1469">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">1470</span><a id="line.1470">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1471</span><a id="line.1471">     *    point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">1472</span><a id="line.1472">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1473</span><a id="line.1473">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1474</span><a id="line.1474">     *    point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">1475</span><a id="line.1475">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1476</span><a id="line.1476">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1477</span><a id="line.1477">     *    point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">1478</span><a id="line.1478">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1479</span><a id="line.1479">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1480</span><a id="line.1480">     *    point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">1481</span><a id="line.1481">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1482</span><a id="line.1482">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">1483</span><a id="line.1483">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1484</span><a id="line.1484">     *    REF: SOLVEPNP_SQPNP Method is based on the paper "A Consistently Fast and Globally Optimal Solution to the</a>
<span class="sourceLineNo">1485</span><a id="line.1485">     * Perspective-n-Point Problem" by G. Terzakis and M.Lourakis (CITE: Terzakis20). It requires 3 or more points.</a>
<span class="sourceLineNo">1486</span><a id="line.1486">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1487</span><a id="line.1487">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">1488</span><a id="line.1488">     *</a>
<span class="sourceLineNo">1489</span><a id="line.1489">     *</a>
<span class="sourceLineNo">1490</span><a id="line.1490">     * The function estimates the object pose given a set of object points, their corresponding image</a>
<span class="sourceLineNo">1491</span><a id="line.1491">     * projections, as well as the camera intrinsic matrix and the distortion coefficients, see the figure below</a>
<span class="sourceLineNo">1492</span><a id="line.1492">     * (more precisely, the X-axis of the camera frame is pointing to the right, the Y-axis downward</a>
<span class="sourceLineNo">1493</span><a id="line.1493">     * and the Z-axis forward).</a>
<span class="sourceLineNo">1494</span><a id="line.1494">     *</a>
<span class="sourceLineNo">1495</span><a id="line.1495">     * ![](pnp.jpg)</a>
<span class="sourceLineNo">1496</span><a id="line.1496">     *</a>
<span class="sourceLineNo">1497</span><a id="line.1497">     * Points expressed in the world frame \( \bf{X}_w \) are projected into the image plane \( \left[ u, v \right] \)</a>
<span class="sourceLineNo">1498</span><a id="line.1498">     * using the perspective projection model \( \Pi \) and the camera intrinsic parameters matrix \( \bf{A} \):</a>
<span class="sourceLineNo">1499</span><a id="line.1499">     *</a>
<span class="sourceLineNo">1500</span><a id="line.1500">     * \(</a>
<span class="sourceLineNo">1501</span><a id="line.1501">     *   \begin{align*}</a>
<span class="sourceLineNo">1502</span><a id="line.1502">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1503</span><a id="line.1503">     *   u \\</a>
<span class="sourceLineNo">1504</span><a id="line.1504">     *   v \\</a>
<span class="sourceLineNo">1505</span><a id="line.1505">     *   1</a>
<span class="sourceLineNo">1506</span><a id="line.1506">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">1507</span><a id="line.1507">     *   \bf{A} \hspace{0.1em} \Pi \hspace{0.2em} ^{c}\bf{T}_w</a>
<span class="sourceLineNo">1508</span><a id="line.1508">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1509</span><a id="line.1509">     *   X_{w} \\</a>
<span class="sourceLineNo">1510</span><a id="line.1510">     *   Y_{w} \\</a>
<span class="sourceLineNo">1511</span><a id="line.1511">     *   Z_{w} \\</a>
<span class="sourceLineNo">1512</span><a id="line.1512">     *   1</a>
<span class="sourceLineNo">1513</span><a id="line.1513">     *   \end{bmatrix} \\</a>
<span class="sourceLineNo">1514</span><a id="line.1514">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1515</span><a id="line.1515">     *   u \\</a>
<span class="sourceLineNo">1516</span><a id="line.1516">     *   v \\</a>
<span class="sourceLineNo">1517</span><a id="line.1517">     *   1</a>
<span class="sourceLineNo">1518</span><a id="line.1518">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">1519</span><a id="line.1519">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1520</span><a id="line.1520">     *   f_x &amp;amp; 0 &amp;amp; c_x \\</a>
<span class="sourceLineNo">1521</span><a id="line.1521">     *   0 &amp;amp; f_y &amp;amp; c_y \\</a>
<span class="sourceLineNo">1522</span><a id="line.1522">     *   0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">1523</span><a id="line.1523">     *   \end{bmatrix}</a>
<span class="sourceLineNo">1524</span><a id="line.1524">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1525</span><a id="line.1525">     *   1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\</a>
<span class="sourceLineNo">1526</span><a id="line.1526">     *   0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\</a>
<span class="sourceLineNo">1527</span><a id="line.1527">     *   0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">1528</span><a id="line.1528">     *   \end{bmatrix}</a>
<span class="sourceLineNo">1529</span><a id="line.1529">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1530</span><a id="line.1530">     *   r_{11} &amp;amp; r_{12} &amp;amp; r_{13} &amp;amp; t_x \\</a>
<span class="sourceLineNo">1531</span><a id="line.1531">     *   r_{21} &amp;amp; r_{22} &amp;amp; r_{23} &amp;amp; t_y \\</a>
<span class="sourceLineNo">1532</span><a id="line.1532">     *   r_{31} &amp;amp; r_{32} &amp;amp; r_{33} &amp;amp; t_z \\</a>
<span class="sourceLineNo">1533</span><a id="line.1533">     *   0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">1534</span><a id="line.1534">     *   \end{bmatrix}</a>
<span class="sourceLineNo">1535</span><a id="line.1535">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1536</span><a id="line.1536">     *   X_{w} \\</a>
<span class="sourceLineNo">1537</span><a id="line.1537">     *   Y_{w} \\</a>
<span class="sourceLineNo">1538</span><a id="line.1538">     *   Z_{w} \\</a>
<span class="sourceLineNo">1539</span><a id="line.1539">     *   1</a>
<span class="sourceLineNo">1540</span><a id="line.1540">     *   \end{bmatrix}</a>
<span class="sourceLineNo">1541</span><a id="line.1541">     *   \end{align*}</a>
<span class="sourceLineNo">1542</span><a id="line.1542">     * \)</a>
<span class="sourceLineNo">1543</span><a id="line.1543">     *</a>
<span class="sourceLineNo">1544</span><a id="line.1544">     * The estimated pose is thus the rotation ({@code rvec}) and the translation ({@code tvec}) vectors that allow transforming</a>
<span class="sourceLineNo">1545</span><a id="line.1545">     * a 3D point expressed in the world frame into the camera frame:</a>
<span class="sourceLineNo">1546</span><a id="line.1546">     *</a>
<span class="sourceLineNo">1547</span><a id="line.1547">     * \(</a>
<span class="sourceLineNo">1548</span><a id="line.1548">     *   \begin{align*}</a>
<span class="sourceLineNo">1549</span><a id="line.1549">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1550</span><a id="line.1550">     *   X_c \\</a>
<span class="sourceLineNo">1551</span><a id="line.1551">     *   Y_c \\</a>
<span class="sourceLineNo">1552</span><a id="line.1552">     *   Z_c \\</a>
<span class="sourceLineNo">1553</span><a id="line.1553">     *   1</a>
<span class="sourceLineNo">1554</span><a id="line.1554">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">1555</span><a id="line.1555">     *   \hspace{0.2em} ^{c}\bf{T}_w</a>
<span class="sourceLineNo">1556</span><a id="line.1556">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1557</span><a id="line.1557">     *   X_{w} \\</a>
<span class="sourceLineNo">1558</span><a id="line.1558">     *   Y_{w} \\</a>
<span class="sourceLineNo">1559</span><a id="line.1559">     *   Z_{w} \\</a>
<span class="sourceLineNo">1560</span><a id="line.1560">     *   1</a>
<span class="sourceLineNo">1561</span><a id="line.1561">     *   \end{bmatrix} \\</a>
<span class="sourceLineNo">1562</span><a id="line.1562">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1563</span><a id="line.1563">     *   X_c \\</a>
<span class="sourceLineNo">1564</span><a id="line.1564">     *   Y_c \\</a>
<span class="sourceLineNo">1565</span><a id="line.1565">     *   Z_c \\</a>
<span class="sourceLineNo">1566</span><a id="line.1566">     *   1</a>
<span class="sourceLineNo">1567</span><a id="line.1567">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">1568</span><a id="line.1568">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1569</span><a id="line.1569">     *   r_{11} &amp;amp; r_{12} &amp;amp; r_{13} &amp;amp; t_x \\</a>
<span class="sourceLineNo">1570</span><a id="line.1570">     *   r_{21} &amp;amp; r_{22} &amp;amp; r_{23} &amp;amp; t_y \\</a>
<span class="sourceLineNo">1571</span><a id="line.1571">     *   r_{31} &amp;amp; r_{32} &amp;amp; r_{33} &amp;amp; t_z \\</a>
<span class="sourceLineNo">1572</span><a id="line.1572">     *   0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">1573</span><a id="line.1573">     *   \end{bmatrix}</a>
<span class="sourceLineNo">1574</span><a id="line.1574">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1575</span><a id="line.1575">     *   X_{w} \\</a>
<span class="sourceLineNo">1576</span><a id="line.1576">     *   Y_{w} \\</a>
<span class="sourceLineNo">1577</span><a id="line.1577">     *   Z_{w} \\</a>
<span class="sourceLineNo">1578</span><a id="line.1578">     *   1</a>
<span class="sourceLineNo">1579</span><a id="line.1579">     *   \end{bmatrix}</a>
<span class="sourceLineNo">1580</span><a id="line.1580">     *   \end{align*}</a>
<span class="sourceLineNo">1581</span><a id="line.1581">     * \)</a>
<span class="sourceLineNo">1582</span><a id="line.1582">     *</a>
<span class="sourceLineNo">1583</span><a id="line.1583">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">1584</span><a id="line.1584">     * &lt;ul&gt;</a>
<span class="sourceLineNo">1585</span><a id="line.1585">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1586</span><a id="line.1586">     *       An example of how to use solvePnP for planar augmented reality can be found at</a>
<span class="sourceLineNo">1587</span><a id="line.1587">     *         opencv_source_code/samples/python/plane_ar.py</a>
<span class="sourceLineNo">1588</span><a id="line.1588">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1589</span><a id="line.1589">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1590</span><a id="line.1590">     *       If you are using Python:</a>
<span class="sourceLineNo">1591</span><a id="line.1591">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">1592</span><a id="line.1592">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1593</span><a id="line.1593">     *          Numpy array slices won't work as input because solvePnP requires contiguous</a>
<span class="sourceLineNo">1594</span><a id="line.1594">     *         arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of</a>
<span class="sourceLineNo">1595</span><a id="line.1595">     *         modules/calib3d/src/solvepnp.cpp version 2.4.9)</a>
<span class="sourceLineNo">1596</span><a id="line.1596">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1597</span><a id="line.1597">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1598</span><a id="line.1598">     *          The P3P algorithm requires image points to be in an array of shape (N,1,2) due</a>
<span class="sourceLineNo">1599</span><a id="line.1599">     *         to its calling of cv::undistortPoints (around line 75 of modules/calib3d/src/solvepnp.cpp version 2.4.9)</a>
<span class="sourceLineNo">1600</span><a id="line.1600">     *         which requires 2-channel information.</a>
<span class="sourceLineNo">1601</span><a id="line.1601">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1602</span><a id="line.1602">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1603</span><a id="line.1603">     *          Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of</a>
<span class="sourceLineNo">1604</span><a id="line.1604">     *         it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =</a>
<span class="sourceLineNo">1605</span><a id="line.1605">     *         np.ascontiguousarray(D[:,:2]).reshape((N,1,2))</a>
<span class="sourceLineNo">1606</span><a id="line.1606">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1607</span><a id="line.1607">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">1608</span><a id="line.1608">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1609</span><a id="line.1609">     *       The methods REF: SOLVEPNP_DLS and REF: SOLVEPNP_UPNP cannot be used as the current implementations are</a>
<span class="sourceLineNo">1610</span><a id="line.1610">     *        unstable and sometimes give completely wrong results. If you pass one of these two</a>
<span class="sourceLineNo">1611</span><a id="line.1611">     *        flags, REF: SOLVEPNP_EPNP method will be used instead.</a>
<span class="sourceLineNo">1612</span><a id="line.1612">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1613</span><a id="line.1613">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1614</span><a id="line.1614">     *       The minimum number of points is 4 in the general case. In the case of REF: SOLVEPNP_P3P and REF: SOLVEPNP_AP3P</a>
<span class="sourceLineNo">1615</span><a id="line.1615">     *        methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions</a>
<span class="sourceLineNo">1616</span><a id="line.1616">     *        of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).</a>
<span class="sourceLineNo">1617</span><a id="line.1617">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1618</span><a id="line.1618">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1619</span><a id="line.1619">     *       With REF: SOLVEPNP_ITERATIVE method and {@code useExtrinsicGuess=true}, the minimum number of points is 3 (3 points</a>
<span class="sourceLineNo">1620</span><a id="line.1620">     *        are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the</a>
<span class="sourceLineNo">1621</span><a id="line.1621">     *        global solution to converge.</a>
<span class="sourceLineNo">1622</span><a id="line.1622">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1623</span><a id="line.1623">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1624</span><a id="line.1624">     *       With REF: SOLVEPNP_IPPE input points must be &amp;gt;= 4 and object points must be coplanar.</a>
<span class="sourceLineNo">1625</span><a id="line.1625">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1626</span><a id="line.1626">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1627</span><a id="line.1627">     *       With REF: SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation.</a>
<span class="sourceLineNo">1628</span><a id="line.1628">     *        Number of input points must be 4. Object points must be defined in the following order:</a>
<span class="sourceLineNo">1629</span><a id="line.1629">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">1630</span><a id="line.1630">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1631</span><a id="line.1631">     *           point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">1632</span><a id="line.1632">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1633</span><a id="line.1633">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1634</span><a id="line.1634">     *           point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">1635</span><a id="line.1635">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1636</span><a id="line.1636">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1637</span><a id="line.1637">     *           point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">1638</span><a id="line.1638">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1639</span><a id="line.1639">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1640</span><a id="line.1640">     *           point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">1641</span><a id="line.1641">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1642</span><a id="line.1642">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">1643</span><a id="line.1643">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">1644</span><a id="line.1644">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1645</span><a id="line.1645">     *       With REF: SOLVEPNP_SQPNP input points must be &amp;gt;= 3</a>
<span class="sourceLineNo">1646</span><a id="line.1646">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1647</span><a id="line.1647">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">1648</span><a id="line.1648">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1649</span><a id="line.1649">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">1650</span><a id="line.1650">     * @return automatically generated</a>
<span class="sourceLineNo">1651</span><a id="line.1651">     */</a>
<span class="sourceLineNo">1652</span><a id="line.1652">    public static boolean solvePnP(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int flags) {</a>
<span class="sourceLineNo">1653</span><a id="line.1653">        Mat objectPoints_mat = objectPoints;</a>
<span class="sourceLineNo">1654</span><a id="line.1654">        Mat imagePoints_mat = imagePoints;</a>
<span class="sourceLineNo">1655</span><a id="line.1655">        Mat distCoeffs_mat = distCoeffs;</a>
<span class="sourceLineNo">1656</span><a id="line.1656">        return solvePnP_0(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, cameraMatrix.nativeObj, distCoeffs_mat.nativeObj, rvec.nativeObj, tvec.nativeObj, useExtrinsicGuess, flags);</a>
<span class="sourceLineNo">1657</span><a id="line.1657">    }</a>
<span class="sourceLineNo">1658</span><a id="line.1658"></a>
<span class="sourceLineNo">1659</span><a id="line.1659">    /**</a>
<span class="sourceLineNo">1660</span><a id="line.1660">     * Finds an object pose from 3D-2D point correspondences.</a>
<span class="sourceLineNo">1661</span><a id="line.1661">     * This function returns the rotation and the translation vectors that transform a 3D point expressed in the object</a>
<span class="sourceLineNo">1662</span><a id="line.1662">     * coordinate frame to the camera coordinate frame, using different methods:</a>
<span class="sourceLineNo">1663</span><a id="line.1663">     * &lt;ul&gt;</a>
<span class="sourceLineNo">1664</span><a id="line.1664">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1665</span><a id="line.1665">     *  P3P methods (REF: SOLVEPNP_P3P, REF: SOLVEPNP_AP3P): need 4 input points to return a unique solution.</a>
<span class="sourceLineNo">1666</span><a id="line.1666">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1667</span><a id="line.1667">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1668</span><a id="line.1668">     *  REF: SOLVEPNP_IPPE Input points must be &amp;gt;= 4 and object points must be coplanar.</a>
<span class="sourceLineNo">1669</span><a id="line.1669">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1670</span><a id="line.1670">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1671</span><a id="line.1671">     *  REF: SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.</a>
<span class="sourceLineNo">1672</span><a id="line.1672">     * Number of input points must be 4. Object points must be defined in the following order:</a>
<span class="sourceLineNo">1673</span><a id="line.1673">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">1674</span><a id="line.1674">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1675</span><a id="line.1675">     *    point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">1676</span><a id="line.1676">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1677</span><a id="line.1677">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1678</span><a id="line.1678">     *    point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">1679</span><a id="line.1679">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1680</span><a id="line.1680">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1681</span><a id="line.1681">     *    point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">1682</span><a id="line.1682">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1683</span><a id="line.1683">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1684</span><a id="line.1684">     *    point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">1685</span><a id="line.1685">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1686</span><a id="line.1686">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">1687</span><a id="line.1687">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1688</span><a id="line.1688">     *  for all the other flags, number of input points must be &amp;gt;= 4 and object points can be in any configuration.</a>
<span class="sourceLineNo">1689</span><a id="line.1689">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1690</span><a id="line.1690">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">1691</span><a id="line.1691">     *</a>
<span class="sourceLineNo">1692</span><a id="line.1692">     * @param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or</a>
<span class="sourceLineNo">1693</span><a id="line.1693">     * 1xN/Nx1 3-channel, where N is the number of points. vector&amp;lt;Point3d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">1694</span><a id="line.1694">     * @param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,</a>
<span class="sourceLineNo">1695</span><a id="line.1695">     * where N is the number of points. vector&amp;lt;Point2d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">1696</span><a id="line.1696">     * @param cameraMatrix Input camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">1697</span><a id="line.1697">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">1698</span><a id="line.1698">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">1699</span><a id="line.1699">     * assumed.</a>
<span class="sourceLineNo">1700</span><a id="line.1700">     * @param rvec Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from</a>
<span class="sourceLineNo">1701</span><a id="line.1701">     * the model coordinate system to the camera coordinate system.</a>
<span class="sourceLineNo">1702</span><a id="line.1702">     * @param tvec Output translation vector.</a>
<span class="sourceLineNo">1703</span><a id="line.1703">     * @param useExtrinsicGuess Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses</a>
<span class="sourceLineNo">1704</span><a id="line.1704">     * the provided rvec and tvec values as initial approximations of the rotation and translation</a>
<span class="sourceLineNo">1705</span><a id="line.1705">     * vectors, respectively, and further optimizes them.</a>
<span class="sourceLineNo">1706</span><a id="line.1706">     * &lt;ul&gt;</a>
<span class="sourceLineNo">1707</span><a id="line.1707">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1708</span><a id="line.1708">     *    REF: SOLVEPNP_ITERATIVE Iterative method is based on a Levenberg-Marquardt optimization. In</a>
<span class="sourceLineNo">1709</span><a id="line.1709">     * this case the function finds such a pose that minimizes reprojection error, that is the sum</a>
<span class="sourceLineNo">1710</span><a id="line.1710">     * of squared distances between the observed projections imagePoints and the projected (using</a>
<span class="sourceLineNo">1711</span><a id="line.1711">     * REF: projectPoints ) objectPoints .</a>
<span class="sourceLineNo">1712</span><a id="line.1712">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1713</span><a id="line.1713">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1714</span><a id="line.1714">     *    REF: SOLVEPNP_P3P Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang</a>
<span class="sourceLineNo">1715</span><a id="line.1715">     * "Complete Solution Classification for the Perspective-Three-Point Problem" (CITE: gao2003complete).</a>
<span class="sourceLineNo">1716</span><a id="line.1716">     * In this case the function requires exactly four object and image points.</a>
<span class="sourceLineNo">1717</span><a id="line.1717">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1718</span><a id="line.1718">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1719</span><a id="line.1719">     *    REF: SOLVEPNP_AP3P Method is based on the paper of T. Ke, S. Roumeliotis</a>
<span class="sourceLineNo">1720</span><a id="line.1720">     * "An Efficient Algebraic Solution to the Perspective-Three-Point Problem" (CITE: Ke17).</a>
<span class="sourceLineNo">1721</span><a id="line.1721">     * In this case the function requires exactly four object and image points.</a>
<span class="sourceLineNo">1722</span><a id="line.1722">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1723</span><a id="line.1723">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1724</span><a id="line.1724">     *    REF: SOLVEPNP_EPNP Method has been introduced by F. Moreno-Noguer, V. Lepetit and P. Fua in the</a>
<span class="sourceLineNo">1725</span><a id="line.1725">     * paper "EPnP: Efficient Perspective-n-Point Camera Pose Estimation" (CITE: lepetit2009epnp).</a>
<span class="sourceLineNo">1726</span><a id="line.1726">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1727</span><a id="line.1727">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1728</span><a id="line.1728">     *    REF: SOLVEPNP_DLS &lt;b&gt;Broken implementation. Using this flag will fallback to EPnP.&lt;/b&gt; \n</a>
<span class="sourceLineNo">1729</span><a id="line.1729">     * Method is based on the paper of J. Hesch and S. Roumeliotis.</a>
<span class="sourceLineNo">1730</span><a id="line.1730">     * "A Direct Least-Squares (DLS) Method for PnP" (CITE: hesch2011direct).</a>
<span class="sourceLineNo">1731</span><a id="line.1731">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1732</span><a id="line.1732">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1733</span><a id="line.1733">     *    REF: SOLVEPNP_UPNP &lt;b&gt;Broken implementation. Using this flag will fallback to EPnP.&lt;/b&gt; \n</a>
<span class="sourceLineNo">1734</span><a id="line.1734">     * Method is based on the paper of A. Penate-Sanchez, J. Andrade-Cetto,</a>
<span class="sourceLineNo">1735</span><a id="line.1735">     * F. Moreno-Noguer. "Exhaustive Linearization for Robust Camera Pose and Focal Length</a>
<span class="sourceLineNo">1736</span><a id="line.1736">     * Estimation" (CITE: penate2013exhaustive). In this case the function also estimates the parameters \(f_x\) and \(f_y\)</a>
<span class="sourceLineNo">1737</span><a id="line.1737">     * assuming that both have the same value. Then the cameraMatrix is updated with the estimated</a>
<span class="sourceLineNo">1738</span><a id="line.1738">     * focal length.</a>
<span class="sourceLineNo">1739</span><a id="line.1739">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1740</span><a id="line.1740">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1741</span><a id="line.1741">     *    REF: SOLVEPNP_IPPE Method is based on the paper of T. Collins and A. Bartoli.</a>
<span class="sourceLineNo">1742</span><a id="line.1742">     * "Infinitesimal Plane-Based Pose Estimation" (CITE: Collins14). This method requires coplanar object points.</a>
<span class="sourceLineNo">1743</span><a id="line.1743">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1744</span><a id="line.1744">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1745</span><a id="line.1745">     *    REF: SOLVEPNP_IPPE_SQUARE Method is based on the paper of Toby Collins and Adrien Bartoli.</a>
<span class="sourceLineNo">1746</span><a id="line.1746">     * "Infinitesimal Plane-Based Pose Estimation" (CITE: Collins14). This method is suitable for marker pose estimation.</a>
<span class="sourceLineNo">1747</span><a id="line.1747">     * It requires 4 coplanar object points defined in the following order:</a>
<span class="sourceLineNo">1748</span><a id="line.1748">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">1749</span><a id="line.1749">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1750</span><a id="line.1750">     *    point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">1751</span><a id="line.1751">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1752</span><a id="line.1752">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1753</span><a id="line.1753">     *    point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">1754</span><a id="line.1754">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1755</span><a id="line.1755">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1756</span><a id="line.1756">     *    point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">1757</span><a id="line.1757">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1758</span><a id="line.1758">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1759</span><a id="line.1759">     *    point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">1760</span><a id="line.1760">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1761</span><a id="line.1761">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">1762</span><a id="line.1762">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1763</span><a id="line.1763">     *    REF: SOLVEPNP_SQPNP Method is based on the paper "A Consistently Fast and Globally Optimal Solution to the</a>
<span class="sourceLineNo">1764</span><a id="line.1764">     * Perspective-n-Point Problem" by G. Terzakis and M.Lourakis (CITE: Terzakis20). It requires 3 or more points.</a>
<span class="sourceLineNo">1765</span><a id="line.1765">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1766</span><a id="line.1766">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">1767</span><a id="line.1767">     *</a>
<span class="sourceLineNo">1768</span><a id="line.1768">     *</a>
<span class="sourceLineNo">1769</span><a id="line.1769">     * The function estimates the object pose given a set of object points, their corresponding image</a>
<span class="sourceLineNo">1770</span><a id="line.1770">     * projections, as well as the camera intrinsic matrix and the distortion coefficients, see the figure below</a>
<span class="sourceLineNo">1771</span><a id="line.1771">     * (more precisely, the X-axis of the camera frame is pointing to the right, the Y-axis downward</a>
<span class="sourceLineNo">1772</span><a id="line.1772">     * and the Z-axis forward).</a>
<span class="sourceLineNo">1773</span><a id="line.1773">     *</a>
<span class="sourceLineNo">1774</span><a id="line.1774">     * ![](pnp.jpg)</a>
<span class="sourceLineNo">1775</span><a id="line.1775">     *</a>
<span class="sourceLineNo">1776</span><a id="line.1776">     * Points expressed in the world frame \( \bf{X}_w \) are projected into the image plane \( \left[ u, v \right] \)</a>
<span class="sourceLineNo">1777</span><a id="line.1777">     * using the perspective projection model \( \Pi \) and the camera intrinsic parameters matrix \( \bf{A} \):</a>
<span class="sourceLineNo">1778</span><a id="line.1778">     *</a>
<span class="sourceLineNo">1779</span><a id="line.1779">     * \(</a>
<span class="sourceLineNo">1780</span><a id="line.1780">     *   \begin{align*}</a>
<span class="sourceLineNo">1781</span><a id="line.1781">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1782</span><a id="line.1782">     *   u \\</a>
<span class="sourceLineNo">1783</span><a id="line.1783">     *   v \\</a>
<span class="sourceLineNo">1784</span><a id="line.1784">     *   1</a>
<span class="sourceLineNo">1785</span><a id="line.1785">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">1786</span><a id="line.1786">     *   \bf{A} \hspace{0.1em} \Pi \hspace{0.2em} ^{c}\bf{T}_w</a>
<span class="sourceLineNo">1787</span><a id="line.1787">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1788</span><a id="line.1788">     *   X_{w} \\</a>
<span class="sourceLineNo">1789</span><a id="line.1789">     *   Y_{w} \\</a>
<span class="sourceLineNo">1790</span><a id="line.1790">     *   Z_{w} \\</a>
<span class="sourceLineNo">1791</span><a id="line.1791">     *   1</a>
<span class="sourceLineNo">1792</span><a id="line.1792">     *   \end{bmatrix} \\</a>
<span class="sourceLineNo">1793</span><a id="line.1793">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1794</span><a id="line.1794">     *   u \\</a>
<span class="sourceLineNo">1795</span><a id="line.1795">     *   v \\</a>
<span class="sourceLineNo">1796</span><a id="line.1796">     *   1</a>
<span class="sourceLineNo">1797</span><a id="line.1797">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">1798</span><a id="line.1798">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1799</span><a id="line.1799">     *   f_x &amp;amp; 0 &amp;amp; c_x \\</a>
<span class="sourceLineNo">1800</span><a id="line.1800">     *   0 &amp;amp; f_y &amp;amp; c_y \\</a>
<span class="sourceLineNo">1801</span><a id="line.1801">     *   0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">1802</span><a id="line.1802">     *   \end{bmatrix}</a>
<span class="sourceLineNo">1803</span><a id="line.1803">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1804</span><a id="line.1804">     *   1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\</a>
<span class="sourceLineNo">1805</span><a id="line.1805">     *   0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\</a>
<span class="sourceLineNo">1806</span><a id="line.1806">     *   0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">1807</span><a id="line.1807">     *   \end{bmatrix}</a>
<span class="sourceLineNo">1808</span><a id="line.1808">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1809</span><a id="line.1809">     *   r_{11} &amp;amp; r_{12} &amp;amp; r_{13} &amp;amp; t_x \\</a>
<span class="sourceLineNo">1810</span><a id="line.1810">     *   r_{21} &amp;amp; r_{22} &amp;amp; r_{23} &amp;amp; t_y \\</a>
<span class="sourceLineNo">1811</span><a id="line.1811">     *   r_{31} &amp;amp; r_{32} &amp;amp; r_{33} &amp;amp; t_z \\</a>
<span class="sourceLineNo">1812</span><a id="line.1812">     *   0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">1813</span><a id="line.1813">     *   \end{bmatrix}</a>
<span class="sourceLineNo">1814</span><a id="line.1814">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1815</span><a id="line.1815">     *   X_{w} \\</a>
<span class="sourceLineNo">1816</span><a id="line.1816">     *   Y_{w} \\</a>
<span class="sourceLineNo">1817</span><a id="line.1817">     *   Z_{w} \\</a>
<span class="sourceLineNo">1818</span><a id="line.1818">     *   1</a>
<span class="sourceLineNo">1819</span><a id="line.1819">     *   \end{bmatrix}</a>
<span class="sourceLineNo">1820</span><a id="line.1820">     *   \end{align*}</a>
<span class="sourceLineNo">1821</span><a id="line.1821">     * \)</a>
<span class="sourceLineNo">1822</span><a id="line.1822">     *</a>
<span class="sourceLineNo">1823</span><a id="line.1823">     * The estimated pose is thus the rotation ({@code rvec}) and the translation ({@code tvec}) vectors that allow transforming</a>
<span class="sourceLineNo">1824</span><a id="line.1824">     * a 3D point expressed in the world frame into the camera frame:</a>
<span class="sourceLineNo">1825</span><a id="line.1825">     *</a>
<span class="sourceLineNo">1826</span><a id="line.1826">     * \(</a>
<span class="sourceLineNo">1827</span><a id="line.1827">     *   \begin{align*}</a>
<span class="sourceLineNo">1828</span><a id="line.1828">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1829</span><a id="line.1829">     *   X_c \\</a>
<span class="sourceLineNo">1830</span><a id="line.1830">     *   Y_c \\</a>
<span class="sourceLineNo">1831</span><a id="line.1831">     *   Z_c \\</a>
<span class="sourceLineNo">1832</span><a id="line.1832">     *   1</a>
<span class="sourceLineNo">1833</span><a id="line.1833">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">1834</span><a id="line.1834">     *   \hspace{0.2em} ^{c}\bf{T}_w</a>
<span class="sourceLineNo">1835</span><a id="line.1835">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1836</span><a id="line.1836">     *   X_{w} \\</a>
<span class="sourceLineNo">1837</span><a id="line.1837">     *   Y_{w} \\</a>
<span class="sourceLineNo">1838</span><a id="line.1838">     *   Z_{w} \\</a>
<span class="sourceLineNo">1839</span><a id="line.1839">     *   1</a>
<span class="sourceLineNo">1840</span><a id="line.1840">     *   \end{bmatrix} \\</a>
<span class="sourceLineNo">1841</span><a id="line.1841">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1842</span><a id="line.1842">     *   X_c \\</a>
<span class="sourceLineNo">1843</span><a id="line.1843">     *   Y_c \\</a>
<span class="sourceLineNo">1844</span><a id="line.1844">     *   Z_c \\</a>
<span class="sourceLineNo">1845</span><a id="line.1845">     *   1</a>
<span class="sourceLineNo">1846</span><a id="line.1846">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">1847</span><a id="line.1847">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1848</span><a id="line.1848">     *   r_{11} &amp;amp; r_{12} &amp;amp; r_{13} &amp;amp; t_x \\</a>
<span class="sourceLineNo">1849</span><a id="line.1849">     *   r_{21} &amp;amp; r_{22} &amp;amp; r_{23} &amp;amp; t_y \\</a>
<span class="sourceLineNo">1850</span><a id="line.1850">     *   r_{31} &amp;amp; r_{32} &amp;amp; r_{33} &amp;amp; t_z \\</a>
<span class="sourceLineNo">1851</span><a id="line.1851">     *   0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">1852</span><a id="line.1852">     *   \end{bmatrix}</a>
<span class="sourceLineNo">1853</span><a id="line.1853">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">1854</span><a id="line.1854">     *   X_{w} \\</a>
<span class="sourceLineNo">1855</span><a id="line.1855">     *   Y_{w} \\</a>
<span class="sourceLineNo">1856</span><a id="line.1856">     *   Z_{w} \\</a>
<span class="sourceLineNo">1857</span><a id="line.1857">     *   1</a>
<span class="sourceLineNo">1858</span><a id="line.1858">     *   \end{bmatrix}</a>
<span class="sourceLineNo">1859</span><a id="line.1859">     *   \end{align*}</a>
<span class="sourceLineNo">1860</span><a id="line.1860">     * \)</a>
<span class="sourceLineNo">1861</span><a id="line.1861">     *</a>
<span class="sourceLineNo">1862</span><a id="line.1862">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">1863</span><a id="line.1863">     * &lt;ul&gt;</a>
<span class="sourceLineNo">1864</span><a id="line.1864">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1865</span><a id="line.1865">     *       An example of how to use solvePnP for planar augmented reality can be found at</a>
<span class="sourceLineNo">1866</span><a id="line.1866">     *         opencv_source_code/samples/python/plane_ar.py</a>
<span class="sourceLineNo">1867</span><a id="line.1867">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1868</span><a id="line.1868">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1869</span><a id="line.1869">     *       If you are using Python:</a>
<span class="sourceLineNo">1870</span><a id="line.1870">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">1871</span><a id="line.1871">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1872</span><a id="line.1872">     *          Numpy array slices won't work as input because solvePnP requires contiguous</a>
<span class="sourceLineNo">1873</span><a id="line.1873">     *         arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of</a>
<span class="sourceLineNo">1874</span><a id="line.1874">     *         modules/calib3d/src/solvepnp.cpp version 2.4.9)</a>
<span class="sourceLineNo">1875</span><a id="line.1875">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1876</span><a id="line.1876">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1877</span><a id="line.1877">     *          The P3P algorithm requires image points to be in an array of shape (N,1,2) due</a>
<span class="sourceLineNo">1878</span><a id="line.1878">     *         to its calling of cv::undistortPoints (around line 75 of modules/calib3d/src/solvepnp.cpp version 2.4.9)</a>
<span class="sourceLineNo">1879</span><a id="line.1879">     *         which requires 2-channel information.</a>
<span class="sourceLineNo">1880</span><a id="line.1880">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1881</span><a id="line.1881">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1882</span><a id="line.1882">     *          Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of</a>
<span class="sourceLineNo">1883</span><a id="line.1883">     *         it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =</a>
<span class="sourceLineNo">1884</span><a id="line.1884">     *         np.ascontiguousarray(D[:,:2]).reshape((N,1,2))</a>
<span class="sourceLineNo">1885</span><a id="line.1885">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1886</span><a id="line.1886">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">1887</span><a id="line.1887">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1888</span><a id="line.1888">     *       The methods REF: SOLVEPNP_DLS and REF: SOLVEPNP_UPNP cannot be used as the current implementations are</a>
<span class="sourceLineNo">1889</span><a id="line.1889">     *        unstable and sometimes give completely wrong results. If you pass one of these two</a>
<span class="sourceLineNo">1890</span><a id="line.1890">     *        flags, REF: SOLVEPNP_EPNP method will be used instead.</a>
<span class="sourceLineNo">1891</span><a id="line.1891">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1892</span><a id="line.1892">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1893</span><a id="line.1893">     *       The minimum number of points is 4 in the general case. In the case of REF: SOLVEPNP_P3P and REF: SOLVEPNP_AP3P</a>
<span class="sourceLineNo">1894</span><a id="line.1894">     *        methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions</a>
<span class="sourceLineNo">1895</span><a id="line.1895">     *        of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).</a>
<span class="sourceLineNo">1896</span><a id="line.1896">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1897</span><a id="line.1897">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1898</span><a id="line.1898">     *       With REF: SOLVEPNP_ITERATIVE method and {@code useExtrinsicGuess=true}, the minimum number of points is 3 (3 points</a>
<span class="sourceLineNo">1899</span><a id="line.1899">     *        are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the</a>
<span class="sourceLineNo">1900</span><a id="line.1900">     *        global solution to converge.</a>
<span class="sourceLineNo">1901</span><a id="line.1901">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1902</span><a id="line.1902">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1903</span><a id="line.1903">     *       With REF: SOLVEPNP_IPPE input points must be &amp;gt;= 4 and object points must be coplanar.</a>
<span class="sourceLineNo">1904</span><a id="line.1904">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1905</span><a id="line.1905">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1906</span><a id="line.1906">     *       With REF: SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation.</a>
<span class="sourceLineNo">1907</span><a id="line.1907">     *        Number of input points must be 4. Object points must be defined in the following order:</a>
<span class="sourceLineNo">1908</span><a id="line.1908">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">1909</span><a id="line.1909">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1910</span><a id="line.1910">     *           point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">1911</span><a id="line.1911">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1912</span><a id="line.1912">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1913</span><a id="line.1913">     *           point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">1914</span><a id="line.1914">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1915</span><a id="line.1915">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1916</span><a id="line.1916">     *           point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">1917</span><a id="line.1917">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1918</span><a id="line.1918">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1919</span><a id="line.1919">     *           point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">1920</span><a id="line.1920">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1921</span><a id="line.1921">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">1922</span><a id="line.1922">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">1923</span><a id="line.1923">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1924</span><a id="line.1924">     *       With REF: SOLVEPNP_SQPNP input points must be &amp;gt;= 3</a>
<span class="sourceLineNo">1925</span><a id="line.1925">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1926</span><a id="line.1926">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">1927</span><a id="line.1927">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1928</span><a id="line.1928">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">1929</span><a id="line.1929">     * @return automatically generated</a>
<span class="sourceLineNo">1930</span><a id="line.1930">     */</a>
<span class="sourceLineNo">1931</span><a id="line.1931">    public static boolean solvePnP(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess) {</a>
<span class="sourceLineNo">1932</span><a id="line.1932">        Mat objectPoints_mat = objectPoints;</a>
<span class="sourceLineNo">1933</span><a id="line.1933">        Mat imagePoints_mat = imagePoints;</a>
<span class="sourceLineNo">1934</span><a id="line.1934">        Mat distCoeffs_mat = distCoeffs;</a>
<span class="sourceLineNo">1935</span><a id="line.1935">        return solvePnP_1(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, cameraMatrix.nativeObj, distCoeffs_mat.nativeObj, rvec.nativeObj, tvec.nativeObj, useExtrinsicGuess);</a>
<span class="sourceLineNo">1936</span><a id="line.1936">    }</a>
<span class="sourceLineNo">1937</span><a id="line.1937"></a>
<span class="sourceLineNo">1938</span><a id="line.1938">    /**</a>
<span class="sourceLineNo">1939</span><a id="line.1939">     * Finds an object pose from 3D-2D point correspondences.</a>
<span class="sourceLineNo">1940</span><a id="line.1940">     * This function returns the rotation and the translation vectors that transform a 3D point expressed in the object</a>
<span class="sourceLineNo">1941</span><a id="line.1941">     * coordinate frame to the camera coordinate frame, using different methods:</a>
<span class="sourceLineNo">1942</span><a id="line.1942">     * &lt;ul&gt;</a>
<span class="sourceLineNo">1943</span><a id="line.1943">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1944</span><a id="line.1944">     *  P3P methods (REF: SOLVEPNP_P3P, REF: SOLVEPNP_AP3P): need 4 input points to return a unique solution.</a>
<span class="sourceLineNo">1945</span><a id="line.1945">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1946</span><a id="line.1946">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1947</span><a id="line.1947">     *  REF: SOLVEPNP_IPPE Input points must be &amp;gt;= 4 and object points must be coplanar.</a>
<span class="sourceLineNo">1948</span><a id="line.1948">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1949</span><a id="line.1949">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1950</span><a id="line.1950">     *  REF: SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.</a>
<span class="sourceLineNo">1951</span><a id="line.1951">     * Number of input points must be 4. Object points must be defined in the following order:</a>
<span class="sourceLineNo">1952</span><a id="line.1952">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">1953</span><a id="line.1953">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1954</span><a id="line.1954">     *    point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">1955</span><a id="line.1955">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1956</span><a id="line.1956">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1957</span><a id="line.1957">     *    point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">1958</span><a id="line.1958">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1959</span><a id="line.1959">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1960</span><a id="line.1960">     *    point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">1961</span><a id="line.1961">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1962</span><a id="line.1962">     *     &lt;li&gt;</a>
<span class="sourceLineNo">1963</span><a id="line.1963">     *    point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">1964</span><a id="line.1964">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">1965</span><a id="line.1965">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">1966</span><a id="line.1966">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1967</span><a id="line.1967">     *  for all the other flags, number of input points must be &amp;gt;= 4 and object points can be in any configuration.</a>
<span class="sourceLineNo">1968</span><a id="line.1968">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1969</span><a id="line.1969">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">1970</span><a id="line.1970">     *</a>
<span class="sourceLineNo">1971</span><a id="line.1971">     * @param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or</a>
<span class="sourceLineNo">1972</span><a id="line.1972">     * 1xN/Nx1 3-channel, where N is the number of points. vector&amp;lt;Point3d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">1973</span><a id="line.1973">     * @param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,</a>
<span class="sourceLineNo">1974</span><a id="line.1974">     * where N is the number of points. vector&amp;lt;Point2d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">1975</span><a id="line.1975">     * @param cameraMatrix Input camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">1976</span><a id="line.1976">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">1977</span><a id="line.1977">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">1978</span><a id="line.1978">     * assumed.</a>
<span class="sourceLineNo">1979</span><a id="line.1979">     * @param rvec Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from</a>
<span class="sourceLineNo">1980</span><a id="line.1980">     * the model coordinate system to the camera coordinate system.</a>
<span class="sourceLineNo">1981</span><a id="line.1981">     * @param tvec Output translation vector.</a>
<span class="sourceLineNo">1982</span><a id="line.1982">     * the provided rvec and tvec values as initial approximations of the rotation and translation</a>
<span class="sourceLineNo">1983</span><a id="line.1983">     * vectors, respectively, and further optimizes them.</a>
<span class="sourceLineNo">1984</span><a id="line.1984">     * &lt;ul&gt;</a>
<span class="sourceLineNo">1985</span><a id="line.1985">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1986</span><a id="line.1986">     *    REF: SOLVEPNP_ITERATIVE Iterative method is based on a Levenberg-Marquardt optimization. In</a>
<span class="sourceLineNo">1987</span><a id="line.1987">     * this case the function finds such a pose that minimizes reprojection error, that is the sum</a>
<span class="sourceLineNo">1988</span><a id="line.1988">     * of squared distances between the observed projections imagePoints and the projected (using</a>
<span class="sourceLineNo">1989</span><a id="line.1989">     * REF: projectPoints ) objectPoints .</a>
<span class="sourceLineNo">1990</span><a id="line.1990">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1991</span><a id="line.1991">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1992</span><a id="line.1992">     *    REF: SOLVEPNP_P3P Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang</a>
<span class="sourceLineNo">1993</span><a id="line.1993">     * "Complete Solution Classification for the Perspective-Three-Point Problem" (CITE: gao2003complete).</a>
<span class="sourceLineNo">1994</span><a id="line.1994">     * In this case the function requires exactly four object and image points.</a>
<span class="sourceLineNo">1995</span><a id="line.1995">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">1996</span><a id="line.1996">     *   &lt;li&gt;</a>
<span class="sourceLineNo">1997</span><a id="line.1997">     *    REF: SOLVEPNP_AP3P Method is based on the paper of T. Ke, S. Roumeliotis</a>
<span class="sourceLineNo">1998</span><a id="line.1998">     * "An Efficient Algebraic Solution to the Perspective-Three-Point Problem" (CITE: Ke17).</a>
<span class="sourceLineNo">1999</span><a id="line.1999">     * In this case the function requires exactly four object and image points.</a>
<span class="sourceLineNo">2000</span><a id="line.2000">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2001</span><a id="line.2001">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2002</span><a id="line.2002">     *    REF: SOLVEPNP_EPNP Method has been introduced by F. Moreno-Noguer, V. Lepetit and P. Fua in the</a>
<span class="sourceLineNo">2003</span><a id="line.2003">     * paper "EPnP: Efficient Perspective-n-Point Camera Pose Estimation" (CITE: lepetit2009epnp).</a>
<span class="sourceLineNo">2004</span><a id="line.2004">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2005</span><a id="line.2005">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2006</span><a id="line.2006">     *    REF: SOLVEPNP_DLS &lt;b&gt;Broken implementation. Using this flag will fallback to EPnP.&lt;/b&gt; \n</a>
<span class="sourceLineNo">2007</span><a id="line.2007">     * Method is based on the paper of J. Hesch and S. Roumeliotis.</a>
<span class="sourceLineNo">2008</span><a id="line.2008">     * "A Direct Least-Squares (DLS) Method for PnP" (CITE: hesch2011direct).</a>
<span class="sourceLineNo">2009</span><a id="line.2009">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2010</span><a id="line.2010">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2011</span><a id="line.2011">     *    REF: SOLVEPNP_UPNP &lt;b&gt;Broken implementation. Using this flag will fallback to EPnP.&lt;/b&gt; \n</a>
<span class="sourceLineNo">2012</span><a id="line.2012">     * Method is based on the paper of A. Penate-Sanchez, J. Andrade-Cetto,</a>
<span class="sourceLineNo">2013</span><a id="line.2013">     * F. Moreno-Noguer. "Exhaustive Linearization for Robust Camera Pose and Focal Length</a>
<span class="sourceLineNo">2014</span><a id="line.2014">     * Estimation" (CITE: penate2013exhaustive). In this case the function also estimates the parameters \(f_x\) and \(f_y\)</a>
<span class="sourceLineNo">2015</span><a id="line.2015">     * assuming that both have the same value. Then the cameraMatrix is updated with the estimated</a>
<span class="sourceLineNo">2016</span><a id="line.2016">     * focal length.</a>
<span class="sourceLineNo">2017</span><a id="line.2017">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2018</span><a id="line.2018">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2019</span><a id="line.2019">     *    REF: SOLVEPNP_IPPE Method is based on the paper of T. Collins and A. Bartoli.</a>
<span class="sourceLineNo">2020</span><a id="line.2020">     * "Infinitesimal Plane-Based Pose Estimation" (CITE: Collins14). This method requires coplanar object points.</a>
<span class="sourceLineNo">2021</span><a id="line.2021">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2022</span><a id="line.2022">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2023</span><a id="line.2023">     *    REF: SOLVEPNP_IPPE_SQUARE Method is based on the paper of Toby Collins and Adrien Bartoli.</a>
<span class="sourceLineNo">2024</span><a id="line.2024">     * "Infinitesimal Plane-Based Pose Estimation" (CITE: Collins14). This method is suitable for marker pose estimation.</a>
<span class="sourceLineNo">2025</span><a id="line.2025">     * It requires 4 coplanar object points defined in the following order:</a>
<span class="sourceLineNo">2026</span><a id="line.2026">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">2027</span><a id="line.2027">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2028</span><a id="line.2028">     *    point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">2029</span><a id="line.2029">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2030</span><a id="line.2030">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2031</span><a id="line.2031">     *    point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">2032</span><a id="line.2032">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2033</span><a id="line.2033">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2034</span><a id="line.2034">     *    point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">2035</span><a id="line.2035">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2036</span><a id="line.2036">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2037</span><a id="line.2037">     *    point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">2038</span><a id="line.2038">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2039</span><a id="line.2039">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">2040</span><a id="line.2040">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2041</span><a id="line.2041">     *    REF: SOLVEPNP_SQPNP Method is based on the paper "A Consistently Fast and Globally Optimal Solution to the</a>
<span class="sourceLineNo">2042</span><a id="line.2042">     * Perspective-n-Point Problem" by G. Terzakis and M.Lourakis (CITE: Terzakis20). It requires 3 or more points.</a>
<span class="sourceLineNo">2043</span><a id="line.2043">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2044</span><a id="line.2044">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">2045</span><a id="line.2045">     *</a>
<span class="sourceLineNo">2046</span><a id="line.2046">     *</a>
<span class="sourceLineNo">2047</span><a id="line.2047">     * The function estimates the object pose given a set of object points, their corresponding image</a>
<span class="sourceLineNo">2048</span><a id="line.2048">     * projections, as well as the camera intrinsic matrix and the distortion coefficients, see the figure below</a>
<span class="sourceLineNo">2049</span><a id="line.2049">     * (more precisely, the X-axis of the camera frame is pointing to the right, the Y-axis downward</a>
<span class="sourceLineNo">2050</span><a id="line.2050">     * and the Z-axis forward).</a>
<span class="sourceLineNo">2051</span><a id="line.2051">     *</a>
<span class="sourceLineNo">2052</span><a id="line.2052">     * ![](pnp.jpg)</a>
<span class="sourceLineNo">2053</span><a id="line.2053">     *</a>
<span class="sourceLineNo">2054</span><a id="line.2054">     * Points expressed in the world frame \( \bf{X}_w \) are projected into the image plane \( \left[ u, v \right] \)</a>
<span class="sourceLineNo">2055</span><a id="line.2055">     * using the perspective projection model \( \Pi \) and the camera intrinsic parameters matrix \( \bf{A} \):</a>
<span class="sourceLineNo">2056</span><a id="line.2056">     *</a>
<span class="sourceLineNo">2057</span><a id="line.2057">     * \(</a>
<span class="sourceLineNo">2058</span><a id="line.2058">     *   \begin{align*}</a>
<span class="sourceLineNo">2059</span><a id="line.2059">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">2060</span><a id="line.2060">     *   u \\</a>
<span class="sourceLineNo">2061</span><a id="line.2061">     *   v \\</a>
<span class="sourceLineNo">2062</span><a id="line.2062">     *   1</a>
<span class="sourceLineNo">2063</span><a id="line.2063">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">2064</span><a id="line.2064">     *   \bf{A} \hspace{0.1em} \Pi \hspace{0.2em} ^{c}\bf{T}_w</a>
<span class="sourceLineNo">2065</span><a id="line.2065">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">2066</span><a id="line.2066">     *   X_{w} \\</a>
<span class="sourceLineNo">2067</span><a id="line.2067">     *   Y_{w} \\</a>
<span class="sourceLineNo">2068</span><a id="line.2068">     *   Z_{w} \\</a>
<span class="sourceLineNo">2069</span><a id="line.2069">     *   1</a>
<span class="sourceLineNo">2070</span><a id="line.2070">     *   \end{bmatrix} \\</a>
<span class="sourceLineNo">2071</span><a id="line.2071">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">2072</span><a id="line.2072">     *   u \\</a>
<span class="sourceLineNo">2073</span><a id="line.2073">     *   v \\</a>
<span class="sourceLineNo">2074</span><a id="line.2074">     *   1</a>
<span class="sourceLineNo">2075</span><a id="line.2075">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">2076</span><a id="line.2076">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">2077</span><a id="line.2077">     *   f_x &amp;amp; 0 &amp;amp; c_x \\</a>
<span class="sourceLineNo">2078</span><a id="line.2078">     *   0 &amp;amp; f_y &amp;amp; c_y \\</a>
<span class="sourceLineNo">2079</span><a id="line.2079">     *   0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">2080</span><a id="line.2080">     *   \end{bmatrix}</a>
<span class="sourceLineNo">2081</span><a id="line.2081">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">2082</span><a id="line.2082">     *   1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\</a>
<span class="sourceLineNo">2083</span><a id="line.2083">     *   0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\</a>
<span class="sourceLineNo">2084</span><a id="line.2084">     *   0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">2085</span><a id="line.2085">     *   \end{bmatrix}</a>
<span class="sourceLineNo">2086</span><a id="line.2086">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">2087</span><a id="line.2087">     *   r_{11} &amp;amp; r_{12} &amp;amp; r_{13} &amp;amp; t_x \\</a>
<span class="sourceLineNo">2088</span><a id="line.2088">     *   r_{21} &amp;amp; r_{22} &amp;amp; r_{23} &amp;amp; t_y \\</a>
<span class="sourceLineNo">2089</span><a id="line.2089">     *   r_{31} &amp;amp; r_{32} &amp;amp; r_{33} &amp;amp; t_z \\</a>
<span class="sourceLineNo">2090</span><a id="line.2090">     *   0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">2091</span><a id="line.2091">     *   \end{bmatrix}</a>
<span class="sourceLineNo">2092</span><a id="line.2092">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">2093</span><a id="line.2093">     *   X_{w} \\</a>
<span class="sourceLineNo">2094</span><a id="line.2094">     *   Y_{w} \\</a>
<span class="sourceLineNo">2095</span><a id="line.2095">     *   Z_{w} \\</a>
<span class="sourceLineNo">2096</span><a id="line.2096">     *   1</a>
<span class="sourceLineNo">2097</span><a id="line.2097">     *   \end{bmatrix}</a>
<span class="sourceLineNo">2098</span><a id="line.2098">     *   \end{align*}</a>
<span class="sourceLineNo">2099</span><a id="line.2099">     * \)</a>
<span class="sourceLineNo">2100</span><a id="line.2100">     *</a>
<span class="sourceLineNo">2101</span><a id="line.2101">     * The estimated pose is thus the rotation ({@code rvec}) and the translation ({@code tvec}) vectors that allow transforming</a>
<span class="sourceLineNo">2102</span><a id="line.2102">     * a 3D point expressed in the world frame into the camera frame:</a>
<span class="sourceLineNo">2103</span><a id="line.2103">     *</a>
<span class="sourceLineNo">2104</span><a id="line.2104">     * \(</a>
<span class="sourceLineNo">2105</span><a id="line.2105">     *   \begin{align*}</a>
<span class="sourceLineNo">2106</span><a id="line.2106">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">2107</span><a id="line.2107">     *   X_c \\</a>
<span class="sourceLineNo">2108</span><a id="line.2108">     *   Y_c \\</a>
<span class="sourceLineNo">2109</span><a id="line.2109">     *   Z_c \\</a>
<span class="sourceLineNo">2110</span><a id="line.2110">     *   1</a>
<span class="sourceLineNo">2111</span><a id="line.2111">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">2112</span><a id="line.2112">     *   \hspace{0.2em} ^{c}\bf{T}_w</a>
<span class="sourceLineNo">2113</span><a id="line.2113">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">2114</span><a id="line.2114">     *   X_{w} \\</a>
<span class="sourceLineNo">2115</span><a id="line.2115">     *   Y_{w} \\</a>
<span class="sourceLineNo">2116</span><a id="line.2116">     *   Z_{w} \\</a>
<span class="sourceLineNo">2117</span><a id="line.2117">     *   1</a>
<span class="sourceLineNo">2118</span><a id="line.2118">     *   \end{bmatrix} \\</a>
<span class="sourceLineNo">2119</span><a id="line.2119">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">2120</span><a id="line.2120">     *   X_c \\</a>
<span class="sourceLineNo">2121</span><a id="line.2121">     *   Y_c \\</a>
<span class="sourceLineNo">2122</span><a id="line.2122">     *   Z_c \\</a>
<span class="sourceLineNo">2123</span><a id="line.2123">     *   1</a>
<span class="sourceLineNo">2124</span><a id="line.2124">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">2125</span><a id="line.2125">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">2126</span><a id="line.2126">     *   r_{11} &amp;amp; r_{12} &amp;amp; r_{13} &amp;amp; t_x \\</a>
<span class="sourceLineNo">2127</span><a id="line.2127">     *   r_{21} &amp;amp; r_{22} &amp;amp; r_{23} &amp;amp; t_y \\</a>
<span class="sourceLineNo">2128</span><a id="line.2128">     *   r_{31} &amp;amp; r_{32} &amp;amp; r_{33} &amp;amp; t_z \\</a>
<span class="sourceLineNo">2129</span><a id="line.2129">     *   0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">2130</span><a id="line.2130">     *   \end{bmatrix}</a>
<span class="sourceLineNo">2131</span><a id="line.2131">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">2132</span><a id="line.2132">     *   X_{w} \\</a>
<span class="sourceLineNo">2133</span><a id="line.2133">     *   Y_{w} \\</a>
<span class="sourceLineNo">2134</span><a id="line.2134">     *   Z_{w} \\</a>
<span class="sourceLineNo">2135</span><a id="line.2135">     *   1</a>
<span class="sourceLineNo">2136</span><a id="line.2136">     *   \end{bmatrix}</a>
<span class="sourceLineNo">2137</span><a id="line.2137">     *   \end{align*}</a>
<span class="sourceLineNo">2138</span><a id="line.2138">     * \)</a>
<span class="sourceLineNo">2139</span><a id="line.2139">     *</a>
<span class="sourceLineNo">2140</span><a id="line.2140">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">2141</span><a id="line.2141">     * &lt;ul&gt;</a>
<span class="sourceLineNo">2142</span><a id="line.2142">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2143</span><a id="line.2143">     *       An example of how to use solvePnP for planar augmented reality can be found at</a>
<span class="sourceLineNo">2144</span><a id="line.2144">     *         opencv_source_code/samples/python/plane_ar.py</a>
<span class="sourceLineNo">2145</span><a id="line.2145">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2146</span><a id="line.2146">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2147</span><a id="line.2147">     *       If you are using Python:</a>
<span class="sourceLineNo">2148</span><a id="line.2148">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">2149</span><a id="line.2149">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2150</span><a id="line.2150">     *          Numpy array slices won't work as input because solvePnP requires contiguous</a>
<span class="sourceLineNo">2151</span><a id="line.2151">     *         arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of</a>
<span class="sourceLineNo">2152</span><a id="line.2152">     *         modules/calib3d/src/solvepnp.cpp version 2.4.9)</a>
<span class="sourceLineNo">2153</span><a id="line.2153">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2154</span><a id="line.2154">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2155</span><a id="line.2155">     *          The P3P algorithm requires image points to be in an array of shape (N,1,2) due</a>
<span class="sourceLineNo">2156</span><a id="line.2156">     *         to its calling of cv::undistortPoints (around line 75 of modules/calib3d/src/solvepnp.cpp version 2.4.9)</a>
<span class="sourceLineNo">2157</span><a id="line.2157">     *         which requires 2-channel information.</a>
<span class="sourceLineNo">2158</span><a id="line.2158">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2159</span><a id="line.2159">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2160</span><a id="line.2160">     *          Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of</a>
<span class="sourceLineNo">2161</span><a id="line.2161">     *         it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =</a>
<span class="sourceLineNo">2162</span><a id="line.2162">     *         np.ascontiguousarray(D[:,:2]).reshape((N,1,2))</a>
<span class="sourceLineNo">2163</span><a id="line.2163">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2164</span><a id="line.2164">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">2165</span><a id="line.2165">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2166</span><a id="line.2166">     *       The methods REF: SOLVEPNP_DLS and REF: SOLVEPNP_UPNP cannot be used as the current implementations are</a>
<span class="sourceLineNo">2167</span><a id="line.2167">     *        unstable and sometimes give completely wrong results. If you pass one of these two</a>
<span class="sourceLineNo">2168</span><a id="line.2168">     *        flags, REF: SOLVEPNP_EPNP method will be used instead.</a>
<span class="sourceLineNo">2169</span><a id="line.2169">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2170</span><a id="line.2170">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2171</span><a id="line.2171">     *       The minimum number of points is 4 in the general case. In the case of REF: SOLVEPNP_P3P and REF: SOLVEPNP_AP3P</a>
<span class="sourceLineNo">2172</span><a id="line.2172">     *        methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions</a>
<span class="sourceLineNo">2173</span><a id="line.2173">     *        of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).</a>
<span class="sourceLineNo">2174</span><a id="line.2174">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2175</span><a id="line.2175">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2176</span><a id="line.2176">     *       With REF: SOLVEPNP_ITERATIVE method and {@code useExtrinsicGuess=true}, the minimum number of points is 3 (3 points</a>
<span class="sourceLineNo">2177</span><a id="line.2177">     *        are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the</a>
<span class="sourceLineNo">2178</span><a id="line.2178">     *        global solution to converge.</a>
<span class="sourceLineNo">2179</span><a id="line.2179">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2180</span><a id="line.2180">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2181</span><a id="line.2181">     *       With REF: SOLVEPNP_IPPE input points must be &amp;gt;= 4 and object points must be coplanar.</a>
<span class="sourceLineNo">2182</span><a id="line.2182">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2183</span><a id="line.2183">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2184</span><a id="line.2184">     *       With REF: SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation.</a>
<span class="sourceLineNo">2185</span><a id="line.2185">     *        Number of input points must be 4. Object points must be defined in the following order:</a>
<span class="sourceLineNo">2186</span><a id="line.2186">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">2187</span><a id="line.2187">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2188</span><a id="line.2188">     *           point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">2189</span><a id="line.2189">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2190</span><a id="line.2190">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2191</span><a id="line.2191">     *           point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">2192</span><a id="line.2192">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2193</span><a id="line.2193">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2194</span><a id="line.2194">     *           point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">2195</span><a id="line.2195">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2196</span><a id="line.2196">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2197</span><a id="line.2197">     *           point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">2198</span><a id="line.2198">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2199</span><a id="line.2199">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">2200</span><a id="line.2200">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">2201</span><a id="line.2201">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2202</span><a id="line.2202">     *       With REF: SOLVEPNP_SQPNP input points must be &amp;gt;= 3</a>
<span class="sourceLineNo">2203</span><a id="line.2203">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2204</span><a id="line.2204">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">2205</span><a id="line.2205">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2206</span><a id="line.2206">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">2207</span><a id="line.2207">     * @return automatically generated</a>
<span class="sourceLineNo">2208</span><a id="line.2208">     */</a>
<span class="sourceLineNo">2209</span><a id="line.2209">    public static boolean solvePnP(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec) {</a>
<span class="sourceLineNo">2210</span><a id="line.2210">        Mat objectPoints_mat = objectPoints;</a>
<span class="sourceLineNo">2211</span><a id="line.2211">        Mat imagePoints_mat = imagePoints;</a>
<span class="sourceLineNo">2212</span><a id="line.2212">        Mat distCoeffs_mat = distCoeffs;</a>
<span class="sourceLineNo">2213</span><a id="line.2213">        return solvePnP_2(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, cameraMatrix.nativeObj, distCoeffs_mat.nativeObj, rvec.nativeObj, tvec.nativeObj);</a>
<span class="sourceLineNo">2214</span><a id="line.2214">    }</a>
<span class="sourceLineNo">2215</span><a id="line.2215"></a>
<span class="sourceLineNo">2216</span><a id="line.2216"></a>
<span class="sourceLineNo">2217</span><a id="line.2217">    //</a>
<span class="sourceLineNo">2218</span><a id="line.2218">    // C++:  bool cv::solvePnPRansac(vector_Point3f objectPoints, vector_Point2f imagePoints, Mat cameraMatrix, vector_double distCoeffs, Mat&amp; rvec, Mat&amp; tvec, bool useExtrinsicGuess = false, int iterationsCount = 100, float reprojectionError = 8.0, double confidence = 0.99, Mat&amp; inliers = Mat(), int flags = SOLVEPNP_ITERATIVE)</a>
<span class="sourceLineNo">2219</span><a id="line.2219">    //</a>
<span class="sourceLineNo">2220</span><a id="line.2220"></a>
<span class="sourceLineNo">2221</span><a id="line.2221">    /**</a>
<span class="sourceLineNo">2222</span><a id="line.2222">     * Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.</a>
<span class="sourceLineNo">2223</span><a id="line.2223">     *</a>
<span class="sourceLineNo">2224</span><a id="line.2224">     * @param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or</a>
<span class="sourceLineNo">2225</span><a id="line.2225">     * 1xN/Nx1 3-channel, where N is the number of points. vector&amp;lt;Point3d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">2226</span><a id="line.2226">     * @param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,</a>
<span class="sourceLineNo">2227</span><a id="line.2227">     * where N is the number of points. vector&amp;lt;Point2d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">2228</span><a id="line.2228">     * @param cameraMatrix Input camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">2229</span><a id="line.2229">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">2230</span><a id="line.2230">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">2231</span><a id="line.2231">     * assumed.</a>
<span class="sourceLineNo">2232</span><a id="line.2232">     * @param rvec Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from</a>
<span class="sourceLineNo">2233</span><a id="line.2233">     * the model coordinate system to the camera coordinate system.</a>
<span class="sourceLineNo">2234</span><a id="line.2234">     * @param tvec Output translation vector.</a>
<span class="sourceLineNo">2235</span><a id="line.2235">     * @param useExtrinsicGuess Parameter used for REF: SOLVEPNP_ITERATIVE. If true (1), the function uses</a>
<span class="sourceLineNo">2236</span><a id="line.2236">     * the provided rvec and tvec values as initial approximations of the rotation and translation</a>
<span class="sourceLineNo">2237</span><a id="line.2237">     * vectors, respectively, and further optimizes them.</a>
<span class="sourceLineNo">2238</span><a id="line.2238">     * @param iterationsCount Number of iterations.</a>
<span class="sourceLineNo">2239</span><a id="line.2239">     * @param reprojectionError Inlier threshold value used by the RANSAC procedure. The parameter value</a>
<span class="sourceLineNo">2240</span><a id="line.2240">     * is the maximum allowed distance between the observed and computed point projections to consider it</a>
<span class="sourceLineNo">2241</span><a id="line.2241">     * an inlier.</a>
<span class="sourceLineNo">2242</span><a id="line.2242">     * @param confidence The probability that the algorithm produces a useful result.</a>
<span class="sourceLineNo">2243</span><a id="line.2243">     * @param inliers Output vector that contains indices of inliers in objectPoints and imagePoints .</a>
<span class="sourceLineNo">2244</span><a id="line.2244">     * @param flags Method for solving a PnP problem (see REF: solvePnP ).</a>
<span class="sourceLineNo">2245</span><a id="line.2245">     *</a>
<span class="sourceLineNo">2246</span><a id="line.2246">     * The function estimates an object pose given a set of object points, their corresponding image</a>
<span class="sourceLineNo">2247</span><a id="line.2247">     * projections, as well as the camera intrinsic matrix and the distortion coefficients. This function finds such</a>
<span class="sourceLineNo">2248</span><a id="line.2248">     * a pose that minimizes reprojection error, that is, the sum of squared distances between the observed</a>
<span class="sourceLineNo">2249</span><a id="line.2249">     * projections imagePoints and the projected (using REF: projectPoints ) objectPoints. The use of RANSAC</a>
<span class="sourceLineNo">2250</span><a id="line.2250">     * makes the function resistant to outliers.</a>
<span class="sourceLineNo">2251</span><a id="line.2251">     *</a>
<span class="sourceLineNo">2252</span><a id="line.2252">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">2253</span><a id="line.2253">     * &lt;ul&gt;</a>
<span class="sourceLineNo">2254</span><a id="line.2254">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2255</span><a id="line.2255">     *       An example of how to use solvePNPRansac for object detection can be found at</a>
<span class="sourceLineNo">2256</span><a id="line.2256">     *         opencv_source_code/samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/</a>
<span class="sourceLineNo">2257</span><a id="line.2257">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2258</span><a id="line.2258">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2259</span><a id="line.2259">     *       The default method used to estimate the camera pose for the Minimal Sample Sets step</a>
<span class="sourceLineNo">2260</span><a id="line.2260">     *        is #SOLVEPNP_EPNP. Exceptions are:</a>
<span class="sourceLineNo">2261</span><a id="line.2261">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">2262</span><a id="line.2262">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2263</span><a id="line.2263">     *           if you choose #SOLVEPNP_P3P or #SOLVEPNP_AP3P, these methods will be used.</a>
<span class="sourceLineNo">2264</span><a id="line.2264">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2265</span><a id="line.2265">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2266</span><a id="line.2266">     *           if the number of input points is equal to 4, #SOLVEPNP_P3P is used.</a>
<span class="sourceLineNo">2267</span><a id="line.2267">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2268</span><a id="line.2268">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">2269</span><a id="line.2269">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2270</span><a id="line.2270">     *       The method used to estimate the camera pose using all the inliers is defined by the</a>
<span class="sourceLineNo">2271</span><a id="line.2271">     *        flags parameters unless it is equal to #SOLVEPNP_P3P or #SOLVEPNP_AP3P. In this case,</a>
<span class="sourceLineNo">2272</span><a id="line.2272">     *        the method #SOLVEPNP_EPNP will be used instead.</a>
<span class="sourceLineNo">2273</span><a id="line.2273">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2274</span><a id="line.2274">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">2275</span><a id="line.2275">     * @return automatically generated</a>
<span class="sourceLineNo">2276</span><a id="line.2276">     */</a>
<span class="sourceLineNo">2277</span><a id="line.2277">    public static boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int iterationsCount, float reprojectionError, double confidence, Mat inliers, int flags) {</a>
<span class="sourceLineNo">2278</span><a id="line.2278">        Mat objectPoints_mat = objectPoints;</a>
<span class="sourceLineNo">2279</span><a id="line.2279">        Mat imagePoints_mat = imagePoints;</a>
<span class="sourceLineNo">2280</span><a id="line.2280">        Mat distCoeffs_mat = distCoeffs;</a>
<span class="sourceLineNo">2281</span><a id="line.2281">        return solvePnPRansac_0(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, cameraMatrix.nativeObj, distCoeffs_mat.nativeObj, rvec.nativeObj, tvec.nativeObj, useExtrinsicGuess, iterationsCount, reprojectionError, confidence, inliers.nativeObj, flags);</a>
<span class="sourceLineNo">2282</span><a id="line.2282">    }</a>
<span class="sourceLineNo">2283</span><a id="line.2283"></a>
<span class="sourceLineNo">2284</span><a id="line.2284">    /**</a>
<span class="sourceLineNo">2285</span><a id="line.2285">     * Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.</a>
<span class="sourceLineNo">2286</span><a id="line.2286">     *</a>
<span class="sourceLineNo">2287</span><a id="line.2287">     * @param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or</a>
<span class="sourceLineNo">2288</span><a id="line.2288">     * 1xN/Nx1 3-channel, where N is the number of points. vector&amp;lt;Point3d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">2289</span><a id="line.2289">     * @param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,</a>
<span class="sourceLineNo">2290</span><a id="line.2290">     * where N is the number of points. vector&amp;lt;Point2d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">2291</span><a id="line.2291">     * @param cameraMatrix Input camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">2292</span><a id="line.2292">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">2293</span><a id="line.2293">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">2294</span><a id="line.2294">     * assumed.</a>
<span class="sourceLineNo">2295</span><a id="line.2295">     * @param rvec Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from</a>
<span class="sourceLineNo">2296</span><a id="line.2296">     * the model coordinate system to the camera coordinate system.</a>
<span class="sourceLineNo">2297</span><a id="line.2297">     * @param tvec Output translation vector.</a>
<span class="sourceLineNo">2298</span><a id="line.2298">     * @param useExtrinsicGuess Parameter used for REF: SOLVEPNP_ITERATIVE. If true (1), the function uses</a>
<span class="sourceLineNo">2299</span><a id="line.2299">     * the provided rvec and tvec values as initial approximations of the rotation and translation</a>
<span class="sourceLineNo">2300</span><a id="line.2300">     * vectors, respectively, and further optimizes them.</a>
<span class="sourceLineNo">2301</span><a id="line.2301">     * @param iterationsCount Number of iterations.</a>
<span class="sourceLineNo">2302</span><a id="line.2302">     * @param reprojectionError Inlier threshold value used by the RANSAC procedure. The parameter value</a>
<span class="sourceLineNo">2303</span><a id="line.2303">     * is the maximum allowed distance between the observed and computed point projections to consider it</a>
<span class="sourceLineNo">2304</span><a id="line.2304">     * an inlier.</a>
<span class="sourceLineNo">2305</span><a id="line.2305">     * @param confidence The probability that the algorithm produces a useful result.</a>
<span class="sourceLineNo">2306</span><a id="line.2306">     * @param inliers Output vector that contains indices of inliers in objectPoints and imagePoints .</a>
<span class="sourceLineNo">2307</span><a id="line.2307">     *</a>
<span class="sourceLineNo">2308</span><a id="line.2308">     * The function estimates an object pose given a set of object points, their corresponding image</a>
<span class="sourceLineNo">2309</span><a id="line.2309">     * projections, as well as the camera intrinsic matrix and the distortion coefficients. This function finds such</a>
<span class="sourceLineNo">2310</span><a id="line.2310">     * a pose that minimizes reprojection error, that is, the sum of squared distances between the observed</a>
<span class="sourceLineNo">2311</span><a id="line.2311">     * projections imagePoints and the projected (using REF: projectPoints ) objectPoints. The use of RANSAC</a>
<span class="sourceLineNo">2312</span><a id="line.2312">     * makes the function resistant to outliers.</a>
<span class="sourceLineNo">2313</span><a id="line.2313">     *</a>
<span class="sourceLineNo">2314</span><a id="line.2314">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">2315</span><a id="line.2315">     * &lt;ul&gt;</a>
<span class="sourceLineNo">2316</span><a id="line.2316">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2317</span><a id="line.2317">     *       An example of how to use solvePNPRansac for object detection can be found at</a>
<span class="sourceLineNo">2318</span><a id="line.2318">     *         opencv_source_code/samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/</a>
<span class="sourceLineNo">2319</span><a id="line.2319">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2320</span><a id="line.2320">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2321</span><a id="line.2321">     *       The default method used to estimate the camera pose for the Minimal Sample Sets step</a>
<span class="sourceLineNo">2322</span><a id="line.2322">     *        is #SOLVEPNP_EPNP. Exceptions are:</a>
<span class="sourceLineNo">2323</span><a id="line.2323">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">2324</span><a id="line.2324">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2325</span><a id="line.2325">     *           if you choose #SOLVEPNP_P3P or #SOLVEPNP_AP3P, these methods will be used.</a>
<span class="sourceLineNo">2326</span><a id="line.2326">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2327</span><a id="line.2327">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2328</span><a id="line.2328">     *           if the number of input points is equal to 4, #SOLVEPNP_P3P is used.</a>
<span class="sourceLineNo">2329</span><a id="line.2329">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2330</span><a id="line.2330">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">2331</span><a id="line.2331">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2332</span><a id="line.2332">     *       The method used to estimate the camera pose using all the inliers is defined by the</a>
<span class="sourceLineNo">2333</span><a id="line.2333">     *        flags parameters unless it is equal to #SOLVEPNP_P3P or #SOLVEPNP_AP3P. In this case,</a>
<span class="sourceLineNo">2334</span><a id="line.2334">     *        the method #SOLVEPNP_EPNP will be used instead.</a>
<span class="sourceLineNo">2335</span><a id="line.2335">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2336</span><a id="line.2336">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">2337</span><a id="line.2337">     * @return automatically generated</a>
<span class="sourceLineNo">2338</span><a id="line.2338">     */</a>
<span class="sourceLineNo">2339</span><a id="line.2339">    public static boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int iterationsCount, float reprojectionError, double confidence, Mat inliers) {</a>
<span class="sourceLineNo">2340</span><a id="line.2340">        Mat objectPoints_mat = objectPoints;</a>
<span class="sourceLineNo">2341</span><a id="line.2341">        Mat imagePoints_mat = imagePoints;</a>
<span class="sourceLineNo">2342</span><a id="line.2342">        Mat distCoeffs_mat = distCoeffs;</a>
<span class="sourceLineNo">2343</span><a id="line.2343">        return solvePnPRansac_1(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, cameraMatrix.nativeObj, distCoeffs_mat.nativeObj, rvec.nativeObj, tvec.nativeObj, useExtrinsicGuess, iterationsCount, reprojectionError, confidence, inliers.nativeObj);</a>
<span class="sourceLineNo">2344</span><a id="line.2344">    }</a>
<span class="sourceLineNo">2345</span><a id="line.2345"></a>
<span class="sourceLineNo">2346</span><a id="line.2346">    /**</a>
<span class="sourceLineNo">2347</span><a id="line.2347">     * Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.</a>
<span class="sourceLineNo">2348</span><a id="line.2348">     *</a>
<span class="sourceLineNo">2349</span><a id="line.2349">     * @param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or</a>
<span class="sourceLineNo">2350</span><a id="line.2350">     * 1xN/Nx1 3-channel, where N is the number of points. vector&amp;lt;Point3d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">2351</span><a id="line.2351">     * @param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,</a>
<span class="sourceLineNo">2352</span><a id="line.2352">     * where N is the number of points. vector&amp;lt;Point2d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">2353</span><a id="line.2353">     * @param cameraMatrix Input camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">2354</span><a id="line.2354">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">2355</span><a id="line.2355">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">2356</span><a id="line.2356">     * assumed.</a>
<span class="sourceLineNo">2357</span><a id="line.2357">     * @param rvec Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from</a>
<span class="sourceLineNo">2358</span><a id="line.2358">     * the model coordinate system to the camera coordinate system.</a>
<span class="sourceLineNo">2359</span><a id="line.2359">     * @param tvec Output translation vector.</a>
<span class="sourceLineNo">2360</span><a id="line.2360">     * @param useExtrinsicGuess Parameter used for REF: SOLVEPNP_ITERATIVE. If true (1), the function uses</a>
<span class="sourceLineNo">2361</span><a id="line.2361">     * the provided rvec and tvec values as initial approximations of the rotation and translation</a>
<span class="sourceLineNo">2362</span><a id="line.2362">     * vectors, respectively, and further optimizes them.</a>
<span class="sourceLineNo">2363</span><a id="line.2363">     * @param iterationsCount Number of iterations.</a>
<span class="sourceLineNo">2364</span><a id="line.2364">     * @param reprojectionError Inlier threshold value used by the RANSAC procedure. The parameter value</a>
<span class="sourceLineNo">2365</span><a id="line.2365">     * is the maximum allowed distance between the observed and computed point projections to consider it</a>
<span class="sourceLineNo">2366</span><a id="line.2366">     * an inlier.</a>
<span class="sourceLineNo">2367</span><a id="line.2367">     * @param confidence The probability that the algorithm produces a useful result.</a>
<span class="sourceLineNo">2368</span><a id="line.2368">     *</a>
<span class="sourceLineNo">2369</span><a id="line.2369">     * The function estimates an object pose given a set of object points, their corresponding image</a>
<span class="sourceLineNo">2370</span><a id="line.2370">     * projections, as well as the camera intrinsic matrix and the distortion coefficients. This function finds such</a>
<span class="sourceLineNo">2371</span><a id="line.2371">     * a pose that minimizes reprojection error, that is, the sum of squared distances between the observed</a>
<span class="sourceLineNo">2372</span><a id="line.2372">     * projections imagePoints and the projected (using REF: projectPoints ) objectPoints. The use of RANSAC</a>
<span class="sourceLineNo">2373</span><a id="line.2373">     * makes the function resistant to outliers.</a>
<span class="sourceLineNo">2374</span><a id="line.2374">     *</a>
<span class="sourceLineNo">2375</span><a id="line.2375">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">2376</span><a id="line.2376">     * &lt;ul&gt;</a>
<span class="sourceLineNo">2377</span><a id="line.2377">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2378</span><a id="line.2378">     *       An example of how to use solvePNPRansac for object detection can be found at</a>
<span class="sourceLineNo">2379</span><a id="line.2379">     *         opencv_source_code/samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/</a>
<span class="sourceLineNo">2380</span><a id="line.2380">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2381</span><a id="line.2381">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2382</span><a id="line.2382">     *       The default method used to estimate the camera pose for the Minimal Sample Sets step</a>
<span class="sourceLineNo">2383</span><a id="line.2383">     *        is #SOLVEPNP_EPNP. Exceptions are:</a>
<span class="sourceLineNo">2384</span><a id="line.2384">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">2385</span><a id="line.2385">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2386</span><a id="line.2386">     *           if you choose #SOLVEPNP_P3P or #SOLVEPNP_AP3P, these methods will be used.</a>
<span class="sourceLineNo">2387</span><a id="line.2387">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2388</span><a id="line.2388">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2389</span><a id="line.2389">     *           if the number of input points is equal to 4, #SOLVEPNP_P3P is used.</a>
<span class="sourceLineNo">2390</span><a id="line.2390">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2391</span><a id="line.2391">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">2392</span><a id="line.2392">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2393</span><a id="line.2393">     *       The method used to estimate the camera pose using all the inliers is defined by the</a>
<span class="sourceLineNo">2394</span><a id="line.2394">     *        flags parameters unless it is equal to #SOLVEPNP_P3P or #SOLVEPNP_AP3P. In this case,</a>
<span class="sourceLineNo">2395</span><a id="line.2395">     *        the method #SOLVEPNP_EPNP will be used instead.</a>
<span class="sourceLineNo">2396</span><a id="line.2396">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2397</span><a id="line.2397">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">2398</span><a id="line.2398">     * @return automatically generated</a>
<span class="sourceLineNo">2399</span><a id="line.2399">     */</a>
<span class="sourceLineNo">2400</span><a id="line.2400">    public static boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int iterationsCount, float reprojectionError, double confidence) {</a>
<span class="sourceLineNo">2401</span><a id="line.2401">        Mat objectPoints_mat = objectPoints;</a>
<span class="sourceLineNo">2402</span><a id="line.2402">        Mat imagePoints_mat = imagePoints;</a>
<span class="sourceLineNo">2403</span><a id="line.2403">        Mat distCoeffs_mat = distCoeffs;</a>
<span class="sourceLineNo">2404</span><a id="line.2404">        return solvePnPRansac_2(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, cameraMatrix.nativeObj, distCoeffs_mat.nativeObj, rvec.nativeObj, tvec.nativeObj, useExtrinsicGuess, iterationsCount, reprojectionError, confidence);</a>
<span class="sourceLineNo">2405</span><a id="line.2405">    }</a>
<span class="sourceLineNo">2406</span><a id="line.2406"></a>
<span class="sourceLineNo">2407</span><a id="line.2407">    /**</a>
<span class="sourceLineNo">2408</span><a id="line.2408">     * Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.</a>
<span class="sourceLineNo">2409</span><a id="line.2409">     *</a>
<span class="sourceLineNo">2410</span><a id="line.2410">     * @param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or</a>
<span class="sourceLineNo">2411</span><a id="line.2411">     * 1xN/Nx1 3-channel, where N is the number of points. vector&amp;lt;Point3d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">2412</span><a id="line.2412">     * @param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,</a>
<span class="sourceLineNo">2413</span><a id="line.2413">     * where N is the number of points. vector&amp;lt;Point2d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">2414</span><a id="line.2414">     * @param cameraMatrix Input camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">2415</span><a id="line.2415">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">2416</span><a id="line.2416">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">2417</span><a id="line.2417">     * assumed.</a>
<span class="sourceLineNo">2418</span><a id="line.2418">     * @param rvec Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from</a>
<span class="sourceLineNo">2419</span><a id="line.2419">     * the model coordinate system to the camera coordinate system.</a>
<span class="sourceLineNo">2420</span><a id="line.2420">     * @param tvec Output translation vector.</a>
<span class="sourceLineNo">2421</span><a id="line.2421">     * @param useExtrinsicGuess Parameter used for REF: SOLVEPNP_ITERATIVE. If true (1), the function uses</a>
<span class="sourceLineNo">2422</span><a id="line.2422">     * the provided rvec and tvec values as initial approximations of the rotation and translation</a>
<span class="sourceLineNo">2423</span><a id="line.2423">     * vectors, respectively, and further optimizes them.</a>
<span class="sourceLineNo">2424</span><a id="line.2424">     * @param iterationsCount Number of iterations.</a>
<span class="sourceLineNo">2425</span><a id="line.2425">     * @param reprojectionError Inlier threshold value used by the RANSAC procedure. The parameter value</a>
<span class="sourceLineNo">2426</span><a id="line.2426">     * is the maximum allowed distance between the observed and computed point projections to consider it</a>
<span class="sourceLineNo">2427</span><a id="line.2427">     * an inlier.</a>
<span class="sourceLineNo">2428</span><a id="line.2428">     *</a>
<span class="sourceLineNo">2429</span><a id="line.2429">     * The function estimates an object pose given a set of object points, their corresponding image</a>
<span class="sourceLineNo">2430</span><a id="line.2430">     * projections, as well as the camera intrinsic matrix and the distortion coefficients. This function finds such</a>
<span class="sourceLineNo">2431</span><a id="line.2431">     * a pose that minimizes reprojection error, that is, the sum of squared distances between the observed</a>
<span class="sourceLineNo">2432</span><a id="line.2432">     * projections imagePoints and the projected (using REF: projectPoints ) objectPoints. The use of RANSAC</a>
<span class="sourceLineNo">2433</span><a id="line.2433">     * makes the function resistant to outliers.</a>
<span class="sourceLineNo">2434</span><a id="line.2434">     *</a>
<span class="sourceLineNo">2435</span><a id="line.2435">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">2436</span><a id="line.2436">     * &lt;ul&gt;</a>
<span class="sourceLineNo">2437</span><a id="line.2437">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2438</span><a id="line.2438">     *       An example of how to use solvePNPRansac for object detection can be found at</a>
<span class="sourceLineNo">2439</span><a id="line.2439">     *         opencv_source_code/samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/</a>
<span class="sourceLineNo">2440</span><a id="line.2440">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2441</span><a id="line.2441">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2442</span><a id="line.2442">     *       The default method used to estimate the camera pose for the Minimal Sample Sets step</a>
<span class="sourceLineNo">2443</span><a id="line.2443">     *        is #SOLVEPNP_EPNP. Exceptions are:</a>
<span class="sourceLineNo">2444</span><a id="line.2444">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">2445</span><a id="line.2445">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2446</span><a id="line.2446">     *           if you choose #SOLVEPNP_P3P or #SOLVEPNP_AP3P, these methods will be used.</a>
<span class="sourceLineNo">2447</span><a id="line.2447">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2448</span><a id="line.2448">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2449</span><a id="line.2449">     *           if the number of input points is equal to 4, #SOLVEPNP_P3P is used.</a>
<span class="sourceLineNo">2450</span><a id="line.2450">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2451</span><a id="line.2451">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">2452</span><a id="line.2452">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2453</span><a id="line.2453">     *       The method used to estimate the camera pose using all the inliers is defined by the</a>
<span class="sourceLineNo">2454</span><a id="line.2454">     *        flags parameters unless it is equal to #SOLVEPNP_P3P or #SOLVEPNP_AP3P. In this case,</a>
<span class="sourceLineNo">2455</span><a id="line.2455">     *        the method #SOLVEPNP_EPNP will be used instead.</a>
<span class="sourceLineNo">2456</span><a id="line.2456">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2457</span><a id="line.2457">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">2458</span><a id="line.2458">     * @return automatically generated</a>
<span class="sourceLineNo">2459</span><a id="line.2459">     */</a>
<span class="sourceLineNo">2460</span><a id="line.2460">    public static boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int iterationsCount, float reprojectionError) {</a>
<span class="sourceLineNo">2461</span><a id="line.2461">        Mat objectPoints_mat = objectPoints;</a>
<span class="sourceLineNo">2462</span><a id="line.2462">        Mat imagePoints_mat = imagePoints;</a>
<span class="sourceLineNo">2463</span><a id="line.2463">        Mat distCoeffs_mat = distCoeffs;</a>
<span class="sourceLineNo">2464</span><a id="line.2464">        return solvePnPRansac_3(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, cameraMatrix.nativeObj, distCoeffs_mat.nativeObj, rvec.nativeObj, tvec.nativeObj, useExtrinsicGuess, iterationsCount, reprojectionError);</a>
<span class="sourceLineNo">2465</span><a id="line.2465">    }</a>
<span class="sourceLineNo">2466</span><a id="line.2466"></a>
<span class="sourceLineNo">2467</span><a id="line.2467">    /**</a>
<span class="sourceLineNo">2468</span><a id="line.2468">     * Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.</a>
<span class="sourceLineNo">2469</span><a id="line.2469">     *</a>
<span class="sourceLineNo">2470</span><a id="line.2470">     * @param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or</a>
<span class="sourceLineNo">2471</span><a id="line.2471">     * 1xN/Nx1 3-channel, where N is the number of points. vector&amp;lt;Point3d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">2472</span><a id="line.2472">     * @param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,</a>
<span class="sourceLineNo">2473</span><a id="line.2473">     * where N is the number of points. vector&amp;lt;Point2d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">2474</span><a id="line.2474">     * @param cameraMatrix Input camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">2475</span><a id="line.2475">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">2476</span><a id="line.2476">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">2477</span><a id="line.2477">     * assumed.</a>
<span class="sourceLineNo">2478</span><a id="line.2478">     * @param rvec Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from</a>
<span class="sourceLineNo">2479</span><a id="line.2479">     * the model coordinate system to the camera coordinate system.</a>
<span class="sourceLineNo">2480</span><a id="line.2480">     * @param tvec Output translation vector.</a>
<span class="sourceLineNo">2481</span><a id="line.2481">     * @param useExtrinsicGuess Parameter used for REF: SOLVEPNP_ITERATIVE. If true (1), the function uses</a>
<span class="sourceLineNo">2482</span><a id="line.2482">     * the provided rvec and tvec values as initial approximations of the rotation and translation</a>
<span class="sourceLineNo">2483</span><a id="line.2483">     * vectors, respectively, and further optimizes them.</a>
<span class="sourceLineNo">2484</span><a id="line.2484">     * @param iterationsCount Number of iterations.</a>
<span class="sourceLineNo">2485</span><a id="line.2485">     * is the maximum allowed distance between the observed and computed point projections to consider it</a>
<span class="sourceLineNo">2486</span><a id="line.2486">     * an inlier.</a>
<span class="sourceLineNo">2487</span><a id="line.2487">     *</a>
<span class="sourceLineNo">2488</span><a id="line.2488">     * The function estimates an object pose given a set of object points, their corresponding image</a>
<span class="sourceLineNo">2489</span><a id="line.2489">     * projections, as well as the camera intrinsic matrix and the distortion coefficients. This function finds such</a>
<span class="sourceLineNo">2490</span><a id="line.2490">     * a pose that minimizes reprojection error, that is, the sum of squared distances between the observed</a>
<span class="sourceLineNo">2491</span><a id="line.2491">     * projections imagePoints and the projected (using REF: projectPoints ) objectPoints. The use of RANSAC</a>
<span class="sourceLineNo">2492</span><a id="line.2492">     * makes the function resistant to outliers.</a>
<span class="sourceLineNo">2493</span><a id="line.2493">     *</a>
<span class="sourceLineNo">2494</span><a id="line.2494">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">2495</span><a id="line.2495">     * &lt;ul&gt;</a>
<span class="sourceLineNo">2496</span><a id="line.2496">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2497</span><a id="line.2497">     *       An example of how to use solvePNPRansac for object detection can be found at</a>
<span class="sourceLineNo">2498</span><a id="line.2498">     *         opencv_source_code/samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/</a>
<span class="sourceLineNo">2499</span><a id="line.2499">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2500</span><a id="line.2500">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2501</span><a id="line.2501">     *       The default method used to estimate the camera pose for the Minimal Sample Sets step</a>
<span class="sourceLineNo">2502</span><a id="line.2502">     *        is #SOLVEPNP_EPNP. Exceptions are:</a>
<span class="sourceLineNo">2503</span><a id="line.2503">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">2504</span><a id="line.2504">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2505</span><a id="line.2505">     *           if you choose #SOLVEPNP_P3P or #SOLVEPNP_AP3P, these methods will be used.</a>
<span class="sourceLineNo">2506</span><a id="line.2506">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2507</span><a id="line.2507">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2508</span><a id="line.2508">     *           if the number of input points is equal to 4, #SOLVEPNP_P3P is used.</a>
<span class="sourceLineNo">2509</span><a id="line.2509">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2510</span><a id="line.2510">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">2511</span><a id="line.2511">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2512</span><a id="line.2512">     *       The method used to estimate the camera pose using all the inliers is defined by the</a>
<span class="sourceLineNo">2513</span><a id="line.2513">     *        flags parameters unless it is equal to #SOLVEPNP_P3P or #SOLVEPNP_AP3P. In this case,</a>
<span class="sourceLineNo">2514</span><a id="line.2514">     *        the method #SOLVEPNP_EPNP will be used instead.</a>
<span class="sourceLineNo">2515</span><a id="line.2515">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2516</span><a id="line.2516">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">2517</span><a id="line.2517">     * @return automatically generated</a>
<span class="sourceLineNo">2518</span><a id="line.2518">     */</a>
<span class="sourceLineNo">2519</span><a id="line.2519">    public static boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int iterationsCount) {</a>
<span class="sourceLineNo">2520</span><a id="line.2520">        Mat objectPoints_mat = objectPoints;</a>
<span class="sourceLineNo">2521</span><a id="line.2521">        Mat imagePoints_mat = imagePoints;</a>
<span class="sourceLineNo">2522</span><a id="line.2522">        Mat distCoeffs_mat = distCoeffs;</a>
<span class="sourceLineNo">2523</span><a id="line.2523">        return solvePnPRansac_4(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, cameraMatrix.nativeObj, distCoeffs_mat.nativeObj, rvec.nativeObj, tvec.nativeObj, useExtrinsicGuess, iterationsCount);</a>
<span class="sourceLineNo">2524</span><a id="line.2524">    }</a>
<span class="sourceLineNo">2525</span><a id="line.2525"></a>
<span class="sourceLineNo">2526</span><a id="line.2526">    /**</a>
<span class="sourceLineNo">2527</span><a id="line.2527">     * Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.</a>
<span class="sourceLineNo">2528</span><a id="line.2528">     *</a>
<span class="sourceLineNo">2529</span><a id="line.2529">     * @param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or</a>
<span class="sourceLineNo">2530</span><a id="line.2530">     * 1xN/Nx1 3-channel, where N is the number of points. vector&amp;lt;Point3d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">2531</span><a id="line.2531">     * @param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,</a>
<span class="sourceLineNo">2532</span><a id="line.2532">     * where N is the number of points. vector&amp;lt;Point2d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">2533</span><a id="line.2533">     * @param cameraMatrix Input camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">2534</span><a id="line.2534">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">2535</span><a id="line.2535">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">2536</span><a id="line.2536">     * assumed.</a>
<span class="sourceLineNo">2537</span><a id="line.2537">     * @param rvec Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from</a>
<span class="sourceLineNo">2538</span><a id="line.2538">     * the model coordinate system to the camera coordinate system.</a>
<span class="sourceLineNo">2539</span><a id="line.2539">     * @param tvec Output translation vector.</a>
<span class="sourceLineNo">2540</span><a id="line.2540">     * @param useExtrinsicGuess Parameter used for REF: SOLVEPNP_ITERATIVE. If true (1), the function uses</a>
<span class="sourceLineNo">2541</span><a id="line.2541">     * the provided rvec and tvec values as initial approximations of the rotation and translation</a>
<span class="sourceLineNo">2542</span><a id="line.2542">     * vectors, respectively, and further optimizes them.</a>
<span class="sourceLineNo">2543</span><a id="line.2543">     * is the maximum allowed distance between the observed and computed point projections to consider it</a>
<span class="sourceLineNo">2544</span><a id="line.2544">     * an inlier.</a>
<span class="sourceLineNo">2545</span><a id="line.2545">     *</a>
<span class="sourceLineNo">2546</span><a id="line.2546">     * The function estimates an object pose given a set of object points, their corresponding image</a>
<span class="sourceLineNo">2547</span><a id="line.2547">     * projections, as well as the camera intrinsic matrix and the distortion coefficients. This function finds such</a>
<span class="sourceLineNo">2548</span><a id="line.2548">     * a pose that minimizes reprojection error, that is, the sum of squared distances between the observed</a>
<span class="sourceLineNo">2549</span><a id="line.2549">     * projections imagePoints and the projected (using REF: projectPoints ) objectPoints. The use of RANSAC</a>
<span class="sourceLineNo">2550</span><a id="line.2550">     * makes the function resistant to outliers.</a>
<span class="sourceLineNo">2551</span><a id="line.2551">     *</a>
<span class="sourceLineNo">2552</span><a id="line.2552">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">2553</span><a id="line.2553">     * &lt;ul&gt;</a>
<span class="sourceLineNo">2554</span><a id="line.2554">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2555</span><a id="line.2555">     *       An example of how to use solvePNPRansac for object detection can be found at</a>
<span class="sourceLineNo">2556</span><a id="line.2556">     *         opencv_source_code/samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/</a>
<span class="sourceLineNo">2557</span><a id="line.2557">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2558</span><a id="line.2558">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2559</span><a id="line.2559">     *       The default method used to estimate the camera pose for the Minimal Sample Sets step</a>
<span class="sourceLineNo">2560</span><a id="line.2560">     *        is #SOLVEPNP_EPNP. Exceptions are:</a>
<span class="sourceLineNo">2561</span><a id="line.2561">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">2562</span><a id="line.2562">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2563</span><a id="line.2563">     *           if you choose #SOLVEPNP_P3P or #SOLVEPNP_AP3P, these methods will be used.</a>
<span class="sourceLineNo">2564</span><a id="line.2564">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2565</span><a id="line.2565">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2566</span><a id="line.2566">     *           if the number of input points is equal to 4, #SOLVEPNP_P3P is used.</a>
<span class="sourceLineNo">2567</span><a id="line.2567">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2568</span><a id="line.2568">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">2569</span><a id="line.2569">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2570</span><a id="line.2570">     *       The method used to estimate the camera pose using all the inliers is defined by the</a>
<span class="sourceLineNo">2571</span><a id="line.2571">     *        flags parameters unless it is equal to #SOLVEPNP_P3P or #SOLVEPNP_AP3P. In this case,</a>
<span class="sourceLineNo">2572</span><a id="line.2572">     *        the method #SOLVEPNP_EPNP will be used instead.</a>
<span class="sourceLineNo">2573</span><a id="line.2573">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2574</span><a id="line.2574">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">2575</span><a id="line.2575">     * @return automatically generated</a>
<span class="sourceLineNo">2576</span><a id="line.2576">     */</a>
<span class="sourceLineNo">2577</span><a id="line.2577">    public static boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess) {</a>
<span class="sourceLineNo">2578</span><a id="line.2578">        Mat objectPoints_mat = objectPoints;</a>
<span class="sourceLineNo">2579</span><a id="line.2579">        Mat imagePoints_mat = imagePoints;</a>
<span class="sourceLineNo">2580</span><a id="line.2580">        Mat distCoeffs_mat = distCoeffs;</a>
<span class="sourceLineNo">2581</span><a id="line.2581">        return solvePnPRansac_5(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, cameraMatrix.nativeObj, distCoeffs_mat.nativeObj, rvec.nativeObj, tvec.nativeObj, useExtrinsicGuess);</a>
<span class="sourceLineNo">2582</span><a id="line.2582">    }</a>
<span class="sourceLineNo">2583</span><a id="line.2583"></a>
<span class="sourceLineNo">2584</span><a id="line.2584">    /**</a>
<span class="sourceLineNo">2585</span><a id="line.2585">     * Finds an object pose from 3D-2D point correspondences using the RANSAC scheme.</a>
<span class="sourceLineNo">2586</span><a id="line.2586">     *</a>
<span class="sourceLineNo">2587</span><a id="line.2587">     * @param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or</a>
<span class="sourceLineNo">2588</span><a id="line.2588">     * 1xN/Nx1 3-channel, where N is the number of points. vector&amp;lt;Point3d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">2589</span><a id="line.2589">     * @param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,</a>
<span class="sourceLineNo">2590</span><a id="line.2590">     * where N is the number of points. vector&amp;lt;Point2d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">2591</span><a id="line.2591">     * @param cameraMatrix Input camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">2592</span><a id="line.2592">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">2593</span><a id="line.2593">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">2594</span><a id="line.2594">     * assumed.</a>
<span class="sourceLineNo">2595</span><a id="line.2595">     * @param rvec Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from</a>
<span class="sourceLineNo">2596</span><a id="line.2596">     * the model coordinate system to the camera coordinate system.</a>
<span class="sourceLineNo">2597</span><a id="line.2597">     * @param tvec Output translation vector.</a>
<span class="sourceLineNo">2598</span><a id="line.2598">     * the provided rvec and tvec values as initial approximations of the rotation and translation</a>
<span class="sourceLineNo">2599</span><a id="line.2599">     * vectors, respectively, and further optimizes them.</a>
<span class="sourceLineNo">2600</span><a id="line.2600">     * is the maximum allowed distance between the observed and computed point projections to consider it</a>
<span class="sourceLineNo">2601</span><a id="line.2601">     * an inlier.</a>
<span class="sourceLineNo">2602</span><a id="line.2602">     *</a>
<span class="sourceLineNo">2603</span><a id="line.2603">     * The function estimates an object pose given a set of object points, their corresponding image</a>
<span class="sourceLineNo">2604</span><a id="line.2604">     * projections, as well as the camera intrinsic matrix and the distortion coefficients. This function finds such</a>
<span class="sourceLineNo">2605</span><a id="line.2605">     * a pose that minimizes reprojection error, that is, the sum of squared distances between the observed</a>
<span class="sourceLineNo">2606</span><a id="line.2606">     * projections imagePoints and the projected (using REF: projectPoints ) objectPoints. The use of RANSAC</a>
<span class="sourceLineNo">2607</span><a id="line.2607">     * makes the function resistant to outliers.</a>
<span class="sourceLineNo">2608</span><a id="line.2608">     *</a>
<span class="sourceLineNo">2609</span><a id="line.2609">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">2610</span><a id="line.2610">     * &lt;ul&gt;</a>
<span class="sourceLineNo">2611</span><a id="line.2611">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2612</span><a id="line.2612">     *       An example of how to use solvePNPRansac for object detection can be found at</a>
<span class="sourceLineNo">2613</span><a id="line.2613">     *         opencv_source_code/samples/cpp/tutorial_code/calib3d/real_time_pose_estimation/</a>
<span class="sourceLineNo">2614</span><a id="line.2614">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2615</span><a id="line.2615">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2616</span><a id="line.2616">     *       The default method used to estimate the camera pose for the Minimal Sample Sets step</a>
<span class="sourceLineNo">2617</span><a id="line.2617">     *        is #SOLVEPNP_EPNP. Exceptions are:</a>
<span class="sourceLineNo">2618</span><a id="line.2618">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">2619</span><a id="line.2619">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2620</span><a id="line.2620">     *           if you choose #SOLVEPNP_P3P or #SOLVEPNP_AP3P, these methods will be used.</a>
<span class="sourceLineNo">2621</span><a id="line.2621">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2622</span><a id="line.2622">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2623</span><a id="line.2623">     *           if the number of input points is equal to 4, #SOLVEPNP_P3P is used.</a>
<span class="sourceLineNo">2624</span><a id="line.2624">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2625</span><a id="line.2625">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">2626</span><a id="line.2626">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2627</span><a id="line.2627">     *       The method used to estimate the camera pose using all the inliers is defined by the</a>
<span class="sourceLineNo">2628</span><a id="line.2628">     *        flags parameters unless it is equal to #SOLVEPNP_P3P or #SOLVEPNP_AP3P. In this case,</a>
<span class="sourceLineNo">2629</span><a id="line.2629">     *        the method #SOLVEPNP_EPNP will be used instead.</a>
<span class="sourceLineNo">2630</span><a id="line.2630">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2631</span><a id="line.2631">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">2632</span><a id="line.2632">     * @return automatically generated</a>
<span class="sourceLineNo">2633</span><a id="line.2633">     */</a>
<span class="sourceLineNo">2634</span><a id="line.2634">    public static boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec) {</a>
<span class="sourceLineNo">2635</span><a id="line.2635">        Mat objectPoints_mat = objectPoints;</a>
<span class="sourceLineNo">2636</span><a id="line.2636">        Mat imagePoints_mat = imagePoints;</a>
<span class="sourceLineNo">2637</span><a id="line.2637">        Mat distCoeffs_mat = distCoeffs;</a>
<span class="sourceLineNo">2638</span><a id="line.2638">        return solvePnPRansac_6(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, cameraMatrix.nativeObj, distCoeffs_mat.nativeObj, rvec.nativeObj, tvec.nativeObj);</a>
<span class="sourceLineNo">2639</span><a id="line.2639">    }</a>
<span class="sourceLineNo">2640</span><a id="line.2640"></a>
<span class="sourceLineNo">2641</span><a id="line.2641"></a>
<span class="sourceLineNo">2642</span><a id="line.2642">    //</a>
<span class="sourceLineNo">2643</span><a id="line.2643">    // C++:  bool cv::solvePnPRansac(vector_Point3f objectPoints, vector_Point2f imagePoints, Mat&amp; cameraMatrix, vector_double distCoeffs, Mat&amp; rvec, Mat&amp; tvec, Mat&amp; inliers, UsacParams params = UsacParams())</a>
<span class="sourceLineNo">2644</span><a id="line.2644">    //</a>
<span class="sourceLineNo">2645</span><a id="line.2645"></a>
<span class="sourceLineNo">2646</span><a id="line.2646">    public static boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, Mat inliers, UsacParams params) {</a>
<span class="sourceLineNo">2647</span><a id="line.2647">        Mat objectPoints_mat = objectPoints;</a>
<span class="sourceLineNo">2648</span><a id="line.2648">        Mat imagePoints_mat = imagePoints;</a>
<span class="sourceLineNo">2649</span><a id="line.2649">        Mat distCoeffs_mat = distCoeffs;</a>
<span class="sourceLineNo">2650</span><a id="line.2650">        return solvePnPRansac_7(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, cameraMatrix.nativeObj, distCoeffs_mat.nativeObj, rvec.nativeObj, tvec.nativeObj, inliers.nativeObj, params.nativeObj);</a>
<span class="sourceLineNo">2651</span><a id="line.2651">    }</a>
<span class="sourceLineNo">2652</span><a id="line.2652"></a>
<span class="sourceLineNo">2653</span><a id="line.2653">    public static boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, Mat inliers) {</a>
<span class="sourceLineNo">2654</span><a id="line.2654">        Mat objectPoints_mat = objectPoints;</a>
<span class="sourceLineNo">2655</span><a id="line.2655">        Mat imagePoints_mat = imagePoints;</a>
<span class="sourceLineNo">2656</span><a id="line.2656">        Mat distCoeffs_mat = distCoeffs;</a>
<span class="sourceLineNo">2657</span><a id="line.2657">        return solvePnPRansac_8(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, cameraMatrix.nativeObj, distCoeffs_mat.nativeObj, rvec.nativeObj, tvec.nativeObj, inliers.nativeObj);</a>
<span class="sourceLineNo">2658</span><a id="line.2658">    }</a>
<span class="sourceLineNo">2659</span><a id="line.2659"></a>
<span class="sourceLineNo">2660</span><a id="line.2660"></a>
<span class="sourceLineNo">2661</span><a id="line.2661">    //</a>
<span class="sourceLineNo">2662</span><a id="line.2662">    // C++:  int cv::solveP3P(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, vector_Mat&amp; rvecs, vector_Mat&amp; tvecs, int flags)</a>
<span class="sourceLineNo">2663</span><a id="line.2663">    //</a>
<span class="sourceLineNo">2664</span><a id="line.2664"></a>
<span class="sourceLineNo">2665</span><a id="line.2665">    /**</a>
<span class="sourceLineNo">2666</span><a id="line.2666">     * Finds an object pose from 3 3D-2D point correspondences.</a>
<span class="sourceLineNo">2667</span><a id="line.2667">     *</a>
<span class="sourceLineNo">2668</span><a id="line.2668">     * @param objectPoints Array of object points in the object coordinate space, 3x3 1-channel or</a>
<span class="sourceLineNo">2669</span><a id="line.2669">     * 1x3/3x1 3-channel. vector&amp;lt;Point3f&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">2670</span><a id="line.2670">     * @param imagePoints Array of corresponding image points, 3x2 1-channel or 1x3/3x1 2-channel.</a>
<span class="sourceLineNo">2671</span><a id="line.2671">     *  vector&amp;lt;Point2f&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">2672</span><a id="line.2672">     * @param cameraMatrix Input camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">2673</span><a id="line.2673">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">2674</span><a id="line.2674">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">2675</span><a id="line.2675">     * assumed.</a>
<span class="sourceLineNo">2676</span><a id="line.2676">     * @param rvecs Output rotation vectors (see REF: Rodrigues ) that, together with tvecs, brings points from</a>
<span class="sourceLineNo">2677</span><a id="line.2677">     * the model coordinate system to the camera coordinate system. A P3P problem has up to 4 solutions.</a>
<span class="sourceLineNo">2678</span><a id="line.2678">     * @param tvecs Output translation vectors.</a>
<span class="sourceLineNo">2679</span><a id="line.2679">     * @param flags Method for solving a P3P problem:</a>
<span class="sourceLineNo">2680</span><a id="line.2680">     * &lt;ul&gt;</a>
<span class="sourceLineNo">2681</span><a id="line.2681">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2682</span><a id="line.2682">     *    REF: SOLVEPNP_P3P Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang</a>
<span class="sourceLineNo">2683</span><a id="line.2683">     * "Complete Solution Classification for the Perspective-Three-Point Problem" (CITE: gao2003complete).</a>
<span class="sourceLineNo">2684</span><a id="line.2684">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2685</span><a id="line.2685">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2686</span><a id="line.2686">     *    REF: SOLVEPNP_AP3P Method is based on the paper of T. Ke and S. Roumeliotis.</a>
<span class="sourceLineNo">2687</span><a id="line.2687">     * "An Efficient Algebraic Solution to the Perspective-Three-Point Problem" (CITE: Ke17).</a>
<span class="sourceLineNo">2688</span><a id="line.2688">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2689</span><a id="line.2689">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">2690</span><a id="line.2690">     *</a>
<span class="sourceLineNo">2691</span><a id="line.2691">     * The function estimates the object pose given 3 object points, their corresponding image</a>
<span class="sourceLineNo">2692</span><a id="line.2692">     * projections, as well as the camera intrinsic matrix and the distortion coefficients.</a>
<span class="sourceLineNo">2693</span><a id="line.2693">     *</a>
<span class="sourceLineNo">2694</span><a id="line.2694">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">2695</span><a id="line.2695">     * The solutions are sorted by reprojection errors (lowest to highest).</a>
<span class="sourceLineNo">2696</span><a id="line.2696">     * @return automatically generated</a>
<span class="sourceLineNo">2697</span><a id="line.2697">     */</a>
<span class="sourceLineNo">2698</span><a id="line.2698">    public static int solveP3P(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List&lt;Mat&gt; rvecs, List&lt;Mat&gt; tvecs, int flags) {</a>
<span class="sourceLineNo">2699</span><a id="line.2699">        Mat rvecs_mat = new Mat();</a>
<span class="sourceLineNo">2700</span><a id="line.2700">        Mat tvecs_mat = new Mat();</a>
<span class="sourceLineNo">2701</span><a id="line.2701">        int retVal = solveP3P_0(objectPoints.nativeObj, imagePoints.nativeObj, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvecs_mat.nativeObj, tvecs_mat.nativeObj, flags);</a>
<span class="sourceLineNo">2702</span><a id="line.2702">        Converters.Mat_to_vector_Mat(rvecs_mat, rvecs);</a>
<span class="sourceLineNo">2703</span><a id="line.2703">        rvecs_mat.release();</a>
<span class="sourceLineNo">2704</span><a id="line.2704">        Converters.Mat_to_vector_Mat(tvecs_mat, tvecs);</a>
<span class="sourceLineNo">2705</span><a id="line.2705">        tvecs_mat.release();</a>
<span class="sourceLineNo">2706</span><a id="line.2706">        return retVal;</a>
<span class="sourceLineNo">2707</span><a id="line.2707">    }</a>
<span class="sourceLineNo">2708</span><a id="line.2708"></a>
<span class="sourceLineNo">2709</span><a id="line.2709"></a>
<span class="sourceLineNo">2710</span><a id="line.2710">    //</a>
<span class="sourceLineNo">2711</span><a id="line.2711">    // C++:  void cv::solvePnPRefineLM(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat&amp; rvec, Mat&amp; tvec, TermCriteria criteria = TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON))</a>
<span class="sourceLineNo">2712</span><a id="line.2712">    //</a>
<span class="sourceLineNo">2713</span><a id="line.2713"></a>
<span class="sourceLineNo">2714</span><a id="line.2714">    /**</a>
<span class="sourceLineNo">2715</span><a id="line.2715">     * Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame</a>
<span class="sourceLineNo">2716</span><a id="line.2716">     * to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution.</a>
<span class="sourceLineNo">2717</span><a id="line.2717">     *</a>
<span class="sourceLineNo">2718</span><a id="line.2718">     * @param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel,</a>
<span class="sourceLineNo">2719</span><a id="line.2719">     * where N is the number of points. vector&amp;lt;Point3d&amp;gt; can also be passed here.</a>
<span class="sourceLineNo">2720</span><a id="line.2720">     * @param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,</a>
<span class="sourceLineNo">2721</span><a id="line.2721">     * where N is the number of points. vector&amp;lt;Point2d&amp;gt; can also be passed here.</a>
<span class="sourceLineNo">2722</span><a id="line.2722">     * @param cameraMatrix Input camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">2723</span><a id="line.2723">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">2724</span><a id="line.2724">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">2725</span><a id="line.2725">     * assumed.</a>
<span class="sourceLineNo">2726</span><a id="line.2726">     * @param rvec Input/Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from</a>
<span class="sourceLineNo">2727</span><a id="line.2727">     * the model coordinate system to the camera coordinate system. Input values are used as an initial solution.</a>
<span class="sourceLineNo">2728</span><a id="line.2728">     * @param tvec Input/Output translation vector. Input values are used as an initial solution.</a>
<span class="sourceLineNo">2729</span><a id="line.2729">     * @param criteria Criteria when to stop the Levenberg-Marquard iterative algorithm.</a>
<span class="sourceLineNo">2730</span><a id="line.2730">     *</a>
<span class="sourceLineNo">2731</span><a id="line.2731">     * The function refines the object pose given at least 3 object points, their corresponding image</a>
<span class="sourceLineNo">2732</span><a id="line.2732">     * projections, an initial solution for the rotation and translation vector,</a>
<span class="sourceLineNo">2733</span><a id="line.2733">     * as well as the camera intrinsic matrix and the distortion coefficients.</a>
<span class="sourceLineNo">2734</span><a id="line.2734">     * The function minimizes the projection error with respect to the rotation and the translation vectors, according</a>
<span class="sourceLineNo">2735</span><a id="line.2735">     * to a Levenberg-Marquardt iterative minimization CITE: Madsen04 CITE: Eade13 process.</a>
<span class="sourceLineNo">2736</span><a id="line.2736">     */</a>
<span class="sourceLineNo">2737</span><a id="line.2737">    public static void solvePnPRefineLM(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, TermCriteria criteria) {</a>
<span class="sourceLineNo">2738</span><a id="line.2738">        solvePnPRefineLM_0(objectPoints.nativeObj, imagePoints.nativeObj, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvec.nativeObj, tvec.nativeObj, criteria.type, criteria.maxCount, criteria.epsilon);</a>
<span class="sourceLineNo">2739</span><a id="line.2739">    }</a>
<span class="sourceLineNo">2740</span><a id="line.2740"></a>
<span class="sourceLineNo">2741</span><a id="line.2741">    /**</a>
<span class="sourceLineNo">2742</span><a id="line.2742">     * Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame</a>
<span class="sourceLineNo">2743</span><a id="line.2743">     * to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution.</a>
<span class="sourceLineNo">2744</span><a id="line.2744">     *</a>
<span class="sourceLineNo">2745</span><a id="line.2745">     * @param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel,</a>
<span class="sourceLineNo">2746</span><a id="line.2746">     * where N is the number of points. vector&amp;lt;Point3d&amp;gt; can also be passed here.</a>
<span class="sourceLineNo">2747</span><a id="line.2747">     * @param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,</a>
<span class="sourceLineNo">2748</span><a id="line.2748">     * where N is the number of points. vector&amp;lt;Point2d&amp;gt; can also be passed here.</a>
<span class="sourceLineNo">2749</span><a id="line.2749">     * @param cameraMatrix Input camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">2750</span><a id="line.2750">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">2751</span><a id="line.2751">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">2752</span><a id="line.2752">     * assumed.</a>
<span class="sourceLineNo">2753</span><a id="line.2753">     * @param rvec Input/Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from</a>
<span class="sourceLineNo">2754</span><a id="line.2754">     * the model coordinate system to the camera coordinate system. Input values are used as an initial solution.</a>
<span class="sourceLineNo">2755</span><a id="line.2755">     * @param tvec Input/Output translation vector. Input values are used as an initial solution.</a>
<span class="sourceLineNo">2756</span><a id="line.2756">     *</a>
<span class="sourceLineNo">2757</span><a id="line.2757">     * The function refines the object pose given at least 3 object points, their corresponding image</a>
<span class="sourceLineNo">2758</span><a id="line.2758">     * projections, an initial solution for the rotation and translation vector,</a>
<span class="sourceLineNo">2759</span><a id="line.2759">     * as well as the camera intrinsic matrix and the distortion coefficients.</a>
<span class="sourceLineNo">2760</span><a id="line.2760">     * The function minimizes the projection error with respect to the rotation and the translation vectors, according</a>
<span class="sourceLineNo">2761</span><a id="line.2761">     * to a Levenberg-Marquardt iterative minimization CITE: Madsen04 CITE: Eade13 process.</a>
<span class="sourceLineNo">2762</span><a id="line.2762">     */</a>
<span class="sourceLineNo">2763</span><a id="line.2763">    public static void solvePnPRefineLM(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec) {</a>
<span class="sourceLineNo">2764</span><a id="line.2764">        solvePnPRefineLM_1(objectPoints.nativeObj, imagePoints.nativeObj, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvec.nativeObj, tvec.nativeObj);</a>
<span class="sourceLineNo">2765</span><a id="line.2765">    }</a>
<span class="sourceLineNo">2766</span><a id="line.2766"></a>
<span class="sourceLineNo">2767</span><a id="line.2767"></a>
<span class="sourceLineNo">2768</span><a id="line.2768">    //</a>
<span class="sourceLineNo">2769</span><a id="line.2769">    // C++:  void cv::solvePnPRefineVVS(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat&amp; rvec, Mat&amp; tvec, TermCriteria criteria = TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON), double VVSlambda = 1)</a>
<span class="sourceLineNo">2770</span><a id="line.2770">    //</a>
<span class="sourceLineNo">2771</span><a id="line.2771"></a>
<span class="sourceLineNo">2772</span><a id="line.2772">    /**</a>
<span class="sourceLineNo">2773</span><a id="line.2773">     * Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame</a>
<span class="sourceLineNo">2774</span><a id="line.2774">     * to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution.</a>
<span class="sourceLineNo">2775</span><a id="line.2775">     *</a>
<span class="sourceLineNo">2776</span><a id="line.2776">     * @param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel,</a>
<span class="sourceLineNo">2777</span><a id="line.2777">     * where N is the number of points. vector&amp;lt;Point3d&amp;gt; can also be passed here.</a>
<span class="sourceLineNo">2778</span><a id="line.2778">     * @param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,</a>
<span class="sourceLineNo">2779</span><a id="line.2779">     * where N is the number of points. vector&amp;lt;Point2d&amp;gt; can also be passed here.</a>
<span class="sourceLineNo">2780</span><a id="line.2780">     * @param cameraMatrix Input camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">2781</span><a id="line.2781">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">2782</span><a id="line.2782">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">2783</span><a id="line.2783">     * assumed.</a>
<span class="sourceLineNo">2784</span><a id="line.2784">     * @param rvec Input/Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from</a>
<span class="sourceLineNo">2785</span><a id="line.2785">     * the model coordinate system to the camera coordinate system. Input values are used as an initial solution.</a>
<span class="sourceLineNo">2786</span><a id="line.2786">     * @param tvec Input/Output translation vector. Input values are used as an initial solution.</a>
<span class="sourceLineNo">2787</span><a id="line.2787">     * @param criteria Criteria when to stop the Levenberg-Marquard iterative algorithm.</a>
<span class="sourceLineNo">2788</span><a id="line.2788">     * @param VVSlambda Gain for the virtual visual servoing control law, equivalent to the \(\alpha\)</a>
<span class="sourceLineNo">2789</span><a id="line.2789">     * gain in the Damped Gauss-Newton formulation.</a>
<span class="sourceLineNo">2790</span><a id="line.2790">     *</a>
<span class="sourceLineNo">2791</span><a id="line.2791">     * The function refines the object pose given at least 3 object points, their corresponding image</a>
<span class="sourceLineNo">2792</span><a id="line.2792">     * projections, an initial solution for the rotation and translation vector,</a>
<span class="sourceLineNo">2793</span><a id="line.2793">     * as well as the camera intrinsic matrix and the distortion coefficients.</a>
<span class="sourceLineNo">2794</span><a id="line.2794">     * The function minimizes the projection error with respect to the rotation and the translation vectors, using a</a>
<span class="sourceLineNo">2795</span><a id="line.2795">     * virtual visual servoing (VVS) CITE: Chaumette06 CITE: Marchand16 scheme.</a>
<span class="sourceLineNo">2796</span><a id="line.2796">     */</a>
<span class="sourceLineNo">2797</span><a id="line.2797">    public static void solvePnPRefineVVS(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, TermCriteria criteria, double VVSlambda) {</a>
<span class="sourceLineNo">2798</span><a id="line.2798">        solvePnPRefineVVS_0(objectPoints.nativeObj, imagePoints.nativeObj, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvec.nativeObj, tvec.nativeObj, criteria.type, criteria.maxCount, criteria.epsilon, VVSlambda);</a>
<span class="sourceLineNo">2799</span><a id="line.2799">    }</a>
<span class="sourceLineNo">2800</span><a id="line.2800"></a>
<span class="sourceLineNo">2801</span><a id="line.2801">    /**</a>
<span class="sourceLineNo">2802</span><a id="line.2802">     * Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame</a>
<span class="sourceLineNo">2803</span><a id="line.2803">     * to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution.</a>
<span class="sourceLineNo">2804</span><a id="line.2804">     *</a>
<span class="sourceLineNo">2805</span><a id="line.2805">     * @param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel,</a>
<span class="sourceLineNo">2806</span><a id="line.2806">     * where N is the number of points. vector&amp;lt;Point3d&amp;gt; can also be passed here.</a>
<span class="sourceLineNo">2807</span><a id="line.2807">     * @param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,</a>
<span class="sourceLineNo">2808</span><a id="line.2808">     * where N is the number of points. vector&amp;lt;Point2d&amp;gt; can also be passed here.</a>
<span class="sourceLineNo">2809</span><a id="line.2809">     * @param cameraMatrix Input camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">2810</span><a id="line.2810">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">2811</span><a id="line.2811">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">2812</span><a id="line.2812">     * assumed.</a>
<span class="sourceLineNo">2813</span><a id="line.2813">     * @param rvec Input/Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from</a>
<span class="sourceLineNo">2814</span><a id="line.2814">     * the model coordinate system to the camera coordinate system. Input values are used as an initial solution.</a>
<span class="sourceLineNo">2815</span><a id="line.2815">     * @param tvec Input/Output translation vector. Input values are used as an initial solution.</a>
<span class="sourceLineNo">2816</span><a id="line.2816">     * @param criteria Criteria when to stop the Levenberg-Marquard iterative algorithm.</a>
<span class="sourceLineNo">2817</span><a id="line.2817">     * gain in the Damped Gauss-Newton formulation.</a>
<span class="sourceLineNo">2818</span><a id="line.2818">     *</a>
<span class="sourceLineNo">2819</span><a id="line.2819">     * The function refines the object pose given at least 3 object points, their corresponding image</a>
<span class="sourceLineNo">2820</span><a id="line.2820">     * projections, an initial solution for the rotation and translation vector,</a>
<span class="sourceLineNo">2821</span><a id="line.2821">     * as well as the camera intrinsic matrix and the distortion coefficients.</a>
<span class="sourceLineNo">2822</span><a id="line.2822">     * The function minimizes the projection error with respect to the rotation and the translation vectors, using a</a>
<span class="sourceLineNo">2823</span><a id="line.2823">     * virtual visual servoing (VVS) CITE: Chaumette06 CITE: Marchand16 scheme.</a>
<span class="sourceLineNo">2824</span><a id="line.2824">     */</a>
<span class="sourceLineNo">2825</span><a id="line.2825">    public static void solvePnPRefineVVS(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, TermCriteria criteria) {</a>
<span class="sourceLineNo">2826</span><a id="line.2826">        solvePnPRefineVVS_1(objectPoints.nativeObj, imagePoints.nativeObj, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvec.nativeObj, tvec.nativeObj, criteria.type, criteria.maxCount, criteria.epsilon);</a>
<span class="sourceLineNo">2827</span><a id="line.2827">    }</a>
<span class="sourceLineNo">2828</span><a id="line.2828"></a>
<span class="sourceLineNo">2829</span><a id="line.2829">    /**</a>
<span class="sourceLineNo">2830</span><a id="line.2830">     * Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coordinate frame</a>
<span class="sourceLineNo">2831</span><a id="line.2831">     * to the camera coordinate frame) from a 3D-2D point correspondences and starting from an initial solution.</a>
<span class="sourceLineNo">2832</span><a id="line.2832">     *</a>
<span class="sourceLineNo">2833</span><a id="line.2833">     * @param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or 1xN/Nx1 3-channel,</a>
<span class="sourceLineNo">2834</span><a id="line.2834">     * where N is the number of points. vector&amp;lt;Point3d&amp;gt; can also be passed here.</a>
<span class="sourceLineNo">2835</span><a id="line.2835">     * @param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,</a>
<span class="sourceLineNo">2836</span><a id="line.2836">     * where N is the number of points. vector&amp;lt;Point2d&amp;gt; can also be passed here.</a>
<span class="sourceLineNo">2837</span><a id="line.2837">     * @param cameraMatrix Input camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">2838</span><a id="line.2838">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">2839</span><a id="line.2839">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">2840</span><a id="line.2840">     * assumed.</a>
<span class="sourceLineNo">2841</span><a id="line.2841">     * @param rvec Input/Output rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from</a>
<span class="sourceLineNo">2842</span><a id="line.2842">     * the model coordinate system to the camera coordinate system. Input values are used as an initial solution.</a>
<span class="sourceLineNo">2843</span><a id="line.2843">     * @param tvec Input/Output translation vector. Input values are used as an initial solution.</a>
<span class="sourceLineNo">2844</span><a id="line.2844">     * gain in the Damped Gauss-Newton formulation.</a>
<span class="sourceLineNo">2845</span><a id="line.2845">     *</a>
<span class="sourceLineNo">2846</span><a id="line.2846">     * The function refines the object pose given at least 3 object points, their corresponding image</a>
<span class="sourceLineNo">2847</span><a id="line.2847">     * projections, an initial solution for the rotation and translation vector,</a>
<span class="sourceLineNo">2848</span><a id="line.2848">     * as well as the camera intrinsic matrix and the distortion coefficients.</a>
<span class="sourceLineNo">2849</span><a id="line.2849">     * The function minimizes the projection error with respect to the rotation and the translation vectors, using a</a>
<span class="sourceLineNo">2850</span><a id="line.2850">     * virtual visual servoing (VVS) CITE: Chaumette06 CITE: Marchand16 scheme.</a>
<span class="sourceLineNo">2851</span><a id="line.2851">     */</a>
<span class="sourceLineNo">2852</span><a id="line.2852">    public static void solvePnPRefineVVS(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec) {</a>
<span class="sourceLineNo">2853</span><a id="line.2853">        solvePnPRefineVVS_2(objectPoints.nativeObj, imagePoints.nativeObj, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvec.nativeObj, tvec.nativeObj);</a>
<span class="sourceLineNo">2854</span><a id="line.2854">    }</a>
<span class="sourceLineNo">2855</span><a id="line.2855"></a>
<span class="sourceLineNo">2856</span><a id="line.2856"></a>
<span class="sourceLineNo">2857</span><a id="line.2857">    //</a>
<span class="sourceLineNo">2858</span><a id="line.2858">    // C++:  int cv::solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, vector_Mat&amp; rvecs, vector_Mat&amp; tvecs, bool useExtrinsicGuess = false, SolvePnPMethod flags = SOLVEPNP_ITERATIVE, Mat rvec = Mat(), Mat tvec = Mat(), Mat&amp; reprojectionError = Mat())</a>
<span class="sourceLineNo">2859</span><a id="line.2859">    //</a>
<span class="sourceLineNo">2860</span><a id="line.2860"></a>
<span class="sourceLineNo">2861</span><a id="line.2861">    /**</a>
<span class="sourceLineNo">2862</span><a id="line.2862">     * Finds an object pose from 3D-2D point correspondences.</a>
<span class="sourceLineNo">2863</span><a id="line.2863">     * This function returns a list of all the possible solutions (a solution is a &amp;lt;rotation vector, translation vector&amp;gt;</a>
<span class="sourceLineNo">2864</span><a id="line.2864">     * couple), depending on the number of input points and the chosen method:</a>
<span class="sourceLineNo">2865</span><a id="line.2865">     * &lt;ul&gt;</a>
<span class="sourceLineNo">2866</span><a id="line.2866">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2867</span><a id="line.2867">     *  P3P methods (REF: SOLVEPNP_P3P, REF: SOLVEPNP_AP3P): 3 or 4 input points. Number of returned solutions can be between 0 and 4 with 3 input points.</a>
<span class="sourceLineNo">2868</span><a id="line.2868">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2869</span><a id="line.2869">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2870</span><a id="line.2870">     *  REF: SOLVEPNP_IPPE Input points must be &amp;gt;= 4 and object points must be coplanar. Returns 2 solutions.</a>
<span class="sourceLineNo">2871</span><a id="line.2871">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2872</span><a id="line.2872">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2873</span><a id="line.2873">     *  REF: SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.</a>
<span class="sourceLineNo">2874</span><a id="line.2874">     * Number of input points must be 4 and 2 solutions are returned. Object points must be defined in the following order:</a>
<span class="sourceLineNo">2875</span><a id="line.2875">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">2876</span><a id="line.2876">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2877</span><a id="line.2877">     *    point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">2878</span><a id="line.2878">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2879</span><a id="line.2879">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2880</span><a id="line.2880">     *    point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">2881</span><a id="line.2881">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2882</span><a id="line.2882">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2883</span><a id="line.2883">     *    point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">2884</span><a id="line.2884">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2885</span><a id="line.2885">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2886</span><a id="line.2886">     *    point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">2887</span><a id="line.2887">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2888</span><a id="line.2888">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">2889</span><a id="line.2889">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2890</span><a id="line.2890">     *  for all the other flags, number of input points must be &amp;gt;= 4 and object points can be in any configuration.</a>
<span class="sourceLineNo">2891</span><a id="line.2891">     * Only 1 solution is returned.</a>
<span class="sourceLineNo">2892</span><a id="line.2892">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2893</span><a id="line.2893">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">2894</span><a id="line.2894">     *</a>
<span class="sourceLineNo">2895</span><a id="line.2895">     * @param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or</a>
<span class="sourceLineNo">2896</span><a id="line.2896">     * 1xN/Nx1 3-channel, where N is the number of points. vector&amp;lt;Point3d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">2897</span><a id="line.2897">     * @param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,</a>
<span class="sourceLineNo">2898</span><a id="line.2898">     * where N is the number of points. vector&amp;lt;Point2d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">2899</span><a id="line.2899">     * @param cameraMatrix Input camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">2900</span><a id="line.2900">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">2901</span><a id="line.2901">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">2902</span><a id="line.2902">     * assumed.</a>
<span class="sourceLineNo">2903</span><a id="line.2903">     * @param rvecs Vector of output rotation vectors (see REF: Rodrigues ) that, together with tvecs, brings points from</a>
<span class="sourceLineNo">2904</span><a id="line.2904">     * the model coordinate system to the camera coordinate system.</a>
<span class="sourceLineNo">2905</span><a id="line.2905">     * @param tvecs Vector of output translation vectors.</a>
<span class="sourceLineNo">2906</span><a id="line.2906">     * @param useExtrinsicGuess Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses</a>
<span class="sourceLineNo">2907</span><a id="line.2907">     * the provided rvec and tvec values as initial approximations of the rotation and translation</a>
<span class="sourceLineNo">2908</span><a id="line.2908">     * vectors, respectively, and further optimizes them.</a>
<span class="sourceLineNo">2909</span><a id="line.2909">     * @param flags Method for solving a PnP problem:</a>
<span class="sourceLineNo">2910</span><a id="line.2910">     * &lt;ul&gt;</a>
<span class="sourceLineNo">2911</span><a id="line.2911">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2912</span><a id="line.2912">     *    REF: SOLVEPNP_ITERATIVE Iterative method is based on a Levenberg-Marquardt optimization. In</a>
<span class="sourceLineNo">2913</span><a id="line.2913">     * this case the function finds such a pose that minimizes reprojection error, that is the sum</a>
<span class="sourceLineNo">2914</span><a id="line.2914">     * of squared distances between the observed projections imagePoints and the projected (using</a>
<span class="sourceLineNo">2915</span><a id="line.2915">     * projectPoints ) objectPoints .</a>
<span class="sourceLineNo">2916</span><a id="line.2916">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2917</span><a id="line.2917">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2918</span><a id="line.2918">     *    REF: SOLVEPNP_P3P Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang</a>
<span class="sourceLineNo">2919</span><a id="line.2919">     * "Complete Solution Classification for the Perspective-Three-Point Problem" (CITE: gao2003complete).</a>
<span class="sourceLineNo">2920</span><a id="line.2920">     * In this case the function requires exactly four object and image points.</a>
<span class="sourceLineNo">2921</span><a id="line.2921">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2922</span><a id="line.2922">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2923</span><a id="line.2923">     *    REF: SOLVEPNP_AP3P Method is based on the paper of T. Ke, S. Roumeliotis</a>
<span class="sourceLineNo">2924</span><a id="line.2924">     * "An Efficient Algebraic Solution to the Perspective-Three-Point Problem" (CITE: Ke17).</a>
<span class="sourceLineNo">2925</span><a id="line.2925">     * In this case the function requires exactly four object and image points.</a>
<span class="sourceLineNo">2926</span><a id="line.2926">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2927</span><a id="line.2927">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2928</span><a id="line.2928">     *    REF: SOLVEPNP_EPNP Method has been introduced by F.Moreno-Noguer, V.Lepetit and P.Fua in the</a>
<span class="sourceLineNo">2929</span><a id="line.2929">     * paper "EPnP: Efficient Perspective-n-Point Camera Pose Estimation" (CITE: lepetit2009epnp).</a>
<span class="sourceLineNo">2930</span><a id="line.2930">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2931</span><a id="line.2931">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2932</span><a id="line.2932">     *    REF: SOLVEPNP_DLS &lt;b&gt;Broken implementation. Using this flag will fallback to EPnP.&lt;/b&gt; \n</a>
<span class="sourceLineNo">2933</span><a id="line.2933">     * Method is based on the paper of Joel A. Hesch and Stergios I. Roumeliotis.</a>
<span class="sourceLineNo">2934</span><a id="line.2934">     * "A Direct Least-Squares (DLS) Method for PnP" (CITE: hesch2011direct).</a>
<span class="sourceLineNo">2935</span><a id="line.2935">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2936</span><a id="line.2936">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2937</span><a id="line.2937">     *    REF: SOLVEPNP_UPNP &lt;b&gt;Broken implementation. Using this flag will fallback to EPnP.&lt;/b&gt; \n</a>
<span class="sourceLineNo">2938</span><a id="line.2938">     * Method is based on the paper of A.Penate-Sanchez, J.Andrade-Cetto,</a>
<span class="sourceLineNo">2939</span><a id="line.2939">     * F.Moreno-Noguer. "Exhaustive Linearization for Robust Camera Pose and Focal Length</a>
<span class="sourceLineNo">2940</span><a id="line.2940">     * Estimation" (CITE: penate2013exhaustive). In this case the function also estimates the parameters \(f_x\) and \(f_y\)</a>
<span class="sourceLineNo">2941</span><a id="line.2941">     * assuming that both have the same value. Then the cameraMatrix is updated with the estimated</a>
<span class="sourceLineNo">2942</span><a id="line.2942">     * focal length.</a>
<span class="sourceLineNo">2943</span><a id="line.2943">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2944</span><a id="line.2944">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2945</span><a id="line.2945">     *    REF: SOLVEPNP_IPPE Method is based on the paper of T. Collins and A. Bartoli.</a>
<span class="sourceLineNo">2946</span><a id="line.2946">     * "Infinitesimal Plane-Based Pose Estimation" (CITE: Collins14). This method requires coplanar object points.</a>
<span class="sourceLineNo">2947</span><a id="line.2947">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2948</span><a id="line.2948">     *   &lt;li&gt;</a>
<span class="sourceLineNo">2949</span><a id="line.2949">     *    REF: SOLVEPNP_IPPE_SQUARE Method is based on the paper of Toby Collins and Adrien Bartoli.</a>
<span class="sourceLineNo">2950</span><a id="line.2950">     * "Infinitesimal Plane-Based Pose Estimation" (CITE: Collins14). This method is suitable for marker pose estimation.</a>
<span class="sourceLineNo">2951</span><a id="line.2951">     * It requires 4 coplanar object points defined in the following order:</a>
<span class="sourceLineNo">2952</span><a id="line.2952">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">2953</span><a id="line.2953">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2954</span><a id="line.2954">     *    point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">2955</span><a id="line.2955">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2956</span><a id="line.2956">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2957</span><a id="line.2957">     *    point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">2958</span><a id="line.2958">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2959</span><a id="line.2959">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2960</span><a id="line.2960">     *    point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">2961</span><a id="line.2961">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2962</span><a id="line.2962">     *     &lt;li&gt;</a>
<span class="sourceLineNo">2963</span><a id="line.2963">     *    point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">2964</span><a id="line.2964">     * @param rvec Rotation vector used to initialize an iterative PnP refinement algorithm, when flag is REF: SOLVEPNP_ITERATIVE</a>
<span class="sourceLineNo">2965</span><a id="line.2965">     * and useExtrinsicGuess is set to true.</a>
<span class="sourceLineNo">2966</span><a id="line.2966">     * @param tvec Translation vector used to initialize an iterative PnP refinement algorithm, when flag is REF: SOLVEPNP_ITERATIVE</a>
<span class="sourceLineNo">2967</span><a id="line.2967">     * and useExtrinsicGuess is set to true.</a>
<span class="sourceLineNo">2968</span><a id="line.2968">     * @param reprojectionError Optional vector of reprojection error, that is the RMS error</a>
<span class="sourceLineNo">2969</span><a id="line.2969">     * (\( \text{RMSE} = \sqrt{\frac{\sum_{i}^{N} \left ( \hat{y_i} - y_i \right )^2}{N}} \)) between the input image points</a>
<span class="sourceLineNo">2970</span><a id="line.2970">     * and the 3D object points projected with the estimated pose.</a>
<span class="sourceLineNo">2971</span><a id="line.2971">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">2972</span><a id="line.2972">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">2973</span><a id="line.2973">     *</a>
<span class="sourceLineNo">2974</span><a id="line.2974">     * The function estimates the object pose given a set of object points, their corresponding image</a>
<span class="sourceLineNo">2975</span><a id="line.2975">     * projections, as well as the camera intrinsic matrix and the distortion coefficients, see the figure below</a>
<span class="sourceLineNo">2976</span><a id="line.2976">     * (more precisely, the X-axis of the camera frame is pointing to the right, the Y-axis downward</a>
<span class="sourceLineNo">2977</span><a id="line.2977">     * and the Z-axis forward).</a>
<span class="sourceLineNo">2978</span><a id="line.2978">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">2979</span><a id="line.2979">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">2980</span><a id="line.2980">     *</a>
<span class="sourceLineNo">2981</span><a id="line.2981">     * ![](pnp.jpg)</a>
<span class="sourceLineNo">2982</span><a id="line.2982">     *</a>
<span class="sourceLineNo">2983</span><a id="line.2983">     * Points expressed in the world frame \( \bf{X}_w \) are projected into the image plane \( \left[ u, v \right] \)</a>
<span class="sourceLineNo">2984</span><a id="line.2984">     * using the perspective projection model \( \Pi \) and the camera intrinsic parameters matrix \( \bf{A} \):</a>
<span class="sourceLineNo">2985</span><a id="line.2985">     *</a>
<span class="sourceLineNo">2986</span><a id="line.2986">     * \(</a>
<span class="sourceLineNo">2987</span><a id="line.2987">     *   \begin{align*}</a>
<span class="sourceLineNo">2988</span><a id="line.2988">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">2989</span><a id="line.2989">     *   u \\</a>
<span class="sourceLineNo">2990</span><a id="line.2990">     *   v \\</a>
<span class="sourceLineNo">2991</span><a id="line.2991">     *   1</a>
<span class="sourceLineNo">2992</span><a id="line.2992">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">2993</span><a id="line.2993">     *   \bf{A} \hspace{0.1em} \Pi \hspace{0.2em} ^{c}\bf{T}_w</a>
<span class="sourceLineNo">2994</span><a id="line.2994">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">2995</span><a id="line.2995">     *   X_{w} \\</a>
<span class="sourceLineNo">2996</span><a id="line.2996">     *   Y_{w} \\</a>
<span class="sourceLineNo">2997</span><a id="line.2997">     *   Z_{w} \\</a>
<span class="sourceLineNo">2998</span><a id="line.2998">     *   1</a>
<span class="sourceLineNo">2999</span><a id="line.2999">     *   \end{bmatrix} \\</a>
<span class="sourceLineNo">3000</span><a id="line.3000">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3001</span><a id="line.3001">     *   u \\</a>
<span class="sourceLineNo">3002</span><a id="line.3002">     *   v \\</a>
<span class="sourceLineNo">3003</span><a id="line.3003">     *   1</a>
<span class="sourceLineNo">3004</span><a id="line.3004">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">3005</span><a id="line.3005">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3006</span><a id="line.3006">     *   f_x &amp;amp; 0 &amp;amp; c_x \\</a>
<span class="sourceLineNo">3007</span><a id="line.3007">     *   0 &amp;amp; f_y &amp;amp; c_y \\</a>
<span class="sourceLineNo">3008</span><a id="line.3008">     *   0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">3009</span><a id="line.3009">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3010</span><a id="line.3010">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3011</span><a id="line.3011">     *   1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\</a>
<span class="sourceLineNo">3012</span><a id="line.3012">     *   0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\</a>
<span class="sourceLineNo">3013</span><a id="line.3013">     *   0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">3014</span><a id="line.3014">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3015</span><a id="line.3015">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3016</span><a id="line.3016">     *   r_{11} &amp;amp; r_{12} &amp;amp; r_{13} &amp;amp; t_x \\</a>
<span class="sourceLineNo">3017</span><a id="line.3017">     *   r_{21} &amp;amp; r_{22} &amp;amp; r_{23} &amp;amp; t_y \\</a>
<span class="sourceLineNo">3018</span><a id="line.3018">     *   r_{31} &amp;amp; r_{32} &amp;amp; r_{33} &amp;amp; t_z \\</a>
<span class="sourceLineNo">3019</span><a id="line.3019">     *   0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">3020</span><a id="line.3020">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3021</span><a id="line.3021">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3022</span><a id="line.3022">     *   X_{w} \\</a>
<span class="sourceLineNo">3023</span><a id="line.3023">     *   Y_{w} \\</a>
<span class="sourceLineNo">3024</span><a id="line.3024">     *   Z_{w} \\</a>
<span class="sourceLineNo">3025</span><a id="line.3025">     *   1</a>
<span class="sourceLineNo">3026</span><a id="line.3026">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3027</span><a id="line.3027">     *   \end{align*}</a>
<span class="sourceLineNo">3028</span><a id="line.3028">     * \)</a>
<span class="sourceLineNo">3029</span><a id="line.3029">     *</a>
<span class="sourceLineNo">3030</span><a id="line.3030">     * The estimated pose is thus the rotation ({@code rvec}) and the translation ({@code tvec}) vectors that allow transforming</a>
<span class="sourceLineNo">3031</span><a id="line.3031">     * a 3D point expressed in the world frame into the camera frame:</a>
<span class="sourceLineNo">3032</span><a id="line.3032">     *</a>
<span class="sourceLineNo">3033</span><a id="line.3033">     * \(</a>
<span class="sourceLineNo">3034</span><a id="line.3034">     *   \begin{align*}</a>
<span class="sourceLineNo">3035</span><a id="line.3035">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3036</span><a id="line.3036">     *   X_c \\</a>
<span class="sourceLineNo">3037</span><a id="line.3037">     *   Y_c \\</a>
<span class="sourceLineNo">3038</span><a id="line.3038">     *   Z_c \\</a>
<span class="sourceLineNo">3039</span><a id="line.3039">     *   1</a>
<span class="sourceLineNo">3040</span><a id="line.3040">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">3041</span><a id="line.3041">     *   \hspace{0.2em} ^{c}\bf{T}_w</a>
<span class="sourceLineNo">3042</span><a id="line.3042">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3043</span><a id="line.3043">     *   X_{w} \\</a>
<span class="sourceLineNo">3044</span><a id="line.3044">     *   Y_{w} \\</a>
<span class="sourceLineNo">3045</span><a id="line.3045">     *   Z_{w} \\</a>
<span class="sourceLineNo">3046</span><a id="line.3046">     *   1</a>
<span class="sourceLineNo">3047</span><a id="line.3047">     *   \end{bmatrix} \\</a>
<span class="sourceLineNo">3048</span><a id="line.3048">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3049</span><a id="line.3049">     *   X_c \\</a>
<span class="sourceLineNo">3050</span><a id="line.3050">     *   Y_c \\</a>
<span class="sourceLineNo">3051</span><a id="line.3051">     *   Z_c \\</a>
<span class="sourceLineNo">3052</span><a id="line.3052">     *   1</a>
<span class="sourceLineNo">3053</span><a id="line.3053">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">3054</span><a id="line.3054">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3055</span><a id="line.3055">     *   r_{11} &amp;amp; r_{12} &amp;amp; r_{13} &amp;amp; t_x \\</a>
<span class="sourceLineNo">3056</span><a id="line.3056">     *   r_{21} &amp;amp; r_{22} &amp;amp; r_{23} &amp;amp; t_y \\</a>
<span class="sourceLineNo">3057</span><a id="line.3057">     *   r_{31} &amp;amp; r_{32} &amp;amp; r_{33} &amp;amp; t_z \\</a>
<span class="sourceLineNo">3058</span><a id="line.3058">     *   0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">3059</span><a id="line.3059">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3060</span><a id="line.3060">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3061</span><a id="line.3061">     *   X_{w} \\</a>
<span class="sourceLineNo">3062</span><a id="line.3062">     *   Y_{w} \\</a>
<span class="sourceLineNo">3063</span><a id="line.3063">     *   Z_{w} \\</a>
<span class="sourceLineNo">3064</span><a id="line.3064">     *   1</a>
<span class="sourceLineNo">3065</span><a id="line.3065">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3066</span><a id="line.3066">     *   \end{align*}</a>
<span class="sourceLineNo">3067</span><a id="line.3067">     * \)</a>
<span class="sourceLineNo">3068</span><a id="line.3068">     *</a>
<span class="sourceLineNo">3069</span><a id="line.3069">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">3070</span><a id="line.3070">     * &lt;ul&gt;</a>
<span class="sourceLineNo">3071</span><a id="line.3071">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3072</span><a id="line.3072">     *       An example of how to use solvePnP for planar augmented reality can be found at</a>
<span class="sourceLineNo">3073</span><a id="line.3073">     *         opencv_source_code/samples/python/plane_ar.py</a>
<span class="sourceLineNo">3074</span><a id="line.3074">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3075</span><a id="line.3075">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3076</span><a id="line.3076">     *       If you are using Python:</a>
<span class="sourceLineNo">3077</span><a id="line.3077">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">3078</span><a id="line.3078">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3079</span><a id="line.3079">     *          Numpy array slices won't work as input because solvePnP requires contiguous</a>
<span class="sourceLineNo">3080</span><a id="line.3080">     *         arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of</a>
<span class="sourceLineNo">3081</span><a id="line.3081">     *         modules/calib3d/src/solvepnp.cpp version 2.4.9)</a>
<span class="sourceLineNo">3082</span><a id="line.3082">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3083</span><a id="line.3083">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3084</span><a id="line.3084">     *          The P3P algorithm requires image points to be in an array of shape (N,1,2) due</a>
<span class="sourceLineNo">3085</span><a id="line.3085">     *         to its calling of cv::undistortPoints (around line 75 of modules/calib3d/src/solvepnp.cpp version 2.4.9)</a>
<span class="sourceLineNo">3086</span><a id="line.3086">     *         which requires 2-channel information.</a>
<span class="sourceLineNo">3087</span><a id="line.3087">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3088</span><a id="line.3088">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3089</span><a id="line.3089">     *          Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of</a>
<span class="sourceLineNo">3090</span><a id="line.3090">     *         it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =</a>
<span class="sourceLineNo">3091</span><a id="line.3091">     *         np.ascontiguousarray(D[:,:2]).reshape((N,1,2))</a>
<span class="sourceLineNo">3092</span><a id="line.3092">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3093</span><a id="line.3093">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">3094</span><a id="line.3094">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3095</span><a id="line.3095">     *       The methods REF: SOLVEPNP_DLS and REF: SOLVEPNP_UPNP cannot be used as the current implementations are</a>
<span class="sourceLineNo">3096</span><a id="line.3096">     *        unstable and sometimes give completely wrong results. If you pass one of these two</a>
<span class="sourceLineNo">3097</span><a id="line.3097">     *        flags, REF: SOLVEPNP_EPNP method will be used instead.</a>
<span class="sourceLineNo">3098</span><a id="line.3098">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3099</span><a id="line.3099">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3100</span><a id="line.3100">     *       The minimum number of points is 4 in the general case. In the case of REF: SOLVEPNP_P3P and REF: SOLVEPNP_AP3P</a>
<span class="sourceLineNo">3101</span><a id="line.3101">     *        methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions</a>
<span class="sourceLineNo">3102</span><a id="line.3102">     *        of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).</a>
<span class="sourceLineNo">3103</span><a id="line.3103">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3104</span><a id="line.3104">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3105</span><a id="line.3105">     *       With REF: SOLVEPNP_ITERATIVE method and {@code useExtrinsicGuess=true}, the minimum number of points is 3 (3 points</a>
<span class="sourceLineNo">3106</span><a id="line.3106">     *        are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the</a>
<span class="sourceLineNo">3107</span><a id="line.3107">     *        global solution to converge.</a>
<span class="sourceLineNo">3108</span><a id="line.3108">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3109</span><a id="line.3109">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3110</span><a id="line.3110">     *       With REF: SOLVEPNP_IPPE input points must be &amp;gt;= 4 and object points must be coplanar.</a>
<span class="sourceLineNo">3111</span><a id="line.3111">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3112</span><a id="line.3112">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3113</span><a id="line.3113">     *       With REF: SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation.</a>
<span class="sourceLineNo">3114</span><a id="line.3114">     *        Number of input points must be 4. Object points must be defined in the following order:</a>
<span class="sourceLineNo">3115</span><a id="line.3115">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">3116</span><a id="line.3116">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3117</span><a id="line.3117">     *           point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">3118</span><a id="line.3118">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3119</span><a id="line.3119">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3120</span><a id="line.3120">     *           point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">3121</span><a id="line.3121">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3122</span><a id="line.3122">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3123</span><a id="line.3123">     *           point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">3124</span><a id="line.3124">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3125</span><a id="line.3125">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3126</span><a id="line.3126">     *           point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">3127</span><a id="line.3127">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3128</span><a id="line.3128">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">3129</span><a id="line.3129">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3130</span><a id="line.3130">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">3131</span><a id="line.3131">     * @return automatically generated</a>
<span class="sourceLineNo">3132</span><a id="line.3132">     */</a>
<span class="sourceLineNo">3133</span><a id="line.3133">    public static int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List&lt;Mat&gt; rvecs, List&lt;Mat&gt; tvecs, boolean useExtrinsicGuess, int flags, Mat rvec, Mat tvec, Mat reprojectionError) {</a>
<span class="sourceLineNo">3134</span><a id="line.3134">        Mat rvecs_mat = new Mat();</a>
<span class="sourceLineNo">3135</span><a id="line.3135">        Mat tvecs_mat = new Mat();</a>
<span class="sourceLineNo">3136</span><a id="line.3136">        int retVal = solvePnPGeneric_0(objectPoints.nativeObj, imagePoints.nativeObj, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvecs_mat.nativeObj, tvecs_mat.nativeObj, useExtrinsicGuess, flags, rvec.nativeObj, tvec.nativeObj, reprojectionError.nativeObj);</a>
<span class="sourceLineNo">3137</span><a id="line.3137">        Converters.Mat_to_vector_Mat(rvecs_mat, rvecs);</a>
<span class="sourceLineNo">3138</span><a id="line.3138">        rvecs_mat.release();</a>
<span class="sourceLineNo">3139</span><a id="line.3139">        Converters.Mat_to_vector_Mat(tvecs_mat, tvecs);</a>
<span class="sourceLineNo">3140</span><a id="line.3140">        tvecs_mat.release();</a>
<span class="sourceLineNo">3141</span><a id="line.3141">        return retVal;</a>
<span class="sourceLineNo">3142</span><a id="line.3142">    }</a>
<span class="sourceLineNo">3143</span><a id="line.3143"></a>
<span class="sourceLineNo">3144</span><a id="line.3144">    /**</a>
<span class="sourceLineNo">3145</span><a id="line.3145">     * Finds an object pose from 3D-2D point correspondences.</a>
<span class="sourceLineNo">3146</span><a id="line.3146">     * This function returns a list of all the possible solutions (a solution is a &amp;lt;rotation vector, translation vector&amp;gt;</a>
<span class="sourceLineNo">3147</span><a id="line.3147">     * couple), depending on the number of input points and the chosen method:</a>
<span class="sourceLineNo">3148</span><a id="line.3148">     * &lt;ul&gt;</a>
<span class="sourceLineNo">3149</span><a id="line.3149">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3150</span><a id="line.3150">     *  P3P methods (REF: SOLVEPNP_P3P, REF: SOLVEPNP_AP3P): 3 or 4 input points. Number of returned solutions can be between 0 and 4 with 3 input points.</a>
<span class="sourceLineNo">3151</span><a id="line.3151">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3152</span><a id="line.3152">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3153</span><a id="line.3153">     *  REF: SOLVEPNP_IPPE Input points must be &amp;gt;= 4 and object points must be coplanar. Returns 2 solutions.</a>
<span class="sourceLineNo">3154</span><a id="line.3154">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3155</span><a id="line.3155">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3156</span><a id="line.3156">     *  REF: SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.</a>
<span class="sourceLineNo">3157</span><a id="line.3157">     * Number of input points must be 4 and 2 solutions are returned. Object points must be defined in the following order:</a>
<span class="sourceLineNo">3158</span><a id="line.3158">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">3159</span><a id="line.3159">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3160</span><a id="line.3160">     *    point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">3161</span><a id="line.3161">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3162</span><a id="line.3162">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3163</span><a id="line.3163">     *    point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">3164</span><a id="line.3164">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3165</span><a id="line.3165">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3166</span><a id="line.3166">     *    point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">3167</span><a id="line.3167">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3168</span><a id="line.3168">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3169</span><a id="line.3169">     *    point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">3170</span><a id="line.3170">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3171</span><a id="line.3171">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">3172</span><a id="line.3172">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3173</span><a id="line.3173">     *  for all the other flags, number of input points must be &amp;gt;= 4 and object points can be in any configuration.</a>
<span class="sourceLineNo">3174</span><a id="line.3174">     * Only 1 solution is returned.</a>
<span class="sourceLineNo">3175</span><a id="line.3175">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3176</span><a id="line.3176">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">3177</span><a id="line.3177">     *</a>
<span class="sourceLineNo">3178</span><a id="line.3178">     * @param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or</a>
<span class="sourceLineNo">3179</span><a id="line.3179">     * 1xN/Nx1 3-channel, where N is the number of points. vector&amp;lt;Point3d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">3180</span><a id="line.3180">     * @param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,</a>
<span class="sourceLineNo">3181</span><a id="line.3181">     * where N is the number of points. vector&amp;lt;Point2d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">3182</span><a id="line.3182">     * @param cameraMatrix Input camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">3183</span><a id="line.3183">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">3184</span><a id="line.3184">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">3185</span><a id="line.3185">     * assumed.</a>
<span class="sourceLineNo">3186</span><a id="line.3186">     * @param rvecs Vector of output rotation vectors (see REF: Rodrigues ) that, together with tvecs, brings points from</a>
<span class="sourceLineNo">3187</span><a id="line.3187">     * the model coordinate system to the camera coordinate system.</a>
<span class="sourceLineNo">3188</span><a id="line.3188">     * @param tvecs Vector of output translation vectors.</a>
<span class="sourceLineNo">3189</span><a id="line.3189">     * @param useExtrinsicGuess Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses</a>
<span class="sourceLineNo">3190</span><a id="line.3190">     * the provided rvec and tvec values as initial approximations of the rotation and translation</a>
<span class="sourceLineNo">3191</span><a id="line.3191">     * vectors, respectively, and further optimizes them.</a>
<span class="sourceLineNo">3192</span><a id="line.3192">     * @param flags Method for solving a PnP problem:</a>
<span class="sourceLineNo">3193</span><a id="line.3193">     * &lt;ul&gt;</a>
<span class="sourceLineNo">3194</span><a id="line.3194">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3195</span><a id="line.3195">     *    REF: SOLVEPNP_ITERATIVE Iterative method is based on a Levenberg-Marquardt optimization. In</a>
<span class="sourceLineNo">3196</span><a id="line.3196">     * this case the function finds such a pose that minimizes reprojection error, that is the sum</a>
<span class="sourceLineNo">3197</span><a id="line.3197">     * of squared distances between the observed projections imagePoints and the projected (using</a>
<span class="sourceLineNo">3198</span><a id="line.3198">     * projectPoints ) objectPoints .</a>
<span class="sourceLineNo">3199</span><a id="line.3199">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3200</span><a id="line.3200">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3201</span><a id="line.3201">     *    REF: SOLVEPNP_P3P Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang</a>
<span class="sourceLineNo">3202</span><a id="line.3202">     * "Complete Solution Classification for the Perspective-Three-Point Problem" (CITE: gao2003complete).</a>
<span class="sourceLineNo">3203</span><a id="line.3203">     * In this case the function requires exactly four object and image points.</a>
<span class="sourceLineNo">3204</span><a id="line.3204">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3205</span><a id="line.3205">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3206</span><a id="line.3206">     *    REF: SOLVEPNP_AP3P Method is based on the paper of T. Ke, S. Roumeliotis</a>
<span class="sourceLineNo">3207</span><a id="line.3207">     * "An Efficient Algebraic Solution to the Perspective-Three-Point Problem" (CITE: Ke17).</a>
<span class="sourceLineNo">3208</span><a id="line.3208">     * In this case the function requires exactly four object and image points.</a>
<span class="sourceLineNo">3209</span><a id="line.3209">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3210</span><a id="line.3210">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3211</span><a id="line.3211">     *    REF: SOLVEPNP_EPNP Method has been introduced by F.Moreno-Noguer, V.Lepetit and P.Fua in the</a>
<span class="sourceLineNo">3212</span><a id="line.3212">     * paper "EPnP: Efficient Perspective-n-Point Camera Pose Estimation" (CITE: lepetit2009epnp).</a>
<span class="sourceLineNo">3213</span><a id="line.3213">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3214</span><a id="line.3214">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3215</span><a id="line.3215">     *    REF: SOLVEPNP_DLS &lt;b&gt;Broken implementation. Using this flag will fallback to EPnP.&lt;/b&gt; \n</a>
<span class="sourceLineNo">3216</span><a id="line.3216">     * Method is based on the paper of Joel A. Hesch and Stergios I. Roumeliotis.</a>
<span class="sourceLineNo">3217</span><a id="line.3217">     * "A Direct Least-Squares (DLS) Method for PnP" (CITE: hesch2011direct).</a>
<span class="sourceLineNo">3218</span><a id="line.3218">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3219</span><a id="line.3219">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3220</span><a id="line.3220">     *    REF: SOLVEPNP_UPNP &lt;b&gt;Broken implementation. Using this flag will fallback to EPnP.&lt;/b&gt; \n</a>
<span class="sourceLineNo">3221</span><a id="line.3221">     * Method is based on the paper of A.Penate-Sanchez, J.Andrade-Cetto,</a>
<span class="sourceLineNo">3222</span><a id="line.3222">     * F.Moreno-Noguer. "Exhaustive Linearization for Robust Camera Pose and Focal Length</a>
<span class="sourceLineNo">3223</span><a id="line.3223">     * Estimation" (CITE: penate2013exhaustive). In this case the function also estimates the parameters \(f_x\) and \(f_y\)</a>
<span class="sourceLineNo">3224</span><a id="line.3224">     * assuming that both have the same value. Then the cameraMatrix is updated with the estimated</a>
<span class="sourceLineNo">3225</span><a id="line.3225">     * focal length.</a>
<span class="sourceLineNo">3226</span><a id="line.3226">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3227</span><a id="line.3227">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3228</span><a id="line.3228">     *    REF: SOLVEPNP_IPPE Method is based on the paper of T. Collins and A. Bartoli.</a>
<span class="sourceLineNo">3229</span><a id="line.3229">     * "Infinitesimal Plane-Based Pose Estimation" (CITE: Collins14). This method requires coplanar object points.</a>
<span class="sourceLineNo">3230</span><a id="line.3230">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3231</span><a id="line.3231">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3232</span><a id="line.3232">     *    REF: SOLVEPNP_IPPE_SQUARE Method is based on the paper of Toby Collins and Adrien Bartoli.</a>
<span class="sourceLineNo">3233</span><a id="line.3233">     * "Infinitesimal Plane-Based Pose Estimation" (CITE: Collins14). This method is suitable for marker pose estimation.</a>
<span class="sourceLineNo">3234</span><a id="line.3234">     * It requires 4 coplanar object points defined in the following order:</a>
<span class="sourceLineNo">3235</span><a id="line.3235">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">3236</span><a id="line.3236">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3237</span><a id="line.3237">     *    point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">3238</span><a id="line.3238">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3239</span><a id="line.3239">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3240</span><a id="line.3240">     *    point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">3241</span><a id="line.3241">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3242</span><a id="line.3242">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3243</span><a id="line.3243">     *    point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">3244</span><a id="line.3244">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3245</span><a id="line.3245">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3246</span><a id="line.3246">     *    point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">3247</span><a id="line.3247">     * @param rvec Rotation vector used to initialize an iterative PnP refinement algorithm, when flag is REF: SOLVEPNP_ITERATIVE</a>
<span class="sourceLineNo">3248</span><a id="line.3248">     * and useExtrinsicGuess is set to true.</a>
<span class="sourceLineNo">3249</span><a id="line.3249">     * @param tvec Translation vector used to initialize an iterative PnP refinement algorithm, when flag is REF: SOLVEPNP_ITERATIVE</a>
<span class="sourceLineNo">3250</span><a id="line.3250">     * and useExtrinsicGuess is set to true.</a>
<span class="sourceLineNo">3251</span><a id="line.3251">     * (\( \text{RMSE} = \sqrt{\frac{\sum_{i}^{N} \left ( \hat{y_i} - y_i \right )^2}{N}} \)) between the input image points</a>
<span class="sourceLineNo">3252</span><a id="line.3252">     * and the 3D object points projected with the estimated pose.</a>
<span class="sourceLineNo">3253</span><a id="line.3253">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3254</span><a id="line.3254">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">3255</span><a id="line.3255">     *</a>
<span class="sourceLineNo">3256</span><a id="line.3256">     * The function estimates the object pose given a set of object points, their corresponding image</a>
<span class="sourceLineNo">3257</span><a id="line.3257">     * projections, as well as the camera intrinsic matrix and the distortion coefficients, see the figure below</a>
<span class="sourceLineNo">3258</span><a id="line.3258">     * (more precisely, the X-axis of the camera frame is pointing to the right, the Y-axis downward</a>
<span class="sourceLineNo">3259</span><a id="line.3259">     * and the Z-axis forward).</a>
<span class="sourceLineNo">3260</span><a id="line.3260">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3261</span><a id="line.3261">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">3262</span><a id="line.3262">     *</a>
<span class="sourceLineNo">3263</span><a id="line.3263">     * ![](pnp.jpg)</a>
<span class="sourceLineNo">3264</span><a id="line.3264">     *</a>
<span class="sourceLineNo">3265</span><a id="line.3265">     * Points expressed in the world frame \( \bf{X}_w \) are projected into the image plane \( \left[ u, v \right] \)</a>
<span class="sourceLineNo">3266</span><a id="line.3266">     * using the perspective projection model \( \Pi \) and the camera intrinsic parameters matrix \( \bf{A} \):</a>
<span class="sourceLineNo">3267</span><a id="line.3267">     *</a>
<span class="sourceLineNo">3268</span><a id="line.3268">     * \(</a>
<span class="sourceLineNo">3269</span><a id="line.3269">     *   \begin{align*}</a>
<span class="sourceLineNo">3270</span><a id="line.3270">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3271</span><a id="line.3271">     *   u \\</a>
<span class="sourceLineNo">3272</span><a id="line.3272">     *   v \\</a>
<span class="sourceLineNo">3273</span><a id="line.3273">     *   1</a>
<span class="sourceLineNo">3274</span><a id="line.3274">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">3275</span><a id="line.3275">     *   \bf{A} \hspace{0.1em} \Pi \hspace{0.2em} ^{c}\bf{T}_w</a>
<span class="sourceLineNo">3276</span><a id="line.3276">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3277</span><a id="line.3277">     *   X_{w} \\</a>
<span class="sourceLineNo">3278</span><a id="line.3278">     *   Y_{w} \\</a>
<span class="sourceLineNo">3279</span><a id="line.3279">     *   Z_{w} \\</a>
<span class="sourceLineNo">3280</span><a id="line.3280">     *   1</a>
<span class="sourceLineNo">3281</span><a id="line.3281">     *   \end{bmatrix} \\</a>
<span class="sourceLineNo">3282</span><a id="line.3282">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3283</span><a id="line.3283">     *   u \\</a>
<span class="sourceLineNo">3284</span><a id="line.3284">     *   v \\</a>
<span class="sourceLineNo">3285</span><a id="line.3285">     *   1</a>
<span class="sourceLineNo">3286</span><a id="line.3286">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">3287</span><a id="line.3287">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3288</span><a id="line.3288">     *   f_x &amp;amp; 0 &amp;amp; c_x \\</a>
<span class="sourceLineNo">3289</span><a id="line.3289">     *   0 &amp;amp; f_y &amp;amp; c_y \\</a>
<span class="sourceLineNo">3290</span><a id="line.3290">     *   0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">3291</span><a id="line.3291">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3292</span><a id="line.3292">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3293</span><a id="line.3293">     *   1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\</a>
<span class="sourceLineNo">3294</span><a id="line.3294">     *   0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\</a>
<span class="sourceLineNo">3295</span><a id="line.3295">     *   0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">3296</span><a id="line.3296">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3297</span><a id="line.3297">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3298</span><a id="line.3298">     *   r_{11} &amp;amp; r_{12} &amp;amp; r_{13} &amp;amp; t_x \\</a>
<span class="sourceLineNo">3299</span><a id="line.3299">     *   r_{21} &amp;amp; r_{22} &amp;amp; r_{23} &amp;amp; t_y \\</a>
<span class="sourceLineNo">3300</span><a id="line.3300">     *   r_{31} &amp;amp; r_{32} &amp;amp; r_{33} &amp;amp; t_z \\</a>
<span class="sourceLineNo">3301</span><a id="line.3301">     *   0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">3302</span><a id="line.3302">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3303</span><a id="line.3303">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3304</span><a id="line.3304">     *   X_{w} \\</a>
<span class="sourceLineNo">3305</span><a id="line.3305">     *   Y_{w} \\</a>
<span class="sourceLineNo">3306</span><a id="line.3306">     *   Z_{w} \\</a>
<span class="sourceLineNo">3307</span><a id="line.3307">     *   1</a>
<span class="sourceLineNo">3308</span><a id="line.3308">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3309</span><a id="line.3309">     *   \end{align*}</a>
<span class="sourceLineNo">3310</span><a id="line.3310">     * \)</a>
<span class="sourceLineNo">3311</span><a id="line.3311">     *</a>
<span class="sourceLineNo">3312</span><a id="line.3312">     * The estimated pose is thus the rotation ({@code rvec}) and the translation ({@code tvec}) vectors that allow transforming</a>
<span class="sourceLineNo">3313</span><a id="line.3313">     * a 3D point expressed in the world frame into the camera frame:</a>
<span class="sourceLineNo">3314</span><a id="line.3314">     *</a>
<span class="sourceLineNo">3315</span><a id="line.3315">     * \(</a>
<span class="sourceLineNo">3316</span><a id="line.3316">     *   \begin{align*}</a>
<span class="sourceLineNo">3317</span><a id="line.3317">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3318</span><a id="line.3318">     *   X_c \\</a>
<span class="sourceLineNo">3319</span><a id="line.3319">     *   Y_c \\</a>
<span class="sourceLineNo">3320</span><a id="line.3320">     *   Z_c \\</a>
<span class="sourceLineNo">3321</span><a id="line.3321">     *   1</a>
<span class="sourceLineNo">3322</span><a id="line.3322">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">3323</span><a id="line.3323">     *   \hspace{0.2em} ^{c}\bf{T}_w</a>
<span class="sourceLineNo">3324</span><a id="line.3324">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3325</span><a id="line.3325">     *   X_{w} \\</a>
<span class="sourceLineNo">3326</span><a id="line.3326">     *   Y_{w} \\</a>
<span class="sourceLineNo">3327</span><a id="line.3327">     *   Z_{w} \\</a>
<span class="sourceLineNo">3328</span><a id="line.3328">     *   1</a>
<span class="sourceLineNo">3329</span><a id="line.3329">     *   \end{bmatrix} \\</a>
<span class="sourceLineNo">3330</span><a id="line.3330">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3331</span><a id="line.3331">     *   X_c \\</a>
<span class="sourceLineNo">3332</span><a id="line.3332">     *   Y_c \\</a>
<span class="sourceLineNo">3333</span><a id="line.3333">     *   Z_c \\</a>
<span class="sourceLineNo">3334</span><a id="line.3334">     *   1</a>
<span class="sourceLineNo">3335</span><a id="line.3335">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">3336</span><a id="line.3336">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3337</span><a id="line.3337">     *   r_{11} &amp;amp; r_{12} &amp;amp; r_{13} &amp;amp; t_x \\</a>
<span class="sourceLineNo">3338</span><a id="line.3338">     *   r_{21} &amp;amp; r_{22} &amp;amp; r_{23} &amp;amp; t_y \\</a>
<span class="sourceLineNo">3339</span><a id="line.3339">     *   r_{31} &amp;amp; r_{32} &amp;amp; r_{33} &amp;amp; t_z \\</a>
<span class="sourceLineNo">3340</span><a id="line.3340">     *   0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">3341</span><a id="line.3341">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3342</span><a id="line.3342">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3343</span><a id="line.3343">     *   X_{w} \\</a>
<span class="sourceLineNo">3344</span><a id="line.3344">     *   Y_{w} \\</a>
<span class="sourceLineNo">3345</span><a id="line.3345">     *   Z_{w} \\</a>
<span class="sourceLineNo">3346</span><a id="line.3346">     *   1</a>
<span class="sourceLineNo">3347</span><a id="line.3347">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3348</span><a id="line.3348">     *   \end{align*}</a>
<span class="sourceLineNo">3349</span><a id="line.3349">     * \)</a>
<span class="sourceLineNo">3350</span><a id="line.3350">     *</a>
<span class="sourceLineNo">3351</span><a id="line.3351">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">3352</span><a id="line.3352">     * &lt;ul&gt;</a>
<span class="sourceLineNo">3353</span><a id="line.3353">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3354</span><a id="line.3354">     *       An example of how to use solvePnP for planar augmented reality can be found at</a>
<span class="sourceLineNo">3355</span><a id="line.3355">     *         opencv_source_code/samples/python/plane_ar.py</a>
<span class="sourceLineNo">3356</span><a id="line.3356">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3357</span><a id="line.3357">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3358</span><a id="line.3358">     *       If you are using Python:</a>
<span class="sourceLineNo">3359</span><a id="line.3359">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">3360</span><a id="line.3360">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3361</span><a id="line.3361">     *          Numpy array slices won't work as input because solvePnP requires contiguous</a>
<span class="sourceLineNo">3362</span><a id="line.3362">     *         arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of</a>
<span class="sourceLineNo">3363</span><a id="line.3363">     *         modules/calib3d/src/solvepnp.cpp version 2.4.9)</a>
<span class="sourceLineNo">3364</span><a id="line.3364">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3365</span><a id="line.3365">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3366</span><a id="line.3366">     *          The P3P algorithm requires image points to be in an array of shape (N,1,2) due</a>
<span class="sourceLineNo">3367</span><a id="line.3367">     *         to its calling of cv::undistortPoints (around line 75 of modules/calib3d/src/solvepnp.cpp version 2.4.9)</a>
<span class="sourceLineNo">3368</span><a id="line.3368">     *         which requires 2-channel information.</a>
<span class="sourceLineNo">3369</span><a id="line.3369">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3370</span><a id="line.3370">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3371</span><a id="line.3371">     *          Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of</a>
<span class="sourceLineNo">3372</span><a id="line.3372">     *         it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =</a>
<span class="sourceLineNo">3373</span><a id="line.3373">     *         np.ascontiguousarray(D[:,:2]).reshape((N,1,2))</a>
<span class="sourceLineNo">3374</span><a id="line.3374">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3375</span><a id="line.3375">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">3376</span><a id="line.3376">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3377</span><a id="line.3377">     *       The methods REF: SOLVEPNP_DLS and REF: SOLVEPNP_UPNP cannot be used as the current implementations are</a>
<span class="sourceLineNo">3378</span><a id="line.3378">     *        unstable and sometimes give completely wrong results. If you pass one of these two</a>
<span class="sourceLineNo">3379</span><a id="line.3379">     *        flags, REF: SOLVEPNP_EPNP method will be used instead.</a>
<span class="sourceLineNo">3380</span><a id="line.3380">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3381</span><a id="line.3381">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3382</span><a id="line.3382">     *       The minimum number of points is 4 in the general case. In the case of REF: SOLVEPNP_P3P and REF: SOLVEPNP_AP3P</a>
<span class="sourceLineNo">3383</span><a id="line.3383">     *        methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions</a>
<span class="sourceLineNo">3384</span><a id="line.3384">     *        of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).</a>
<span class="sourceLineNo">3385</span><a id="line.3385">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3386</span><a id="line.3386">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3387</span><a id="line.3387">     *       With REF: SOLVEPNP_ITERATIVE method and {@code useExtrinsicGuess=true}, the minimum number of points is 3 (3 points</a>
<span class="sourceLineNo">3388</span><a id="line.3388">     *        are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the</a>
<span class="sourceLineNo">3389</span><a id="line.3389">     *        global solution to converge.</a>
<span class="sourceLineNo">3390</span><a id="line.3390">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3391</span><a id="line.3391">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3392</span><a id="line.3392">     *       With REF: SOLVEPNP_IPPE input points must be &amp;gt;= 4 and object points must be coplanar.</a>
<span class="sourceLineNo">3393</span><a id="line.3393">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3394</span><a id="line.3394">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3395</span><a id="line.3395">     *       With REF: SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation.</a>
<span class="sourceLineNo">3396</span><a id="line.3396">     *        Number of input points must be 4. Object points must be defined in the following order:</a>
<span class="sourceLineNo">3397</span><a id="line.3397">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">3398</span><a id="line.3398">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3399</span><a id="line.3399">     *           point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">3400</span><a id="line.3400">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3401</span><a id="line.3401">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3402</span><a id="line.3402">     *           point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">3403</span><a id="line.3403">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3404</span><a id="line.3404">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3405</span><a id="line.3405">     *           point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">3406</span><a id="line.3406">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3407</span><a id="line.3407">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3408</span><a id="line.3408">     *           point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">3409</span><a id="line.3409">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3410</span><a id="line.3410">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">3411</span><a id="line.3411">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3412</span><a id="line.3412">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">3413</span><a id="line.3413">     * @return automatically generated</a>
<span class="sourceLineNo">3414</span><a id="line.3414">     */</a>
<span class="sourceLineNo">3415</span><a id="line.3415">    public static int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List&lt;Mat&gt; rvecs, List&lt;Mat&gt; tvecs, boolean useExtrinsicGuess, int flags, Mat rvec, Mat tvec) {</a>
<span class="sourceLineNo">3416</span><a id="line.3416">        Mat rvecs_mat = new Mat();</a>
<span class="sourceLineNo">3417</span><a id="line.3417">        Mat tvecs_mat = new Mat();</a>
<span class="sourceLineNo">3418</span><a id="line.3418">        int retVal = solvePnPGeneric_1(objectPoints.nativeObj, imagePoints.nativeObj, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvecs_mat.nativeObj, tvecs_mat.nativeObj, useExtrinsicGuess, flags, rvec.nativeObj, tvec.nativeObj);</a>
<span class="sourceLineNo">3419</span><a id="line.3419">        Converters.Mat_to_vector_Mat(rvecs_mat, rvecs);</a>
<span class="sourceLineNo">3420</span><a id="line.3420">        rvecs_mat.release();</a>
<span class="sourceLineNo">3421</span><a id="line.3421">        Converters.Mat_to_vector_Mat(tvecs_mat, tvecs);</a>
<span class="sourceLineNo">3422</span><a id="line.3422">        tvecs_mat.release();</a>
<span class="sourceLineNo">3423</span><a id="line.3423">        return retVal;</a>
<span class="sourceLineNo">3424</span><a id="line.3424">    }</a>
<span class="sourceLineNo">3425</span><a id="line.3425"></a>
<span class="sourceLineNo">3426</span><a id="line.3426">    /**</a>
<span class="sourceLineNo">3427</span><a id="line.3427">     * Finds an object pose from 3D-2D point correspondences.</a>
<span class="sourceLineNo">3428</span><a id="line.3428">     * This function returns a list of all the possible solutions (a solution is a &amp;lt;rotation vector, translation vector&amp;gt;</a>
<span class="sourceLineNo">3429</span><a id="line.3429">     * couple), depending on the number of input points and the chosen method:</a>
<span class="sourceLineNo">3430</span><a id="line.3430">     * &lt;ul&gt;</a>
<span class="sourceLineNo">3431</span><a id="line.3431">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3432</span><a id="line.3432">     *  P3P methods (REF: SOLVEPNP_P3P, REF: SOLVEPNP_AP3P): 3 or 4 input points. Number of returned solutions can be between 0 and 4 with 3 input points.</a>
<span class="sourceLineNo">3433</span><a id="line.3433">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3434</span><a id="line.3434">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3435</span><a id="line.3435">     *  REF: SOLVEPNP_IPPE Input points must be &amp;gt;= 4 and object points must be coplanar. Returns 2 solutions.</a>
<span class="sourceLineNo">3436</span><a id="line.3436">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3437</span><a id="line.3437">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3438</span><a id="line.3438">     *  REF: SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.</a>
<span class="sourceLineNo">3439</span><a id="line.3439">     * Number of input points must be 4 and 2 solutions are returned. Object points must be defined in the following order:</a>
<span class="sourceLineNo">3440</span><a id="line.3440">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">3441</span><a id="line.3441">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3442</span><a id="line.3442">     *    point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">3443</span><a id="line.3443">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3444</span><a id="line.3444">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3445</span><a id="line.3445">     *    point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">3446</span><a id="line.3446">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3447</span><a id="line.3447">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3448</span><a id="line.3448">     *    point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">3449</span><a id="line.3449">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3450</span><a id="line.3450">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3451</span><a id="line.3451">     *    point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">3452</span><a id="line.3452">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3453</span><a id="line.3453">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">3454</span><a id="line.3454">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3455</span><a id="line.3455">     *  for all the other flags, number of input points must be &amp;gt;= 4 and object points can be in any configuration.</a>
<span class="sourceLineNo">3456</span><a id="line.3456">     * Only 1 solution is returned.</a>
<span class="sourceLineNo">3457</span><a id="line.3457">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3458</span><a id="line.3458">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">3459</span><a id="line.3459">     *</a>
<span class="sourceLineNo">3460</span><a id="line.3460">     * @param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or</a>
<span class="sourceLineNo">3461</span><a id="line.3461">     * 1xN/Nx1 3-channel, where N is the number of points. vector&amp;lt;Point3d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">3462</span><a id="line.3462">     * @param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,</a>
<span class="sourceLineNo">3463</span><a id="line.3463">     * where N is the number of points. vector&amp;lt;Point2d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">3464</span><a id="line.3464">     * @param cameraMatrix Input camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">3465</span><a id="line.3465">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">3466</span><a id="line.3466">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">3467</span><a id="line.3467">     * assumed.</a>
<span class="sourceLineNo">3468</span><a id="line.3468">     * @param rvecs Vector of output rotation vectors (see REF: Rodrigues ) that, together with tvecs, brings points from</a>
<span class="sourceLineNo">3469</span><a id="line.3469">     * the model coordinate system to the camera coordinate system.</a>
<span class="sourceLineNo">3470</span><a id="line.3470">     * @param tvecs Vector of output translation vectors.</a>
<span class="sourceLineNo">3471</span><a id="line.3471">     * @param useExtrinsicGuess Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses</a>
<span class="sourceLineNo">3472</span><a id="line.3472">     * the provided rvec and tvec values as initial approximations of the rotation and translation</a>
<span class="sourceLineNo">3473</span><a id="line.3473">     * vectors, respectively, and further optimizes them.</a>
<span class="sourceLineNo">3474</span><a id="line.3474">     * @param flags Method for solving a PnP problem:</a>
<span class="sourceLineNo">3475</span><a id="line.3475">     * &lt;ul&gt;</a>
<span class="sourceLineNo">3476</span><a id="line.3476">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3477</span><a id="line.3477">     *    REF: SOLVEPNP_ITERATIVE Iterative method is based on a Levenberg-Marquardt optimization. In</a>
<span class="sourceLineNo">3478</span><a id="line.3478">     * this case the function finds such a pose that minimizes reprojection error, that is the sum</a>
<span class="sourceLineNo">3479</span><a id="line.3479">     * of squared distances between the observed projections imagePoints and the projected (using</a>
<span class="sourceLineNo">3480</span><a id="line.3480">     * projectPoints ) objectPoints .</a>
<span class="sourceLineNo">3481</span><a id="line.3481">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3482</span><a id="line.3482">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3483</span><a id="line.3483">     *    REF: SOLVEPNP_P3P Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang</a>
<span class="sourceLineNo">3484</span><a id="line.3484">     * "Complete Solution Classification for the Perspective-Three-Point Problem" (CITE: gao2003complete).</a>
<span class="sourceLineNo">3485</span><a id="line.3485">     * In this case the function requires exactly four object and image points.</a>
<span class="sourceLineNo">3486</span><a id="line.3486">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3487</span><a id="line.3487">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3488</span><a id="line.3488">     *    REF: SOLVEPNP_AP3P Method is based on the paper of T. Ke, S. Roumeliotis</a>
<span class="sourceLineNo">3489</span><a id="line.3489">     * "An Efficient Algebraic Solution to the Perspective-Three-Point Problem" (CITE: Ke17).</a>
<span class="sourceLineNo">3490</span><a id="line.3490">     * In this case the function requires exactly four object and image points.</a>
<span class="sourceLineNo">3491</span><a id="line.3491">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3492</span><a id="line.3492">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3493</span><a id="line.3493">     *    REF: SOLVEPNP_EPNP Method has been introduced by F.Moreno-Noguer, V.Lepetit and P.Fua in the</a>
<span class="sourceLineNo">3494</span><a id="line.3494">     * paper "EPnP: Efficient Perspective-n-Point Camera Pose Estimation" (CITE: lepetit2009epnp).</a>
<span class="sourceLineNo">3495</span><a id="line.3495">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3496</span><a id="line.3496">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3497</span><a id="line.3497">     *    REF: SOLVEPNP_DLS &lt;b&gt;Broken implementation. Using this flag will fallback to EPnP.&lt;/b&gt; \n</a>
<span class="sourceLineNo">3498</span><a id="line.3498">     * Method is based on the paper of Joel A. Hesch and Stergios I. Roumeliotis.</a>
<span class="sourceLineNo">3499</span><a id="line.3499">     * "A Direct Least-Squares (DLS) Method for PnP" (CITE: hesch2011direct).</a>
<span class="sourceLineNo">3500</span><a id="line.3500">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3501</span><a id="line.3501">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3502</span><a id="line.3502">     *    REF: SOLVEPNP_UPNP &lt;b&gt;Broken implementation. Using this flag will fallback to EPnP.&lt;/b&gt; \n</a>
<span class="sourceLineNo">3503</span><a id="line.3503">     * Method is based on the paper of A.Penate-Sanchez, J.Andrade-Cetto,</a>
<span class="sourceLineNo">3504</span><a id="line.3504">     * F.Moreno-Noguer. "Exhaustive Linearization for Robust Camera Pose and Focal Length</a>
<span class="sourceLineNo">3505</span><a id="line.3505">     * Estimation" (CITE: penate2013exhaustive). In this case the function also estimates the parameters \(f_x\) and \(f_y\)</a>
<span class="sourceLineNo">3506</span><a id="line.3506">     * assuming that both have the same value. Then the cameraMatrix is updated with the estimated</a>
<span class="sourceLineNo">3507</span><a id="line.3507">     * focal length.</a>
<span class="sourceLineNo">3508</span><a id="line.3508">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3509</span><a id="line.3509">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3510</span><a id="line.3510">     *    REF: SOLVEPNP_IPPE Method is based on the paper of T. Collins and A. Bartoli.</a>
<span class="sourceLineNo">3511</span><a id="line.3511">     * "Infinitesimal Plane-Based Pose Estimation" (CITE: Collins14). This method requires coplanar object points.</a>
<span class="sourceLineNo">3512</span><a id="line.3512">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3513</span><a id="line.3513">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3514</span><a id="line.3514">     *    REF: SOLVEPNP_IPPE_SQUARE Method is based on the paper of Toby Collins and Adrien Bartoli.</a>
<span class="sourceLineNo">3515</span><a id="line.3515">     * "Infinitesimal Plane-Based Pose Estimation" (CITE: Collins14). This method is suitable for marker pose estimation.</a>
<span class="sourceLineNo">3516</span><a id="line.3516">     * It requires 4 coplanar object points defined in the following order:</a>
<span class="sourceLineNo">3517</span><a id="line.3517">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">3518</span><a id="line.3518">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3519</span><a id="line.3519">     *    point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">3520</span><a id="line.3520">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3521</span><a id="line.3521">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3522</span><a id="line.3522">     *    point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">3523</span><a id="line.3523">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3524</span><a id="line.3524">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3525</span><a id="line.3525">     *    point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">3526</span><a id="line.3526">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3527</span><a id="line.3527">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3528</span><a id="line.3528">     *    point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">3529</span><a id="line.3529">     * @param rvec Rotation vector used to initialize an iterative PnP refinement algorithm, when flag is REF: SOLVEPNP_ITERATIVE</a>
<span class="sourceLineNo">3530</span><a id="line.3530">     * and useExtrinsicGuess is set to true.</a>
<span class="sourceLineNo">3531</span><a id="line.3531">     * and useExtrinsicGuess is set to true.</a>
<span class="sourceLineNo">3532</span><a id="line.3532">     * (\( \text{RMSE} = \sqrt{\frac{\sum_{i}^{N} \left ( \hat{y_i} - y_i \right )^2}{N}} \)) between the input image points</a>
<span class="sourceLineNo">3533</span><a id="line.3533">     * and the 3D object points projected with the estimated pose.</a>
<span class="sourceLineNo">3534</span><a id="line.3534">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3535</span><a id="line.3535">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">3536</span><a id="line.3536">     *</a>
<span class="sourceLineNo">3537</span><a id="line.3537">     * The function estimates the object pose given a set of object points, their corresponding image</a>
<span class="sourceLineNo">3538</span><a id="line.3538">     * projections, as well as the camera intrinsic matrix and the distortion coefficients, see the figure below</a>
<span class="sourceLineNo">3539</span><a id="line.3539">     * (more precisely, the X-axis of the camera frame is pointing to the right, the Y-axis downward</a>
<span class="sourceLineNo">3540</span><a id="line.3540">     * and the Z-axis forward).</a>
<span class="sourceLineNo">3541</span><a id="line.3541">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3542</span><a id="line.3542">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">3543</span><a id="line.3543">     *</a>
<span class="sourceLineNo">3544</span><a id="line.3544">     * ![](pnp.jpg)</a>
<span class="sourceLineNo">3545</span><a id="line.3545">     *</a>
<span class="sourceLineNo">3546</span><a id="line.3546">     * Points expressed in the world frame \( \bf{X}_w \) are projected into the image plane \( \left[ u, v \right] \)</a>
<span class="sourceLineNo">3547</span><a id="line.3547">     * using the perspective projection model \( \Pi \) and the camera intrinsic parameters matrix \( \bf{A} \):</a>
<span class="sourceLineNo">3548</span><a id="line.3548">     *</a>
<span class="sourceLineNo">3549</span><a id="line.3549">     * \(</a>
<span class="sourceLineNo">3550</span><a id="line.3550">     *   \begin{align*}</a>
<span class="sourceLineNo">3551</span><a id="line.3551">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3552</span><a id="line.3552">     *   u \\</a>
<span class="sourceLineNo">3553</span><a id="line.3553">     *   v \\</a>
<span class="sourceLineNo">3554</span><a id="line.3554">     *   1</a>
<span class="sourceLineNo">3555</span><a id="line.3555">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">3556</span><a id="line.3556">     *   \bf{A} \hspace{0.1em} \Pi \hspace{0.2em} ^{c}\bf{T}_w</a>
<span class="sourceLineNo">3557</span><a id="line.3557">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3558</span><a id="line.3558">     *   X_{w} \\</a>
<span class="sourceLineNo">3559</span><a id="line.3559">     *   Y_{w} \\</a>
<span class="sourceLineNo">3560</span><a id="line.3560">     *   Z_{w} \\</a>
<span class="sourceLineNo">3561</span><a id="line.3561">     *   1</a>
<span class="sourceLineNo">3562</span><a id="line.3562">     *   \end{bmatrix} \\</a>
<span class="sourceLineNo">3563</span><a id="line.3563">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3564</span><a id="line.3564">     *   u \\</a>
<span class="sourceLineNo">3565</span><a id="line.3565">     *   v \\</a>
<span class="sourceLineNo">3566</span><a id="line.3566">     *   1</a>
<span class="sourceLineNo">3567</span><a id="line.3567">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">3568</span><a id="line.3568">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3569</span><a id="line.3569">     *   f_x &amp;amp; 0 &amp;amp; c_x \\</a>
<span class="sourceLineNo">3570</span><a id="line.3570">     *   0 &amp;amp; f_y &amp;amp; c_y \\</a>
<span class="sourceLineNo">3571</span><a id="line.3571">     *   0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">3572</span><a id="line.3572">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3573</span><a id="line.3573">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3574</span><a id="line.3574">     *   1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\</a>
<span class="sourceLineNo">3575</span><a id="line.3575">     *   0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\</a>
<span class="sourceLineNo">3576</span><a id="line.3576">     *   0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">3577</span><a id="line.3577">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3578</span><a id="line.3578">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3579</span><a id="line.3579">     *   r_{11} &amp;amp; r_{12} &amp;amp; r_{13} &amp;amp; t_x \\</a>
<span class="sourceLineNo">3580</span><a id="line.3580">     *   r_{21} &amp;amp; r_{22} &amp;amp; r_{23} &amp;amp; t_y \\</a>
<span class="sourceLineNo">3581</span><a id="line.3581">     *   r_{31} &amp;amp; r_{32} &amp;amp; r_{33} &amp;amp; t_z \\</a>
<span class="sourceLineNo">3582</span><a id="line.3582">     *   0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">3583</span><a id="line.3583">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3584</span><a id="line.3584">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3585</span><a id="line.3585">     *   X_{w} \\</a>
<span class="sourceLineNo">3586</span><a id="line.3586">     *   Y_{w} \\</a>
<span class="sourceLineNo">3587</span><a id="line.3587">     *   Z_{w} \\</a>
<span class="sourceLineNo">3588</span><a id="line.3588">     *   1</a>
<span class="sourceLineNo">3589</span><a id="line.3589">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3590</span><a id="line.3590">     *   \end{align*}</a>
<span class="sourceLineNo">3591</span><a id="line.3591">     * \)</a>
<span class="sourceLineNo">3592</span><a id="line.3592">     *</a>
<span class="sourceLineNo">3593</span><a id="line.3593">     * The estimated pose is thus the rotation ({@code rvec}) and the translation ({@code tvec}) vectors that allow transforming</a>
<span class="sourceLineNo">3594</span><a id="line.3594">     * a 3D point expressed in the world frame into the camera frame:</a>
<span class="sourceLineNo">3595</span><a id="line.3595">     *</a>
<span class="sourceLineNo">3596</span><a id="line.3596">     * \(</a>
<span class="sourceLineNo">3597</span><a id="line.3597">     *   \begin{align*}</a>
<span class="sourceLineNo">3598</span><a id="line.3598">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3599</span><a id="line.3599">     *   X_c \\</a>
<span class="sourceLineNo">3600</span><a id="line.3600">     *   Y_c \\</a>
<span class="sourceLineNo">3601</span><a id="line.3601">     *   Z_c \\</a>
<span class="sourceLineNo">3602</span><a id="line.3602">     *   1</a>
<span class="sourceLineNo">3603</span><a id="line.3603">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">3604</span><a id="line.3604">     *   \hspace{0.2em} ^{c}\bf{T}_w</a>
<span class="sourceLineNo">3605</span><a id="line.3605">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3606</span><a id="line.3606">     *   X_{w} \\</a>
<span class="sourceLineNo">3607</span><a id="line.3607">     *   Y_{w} \\</a>
<span class="sourceLineNo">3608</span><a id="line.3608">     *   Z_{w} \\</a>
<span class="sourceLineNo">3609</span><a id="line.3609">     *   1</a>
<span class="sourceLineNo">3610</span><a id="line.3610">     *   \end{bmatrix} \\</a>
<span class="sourceLineNo">3611</span><a id="line.3611">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3612</span><a id="line.3612">     *   X_c \\</a>
<span class="sourceLineNo">3613</span><a id="line.3613">     *   Y_c \\</a>
<span class="sourceLineNo">3614</span><a id="line.3614">     *   Z_c \\</a>
<span class="sourceLineNo">3615</span><a id="line.3615">     *   1</a>
<span class="sourceLineNo">3616</span><a id="line.3616">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">3617</span><a id="line.3617">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3618</span><a id="line.3618">     *   r_{11} &amp;amp; r_{12} &amp;amp; r_{13} &amp;amp; t_x \\</a>
<span class="sourceLineNo">3619</span><a id="line.3619">     *   r_{21} &amp;amp; r_{22} &amp;amp; r_{23} &amp;amp; t_y \\</a>
<span class="sourceLineNo">3620</span><a id="line.3620">     *   r_{31} &amp;amp; r_{32} &amp;amp; r_{33} &amp;amp; t_z \\</a>
<span class="sourceLineNo">3621</span><a id="line.3621">     *   0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">3622</span><a id="line.3622">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3623</span><a id="line.3623">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3624</span><a id="line.3624">     *   X_{w} \\</a>
<span class="sourceLineNo">3625</span><a id="line.3625">     *   Y_{w} \\</a>
<span class="sourceLineNo">3626</span><a id="line.3626">     *   Z_{w} \\</a>
<span class="sourceLineNo">3627</span><a id="line.3627">     *   1</a>
<span class="sourceLineNo">3628</span><a id="line.3628">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3629</span><a id="line.3629">     *   \end{align*}</a>
<span class="sourceLineNo">3630</span><a id="line.3630">     * \)</a>
<span class="sourceLineNo">3631</span><a id="line.3631">     *</a>
<span class="sourceLineNo">3632</span><a id="line.3632">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">3633</span><a id="line.3633">     * &lt;ul&gt;</a>
<span class="sourceLineNo">3634</span><a id="line.3634">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3635</span><a id="line.3635">     *       An example of how to use solvePnP for planar augmented reality can be found at</a>
<span class="sourceLineNo">3636</span><a id="line.3636">     *         opencv_source_code/samples/python/plane_ar.py</a>
<span class="sourceLineNo">3637</span><a id="line.3637">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3638</span><a id="line.3638">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3639</span><a id="line.3639">     *       If you are using Python:</a>
<span class="sourceLineNo">3640</span><a id="line.3640">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">3641</span><a id="line.3641">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3642</span><a id="line.3642">     *          Numpy array slices won't work as input because solvePnP requires contiguous</a>
<span class="sourceLineNo">3643</span><a id="line.3643">     *         arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of</a>
<span class="sourceLineNo">3644</span><a id="line.3644">     *         modules/calib3d/src/solvepnp.cpp version 2.4.9)</a>
<span class="sourceLineNo">3645</span><a id="line.3645">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3646</span><a id="line.3646">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3647</span><a id="line.3647">     *          The P3P algorithm requires image points to be in an array of shape (N,1,2) due</a>
<span class="sourceLineNo">3648</span><a id="line.3648">     *         to its calling of cv::undistortPoints (around line 75 of modules/calib3d/src/solvepnp.cpp version 2.4.9)</a>
<span class="sourceLineNo">3649</span><a id="line.3649">     *         which requires 2-channel information.</a>
<span class="sourceLineNo">3650</span><a id="line.3650">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3651</span><a id="line.3651">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3652</span><a id="line.3652">     *          Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of</a>
<span class="sourceLineNo">3653</span><a id="line.3653">     *         it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =</a>
<span class="sourceLineNo">3654</span><a id="line.3654">     *         np.ascontiguousarray(D[:,:2]).reshape((N,1,2))</a>
<span class="sourceLineNo">3655</span><a id="line.3655">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3656</span><a id="line.3656">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">3657</span><a id="line.3657">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3658</span><a id="line.3658">     *       The methods REF: SOLVEPNP_DLS and REF: SOLVEPNP_UPNP cannot be used as the current implementations are</a>
<span class="sourceLineNo">3659</span><a id="line.3659">     *        unstable and sometimes give completely wrong results. If you pass one of these two</a>
<span class="sourceLineNo">3660</span><a id="line.3660">     *        flags, REF: SOLVEPNP_EPNP method will be used instead.</a>
<span class="sourceLineNo">3661</span><a id="line.3661">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3662</span><a id="line.3662">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3663</span><a id="line.3663">     *       The minimum number of points is 4 in the general case. In the case of REF: SOLVEPNP_P3P and REF: SOLVEPNP_AP3P</a>
<span class="sourceLineNo">3664</span><a id="line.3664">     *        methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions</a>
<span class="sourceLineNo">3665</span><a id="line.3665">     *        of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).</a>
<span class="sourceLineNo">3666</span><a id="line.3666">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3667</span><a id="line.3667">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3668</span><a id="line.3668">     *       With REF: SOLVEPNP_ITERATIVE method and {@code useExtrinsicGuess=true}, the minimum number of points is 3 (3 points</a>
<span class="sourceLineNo">3669</span><a id="line.3669">     *        are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the</a>
<span class="sourceLineNo">3670</span><a id="line.3670">     *        global solution to converge.</a>
<span class="sourceLineNo">3671</span><a id="line.3671">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3672</span><a id="line.3672">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3673</span><a id="line.3673">     *       With REF: SOLVEPNP_IPPE input points must be &amp;gt;= 4 and object points must be coplanar.</a>
<span class="sourceLineNo">3674</span><a id="line.3674">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3675</span><a id="line.3675">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3676</span><a id="line.3676">     *       With REF: SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation.</a>
<span class="sourceLineNo">3677</span><a id="line.3677">     *        Number of input points must be 4. Object points must be defined in the following order:</a>
<span class="sourceLineNo">3678</span><a id="line.3678">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">3679</span><a id="line.3679">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3680</span><a id="line.3680">     *           point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">3681</span><a id="line.3681">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3682</span><a id="line.3682">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3683</span><a id="line.3683">     *           point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">3684</span><a id="line.3684">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3685</span><a id="line.3685">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3686</span><a id="line.3686">     *           point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">3687</span><a id="line.3687">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3688</span><a id="line.3688">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3689</span><a id="line.3689">     *           point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">3690</span><a id="line.3690">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3691</span><a id="line.3691">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">3692</span><a id="line.3692">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3693</span><a id="line.3693">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">3694</span><a id="line.3694">     * @return automatically generated</a>
<span class="sourceLineNo">3695</span><a id="line.3695">     */</a>
<span class="sourceLineNo">3696</span><a id="line.3696">    public static int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List&lt;Mat&gt; rvecs, List&lt;Mat&gt; tvecs, boolean useExtrinsicGuess, int flags, Mat rvec) {</a>
<span class="sourceLineNo">3697</span><a id="line.3697">        Mat rvecs_mat = new Mat();</a>
<span class="sourceLineNo">3698</span><a id="line.3698">        Mat tvecs_mat = new Mat();</a>
<span class="sourceLineNo">3699</span><a id="line.3699">        int retVal = solvePnPGeneric_2(objectPoints.nativeObj, imagePoints.nativeObj, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvecs_mat.nativeObj, tvecs_mat.nativeObj, useExtrinsicGuess, flags, rvec.nativeObj);</a>
<span class="sourceLineNo">3700</span><a id="line.3700">        Converters.Mat_to_vector_Mat(rvecs_mat, rvecs);</a>
<span class="sourceLineNo">3701</span><a id="line.3701">        rvecs_mat.release();</a>
<span class="sourceLineNo">3702</span><a id="line.3702">        Converters.Mat_to_vector_Mat(tvecs_mat, tvecs);</a>
<span class="sourceLineNo">3703</span><a id="line.3703">        tvecs_mat.release();</a>
<span class="sourceLineNo">3704</span><a id="line.3704">        return retVal;</a>
<span class="sourceLineNo">3705</span><a id="line.3705">    }</a>
<span class="sourceLineNo">3706</span><a id="line.3706"></a>
<span class="sourceLineNo">3707</span><a id="line.3707">    /**</a>
<span class="sourceLineNo">3708</span><a id="line.3708">     * Finds an object pose from 3D-2D point correspondences.</a>
<span class="sourceLineNo">3709</span><a id="line.3709">     * This function returns a list of all the possible solutions (a solution is a &amp;lt;rotation vector, translation vector&amp;gt;</a>
<span class="sourceLineNo">3710</span><a id="line.3710">     * couple), depending on the number of input points and the chosen method:</a>
<span class="sourceLineNo">3711</span><a id="line.3711">     * &lt;ul&gt;</a>
<span class="sourceLineNo">3712</span><a id="line.3712">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3713</span><a id="line.3713">     *  P3P methods (REF: SOLVEPNP_P3P, REF: SOLVEPNP_AP3P): 3 or 4 input points. Number of returned solutions can be between 0 and 4 with 3 input points.</a>
<span class="sourceLineNo">3714</span><a id="line.3714">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3715</span><a id="line.3715">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3716</span><a id="line.3716">     *  REF: SOLVEPNP_IPPE Input points must be &amp;gt;= 4 and object points must be coplanar. Returns 2 solutions.</a>
<span class="sourceLineNo">3717</span><a id="line.3717">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3718</span><a id="line.3718">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3719</span><a id="line.3719">     *  REF: SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.</a>
<span class="sourceLineNo">3720</span><a id="line.3720">     * Number of input points must be 4 and 2 solutions are returned. Object points must be defined in the following order:</a>
<span class="sourceLineNo">3721</span><a id="line.3721">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">3722</span><a id="line.3722">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3723</span><a id="line.3723">     *    point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">3724</span><a id="line.3724">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3725</span><a id="line.3725">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3726</span><a id="line.3726">     *    point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">3727</span><a id="line.3727">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3728</span><a id="line.3728">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3729</span><a id="line.3729">     *    point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">3730</span><a id="line.3730">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3731</span><a id="line.3731">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3732</span><a id="line.3732">     *    point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">3733</span><a id="line.3733">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3734</span><a id="line.3734">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">3735</span><a id="line.3735">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3736</span><a id="line.3736">     *  for all the other flags, number of input points must be &amp;gt;= 4 and object points can be in any configuration.</a>
<span class="sourceLineNo">3737</span><a id="line.3737">     * Only 1 solution is returned.</a>
<span class="sourceLineNo">3738</span><a id="line.3738">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3739</span><a id="line.3739">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">3740</span><a id="line.3740">     *</a>
<span class="sourceLineNo">3741</span><a id="line.3741">     * @param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or</a>
<span class="sourceLineNo">3742</span><a id="line.3742">     * 1xN/Nx1 3-channel, where N is the number of points. vector&amp;lt;Point3d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">3743</span><a id="line.3743">     * @param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,</a>
<span class="sourceLineNo">3744</span><a id="line.3744">     * where N is the number of points. vector&amp;lt;Point2d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">3745</span><a id="line.3745">     * @param cameraMatrix Input camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">3746</span><a id="line.3746">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">3747</span><a id="line.3747">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">3748</span><a id="line.3748">     * assumed.</a>
<span class="sourceLineNo">3749</span><a id="line.3749">     * @param rvecs Vector of output rotation vectors (see REF: Rodrigues ) that, together with tvecs, brings points from</a>
<span class="sourceLineNo">3750</span><a id="line.3750">     * the model coordinate system to the camera coordinate system.</a>
<span class="sourceLineNo">3751</span><a id="line.3751">     * @param tvecs Vector of output translation vectors.</a>
<span class="sourceLineNo">3752</span><a id="line.3752">     * @param useExtrinsicGuess Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses</a>
<span class="sourceLineNo">3753</span><a id="line.3753">     * the provided rvec and tvec values as initial approximations of the rotation and translation</a>
<span class="sourceLineNo">3754</span><a id="line.3754">     * vectors, respectively, and further optimizes them.</a>
<span class="sourceLineNo">3755</span><a id="line.3755">     * @param flags Method for solving a PnP problem:</a>
<span class="sourceLineNo">3756</span><a id="line.3756">     * &lt;ul&gt;</a>
<span class="sourceLineNo">3757</span><a id="line.3757">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3758</span><a id="line.3758">     *    REF: SOLVEPNP_ITERATIVE Iterative method is based on a Levenberg-Marquardt optimization. In</a>
<span class="sourceLineNo">3759</span><a id="line.3759">     * this case the function finds such a pose that minimizes reprojection error, that is the sum</a>
<span class="sourceLineNo">3760</span><a id="line.3760">     * of squared distances between the observed projections imagePoints and the projected (using</a>
<span class="sourceLineNo">3761</span><a id="line.3761">     * projectPoints ) objectPoints .</a>
<span class="sourceLineNo">3762</span><a id="line.3762">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3763</span><a id="line.3763">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3764</span><a id="line.3764">     *    REF: SOLVEPNP_P3P Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang</a>
<span class="sourceLineNo">3765</span><a id="line.3765">     * "Complete Solution Classification for the Perspective-Three-Point Problem" (CITE: gao2003complete).</a>
<span class="sourceLineNo">3766</span><a id="line.3766">     * In this case the function requires exactly four object and image points.</a>
<span class="sourceLineNo">3767</span><a id="line.3767">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3768</span><a id="line.3768">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3769</span><a id="line.3769">     *    REF: SOLVEPNP_AP3P Method is based on the paper of T. Ke, S. Roumeliotis</a>
<span class="sourceLineNo">3770</span><a id="line.3770">     * "An Efficient Algebraic Solution to the Perspective-Three-Point Problem" (CITE: Ke17).</a>
<span class="sourceLineNo">3771</span><a id="line.3771">     * In this case the function requires exactly four object and image points.</a>
<span class="sourceLineNo">3772</span><a id="line.3772">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3773</span><a id="line.3773">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3774</span><a id="line.3774">     *    REF: SOLVEPNP_EPNP Method has been introduced by F.Moreno-Noguer, V.Lepetit and P.Fua in the</a>
<span class="sourceLineNo">3775</span><a id="line.3775">     * paper "EPnP: Efficient Perspective-n-Point Camera Pose Estimation" (CITE: lepetit2009epnp).</a>
<span class="sourceLineNo">3776</span><a id="line.3776">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3777</span><a id="line.3777">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3778</span><a id="line.3778">     *    REF: SOLVEPNP_DLS &lt;b&gt;Broken implementation. Using this flag will fallback to EPnP.&lt;/b&gt; \n</a>
<span class="sourceLineNo">3779</span><a id="line.3779">     * Method is based on the paper of Joel A. Hesch and Stergios I. Roumeliotis.</a>
<span class="sourceLineNo">3780</span><a id="line.3780">     * "A Direct Least-Squares (DLS) Method for PnP" (CITE: hesch2011direct).</a>
<span class="sourceLineNo">3781</span><a id="line.3781">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3782</span><a id="line.3782">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3783</span><a id="line.3783">     *    REF: SOLVEPNP_UPNP &lt;b&gt;Broken implementation. Using this flag will fallback to EPnP.&lt;/b&gt; \n</a>
<span class="sourceLineNo">3784</span><a id="line.3784">     * Method is based on the paper of A.Penate-Sanchez, J.Andrade-Cetto,</a>
<span class="sourceLineNo">3785</span><a id="line.3785">     * F.Moreno-Noguer. "Exhaustive Linearization for Robust Camera Pose and Focal Length</a>
<span class="sourceLineNo">3786</span><a id="line.3786">     * Estimation" (CITE: penate2013exhaustive). In this case the function also estimates the parameters \(f_x\) and \(f_y\)</a>
<span class="sourceLineNo">3787</span><a id="line.3787">     * assuming that both have the same value. Then the cameraMatrix is updated with the estimated</a>
<span class="sourceLineNo">3788</span><a id="line.3788">     * focal length.</a>
<span class="sourceLineNo">3789</span><a id="line.3789">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3790</span><a id="line.3790">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3791</span><a id="line.3791">     *    REF: SOLVEPNP_IPPE Method is based on the paper of T. Collins and A. Bartoli.</a>
<span class="sourceLineNo">3792</span><a id="line.3792">     * "Infinitesimal Plane-Based Pose Estimation" (CITE: Collins14). This method requires coplanar object points.</a>
<span class="sourceLineNo">3793</span><a id="line.3793">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3794</span><a id="line.3794">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3795</span><a id="line.3795">     *    REF: SOLVEPNP_IPPE_SQUARE Method is based on the paper of Toby Collins and Adrien Bartoli.</a>
<span class="sourceLineNo">3796</span><a id="line.3796">     * "Infinitesimal Plane-Based Pose Estimation" (CITE: Collins14). This method is suitable for marker pose estimation.</a>
<span class="sourceLineNo">3797</span><a id="line.3797">     * It requires 4 coplanar object points defined in the following order:</a>
<span class="sourceLineNo">3798</span><a id="line.3798">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">3799</span><a id="line.3799">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3800</span><a id="line.3800">     *    point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">3801</span><a id="line.3801">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3802</span><a id="line.3802">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3803</span><a id="line.3803">     *    point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">3804</span><a id="line.3804">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3805</span><a id="line.3805">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3806</span><a id="line.3806">     *    point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">3807</span><a id="line.3807">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3808</span><a id="line.3808">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3809</span><a id="line.3809">     *    point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">3810</span><a id="line.3810">     * and useExtrinsicGuess is set to true.</a>
<span class="sourceLineNo">3811</span><a id="line.3811">     * and useExtrinsicGuess is set to true.</a>
<span class="sourceLineNo">3812</span><a id="line.3812">     * (\( \text{RMSE} = \sqrt{\frac{\sum_{i}^{N} \left ( \hat{y_i} - y_i \right )^2}{N}} \)) between the input image points</a>
<span class="sourceLineNo">3813</span><a id="line.3813">     * and the 3D object points projected with the estimated pose.</a>
<span class="sourceLineNo">3814</span><a id="line.3814">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3815</span><a id="line.3815">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">3816</span><a id="line.3816">     *</a>
<span class="sourceLineNo">3817</span><a id="line.3817">     * The function estimates the object pose given a set of object points, their corresponding image</a>
<span class="sourceLineNo">3818</span><a id="line.3818">     * projections, as well as the camera intrinsic matrix and the distortion coefficients, see the figure below</a>
<span class="sourceLineNo">3819</span><a id="line.3819">     * (more precisely, the X-axis of the camera frame is pointing to the right, the Y-axis downward</a>
<span class="sourceLineNo">3820</span><a id="line.3820">     * and the Z-axis forward).</a>
<span class="sourceLineNo">3821</span><a id="line.3821">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3822</span><a id="line.3822">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">3823</span><a id="line.3823">     *</a>
<span class="sourceLineNo">3824</span><a id="line.3824">     * ![](pnp.jpg)</a>
<span class="sourceLineNo">3825</span><a id="line.3825">     *</a>
<span class="sourceLineNo">3826</span><a id="line.3826">     * Points expressed in the world frame \( \bf{X}_w \) are projected into the image plane \( \left[ u, v \right] \)</a>
<span class="sourceLineNo">3827</span><a id="line.3827">     * using the perspective projection model \( \Pi \) and the camera intrinsic parameters matrix \( \bf{A} \):</a>
<span class="sourceLineNo">3828</span><a id="line.3828">     *</a>
<span class="sourceLineNo">3829</span><a id="line.3829">     * \(</a>
<span class="sourceLineNo">3830</span><a id="line.3830">     *   \begin{align*}</a>
<span class="sourceLineNo">3831</span><a id="line.3831">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3832</span><a id="line.3832">     *   u \\</a>
<span class="sourceLineNo">3833</span><a id="line.3833">     *   v \\</a>
<span class="sourceLineNo">3834</span><a id="line.3834">     *   1</a>
<span class="sourceLineNo">3835</span><a id="line.3835">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">3836</span><a id="line.3836">     *   \bf{A} \hspace{0.1em} \Pi \hspace{0.2em} ^{c}\bf{T}_w</a>
<span class="sourceLineNo">3837</span><a id="line.3837">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3838</span><a id="line.3838">     *   X_{w} \\</a>
<span class="sourceLineNo">3839</span><a id="line.3839">     *   Y_{w} \\</a>
<span class="sourceLineNo">3840</span><a id="line.3840">     *   Z_{w} \\</a>
<span class="sourceLineNo">3841</span><a id="line.3841">     *   1</a>
<span class="sourceLineNo">3842</span><a id="line.3842">     *   \end{bmatrix} \\</a>
<span class="sourceLineNo">3843</span><a id="line.3843">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3844</span><a id="line.3844">     *   u \\</a>
<span class="sourceLineNo">3845</span><a id="line.3845">     *   v \\</a>
<span class="sourceLineNo">3846</span><a id="line.3846">     *   1</a>
<span class="sourceLineNo">3847</span><a id="line.3847">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">3848</span><a id="line.3848">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3849</span><a id="line.3849">     *   f_x &amp;amp; 0 &amp;amp; c_x \\</a>
<span class="sourceLineNo">3850</span><a id="line.3850">     *   0 &amp;amp; f_y &amp;amp; c_y \\</a>
<span class="sourceLineNo">3851</span><a id="line.3851">     *   0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">3852</span><a id="line.3852">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3853</span><a id="line.3853">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3854</span><a id="line.3854">     *   1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\</a>
<span class="sourceLineNo">3855</span><a id="line.3855">     *   0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\</a>
<span class="sourceLineNo">3856</span><a id="line.3856">     *   0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">3857</span><a id="line.3857">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3858</span><a id="line.3858">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3859</span><a id="line.3859">     *   r_{11} &amp;amp; r_{12} &amp;amp; r_{13} &amp;amp; t_x \\</a>
<span class="sourceLineNo">3860</span><a id="line.3860">     *   r_{21} &amp;amp; r_{22} &amp;amp; r_{23} &amp;amp; t_y \\</a>
<span class="sourceLineNo">3861</span><a id="line.3861">     *   r_{31} &amp;amp; r_{32} &amp;amp; r_{33} &amp;amp; t_z \\</a>
<span class="sourceLineNo">3862</span><a id="line.3862">     *   0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">3863</span><a id="line.3863">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3864</span><a id="line.3864">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3865</span><a id="line.3865">     *   X_{w} \\</a>
<span class="sourceLineNo">3866</span><a id="line.3866">     *   Y_{w} \\</a>
<span class="sourceLineNo">3867</span><a id="line.3867">     *   Z_{w} \\</a>
<span class="sourceLineNo">3868</span><a id="line.3868">     *   1</a>
<span class="sourceLineNo">3869</span><a id="line.3869">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3870</span><a id="line.3870">     *   \end{align*}</a>
<span class="sourceLineNo">3871</span><a id="line.3871">     * \)</a>
<span class="sourceLineNo">3872</span><a id="line.3872">     *</a>
<span class="sourceLineNo">3873</span><a id="line.3873">     * The estimated pose is thus the rotation ({@code rvec}) and the translation ({@code tvec}) vectors that allow transforming</a>
<span class="sourceLineNo">3874</span><a id="line.3874">     * a 3D point expressed in the world frame into the camera frame:</a>
<span class="sourceLineNo">3875</span><a id="line.3875">     *</a>
<span class="sourceLineNo">3876</span><a id="line.3876">     * \(</a>
<span class="sourceLineNo">3877</span><a id="line.3877">     *   \begin{align*}</a>
<span class="sourceLineNo">3878</span><a id="line.3878">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3879</span><a id="line.3879">     *   X_c \\</a>
<span class="sourceLineNo">3880</span><a id="line.3880">     *   Y_c \\</a>
<span class="sourceLineNo">3881</span><a id="line.3881">     *   Z_c \\</a>
<span class="sourceLineNo">3882</span><a id="line.3882">     *   1</a>
<span class="sourceLineNo">3883</span><a id="line.3883">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">3884</span><a id="line.3884">     *   \hspace{0.2em} ^{c}\bf{T}_w</a>
<span class="sourceLineNo">3885</span><a id="line.3885">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3886</span><a id="line.3886">     *   X_{w} \\</a>
<span class="sourceLineNo">3887</span><a id="line.3887">     *   Y_{w} \\</a>
<span class="sourceLineNo">3888</span><a id="line.3888">     *   Z_{w} \\</a>
<span class="sourceLineNo">3889</span><a id="line.3889">     *   1</a>
<span class="sourceLineNo">3890</span><a id="line.3890">     *   \end{bmatrix} \\</a>
<span class="sourceLineNo">3891</span><a id="line.3891">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3892</span><a id="line.3892">     *   X_c \\</a>
<span class="sourceLineNo">3893</span><a id="line.3893">     *   Y_c \\</a>
<span class="sourceLineNo">3894</span><a id="line.3894">     *   Z_c \\</a>
<span class="sourceLineNo">3895</span><a id="line.3895">     *   1</a>
<span class="sourceLineNo">3896</span><a id="line.3896">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">3897</span><a id="line.3897">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3898</span><a id="line.3898">     *   r_{11} &amp;amp; r_{12} &amp;amp; r_{13} &amp;amp; t_x \\</a>
<span class="sourceLineNo">3899</span><a id="line.3899">     *   r_{21} &amp;amp; r_{22} &amp;amp; r_{23} &amp;amp; t_y \\</a>
<span class="sourceLineNo">3900</span><a id="line.3900">     *   r_{31} &amp;amp; r_{32} &amp;amp; r_{33} &amp;amp; t_z \\</a>
<span class="sourceLineNo">3901</span><a id="line.3901">     *   0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">3902</span><a id="line.3902">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3903</span><a id="line.3903">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">3904</span><a id="line.3904">     *   X_{w} \\</a>
<span class="sourceLineNo">3905</span><a id="line.3905">     *   Y_{w} \\</a>
<span class="sourceLineNo">3906</span><a id="line.3906">     *   Z_{w} \\</a>
<span class="sourceLineNo">3907</span><a id="line.3907">     *   1</a>
<span class="sourceLineNo">3908</span><a id="line.3908">     *   \end{bmatrix}</a>
<span class="sourceLineNo">3909</span><a id="line.3909">     *   \end{align*}</a>
<span class="sourceLineNo">3910</span><a id="line.3910">     * \)</a>
<span class="sourceLineNo">3911</span><a id="line.3911">     *</a>
<span class="sourceLineNo">3912</span><a id="line.3912">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">3913</span><a id="line.3913">     * &lt;ul&gt;</a>
<span class="sourceLineNo">3914</span><a id="line.3914">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3915</span><a id="line.3915">     *       An example of how to use solvePnP for planar augmented reality can be found at</a>
<span class="sourceLineNo">3916</span><a id="line.3916">     *         opencv_source_code/samples/python/plane_ar.py</a>
<span class="sourceLineNo">3917</span><a id="line.3917">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3918</span><a id="line.3918">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3919</span><a id="line.3919">     *       If you are using Python:</a>
<span class="sourceLineNo">3920</span><a id="line.3920">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">3921</span><a id="line.3921">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3922</span><a id="line.3922">     *          Numpy array slices won't work as input because solvePnP requires contiguous</a>
<span class="sourceLineNo">3923</span><a id="line.3923">     *         arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of</a>
<span class="sourceLineNo">3924</span><a id="line.3924">     *         modules/calib3d/src/solvepnp.cpp version 2.4.9)</a>
<span class="sourceLineNo">3925</span><a id="line.3925">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3926</span><a id="line.3926">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3927</span><a id="line.3927">     *          The P3P algorithm requires image points to be in an array of shape (N,1,2) due</a>
<span class="sourceLineNo">3928</span><a id="line.3928">     *         to its calling of cv::undistortPoints (around line 75 of modules/calib3d/src/solvepnp.cpp version 2.4.9)</a>
<span class="sourceLineNo">3929</span><a id="line.3929">     *         which requires 2-channel information.</a>
<span class="sourceLineNo">3930</span><a id="line.3930">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3931</span><a id="line.3931">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3932</span><a id="line.3932">     *          Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of</a>
<span class="sourceLineNo">3933</span><a id="line.3933">     *         it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =</a>
<span class="sourceLineNo">3934</span><a id="line.3934">     *         np.ascontiguousarray(D[:,:2]).reshape((N,1,2))</a>
<span class="sourceLineNo">3935</span><a id="line.3935">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3936</span><a id="line.3936">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">3937</span><a id="line.3937">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3938</span><a id="line.3938">     *       The methods REF: SOLVEPNP_DLS and REF: SOLVEPNP_UPNP cannot be used as the current implementations are</a>
<span class="sourceLineNo">3939</span><a id="line.3939">     *        unstable and sometimes give completely wrong results. If you pass one of these two</a>
<span class="sourceLineNo">3940</span><a id="line.3940">     *        flags, REF: SOLVEPNP_EPNP method will be used instead.</a>
<span class="sourceLineNo">3941</span><a id="line.3941">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3942</span><a id="line.3942">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3943</span><a id="line.3943">     *       The minimum number of points is 4 in the general case. In the case of REF: SOLVEPNP_P3P and REF: SOLVEPNP_AP3P</a>
<span class="sourceLineNo">3944</span><a id="line.3944">     *        methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions</a>
<span class="sourceLineNo">3945</span><a id="line.3945">     *        of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).</a>
<span class="sourceLineNo">3946</span><a id="line.3946">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3947</span><a id="line.3947">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3948</span><a id="line.3948">     *       With REF: SOLVEPNP_ITERATIVE method and {@code useExtrinsicGuess=true}, the minimum number of points is 3 (3 points</a>
<span class="sourceLineNo">3949</span><a id="line.3949">     *        are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the</a>
<span class="sourceLineNo">3950</span><a id="line.3950">     *        global solution to converge.</a>
<span class="sourceLineNo">3951</span><a id="line.3951">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3952</span><a id="line.3952">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3953</span><a id="line.3953">     *       With REF: SOLVEPNP_IPPE input points must be &amp;gt;= 4 and object points must be coplanar.</a>
<span class="sourceLineNo">3954</span><a id="line.3954">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3955</span><a id="line.3955">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3956</span><a id="line.3956">     *       With REF: SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation.</a>
<span class="sourceLineNo">3957</span><a id="line.3957">     *        Number of input points must be 4. Object points must be defined in the following order:</a>
<span class="sourceLineNo">3958</span><a id="line.3958">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">3959</span><a id="line.3959">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3960</span><a id="line.3960">     *           point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">3961</span><a id="line.3961">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3962</span><a id="line.3962">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3963</span><a id="line.3963">     *           point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">3964</span><a id="line.3964">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3965</span><a id="line.3965">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3966</span><a id="line.3966">     *           point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">3967</span><a id="line.3967">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3968</span><a id="line.3968">     *     &lt;li&gt;</a>
<span class="sourceLineNo">3969</span><a id="line.3969">     *           point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">3970</span><a id="line.3970">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">3971</span><a id="line.3971">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">3972</span><a id="line.3972">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3973</span><a id="line.3973">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">3974</span><a id="line.3974">     * @return automatically generated</a>
<span class="sourceLineNo">3975</span><a id="line.3975">     */</a>
<span class="sourceLineNo">3976</span><a id="line.3976">    public static int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List&lt;Mat&gt; rvecs, List&lt;Mat&gt; tvecs, boolean useExtrinsicGuess, int flags) {</a>
<span class="sourceLineNo">3977</span><a id="line.3977">        Mat rvecs_mat = new Mat();</a>
<span class="sourceLineNo">3978</span><a id="line.3978">        Mat tvecs_mat = new Mat();</a>
<span class="sourceLineNo">3979</span><a id="line.3979">        int retVal = solvePnPGeneric_3(objectPoints.nativeObj, imagePoints.nativeObj, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvecs_mat.nativeObj, tvecs_mat.nativeObj, useExtrinsicGuess, flags);</a>
<span class="sourceLineNo">3980</span><a id="line.3980">        Converters.Mat_to_vector_Mat(rvecs_mat, rvecs);</a>
<span class="sourceLineNo">3981</span><a id="line.3981">        rvecs_mat.release();</a>
<span class="sourceLineNo">3982</span><a id="line.3982">        Converters.Mat_to_vector_Mat(tvecs_mat, tvecs);</a>
<span class="sourceLineNo">3983</span><a id="line.3983">        tvecs_mat.release();</a>
<span class="sourceLineNo">3984</span><a id="line.3984">        return retVal;</a>
<span class="sourceLineNo">3985</span><a id="line.3985">    }</a>
<span class="sourceLineNo">3986</span><a id="line.3986"></a>
<span class="sourceLineNo">3987</span><a id="line.3987">    /**</a>
<span class="sourceLineNo">3988</span><a id="line.3988">     * Finds an object pose from 3D-2D point correspondences.</a>
<span class="sourceLineNo">3989</span><a id="line.3989">     * This function returns a list of all the possible solutions (a solution is a &amp;lt;rotation vector, translation vector&amp;gt;</a>
<span class="sourceLineNo">3990</span><a id="line.3990">     * couple), depending on the number of input points and the chosen method:</a>
<span class="sourceLineNo">3991</span><a id="line.3991">     * &lt;ul&gt;</a>
<span class="sourceLineNo">3992</span><a id="line.3992">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3993</span><a id="line.3993">     *  P3P methods (REF: SOLVEPNP_P3P, REF: SOLVEPNP_AP3P): 3 or 4 input points. Number of returned solutions can be between 0 and 4 with 3 input points.</a>
<span class="sourceLineNo">3994</span><a id="line.3994">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3995</span><a id="line.3995">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3996</span><a id="line.3996">     *  REF: SOLVEPNP_IPPE Input points must be &amp;gt;= 4 and object points must be coplanar. Returns 2 solutions.</a>
<span class="sourceLineNo">3997</span><a id="line.3997">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">3998</span><a id="line.3998">     *   &lt;li&gt;</a>
<span class="sourceLineNo">3999</span><a id="line.3999">     *  REF: SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.</a>
<span class="sourceLineNo">4000</span><a id="line.4000">     * Number of input points must be 4 and 2 solutions are returned. Object points must be defined in the following order:</a>
<span class="sourceLineNo">4001</span><a id="line.4001">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">4002</span><a id="line.4002">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4003</span><a id="line.4003">     *    point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">4004</span><a id="line.4004">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4005</span><a id="line.4005">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4006</span><a id="line.4006">     *    point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">4007</span><a id="line.4007">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4008</span><a id="line.4008">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4009</span><a id="line.4009">     *    point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">4010</span><a id="line.4010">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4011</span><a id="line.4011">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4012</span><a id="line.4012">     *    point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">4013</span><a id="line.4013">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4014</span><a id="line.4014">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">4015</span><a id="line.4015">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4016</span><a id="line.4016">     *  for all the other flags, number of input points must be &amp;gt;= 4 and object points can be in any configuration.</a>
<span class="sourceLineNo">4017</span><a id="line.4017">     * Only 1 solution is returned.</a>
<span class="sourceLineNo">4018</span><a id="line.4018">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4019</span><a id="line.4019">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">4020</span><a id="line.4020">     *</a>
<span class="sourceLineNo">4021</span><a id="line.4021">     * @param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or</a>
<span class="sourceLineNo">4022</span><a id="line.4022">     * 1xN/Nx1 3-channel, where N is the number of points. vector&amp;lt;Point3d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">4023</span><a id="line.4023">     * @param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,</a>
<span class="sourceLineNo">4024</span><a id="line.4024">     * where N is the number of points. vector&amp;lt;Point2d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">4025</span><a id="line.4025">     * @param cameraMatrix Input camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">4026</span><a id="line.4026">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">4027</span><a id="line.4027">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">4028</span><a id="line.4028">     * assumed.</a>
<span class="sourceLineNo">4029</span><a id="line.4029">     * @param rvecs Vector of output rotation vectors (see REF: Rodrigues ) that, together with tvecs, brings points from</a>
<span class="sourceLineNo">4030</span><a id="line.4030">     * the model coordinate system to the camera coordinate system.</a>
<span class="sourceLineNo">4031</span><a id="line.4031">     * @param tvecs Vector of output translation vectors.</a>
<span class="sourceLineNo">4032</span><a id="line.4032">     * @param useExtrinsicGuess Parameter used for #SOLVEPNP_ITERATIVE. If true (1), the function uses</a>
<span class="sourceLineNo">4033</span><a id="line.4033">     * the provided rvec and tvec values as initial approximations of the rotation and translation</a>
<span class="sourceLineNo">4034</span><a id="line.4034">     * vectors, respectively, and further optimizes them.</a>
<span class="sourceLineNo">4035</span><a id="line.4035">     * &lt;ul&gt;</a>
<span class="sourceLineNo">4036</span><a id="line.4036">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4037</span><a id="line.4037">     *    REF: SOLVEPNP_ITERATIVE Iterative method is based on a Levenberg-Marquardt optimization. In</a>
<span class="sourceLineNo">4038</span><a id="line.4038">     * this case the function finds such a pose that minimizes reprojection error, that is the sum</a>
<span class="sourceLineNo">4039</span><a id="line.4039">     * of squared distances between the observed projections imagePoints and the projected (using</a>
<span class="sourceLineNo">4040</span><a id="line.4040">     * projectPoints ) objectPoints .</a>
<span class="sourceLineNo">4041</span><a id="line.4041">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4042</span><a id="line.4042">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4043</span><a id="line.4043">     *    REF: SOLVEPNP_P3P Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang</a>
<span class="sourceLineNo">4044</span><a id="line.4044">     * "Complete Solution Classification for the Perspective-Three-Point Problem" (CITE: gao2003complete).</a>
<span class="sourceLineNo">4045</span><a id="line.4045">     * In this case the function requires exactly four object and image points.</a>
<span class="sourceLineNo">4046</span><a id="line.4046">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4047</span><a id="line.4047">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4048</span><a id="line.4048">     *    REF: SOLVEPNP_AP3P Method is based on the paper of T. Ke, S. Roumeliotis</a>
<span class="sourceLineNo">4049</span><a id="line.4049">     * "An Efficient Algebraic Solution to the Perspective-Three-Point Problem" (CITE: Ke17).</a>
<span class="sourceLineNo">4050</span><a id="line.4050">     * In this case the function requires exactly four object and image points.</a>
<span class="sourceLineNo">4051</span><a id="line.4051">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4052</span><a id="line.4052">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4053</span><a id="line.4053">     *    REF: SOLVEPNP_EPNP Method has been introduced by F.Moreno-Noguer, V.Lepetit and P.Fua in the</a>
<span class="sourceLineNo">4054</span><a id="line.4054">     * paper "EPnP: Efficient Perspective-n-Point Camera Pose Estimation" (CITE: lepetit2009epnp).</a>
<span class="sourceLineNo">4055</span><a id="line.4055">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4056</span><a id="line.4056">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4057</span><a id="line.4057">     *    REF: SOLVEPNP_DLS &lt;b&gt;Broken implementation. Using this flag will fallback to EPnP.&lt;/b&gt; \n</a>
<span class="sourceLineNo">4058</span><a id="line.4058">     * Method is based on the paper of Joel A. Hesch and Stergios I. Roumeliotis.</a>
<span class="sourceLineNo">4059</span><a id="line.4059">     * "A Direct Least-Squares (DLS) Method for PnP" (CITE: hesch2011direct).</a>
<span class="sourceLineNo">4060</span><a id="line.4060">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4061</span><a id="line.4061">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4062</span><a id="line.4062">     *    REF: SOLVEPNP_UPNP &lt;b&gt;Broken implementation. Using this flag will fallback to EPnP.&lt;/b&gt; \n</a>
<span class="sourceLineNo">4063</span><a id="line.4063">     * Method is based on the paper of A.Penate-Sanchez, J.Andrade-Cetto,</a>
<span class="sourceLineNo">4064</span><a id="line.4064">     * F.Moreno-Noguer. "Exhaustive Linearization for Robust Camera Pose and Focal Length</a>
<span class="sourceLineNo">4065</span><a id="line.4065">     * Estimation" (CITE: penate2013exhaustive). In this case the function also estimates the parameters \(f_x\) and \(f_y\)</a>
<span class="sourceLineNo">4066</span><a id="line.4066">     * assuming that both have the same value. Then the cameraMatrix is updated with the estimated</a>
<span class="sourceLineNo">4067</span><a id="line.4067">     * focal length.</a>
<span class="sourceLineNo">4068</span><a id="line.4068">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4069</span><a id="line.4069">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4070</span><a id="line.4070">     *    REF: SOLVEPNP_IPPE Method is based on the paper of T. Collins and A. Bartoli.</a>
<span class="sourceLineNo">4071</span><a id="line.4071">     * "Infinitesimal Plane-Based Pose Estimation" (CITE: Collins14). This method requires coplanar object points.</a>
<span class="sourceLineNo">4072</span><a id="line.4072">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4073</span><a id="line.4073">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4074</span><a id="line.4074">     *    REF: SOLVEPNP_IPPE_SQUARE Method is based on the paper of Toby Collins and Adrien Bartoli.</a>
<span class="sourceLineNo">4075</span><a id="line.4075">     * "Infinitesimal Plane-Based Pose Estimation" (CITE: Collins14). This method is suitable for marker pose estimation.</a>
<span class="sourceLineNo">4076</span><a id="line.4076">     * It requires 4 coplanar object points defined in the following order:</a>
<span class="sourceLineNo">4077</span><a id="line.4077">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">4078</span><a id="line.4078">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4079</span><a id="line.4079">     *    point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">4080</span><a id="line.4080">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4081</span><a id="line.4081">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4082</span><a id="line.4082">     *    point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">4083</span><a id="line.4083">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4084</span><a id="line.4084">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4085</span><a id="line.4085">     *    point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">4086</span><a id="line.4086">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4087</span><a id="line.4087">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4088</span><a id="line.4088">     *    point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">4089</span><a id="line.4089">     * and useExtrinsicGuess is set to true.</a>
<span class="sourceLineNo">4090</span><a id="line.4090">     * and useExtrinsicGuess is set to true.</a>
<span class="sourceLineNo">4091</span><a id="line.4091">     * (\( \text{RMSE} = \sqrt{\frac{\sum_{i}^{N} \left ( \hat{y_i} - y_i \right )^2}{N}} \)) between the input image points</a>
<span class="sourceLineNo">4092</span><a id="line.4092">     * and the 3D object points projected with the estimated pose.</a>
<span class="sourceLineNo">4093</span><a id="line.4093">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4094</span><a id="line.4094">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">4095</span><a id="line.4095">     *</a>
<span class="sourceLineNo">4096</span><a id="line.4096">     * The function estimates the object pose given a set of object points, their corresponding image</a>
<span class="sourceLineNo">4097</span><a id="line.4097">     * projections, as well as the camera intrinsic matrix and the distortion coefficients, see the figure below</a>
<span class="sourceLineNo">4098</span><a id="line.4098">     * (more precisely, the X-axis of the camera frame is pointing to the right, the Y-axis downward</a>
<span class="sourceLineNo">4099</span><a id="line.4099">     * and the Z-axis forward).</a>
<span class="sourceLineNo">4100</span><a id="line.4100">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4101</span><a id="line.4101">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">4102</span><a id="line.4102">     *</a>
<span class="sourceLineNo">4103</span><a id="line.4103">     * ![](pnp.jpg)</a>
<span class="sourceLineNo">4104</span><a id="line.4104">     *</a>
<span class="sourceLineNo">4105</span><a id="line.4105">     * Points expressed in the world frame \( \bf{X}_w \) are projected into the image plane \( \left[ u, v \right] \)</a>
<span class="sourceLineNo">4106</span><a id="line.4106">     * using the perspective projection model \( \Pi \) and the camera intrinsic parameters matrix \( \bf{A} \):</a>
<span class="sourceLineNo">4107</span><a id="line.4107">     *</a>
<span class="sourceLineNo">4108</span><a id="line.4108">     * \(</a>
<span class="sourceLineNo">4109</span><a id="line.4109">     *   \begin{align*}</a>
<span class="sourceLineNo">4110</span><a id="line.4110">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4111</span><a id="line.4111">     *   u \\</a>
<span class="sourceLineNo">4112</span><a id="line.4112">     *   v \\</a>
<span class="sourceLineNo">4113</span><a id="line.4113">     *   1</a>
<span class="sourceLineNo">4114</span><a id="line.4114">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">4115</span><a id="line.4115">     *   \bf{A} \hspace{0.1em} \Pi \hspace{0.2em} ^{c}\bf{T}_w</a>
<span class="sourceLineNo">4116</span><a id="line.4116">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4117</span><a id="line.4117">     *   X_{w} \\</a>
<span class="sourceLineNo">4118</span><a id="line.4118">     *   Y_{w} \\</a>
<span class="sourceLineNo">4119</span><a id="line.4119">     *   Z_{w} \\</a>
<span class="sourceLineNo">4120</span><a id="line.4120">     *   1</a>
<span class="sourceLineNo">4121</span><a id="line.4121">     *   \end{bmatrix} \\</a>
<span class="sourceLineNo">4122</span><a id="line.4122">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4123</span><a id="line.4123">     *   u \\</a>
<span class="sourceLineNo">4124</span><a id="line.4124">     *   v \\</a>
<span class="sourceLineNo">4125</span><a id="line.4125">     *   1</a>
<span class="sourceLineNo">4126</span><a id="line.4126">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">4127</span><a id="line.4127">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4128</span><a id="line.4128">     *   f_x &amp;amp; 0 &amp;amp; c_x \\</a>
<span class="sourceLineNo">4129</span><a id="line.4129">     *   0 &amp;amp; f_y &amp;amp; c_y \\</a>
<span class="sourceLineNo">4130</span><a id="line.4130">     *   0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">4131</span><a id="line.4131">     *   \end{bmatrix}</a>
<span class="sourceLineNo">4132</span><a id="line.4132">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4133</span><a id="line.4133">     *   1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\</a>
<span class="sourceLineNo">4134</span><a id="line.4134">     *   0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\</a>
<span class="sourceLineNo">4135</span><a id="line.4135">     *   0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">4136</span><a id="line.4136">     *   \end{bmatrix}</a>
<span class="sourceLineNo">4137</span><a id="line.4137">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4138</span><a id="line.4138">     *   r_{11} &amp;amp; r_{12} &amp;amp; r_{13} &amp;amp; t_x \\</a>
<span class="sourceLineNo">4139</span><a id="line.4139">     *   r_{21} &amp;amp; r_{22} &amp;amp; r_{23} &amp;amp; t_y \\</a>
<span class="sourceLineNo">4140</span><a id="line.4140">     *   r_{31} &amp;amp; r_{32} &amp;amp; r_{33} &amp;amp; t_z \\</a>
<span class="sourceLineNo">4141</span><a id="line.4141">     *   0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">4142</span><a id="line.4142">     *   \end{bmatrix}</a>
<span class="sourceLineNo">4143</span><a id="line.4143">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4144</span><a id="line.4144">     *   X_{w} \\</a>
<span class="sourceLineNo">4145</span><a id="line.4145">     *   Y_{w} \\</a>
<span class="sourceLineNo">4146</span><a id="line.4146">     *   Z_{w} \\</a>
<span class="sourceLineNo">4147</span><a id="line.4147">     *   1</a>
<span class="sourceLineNo">4148</span><a id="line.4148">     *   \end{bmatrix}</a>
<span class="sourceLineNo">4149</span><a id="line.4149">     *   \end{align*}</a>
<span class="sourceLineNo">4150</span><a id="line.4150">     * \)</a>
<span class="sourceLineNo">4151</span><a id="line.4151">     *</a>
<span class="sourceLineNo">4152</span><a id="line.4152">     * The estimated pose is thus the rotation ({@code rvec}) and the translation ({@code tvec}) vectors that allow transforming</a>
<span class="sourceLineNo">4153</span><a id="line.4153">     * a 3D point expressed in the world frame into the camera frame:</a>
<span class="sourceLineNo">4154</span><a id="line.4154">     *</a>
<span class="sourceLineNo">4155</span><a id="line.4155">     * \(</a>
<span class="sourceLineNo">4156</span><a id="line.4156">     *   \begin{align*}</a>
<span class="sourceLineNo">4157</span><a id="line.4157">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4158</span><a id="line.4158">     *   X_c \\</a>
<span class="sourceLineNo">4159</span><a id="line.4159">     *   Y_c \\</a>
<span class="sourceLineNo">4160</span><a id="line.4160">     *   Z_c \\</a>
<span class="sourceLineNo">4161</span><a id="line.4161">     *   1</a>
<span class="sourceLineNo">4162</span><a id="line.4162">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">4163</span><a id="line.4163">     *   \hspace{0.2em} ^{c}\bf{T}_w</a>
<span class="sourceLineNo">4164</span><a id="line.4164">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4165</span><a id="line.4165">     *   X_{w} \\</a>
<span class="sourceLineNo">4166</span><a id="line.4166">     *   Y_{w} \\</a>
<span class="sourceLineNo">4167</span><a id="line.4167">     *   Z_{w} \\</a>
<span class="sourceLineNo">4168</span><a id="line.4168">     *   1</a>
<span class="sourceLineNo">4169</span><a id="line.4169">     *   \end{bmatrix} \\</a>
<span class="sourceLineNo">4170</span><a id="line.4170">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4171</span><a id="line.4171">     *   X_c \\</a>
<span class="sourceLineNo">4172</span><a id="line.4172">     *   Y_c \\</a>
<span class="sourceLineNo">4173</span><a id="line.4173">     *   Z_c \\</a>
<span class="sourceLineNo">4174</span><a id="line.4174">     *   1</a>
<span class="sourceLineNo">4175</span><a id="line.4175">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">4176</span><a id="line.4176">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4177</span><a id="line.4177">     *   r_{11} &amp;amp; r_{12} &amp;amp; r_{13} &amp;amp; t_x \\</a>
<span class="sourceLineNo">4178</span><a id="line.4178">     *   r_{21} &amp;amp; r_{22} &amp;amp; r_{23} &amp;amp; t_y \\</a>
<span class="sourceLineNo">4179</span><a id="line.4179">     *   r_{31} &amp;amp; r_{32} &amp;amp; r_{33} &amp;amp; t_z \\</a>
<span class="sourceLineNo">4180</span><a id="line.4180">     *   0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">4181</span><a id="line.4181">     *   \end{bmatrix}</a>
<span class="sourceLineNo">4182</span><a id="line.4182">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4183</span><a id="line.4183">     *   X_{w} \\</a>
<span class="sourceLineNo">4184</span><a id="line.4184">     *   Y_{w} \\</a>
<span class="sourceLineNo">4185</span><a id="line.4185">     *   Z_{w} \\</a>
<span class="sourceLineNo">4186</span><a id="line.4186">     *   1</a>
<span class="sourceLineNo">4187</span><a id="line.4187">     *   \end{bmatrix}</a>
<span class="sourceLineNo">4188</span><a id="line.4188">     *   \end{align*}</a>
<span class="sourceLineNo">4189</span><a id="line.4189">     * \)</a>
<span class="sourceLineNo">4190</span><a id="line.4190">     *</a>
<span class="sourceLineNo">4191</span><a id="line.4191">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">4192</span><a id="line.4192">     * &lt;ul&gt;</a>
<span class="sourceLineNo">4193</span><a id="line.4193">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4194</span><a id="line.4194">     *       An example of how to use solvePnP for planar augmented reality can be found at</a>
<span class="sourceLineNo">4195</span><a id="line.4195">     *         opencv_source_code/samples/python/plane_ar.py</a>
<span class="sourceLineNo">4196</span><a id="line.4196">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4197</span><a id="line.4197">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4198</span><a id="line.4198">     *       If you are using Python:</a>
<span class="sourceLineNo">4199</span><a id="line.4199">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">4200</span><a id="line.4200">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4201</span><a id="line.4201">     *          Numpy array slices won't work as input because solvePnP requires contiguous</a>
<span class="sourceLineNo">4202</span><a id="line.4202">     *         arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of</a>
<span class="sourceLineNo">4203</span><a id="line.4203">     *         modules/calib3d/src/solvepnp.cpp version 2.4.9)</a>
<span class="sourceLineNo">4204</span><a id="line.4204">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4205</span><a id="line.4205">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4206</span><a id="line.4206">     *          The P3P algorithm requires image points to be in an array of shape (N,1,2) due</a>
<span class="sourceLineNo">4207</span><a id="line.4207">     *         to its calling of cv::undistortPoints (around line 75 of modules/calib3d/src/solvepnp.cpp version 2.4.9)</a>
<span class="sourceLineNo">4208</span><a id="line.4208">     *         which requires 2-channel information.</a>
<span class="sourceLineNo">4209</span><a id="line.4209">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4210</span><a id="line.4210">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4211</span><a id="line.4211">     *          Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of</a>
<span class="sourceLineNo">4212</span><a id="line.4212">     *         it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =</a>
<span class="sourceLineNo">4213</span><a id="line.4213">     *         np.ascontiguousarray(D[:,:2]).reshape((N,1,2))</a>
<span class="sourceLineNo">4214</span><a id="line.4214">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4215</span><a id="line.4215">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">4216</span><a id="line.4216">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4217</span><a id="line.4217">     *       The methods REF: SOLVEPNP_DLS and REF: SOLVEPNP_UPNP cannot be used as the current implementations are</a>
<span class="sourceLineNo">4218</span><a id="line.4218">     *        unstable and sometimes give completely wrong results. If you pass one of these two</a>
<span class="sourceLineNo">4219</span><a id="line.4219">     *        flags, REF: SOLVEPNP_EPNP method will be used instead.</a>
<span class="sourceLineNo">4220</span><a id="line.4220">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4221</span><a id="line.4221">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4222</span><a id="line.4222">     *       The minimum number of points is 4 in the general case. In the case of REF: SOLVEPNP_P3P and REF: SOLVEPNP_AP3P</a>
<span class="sourceLineNo">4223</span><a id="line.4223">     *        methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions</a>
<span class="sourceLineNo">4224</span><a id="line.4224">     *        of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).</a>
<span class="sourceLineNo">4225</span><a id="line.4225">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4226</span><a id="line.4226">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4227</span><a id="line.4227">     *       With REF: SOLVEPNP_ITERATIVE method and {@code useExtrinsicGuess=true}, the minimum number of points is 3 (3 points</a>
<span class="sourceLineNo">4228</span><a id="line.4228">     *        are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the</a>
<span class="sourceLineNo">4229</span><a id="line.4229">     *        global solution to converge.</a>
<span class="sourceLineNo">4230</span><a id="line.4230">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4231</span><a id="line.4231">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4232</span><a id="line.4232">     *       With REF: SOLVEPNP_IPPE input points must be &amp;gt;= 4 and object points must be coplanar.</a>
<span class="sourceLineNo">4233</span><a id="line.4233">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4234</span><a id="line.4234">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4235</span><a id="line.4235">     *       With REF: SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation.</a>
<span class="sourceLineNo">4236</span><a id="line.4236">     *        Number of input points must be 4. Object points must be defined in the following order:</a>
<span class="sourceLineNo">4237</span><a id="line.4237">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">4238</span><a id="line.4238">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4239</span><a id="line.4239">     *           point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">4240</span><a id="line.4240">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4241</span><a id="line.4241">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4242</span><a id="line.4242">     *           point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">4243</span><a id="line.4243">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4244</span><a id="line.4244">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4245</span><a id="line.4245">     *           point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">4246</span><a id="line.4246">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4247</span><a id="line.4247">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4248</span><a id="line.4248">     *           point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">4249</span><a id="line.4249">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4250</span><a id="line.4250">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">4251</span><a id="line.4251">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4252</span><a id="line.4252">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">4253</span><a id="line.4253">     * @return automatically generated</a>
<span class="sourceLineNo">4254</span><a id="line.4254">     */</a>
<span class="sourceLineNo">4255</span><a id="line.4255">    public static int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List&lt;Mat&gt; rvecs, List&lt;Mat&gt; tvecs, boolean useExtrinsicGuess) {</a>
<span class="sourceLineNo">4256</span><a id="line.4256">        Mat rvecs_mat = new Mat();</a>
<span class="sourceLineNo">4257</span><a id="line.4257">        Mat tvecs_mat = new Mat();</a>
<span class="sourceLineNo">4258</span><a id="line.4258">        int retVal = solvePnPGeneric_4(objectPoints.nativeObj, imagePoints.nativeObj, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvecs_mat.nativeObj, tvecs_mat.nativeObj, useExtrinsicGuess);</a>
<span class="sourceLineNo">4259</span><a id="line.4259">        Converters.Mat_to_vector_Mat(rvecs_mat, rvecs);</a>
<span class="sourceLineNo">4260</span><a id="line.4260">        rvecs_mat.release();</a>
<span class="sourceLineNo">4261</span><a id="line.4261">        Converters.Mat_to_vector_Mat(tvecs_mat, tvecs);</a>
<span class="sourceLineNo">4262</span><a id="line.4262">        tvecs_mat.release();</a>
<span class="sourceLineNo">4263</span><a id="line.4263">        return retVal;</a>
<span class="sourceLineNo">4264</span><a id="line.4264">    }</a>
<span class="sourceLineNo">4265</span><a id="line.4265"></a>
<span class="sourceLineNo">4266</span><a id="line.4266">    /**</a>
<span class="sourceLineNo">4267</span><a id="line.4267">     * Finds an object pose from 3D-2D point correspondences.</a>
<span class="sourceLineNo">4268</span><a id="line.4268">     * This function returns a list of all the possible solutions (a solution is a &amp;lt;rotation vector, translation vector&amp;gt;</a>
<span class="sourceLineNo">4269</span><a id="line.4269">     * couple), depending on the number of input points and the chosen method:</a>
<span class="sourceLineNo">4270</span><a id="line.4270">     * &lt;ul&gt;</a>
<span class="sourceLineNo">4271</span><a id="line.4271">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4272</span><a id="line.4272">     *  P3P methods (REF: SOLVEPNP_P3P, REF: SOLVEPNP_AP3P): 3 or 4 input points. Number of returned solutions can be between 0 and 4 with 3 input points.</a>
<span class="sourceLineNo">4273</span><a id="line.4273">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4274</span><a id="line.4274">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4275</span><a id="line.4275">     *  REF: SOLVEPNP_IPPE Input points must be &amp;gt;= 4 and object points must be coplanar. Returns 2 solutions.</a>
<span class="sourceLineNo">4276</span><a id="line.4276">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4277</span><a id="line.4277">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4278</span><a id="line.4278">     *  REF: SOLVEPNP_IPPE_SQUARE Special case suitable for marker pose estimation.</a>
<span class="sourceLineNo">4279</span><a id="line.4279">     * Number of input points must be 4 and 2 solutions are returned. Object points must be defined in the following order:</a>
<span class="sourceLineNo">4280</span><a id="line.4280">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">4281</span><a id="line.4281">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4282</span><a id="line.4282">     *    point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">4283</span><a id="line.4283">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4284</span><a id="line.4284">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4285</span><a id="line.4285">     *    point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">4286</span><a id="line.4286">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4287</span><a id="line.4287">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4288</span><a id="line.4288">     *    point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">4289</span><a id="line.4289">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4290</span><a id="line.4290">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4291</span><a id="line.4291">     *    point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">4292</span><a id="line.4292">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4293</span><a id="line.4293">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">4294</span><a id="line.4294">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4295</span><a id="line.4295">     *  for all the other flags, number of input points must be &amp;gt;= 4 and object points can be in any configuration.</a>
<span class="sourceLineNo">4296</span><a id="line.4296">     * Only 1 solution is returned.</a>
<span class="sourceLineNo">4297</span><a id="line.4297">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4298</span><a id="line.4298">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">4299</span><a id="line.4299">     *</a>
<span class="sourceLineNo">4300</span><a id="line.4300">     * @param objectPoints Array of object points in the object coordinate space, Nx3 1-channel or</a>
<span class="sourceLineNo">4301</span><a id="line.4301">     * 1xN/Nx1 3-channel, where N is the number of points. vector&amp;lt;Point3d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">4302</span><a id="line.4302">     * @param imagePoints Array of corresponding image points, Nx2 1-channel or 1xN/Nx1 2-channel,</a>
<span class="sourceLineNo">4303</span><a id="line.4303">     * where N is the number of points. vector&amp;lt;Point2d&amp;gt; can be also passed here.</a>
<span class="sourceLineNo">4304</span><a id="line.4304">     * @param cameraMatrix Input camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">4305</span><a id="line.4305">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">4306</span><a id="line.4306">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">4307</span><a id="line.4307">     * assumed.</a>
<span class="sourceLineNo">4308</span><a id="line.4308">     * @param rvecs Vector of output rotation vectors (see REF: Rodrigues ) that, together with tvecs, brings points from</a>
<span class="sourceLineNo">4309</span><a id="line.4309">     * the model coordinate system to the camera coordinate system.</a>
<span class="sourceLineNo">4310</span><a id="line.4310">     * @param tvecs Vector of output translation vectors.</a>
<span class="sourceLineNo">4311</span><a id="line.4311">     * the provided rvec and tvec values as initial approximations of the rotation and translation</a>
<span class="sourceLineNo">4312</span><a id="line.4312">     * vectors, respectively, and further optimizes them.</a>
<span class="sourceLineNo">4313</span><a id="line.4313">     * &lt;ul&gt;</a>
<span class="sourceLineNo">4314</span><a id="line.4314">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4315</span><a id="line.4315">     *    REF: SOLVEPNP_ITERATIVE Iterative method is based on a Levenberg-Marquardt optimization. In</a>
<span class="sourceLineNo">4316</span><a id="line.4316">     * this case the function finds such a pose that minimizes reprojection error, that is the sum</a>
<span class="sourceLineNo">4317</span><a id="line.4317">     * of squared distances between the observed projections imagePoints and the projected (using</a>
<span class="sourceLineNo">4318</span><a id="line.4318">     * projectPoints ) objectPoints .</a>
<span class="sourceLineNo">4319</span><a id="line.4319">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4320</span><a id="line.4320">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4321</span><a id="line.4321">     *    REF: SOLVEPNP_P3P Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang</a>
<span class="sourceLineNo">4322</span><a id="line.4322">     * "Complete Solution Classification for the Perspective-Three-Point Problem" (CITE: gao2003complete).</a>
<span class="sourceLineNo">4323</span><a id="line.4323">     * In this case the function requires exactly four object and image points.</a>
<span class="sourceLineNo">4324</span><a id="line.4324">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4325</span><a id="line.4325">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4326</span><a id="line.4326">     *    REF: SOLVEPNP_AP3P Method is based on the paper of T. Ke, S. Roumeliotis</a>
<span class="sourceLineNo">4327</span><a id="line.4327">     * "An Efficient Algebraic Solution to the Perspective-Three-Point Problem" (CITE: Ke17).</a>
<span class="sourceLineNo">4328</span><a id="line.4328">     * In this case the function requires exactly four object and image points.</a>
<span class="sourceLineNo">4329</span><a id="line.4329">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4330</span><a id="line.4330">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4331</span><a id="line.4331">     *    REF: SOLVEPNP_EPNP Method has been introduced by F.Moreno-Noguer, V.Lepetit and P.Fua in the</a>
<span class="sourceLineNo">4332</span><a id="line.4332">     * paper "EPnP: Efficient Perspective-n-Point Camera Pose Estimation" (CITE: lepetit2009epnp).</a>
<span class="sourceLineNo">4333</span><a id="line.4333">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4334</span><a id="line.4334">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4335</span><a id="line.4335">     *    REF: SOLVEPNP_DLS &lt;b&gt;Broken implementation. Using this flag will fallback to EPnP.&lt;/b&gt; \n</a>
<span class="sourceLineNo">4336</span><a id="line.4336">     * Method is based on the paper of Joel A. Hesch and Stergios I. Roumeliotis.</a>
<span class="sourceLineNo">4337</span><a id="line.4337">     * "A Direct Least-Squares (DLS) Method for PnP" (CITE: hesch2011direct).</a>
<span class="sourceLineNo">4338</span><a id="line.4338">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4339</span><a id="line.4339">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4340</span><a id="line.4340">     *    REF: SOLVEPNP_UPNP &lt;b&gt;Broken implementation. Using this flag will fallback to EPnP.&lt;/b&gt; \n</a>
<span class="sourceLineNo">4341</span><a id="line.4341">     * Method is based on the paper of A.Penate-Sanchez, J.Andrade-Cetto,</a>
<span class="sourceLineNo">4342</span><a id="line.4342">     * F.Moreno-Noguer. "Exhaustive Linearization for Robust Camera Pose and Focal Length</a>
<span class="sourceLineNo">4343</span><a id="line.4343">     * Estimation" (CITE: penate2013exhaustive). In this case the function also estimates the parameters \(f_x\) and \(f_y\)</a>
<span class="sourceLineNo">4344</span><a id="line.4344">     * assuming that both have the same value. Then the cameraMatrix is updated with the estimated</a>
<span class="sourceLineNo">4345</span><a id="line.4345">     * focal length.</a>
<span class="sourceLineNo">4346</span><a id="line.4346">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4347</span><a id="line.4347">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4348</span><a id="line.4348">     *    REF: SOLVEPNP_IPPE Method is based on the paper of T. Collins and A. Bartoli.</a>
<span class="sourceLineNo">4349</span><a id="line.4349">     * "Infinitesimal Plane-Based Pose Estimation" (CITE: Collins14). This method requires coplanar object points.</a>
<span class="sourceLineNo">4350</span><a id="line.4350">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4351</span><a id="line.4351">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4352</span><a id="line.4352">     *    REF: SOLVEPNP_IPPE_SQUARE Method is based on the paper of Toby Collins and Adrien Bartoli.</a>
<span class="sourceLineNo">4353</span><a id="line.4353">     * "Infinitesimal Plane-Based Pose Estimation" (CITE: Collins14). This method is suitable for marker pose estimation.</a>
<span class="sourceLineNo">4354</span><a id="line.4354">     * It requires 4 coplanar object points defined in the following order:</a>
<span class="sourceLineNo">4355</span><a id="line.4355">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">4356</span><a id="line.4356">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4357</span><a id="line.4357">     *    point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">4358</span><a id="line.4358">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4359</span><a id="line.4359">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4360</span><a id="line.4360">     *    point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">4361</span><a id="line.4361">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4362</span><a id="line.4362">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4363</span><a id="line.4363">     *    point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">4364</span><a id="line.4364">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4365</span><a id="line.4365">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4366</span><a id="line.4366">     *    point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">4367</span><a id="line.4367">     * and useExtrinsicGuess is set to true.</a>
<span class="sourceLineNo">4368</span><a id="line.4368">     * and useExtrinsicGuess is set to true.</a>
<span class="sourceLineNo">4369</span><a id="line.4369">     * (\( \text{RMSE} = \sqrt{\frac{\sum_{i}^{N} \left ( \hat{y_i} - y_i \right )^2}{N}} \)) between the input image points</a>
<span class="sourceLineNo">4370</span><a id="line.4370">     * and the 3D object points projected with the estimated pose.</a>
<span class="sourceLineNo">4371</span><a id="line.4371">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4372</span><a id="line.4372">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">4373</span><a id="line.4373">     *</a>
<span class="sourceLineNo">4374</span><a id="line.4374">     * The function estimates the object pose given a set of object points, their corresponding image</a>
<span class="sourceLineNo">4375</span><a id="line.4375">     * projections, as well as the camera intrinsic matrix and the distortion coefficients, see the figure below</a>
<span class="sourceLineNo">4376</span><a id="line.4376">     * (more precisely, the X-axis of the camera frame is pointing to the right, the Y-axis downward</a>
<span class="sourceLineNo">4377</span><a id="line.4377">     * and the Z-axis forward).</a>
<span class="sourceLineNo">4378</span><a id="line.4378">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4379</span><a id="line.4379">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">4380</span><a id="line.4380">     *</a>
<span class="sourceLineNo">4381</span><a id="line.4381">     * ![](pnp.jpg)</a>
<span class="sourceLineNo">4382</span><a id="line.4382">     *</a>
<span class="sourceLineNo">4383</span><a id="line.4383">     * Points expressed in the world frame \( \bf{X}_w \) are projected into the image plane \( \left[ u, v \right] \)</a>
<span class="sourceLineNo">4384</span><a id="line.4384">     * using the perspective projection model \( \Pi \) and the camera intrinsic parameters matrix \( \bf{A} \):</a>
<span class="sourceLineNo">4385</span><a id="line.4385">     *</a>
<span class="sourceLineNo">4386</span><a id="line.4386">     * \(</a>
<span class="sourceLineNo">4387</span><a id="line.4387">     *   \begin{align*}</a>
<span class="sourceLineNo">4388</span><a id="line.4388">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4389</span><a id="line.4389">     *   u \\</a>
<span class="sourceLineNo">4390</span><a id="line.4390">     *   v \\</a>
<span class="sourceLineNo">4391</span><a id="line.4391">     *   1</a>
<span class="sourceLineNo">4392</span><a id="line.4392">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">4393</span><a id="line.4393">     *   \bf{A} \hspace{0.1em} \Pi \hspace{0.2em} ^{c}\bf{T}_w</a>
<span class="sourceLineNo">4394</span><a id="line.4394">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4395</span><a id="line.4395">     *   X_{w} \\</a>
<span class="sourceLineNo">4396</span><a id="line.4396">     *   Y_{w} \\</a>
<span class="sourceLineNo">4397</span><a id="line.4397">     *   Z_{w} \\</a>
<span class="sourceLineNo">4398</span><a id="line.4398">     *   1</a>
<span class="sourceLineNo">4399</span><a id="line.4399">     *   \end{bmatrix} \\</a>
<span class="sourceLineNo">4400</span><a id="line.4400">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4401</span><a id="line.4401">     *   u \\</a>
<span class="sourceLineNo">4402</span><a id="line.4402">     *   v \\</a>
<span class="sourceLineNo">4403</span><a id="line.4403">     *   1</a>
<span class="sourceLineNo">4404</span><a id="line.4404">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">4405</span><a id="line.4405">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4406</span><a id="line.4406">     *   f_x &amp;amp; 0 &amp;amp; c_x \\</a>
<span class="sourceLineNo">4407</span><a id="line.4407">     *   0 &amp;amp; f_y &amp;amp; c_y \\</a>
<span class="sourceLineNo">4408</span><a id="line.4408">     *   0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">4409</span><a id="line.4409">     *   \end{bmatrix}</a>
<span class="sourceLineNo">4410</span><a id="line.4410">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4411</span><a id="line.4411">     *   1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\</a>
<span class="sourceLineNo">4412</span><a id="line.4412">     *   0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\</a>
<span class="sourceLineNo">4413</span><a id="line.4413">     *   0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">4414</span><a id="line.4414">     *   \end{bmatrix}</a>
<span class="sourceLineNo">4415</span><a id="line.4415">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4416</span><a id="line.4416">     *   r_{11} &amp;amp; r_{12} &amp;amp; r_{13} &amp;amp; t_x \\</a>
<span class="sourceLineNo">4417</span><a id="line.4417">     *   r_{21} &amp;amp; r_{22} &amp;amp; r_{23} &amp;amp; t_y \\</a>
<span class="sourceLineNo">4418</span><a id="line.4418">     *   r_{31} &amp;amp; r_{32} &amp;amp; r_{33} &amp;amp; t_z \\</a>
<span class="sourceLineNo">4419</span><a id="line.4419">     *   0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">4420</span><a id="line.4420">     *   \end{bmatrix}</a>
<span class="sourceLineNo">4421</span><a id="line.4421">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4422</span><a id="line.4422">     *   X_{w} \\</a>
<span class="sourceLineNo">4423</span><a id="line.4423">     *   Y_{w} \\</a>
<span class="sourceLineNo">4424</span><a id="line.4424">     *   Z_{w} \\</a>
<span class="sourceLineNo">4425</span><a id="line.4425">     *   1</a>
<span class="sourceLineNo">4426</span><a id="line.4426">     *   \end{bmatrix}</a>
<span class="sourceLineNo">4427</span><a id="line.4427">     *   \end{align*}</a>
<span class="sourceLineNo">4428</span><a id="line.4428">     * \)</a>
<span class="sourceLineNo">4429</span><a id="line.4429">     *</a>
<span class="sourceLineNo">4430</span><a id="line.4430">     * The estimated pose is thus the rotation ({@code rvec}) and the translation ({@code tvec}) vectors that allow transforming</a>
<span class="sourceLineNo">4431</span><a id="line.4431">     * a 3D point expressed in the world frame into the camera frame:</a>
<span class="sourceLineNo">4432</span><a id="line.4432">     *</a>
<span class="sourceLineNo">4433</span><a id="line.4433">     * \(</a>
<span class="sourceLineNo">4434</span><a id="line.4434">     *   \begin{align*}</a>
<span class="sourceLineNo">4435</span><a id="line.4435">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4436</span><a id="line.4436">     *   X_c \\</a>
<span class="sourceLineNo">4437</span><a id="line.4437">     *   Y_c \\</a>
<span class="sourceLineNo">4438</span><a id="line.4438">     *   Z_c \\</a>
<span class="sourceLineNo">4439</span><a id="line.4439">     *   1</a>
<span class="sourceLineNo">4440</span><a id="line.4440">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">4441</span><a id="line.4441">     *   \hspace{0.2em} ^{c}\bf{T}_w</a>
<span class="sourceLineNo">4442</span><a id="line.4442">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4443</span><a id="line.4443">     *   X_{w} \\</a>
<span class="sourceLineNo">4444</span><a id="line.4444">     *   Y_{w} \\</a>
<span class="sourceLineNo">4445</span><a id="line.4445">     *   Z_{w} \\</a>
<span class="sourceLineNo">4446</span><a id="line.4446">     *   1</a>
<span class="sourceLineNo">4447</span><a id="line.4447">     *   \end{bmatrix} \\</a>
<span class="sourceLineNo">4448</span><a id="line.4448">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4449</span><a id="line.4449">     *   X_c \\</a>
<span class="sourceLineNo">4450</span><a id="line.4450">     *   Y_c \\</a>
<span class="sourceLineNo">4451</span><a id="line.4451">     *   Z_c \\</a>
<span class="sourceLineNo">4452</span><a id="line.4452">     *   1</a>
<span class="sourceLineNo">4453</span><a id="line.4453">     *   \end{bmatrix} &amp;amp;=</a>
<span class="sourceLineNo">4454</span><a id="line.4454">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4455</span><a id="line.4455">     *   r_{11} &amp;amp; r_{12} &amp;amp; r_{13} &amp;amp; t_x \\</a>
<span class="sourceLineNo">4456</span><a id="line.4456">     *   r_{21} &amp;amp; r_{22} &amp;amp; r_{23} &amp;amp; t_y \\</a>
<span class="sourceLineNo">4457</span><a id="line.4457">     *   r_{31} &amp;amp; r_{32} &amp;amp; r_{33} &amp;amp; t_z \\</a>
<span class="sourceLineNo">4458</span><a id="line.4458">     *   0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">4459</span><a id="line.4459">     *   \end{bmatrix}</a>
<span class="sourceLineNo">4460</span><a id="line.4460">     *   \begin{bmatrix}</a>
<span class="sourceLineNo">4461</span><a id="line.4461">     *   X_{w} \\</a>
<span class="sourceLineNo">4462</span><a id="line.4462">     *   Y_{w} \\</a>
<span class="sourceLineNo">4463</span><a id="line.4463">     *   Z_{w} \\</a>
<span class="sourceLineNo">4464</span><a id="line.4464">     *   1</a>
<span class="sourceLineNo">4465</span><a id="line.4465">     *   \end{bmatrix}</a>
<span class="sourceLineNo">4466</span><a id="line.4466">     *   \end{align*}</a>
<span class="sourceLineNo">4467</span><a id="line.4467">     * \)</a>
<span class="sourceLineNo">4468</span><a id="line.4468">     *</a>
<span class="sourceLineNo">4469</span><a id="line.4469">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">4470</span><a id="line.4470">     * &lt;ul&gt;</a>
<span class="sourceLineNo">4471</span><a id="line.4471">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4472</span><a id="line.4472">     *       An example of how to use solvePnP for planar augmented reality can be found at</a>
<span class="sourceLineNo">4473</span><a id="line.4473">     *         opencv_source_code/samples/python/plane_ar.py</a>
<span class="sourceLineNo">4474</span><a id="line.4474">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4475</span><a id="line.4475">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4476</span><a id="line.4476">     *       If you are using Python:</a>
<span class="sourceLineNo">4477</span><a id="line.4477">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">4478</span><a id="line.4478">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4479</span><a id="line.4479">     *          Numpy array slices won't work as input because solvePnP requires contiguous</a>
<span class="sourceLineNo">4480</span><a id="line.4480">     *         arrays (enforced by the assertion using cv::Mat::checkVector() around line 55 of</a>
<span class="sourceLineNo">4481</span><a id="line.4481">     *         modules/calib3d/src/solvepnp.cpp version 2.4.9)</a>
<span class="sourceLineNo">4482</span><a id="line.4482">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4483</span><a id="line.4483">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4484</span><a id="line.4484">     *          The P3P algorithm requires image points to be in an array of shape (N,1,2) due</a>
<span class="sourceLineNo">4485</span><a id="line.4485">     *         to its calling of cv::undistortPoints (around line 75 of modules/calib3d/src/solvepnp.cpp version 2.4.9)</a>
<span class="sourceLineNo">4486</span><a id="line.4486">     *         which requires 2-channel information.</a>
<span class="sourceLineNo">4487</span><a id="line.4487">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4488</span><a id="line.4488">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4489</span><a id="line.4489">     *          Thus, given some data D = np.array(...) where D.shape = (N,M), in order to use a subset of</a>
<span class="sourceLineNo">4490</span><a id="line.4490">     *         it as, e.g., imagePoints, one must effectively copy it into a new array: imagePoints =</a>
<span class="sourceLineNo">4491</span><a id="line.4491">     *         np.ascontiguousarray(D[:,:2]).reshape((N,1,2))</a>
<span class="sourceLineNo">4492</span><a id="line.4492">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4493</span><a id="line.4493">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">4494</span><a id="line.4494">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4495</span><a id="line.4495">     *       The methods REF: SOLVEPNP_DLS and REF: SOLVEPNP_UPNP cannot be used as the current implementations are</a>
<span class="sourceLineNo">4496</span><a id="line.4496">     *        unstable and sometimes give completely wrong results. If you pass one of these two</a>
<span class="sourceLineNo">4497</span><a id="line.4497">     *        flags, REF: SOLVEPNP_EPNP method will be used instead.</a>
<span class="sourceLineNo">4498</span><a id="line.4498">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4499</span><a id="line.4499">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4500</span><a id="line.4500">     *       The minimum number of points is 4 in the general case. In the case of REF: SOLVEPNP_P3P and REF: SOLVEPNP_AP3P</a>
<span class="sourceLineNo">4501</span><a id="line.4501">     *        methods, it is required to use exactly 4 points (the first 3 points are used to estimate all the solutions</a>
<span class="sourceLineNo">4502</span><a id="line.4502">     *        of the P3P problem, the last one is used to retain the best solution that minimizes the reprojection error).</a>
<span class="sourceLineNo">4503</span><a id="line.4503">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4504</span><a id="line.4504">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4505</span><a id="line.4505">     *       With REF: SOLVEPNP_ITERATIVE method and {@code useExtrinsicGuess=true}, the minimum number of points is 3 (3 points</a>
<span class="sourceLineNo">4506</span><a id="line.4506">     *        are sufficient to compute a pose but there are up to 4 solutions). The initial solution should be close to the</a>
<span class="sourceLineNo">4507</span><a id="line.4507">     *        global solution to converge.</a>
<span class="sourceLineNo">4508</span><a id="line.4508">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4509</span><a id="line.4509">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4510</span><a id="line.4510">     *       With REF: SOLVEPNP_IPPE input points must be &amp;gt;= 4 and object points must be coplanar.</a>
<span class="sourceLineNo">4511</span><a id="line.4511">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4512</span><a id="line.4512">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4513</span><a id="line.4513">     *       With REF: SOLVEPNP_IPPE_SQUARE this is a special case suitable for marker pose estimation.</a>
<span class="sourceLineNo">4514</span><a id="line.4514">     *        Number of input points must be 4. Object points must be defined in the following order:</a>
<span class="sourceLineNo">4515</span><a id="line.4515">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">4516</span><a id="line.4516">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4517</span><a id="line.4517">     *           point 0: [-squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">4518</span><a id="line.4518">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4519</span><a id="line.4519">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4520</span><a id="line.4520">     *           point 1: [ squareLength / 2,  squareLength / 2, 0]</a>
<span class="sourceLineNo">4521</span><a id="line.4521">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4522</span><a id="line.4522">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4523</span><a id="line.4523">     *           point 2: [ squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">4524</span><a id="line.4524">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4525</span><a id="line.4525">     *     &lt;li&gt;</a>
<span class="sourceLineNo">4526</span><a id="line.4526">     *           point 3: [-squareLength / 2, -squareLength / 2, 0]</a>
<span class="sourceLineNo">4527</span><a id="line.4527">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">4528</span><a id="line.4528">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">4529</span><a id="line.4529">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4530</span><a id="line.4530">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">4531</span><a id="line.4531">     * @return automatically generated</a>
<span class="sourceLineNo">4532</span><a id="line.4532">     */</a>
<span class="sourceLineNo">4533</span><a id="line.4533">    public static int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List&lt;Mat&gt; rvecs, List&lt;Mat&gt; tvecs) {</a>
<span class="sourceLineNo">4534</span><a id="line.4534">        Mat rvecs_mat = new Mat();</a>
<span class="sourceLineNo">4535</span><a id="line.4535">        Mat tvecs_mat = new Mat();</a>
<span class="sourceLineNo">4536</span><a id="line.4536">        int retVal = solvePnPGeneric_5(objectPoints.nativeObj, imagePoints.nativeObj, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvecs_mat.nativeObj, tvecs_mat.nativeObj);</a>
<span class="sourceLineNo">4537</span><a id="line.4537">        Converters.Mat_to_vector_Mat(rvecs_mat, rvecs);</a>
<span class="sourceLineNo">4538</span><a id="line.4538">        rvecs_mat.release();</a>
<span class="sourceLineNo">4539</span><a id="line.4539">        Converters.Mat_to_vector_Mat(tvecs_mat, tvecs);</a>
<span class="sourceLineNo">4540</span><a id="line.4540">        tvecs_mat.release();</a>
<span class="sourceLineNo">4541</span><a id="line.4541">        return retVal;</a>
<span class="sourceLineNo">4542</span><a id="line.4542">    }</a>
<span class="sourceLineNo">4543</span><a id="line.4543"></a>
<span class="sourceLineNo">4544</span><a id="line.4544"></a>
<span class="sourceLineNo">4545</span><a id="line.4545">    //</a>
<span class="sourceLineNo">4546</span><a id="line.4546">    // C++:  Mat cv::initCameraMatrix2D(vector_vector_Point3f objectPoints, vector_vector_Point2f imagePoints, Size imageSize, double aspectRatio = 1.0)</a>
<span class="sourceLineNo">4547</span><a id="line.4547">    //</a>
<span class="sourceLineNo">4548</span><a id="line.4548"></a>
<span class="sourceLineNo">4549</span><a id="line.4549">    /**</a>
<span class="sourceLineNo">4550</span><a id="line.4550">     * Finds an initial camera intrinsic matrix from 3D-2D point correspondences.</a>
<span class="sourceLineNo">4551</span><a id="line.4551">     *</a>
<span class="sourceLineNo">4552</span><a id="line.4552">     * @param objectPoints Vector of vectors of the calibration pattern points in the calibration pattern</a>
<span class="sourceLineNo">4553</span><a id="line.4553">     * coordinate space. In the old interface all the per-view vectors are concatenated. See</a>
<span class="sourceLineNo">4554</span><a id="line.4554">     * calibrateCamera for details.</a>
<span class="sourceLineNo">4555</span><a id="line.4555">     * @param imagePoints Vector of vectors of the projections of the calibration pattern points. In the</a>
<span class="sourceLineNo">4556</span><a id="line.4556">     * old interface all the per-view vectors are concatenated.</a>
<span class="sourceLineNo">4557</span><a id="line.4557">     * @param imageSize Image size in pixels used to initialize the principal point.</a>
<span class="sourceLineNo">4558</span><a id="line.4558">     * @param aspectRatio If it is zero or negative, both \(f_x\) and \(f_y\) are estimated independently.</a>
<span class="sourceLineNo">4559</span><a id="line.4559">     * Otherwise, \(f_x = f_y * \texttt{aspectRatio}\) .</a>
<span class="sourceLineNo">4560</span><a id="line.4560">     *</a>
<span class="sourceLineNo">4561</span><a id="line.4561">     * The function estimates and returns an initial camera intrinsic matrix for the camera calibration process.</a>
<span class="sourceLineNo">4562</span><a id="line.4562">     * Currently, the function only supports planar calibration patterns, which are patterns where each</a>
<span class="sourceLineNo">4563</span><a id="line.4563">     * object point has z-coordinate =0.</a>
<span class="sourceLineNo">4564</span><a id="line.4564">     * @return automatically generated</a>
<span class="sourceLineNo">4565</span><a id="line.4565">     */</a>
<span class="sourceLineNo">4566</span><a id="line.4566">    public static Mat initCameraMatrix2D(List&lt;MatOfPoint3f&gt; objectPoints, List&lt;MatOfPoint2f&gt; imagePoints, Size imageSize, double aspectRatio) {</a>
<span class="sourceLineNo">4567</span><a id="line.4567">        List&lt;Mat&gt; objectPoints_tmplm = new ArrayList&lt;Mat&gt;((objectPoints != null) ? objectPoints.size() : 0);</a>
<span class="sourceLineNo">4568</span><a id="line.4568">        Mat objectPoints_mat = Converters.vector_vector_Point3f_to_Mat(objectPoints, objectPoints_tmplm);</a>
<span class="sourceLineNo">4569</span><a id="line.4569">        List&lt;Mat&gt; imagePoints_tmplm = new ArrayList&lt;Mat&gt;((imagePoints != null) ? imagePoints.size() : 0);</a>
<span class="sourceLineNo">4570</span><a id="line.4570">        Mat imagePoints_mat = Converters.vector_vector_Point2f_to_Mat(imagePoints, imagePoints_tmplm);</a>
<span class="sourceLineNo">4571</span><a id="line.4571">        return new Mat(initCameraMatrix2D_0(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, imageSize.width, imageSize.height, aspectRatio));</a>
<span class="sourceLineNo">4572</span><a id="line.4572">    }</a>
<span class="sourceLineNo">4573</span><a id="line.4573"></a>
<span class="sourceLineNo">4574</span><a id="line.4574">    /**</a>
<span class="sourceLineNo">4575</span><a id="line.4575">     * Finds an initial camera intrinsic matrix from 3D-2D point correspondences.</a>
<span class="sourceLineNo">4576</span><a id="line.4576">     *</a>
<span class="sourceLineNo">4577</span><a id="line.4577">     * @param objectPoints Vector of vectors of the calibration pattern points in the calibration pattern</a>
<span class="sourceLineNo">4578</span><a id="line.4578">     * coordinate space. In the old interface all the per-view vectors are concatenated. See</a>
<span class="sourceLineNo">4579</span><a id="line.4579">     * calibrateCamera for details.</a>
<span class="sourceLineNo">4580</span><a id="line.4580">     * @param imagePoints Vector of vectors of the projections of the calibration pattern points. In the</a>
<span class="sourceLineNo">4581</span><a id="line.4581">     * old interface all the per-view vectors are concatenated.</a>
<span class="sourceLineNo">4582</span><a id="line.4582">     * @param imageSize Image size in pixels used to initialize the principal point.</a>
<span class="sourceLineNo">4583</span><a id="line.4583">     * Otherwise, \(f_x = f_y * \texttt{aspectRatio}\) .</a>
<span class="sourceLineNo">4584</span><a id="line.4584">     *</a>
<span class="sourceLineNo">4585</span><a id="line.4585">     * The function estimates and returns an initial camera intrinsic matrix for the camera calibration process.</a>
<span class="sourceLineNo">4586</span><a id="line.4586">     * Currently, the function only supports planar calibration patterns, which are patterns where each</a>
<span class="sourceLineNo">4587</span><a id="line.4587">     * object point has z-coordinate =0.</a>
<span class="sourceLineNo">4588</span><a id="line.4588">     * @return automatically generated</a>
<span class="sourceLineNo">4589</span><a id="line.4589">     */</a>
<span class="sourceLineNo">4590</span><a id="line.4590">    public static Mat initCameraMatrix2D(List&lt;MatOfPoint3f&gt; objectPoints, List&lt;MatOfPoint2f&gt; imagePoints, Size imageSize) {</a>
<span class="sourceLineNo">4591</span><a id="line.4591">        List&lt;Mat&gt; objectPoints_tmplm = new ArrayList&lt;Mat&gt;((objectPoints != null) ? objectPoints.size() : 0);</a>
<span class="sourceLineNo">4592</span><a id="line.4592">        Mat objectPoints_mat = Converters.vector_vector_Point3f_to_Mat(objectPoints, objectPoints_tmplm);</a>
<span class="sourceLineNo">4593</span><a id="line.4593">        List&lt;Mat&gt; imagePoints_tmplm = new ArrayList&lt;Mat&gt;((imagePoints != null) ? imagePoints.size() : 0);</a>
<span class="sourceLineNo">4594</span><a id="line.4594">        Mat imagePoints_mat = Converters.vector_vector_Point2f_to_Mat(imagePoints, imagePoints_tmplm);</a>
<span class="sourceLineNo">4595</span><a id="line.4595">        return new Mat(initCameraMatrix2D_1(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, imageSize.width, imageSize.height));</a>
<span class="sourceLineNo">4596</span><a id="line.4596">    }</a>
<span class="sourceLineNo">4597</span><a id="line.4597"></a>
<span class="sourceLineNo">4598</span><a id="line.4598"></a>
<span class="sourceLineNo">4599</span><a id="line.4599">    //</a>
<span class="sourceLineNo">4600</span><a id="line.4600">    // C++:  bool cv::findChessboardCorners(Mat image, Size patternSize, vector_Point2f&amp; corners, int flags = CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE)</a>
<span class="sourceLineNo">4601</span><a id="line.4601">    //</a>
<span class="sourceLineNo">4602</span><a id="line.4602"></a>
<span class="sourceLineNo">4603</span><a id="line.4603">    /**</a>
<span class="sourceLineNo">4604</span><a id="line.4604">     * Finds the positions of internal corners of the chessboard.</a>
<span class="sourceLineNo">4605</span><a id="line.4605">     *</a>
<span class="sourceLineNo">4606</span><a id="line.4606">     * @param image Source chessboard view. It must be an 8-bit grayscale or color image.</a>
<span class="sourceLineNo">4607</span><a id="line.4607">     * @param patternSize Number of inner corners per a chessboard row and column</a>
<span class="sourceLineNo">4608</span><a id="line.4608">     * ( patternSize = cv::Size(points_per_row,points_per_colum) = cv::Size(columns,rows) ).</a>
<span class="sourceLineNo">4609</span><a id="line.4609">     * @param corners Output array of detected corners.</a>
<span class="sourceLineNo">4610</span><a id="line.4610">     * @param flags Various operation flags that can be zero or a combination of the following values:</a>
<span class="sourceLineNo">4611</span><a id="line.4611">     * &lt;ul&gt;</a>
<span class="sourceLineNo">4612</span><a id="line.4612">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4613</span><a id="line.4613">     *    REF: CALIB_CB_ADAPTIVE_THRESH Use adaptive thresholding to convert the image to black</a>
<span class="sourceLineNo">4614</span><a id="line.4614">     * and white, rather than a fixed threshold level (computed from the average image brightness).</a>
<span class="sourceLineNo">4615</span><a id="line.4615">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4616</span><a id="line.4616">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4617</span><a id="line.4617">     *    REF: CALIB_CB_NORMALIZE_IMAGE Normalize the image gamma with equalizeHist before</a>
<span class="sourceLineNo">4618</span><a id="line.4618">     * applying fixed or adaptive thresholding.</a>
<span class="sourceLineNo">4619</span><a id="line.4619">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4620</span><a id="line.4620">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4621</span><a id="line.4621">     *    REF: CALIB_CB_FILTER_QUADS Use additional criteria (like contour area, perimeter,</a>
<span class="sourceLineNo">4622</span><a id="line.4622">     * square-like shape) to filter out false quads extracted at the contour retrieval stage.</a>
<span class="sourceLineNo">4623</span><a id="line.4623">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4624</span><a id="line.4624">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4625</span><a id="line.4625">     *    REF: CALIB_CB_FAST_CHECK Run a fast check on the image that looks for chessboard corners,</a>
<span class="sourceLineNo">4626</span><a id="line.4626">     * and shortcut the call if none is found. This can drastically speed up the call in the</a>
<span class="sourceLineNo">4627</span><a id="line.4627">     * degenerate condition when no chessboard is observed.</a>
<span class="sourceLineNo">4628</span><a id="line.4628">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4629</span><a id="line.4629">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">4630</span><a id="line.4630">     *</a>
<span class="sourceLineNo">4631</span><a id="line.4631">     * The function attempts to determine whether the input image is a view of the chessboard pattern and</a>
<span class="sourceLineNo">4632</span><a id="line.4632">     * locate the internal chessboard corners. The function returns a non-zero value if all of the corners</a>
<span class="sourceLineNo">4633</span><a id="line.4633">     * are found and they are placed in a certain order (row by row, left to right in every row).</a>
<span class="sourceLineNo">4634</span><a id="line.4634">     * Otherwise, if the function fails to find all the corners or reorder them, it returns 0. For example,</a>
<span class="sourceLineNo">4635</span><a id="line.4635">     * a regular chessboard has 8 x 8 squares and 7 x 7 internal corners, that is, points where the black</a>
<span class="sourceLineNo">4636</span><a id="line.4636">     * squares touch each other. The detected coordinates are approximate, and to determine their positions</a>
<span class="sourceLineNo">4637</span><a id="line.4637">     * more accurately, the function calls cornerSubPix. You also may use the function cornerSubPix with</a>
<span class="sourceLineNo">4638</span><a id="line.4638">     * different parameters if returned coordinates are not accurate enough.</a>
<span class="sourceLineNo">4639</span><a id="line.4639">     *</a>
<span class="sourceLineNo">4640</span><a id="line.4640">     * Sample usage of detecting and drawing chessboard corners: :</a>
<span class="sourceLineNo">4641</span><a id="line.4641">     * &lt;code&gt;</a>
<span class="sourceLineNo">4642</span><a id="line.4642">     *     Size patternsize(8,6); //interior number of corners</a>
<span class="sourceLineNo">4643</span><a id="line.4643">     *     Mat gray = ....; //source image</a>
<span class="sourceLineNo">4644</span><a id="line.4644">     *     vector&amp;lt;Point2f&amp;gt; corners; //this will be filled by the detected corners</a>
<span class="sourceLineNo">4645</span><a id="line.4645">     *</a>
<span class="sourceLineNo">4646</span><a id="line.4646">     *     //CALIB_CB_FAST_CHECK saves a lot of time on images</a>
<span class="sourceLineNo">4647</span><a id="line.4647">     *     //that do not contain any chessboard corners</a>
<span class="sourceLineNo">4648</span><a id="line.4648">     *     bool patternfound = findChessboardCorners(gray, patternsize, corners,</a>
<span class="sourceLineNo">4649</span><a id="line.4649">     *             CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE</a>
<span class="sourceLineNo">4650</span><a id="line.4650">     *             + CALIB_CB_FAST_CHECK);</a>
<span class="sourceLineNo">4651</span><a id="line.4651">     *</a>
<span class="sourceLineNo">4652</span><a id="line.4652">     *     if(patternfound)</a>
<span class="sourceLineNo">4653</span><a id="line.4653">     *       cornerSubPix(gray, corners, Size(11, 11), Size(-1, -1),</a>
<span class="sourceLineNo">4654</span><a id="line.4654">     *         TermCriteria(CV_TERMCRIT_EPS + CV_TERMCRIT_ITER, 30, 0.1));</a>
<span class="sourceLineNo">4655</span><a id="line.4655">     *</a>
<span class="sourceLineNo">4656</span><a id="line.4656">     *     drawChessboardCorners(img, patternsize, Mat(corners), patternfound);</a>
<span class="sourceLineNo">4657</span><a id="line.4657">     * &lt;/code&gt;</a>
<span class="sourceLineNo">4658</span><a id="line.4658">     * &lt;b&gt;Note:&lt;/b&gt; The function requires white space (like a square-thick border, the wider the better) around</a>
<span class="sourceLineNo">4659</span><a id="line.4659">     * the board to make the detection more robust in various environments. Otherwise, if there is no</a>
<span class="sourceLineNo">4660</span><a id="line.4660">     * border and the background is dark, the outer black squares cannot be segmented properly and so the</a>
<span class="sourceLineNo">4661</span><a id="line.4661">     * square grouping and ordering algorithm fails.</a>
<span class="sourceLineNo">4662</span><a id="line.4662">     * @return automatically generated</a>
<span class="sourceLineNo">4663</span><a id="line.4663">     */</a>
<span class="sourceLineNo">4664</span><a id="line.4664">    public static boolean findChessboardCorners(Mat image, Size patternSize, MatOfPoint2f corners, int flags) {</a>
<span class="sourceLineNo">4665</span><a id="line.4665">        Mat corners_mat = corners;</a>
<span class="sourceLineNo">4666</span><a id="line.4666">        return findChessboardCorners_0(image.nativeObj, patternSize.width, patternSize.height, corners_mat.nativeObj, flags);</a>
<span class="sourceLineNo">4667</span><a id="line.4667">    }</a>
<span class="sourceLineNo">4668</span><a id="line.4668"></a>
<span class="sourceLineNo">4669</span><a id="line.4669">    /**</a>
<span class="sourceLineNo">4670</span><a id="line.4670">     * Finds the positions of internal corners of the chessboard.</a>
<span class="sourceLineNo">4671</span><a id="line.4671">     *</a>
<span class="sourceLineNo">4672</span><a id="line.4672">     * @param image Source chessboard view. It must be an 8-bit grayscale or color image.</a>
<span class="sourceLineNo">4673</span><a id="line.4673">     * @param patternSize Number of inner corners per a chessboard row and column</a>
<span class="sourceLineNo">4674</span><a id="line.4674">     * ( patternSize = cv::Size(points_per_row,points_per_colum) = cv::Size(columns,rows) ).</a>
<span class="sourceLineNo">4675</span><a id="line.4675">     * @param corners Output array of detected corners.</a>
<span class="sourceLineNo">4676</span><a id="line.4676">     * &lt;ul&gt;</a>
<span class="sourceLineNo">4677</span><a id="line.4677">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4678</span><a id="line.4678">     *    REF: CALIB_CB_ADAPTIVE_THRESH Use adaptive thresholding to convert the image to black</a>
<span class="sourceLineNo">4679</span><a id="line.4679">     * and white, rather than a fixed threshold level (computed from the average image brightness).</a>
<span class="sourceLineNo">4680</span><a id="line.4680">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4681</span><a id="line.4681">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4682</span><a id="line.4682">     *    REF: CALIB_CB_NORMALIZE_IMAGE Normalize the image gamma with equalizeHist before</a>
<span class="sourceLineNo">4683</span><a id="line.4683">     * applying fixed or adaptive thresholding.</a>
<span class="sourceLineNo">4684</span><a id="line.4684">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4685</span><a id="line.4685">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4686</span><a id="line.4686">     *    REF: CALIB_CB_FILTER_QUADS Use additional criteria (like contour area, perimeter,</a>
<span class="sourceLineNo">4687</span><a id="line.4687">     * square-like shape) to filter out false quads extracted at the contour retrieval stage.</a>
<span class="sourceLineNo">4688</span><a id="line.4688">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4689</span><a id="line.4689">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4690</span><a id="line.4690">     *    REF: CALIB_CB_FAST_CHECK Run a fast check on the image that looks for chessboard corners,</a>
<span class="sourceLineNo">4691</span><a id="line.4691">     * and shortcut the call if none is found. This can drastically speed up the call in the</a>
<span class="sourceLineNo">4692</span><a id="line.4692">     * degenerate condition when no chessboard is observed.</a>
<span class="sourceLineNo">4693</span><a id="line.4693">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4694</span><a id="line.4694">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">4695</span><a id="line.4695">     *</a>
<span class="sourceLineNo">4696</span><a id="line.4696">     * The function attempts to determine whether the input image is a view of the chessboard pattern and</a>
<span class="sourceLineNo">4697</span><a id="line.4697">     * locate the internal chessboard corners. The function returns a non-zero value if all of the corners</a>
<span class="sourceLineNo">4698</span><a id="line.4698">     * are found and they are placed in a certain order (row by row, left to right in every row).</a>
<span class="sourceLineNo">4699</span><a id="line.4699">     * Otherwise, if the function fails to find all the corners or reorder them, it returns 0. For example,</a>
<span class="sourceLineNo">4700</span><a id="line.4700">     * a regular chessboard has 8 x 8 squares and 7 x 7 internal corners, that is, points where the black</a>
<span class="sourceLineNo">4701</span><a id="line.4701">     * squares touch each other. The detected coordinates are approximate, and to determine their positions</a>
<span class="sourceLineNo">4702</span><a id="line.4702">     * more accurately, the function calls cornerSubPix. You also may use the function cornerSubPix with</a>
<span class="sourceLineNo">4703</span><a id="line.4703">     * different parameters if returned coordinates are not accurate enough.</a>
<span class="sourceLineNo">4704</span><a id="line.4704">     *</a>
<span class="sourceLineNo">4705</span><a id="line.4705">     * Sample usage of detecting and drawing chessboard corners: :</a>
<span class="sourceLineNo">4706</span><a id="line.4706">     * &lt;code&gt;</a>
<span class="sourceLineNo">4707</span><a id="line.4707">     *     Size patternsize(8,6); //interior number of corners</a>
<span class="sourceLineNo">4708</span><a id="line.4708">     *     Mat gray = ....; //source image</a>
<span class="sourceLineNo">4709</span><a id="line.4709">     *     vector&amp;lt;Point2f&amp;gt; corners; //this will be filled by the detected corners</a>
<span class="sourceLineNo">4710</span><a id="line.4710">     *</a>
<span class="sourceLineNo">4711</span><a id="line.4711">     *     //CALIB_CB_FAST_CHECK saves a lot of time on images</a>
<span class="sourceLineNo">4712</span><a id="line.4712">     *     //that do not contain any chessboard corners</a>
<span class="sourceLineNo">4713</span><a id="line.4713">     *     bool patternfound = findChessboardCorners(gray, patternsize, corners,</a>
<span class="sourceLineNo">4714</span><a id="line.4714">     *             CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE</a>
<span class="sourceLineNo">4715</span><a id="line.4715">     *             + CALIB_CB_FAST_CHECK);</a>
<span class="sourceLineNo">4716</span><a id="line.4716">     *</a>
<span class="sourceLineNo">4717</span><a id="line.4717">     *     if(patternfound)</a>
<span class="sourceLineNo">4718</span><a id="line.4718">     *       cornerSubPix(gray, corners, Size(11, 11), Size(-1, -1),</a>
<span class="sourceLineNo">4719</span><a id="line.4719">     *         TermCriteria(CV_TERMCRIT_EPS + CV_TERMCRIT_ITER, 30, 0.1));</a>
<span class="sourceLineNo">4720</span><a id="line.4720">     *</a>
<span class="sourceLineNo">4721</span><a id="line.4721">     *     drawChessboardCorners(img, patternsize, Mat(corners), patternfound);</a>
<span class="sourceLineNo">4722</span><a id="line.4722">     * &lt;/code&gt;</a>
<span class="sourceLineNo">4723</span><a id="line.4723">     * &lt;b&gt;Note:&lt;/b&gt; The function requires white space (like a square-thick border, the wider the better) around</a>
<span class="sourceLineNo">4724</span><a id="line.4724">     * the board to make the detection more robust in various environments. Otherwise, if there is no</a>
<span class="sourceLineNo">4725</span><a id="line.4725">     * border and the background is dark, the outer black squares cannot be segmented properly and so the</a>
<span class="sourceLineNo">4726</span><a id="line.4726">     * square grouping and ordering algorithm fails.</a>
<span class="sourceLineNo">4727</span><a id="line.4727">     * @return automatically generated</a>
<span class="sourceLineNo">4728</span><a id="line.4728">     */</a>
<span class="sourceLineNo">4729</span><a id="line.4729">    public static boolean findChessboardCorners(Mat image, Size patternSize, MatOfPoint2f corners) {</a>
<span class="sourceLineNo">4730</span><a id="line.4730">        Mat corners_mat = corners;</a>
<span class="sourceLineNo">4731</span><a id="line.4731">        return findChessboardCorners_1(image.nativeObj, patternSize.width, patternSize.height, corners_mat.nativeObj);</a>
<span class="sourceLineNo">4732</span><a id="line.4732">    }</a>
<span class="sourceLineNo">4733</span><a id="line.4733"></a>
<span class="sourceLineNo">4734</span><a id="line.4734"></a>
<span class="sourceLineNo">4735</span><a id="line.4735">    //</a>
<span class="sourceLineNo">4736</span><a id="line.4736">    // C++:  bool cv::checkChessboard(Mat img, Size size)</a>
<span class="sourceLineNo">4737</span><a id="line.4737">    //</a>
<span class="sourceLineNo">4738</span><a id="line.4738"></a>
<span class="sourceLineNo">4739</span><a id="line.4739">    public static boolean checkChessboard(Mat img, Size size) {</a>
<span class="sourceLineNo">4740</span><a id="line.4740">        return checkChessboard_0(img.nativeObj, size.width, size.height);</a>
<span class="sourceLineNo">4741</span><a id="line.4741">    }</a>
<span class="sourceLineNo">4742</span><a id="line.4742"></a>
<span class="sourceLineNo">4743</span><a id="line.4743"></a>
<span class="sourceLineNo">4744</span><a id="line.4744">    //</a>
<span class="sourceLineNo">4745</span><a id="line.4745">    // C++:  bool cv::findChessboardCornersSB(Mat image, Size patternSize, Mat&amp; corners, int flags, Mat&amp; meta)</a>
<span class="sourceLineNo">4746</span><a id="line.4746">    //</a>
<span class="sourceLineNo">4747</span><a id="line.4747"></a>
<span class="sourceLineNo">4748</span><a id="line.4748">    /**</a>
<span class="sourceLineNo">4749</span><a id="line.4749">     * Finds the positions of internal corners of the chessboard using a sector based approach.</a>
<span class="sourceLineNo">4750</span><a id="line.4750">     *</a>
<span class="sourceLineNo">4751</span><a id="line.4751">     * @param image Source chessboard view. It must be an 8-bit grayscale or color image.</a>
<span class="sourceLineNo">4752</span><a id="line.4752">     * @param patternSize Number of inner corners per a chessboard row and column</a>
<span class="sourceLineNo">4753</span><a id="line.4753">     * ( patternSize = cv::Size(points_per_row,points_per_colum) = cv::Size(columns,rows) ).</a>
<span class="sourceLineNo">4754</span><a id="line.4754">     * @param corners Output array of detected corners.</a>
<span class="sourceLineNo">4755</span><a id="line.4755">     * @param flags Various operation flags that can be zero or a combination of the following values:</a>
<span class="sourceLineNo">4756</span><a id="line.4756">     * &lt;ul&gt;</a>
<span class="sourceLineNo">4757</span><a id="line.4757">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4758</span><a id="line.4758">     *    REF: CALIB_CB_NORMALIZE_IMAGE Normalize the image gamma with equalizeHist before detection.</a>
<span class="sourceLineNo">4759</span><a id="line.4759">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4760</span><a id="line.4760">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4761</span><a id="line.4761">     *    REF: CALIB_CB_EXHAUSTIVE Run an exhaustive search to improve detection rate.</a>
<span class="sourceLineNo">4762</span><a id="line.4762">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4763</span><a id="line.4763">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4764</span><a id="line.4764">     *    REF: CALIB_CB_ACCURACY Up sample input image to improve sub-pixel accuracy due to aliasing effects.</a>
<span class="sourceLineNo">4765</span><a id="line.4765">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4766</span><a id="line.4766">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4767</span><a id="line.4767">     *    REF: CALIB_CB_LARGER The detected pattern is allowed to be larger than patternSize (see description).</a>
<span class="sourceLineNo">4768</span><a id="line.4768">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4769</span><a id="line.4769">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4770</span><a id="line.4770">     *    REF: CALIB_CB_MARKER The detected pattern must have a marker (see description).</a>
<span class="sourceLineNo">4771</span><a id="line.4771">     * This should be used if an accurate camera calibration is required.</a>
<span class="sourceLineNo">4772</span><a id="line.4772">     * @param meta Optional output arrray of detected corners (CV_8UC1 and size = cv::Size(columns,rows)).</a>
<span class="sourceLineNo">4773</span><a id="line.4773">     * Each entry stands for one corner of the pattern and can have one of the following values:</a>
<span class="sourceLineNo">4774</span><a id="line.4774">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4775</span><a id="line.4775">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4776</span><a id="line.4776">     *    0 = no meta data attached</a>
<span class="sourceLineNo">4777</span><a id="line.4777">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4778</span><a id="line.4778">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4779</span><a id="line.4779">     *    1 = left-top corner of a black cell</a>
<span class="sourceLineNo">4780</span><a id="line.4780">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4781</span><a id="line.4781">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4782</span><a id="line.4782">     *    2 = left-top corner of a white cell</a>
<span class="sourceLineNo">4783</span><a id="line.4783">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4784</span><a id="line.4784">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4785</span><a id="line.4785">     *    3 = left-top corner of a black cell with a white marker dot</a>
<span class="sourceLineNo">4786</span><a id="line.4786">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4787</span><a id="line.4787">     *   &lt;li&gt;</a>
<span class="sourceLineNo">4788</span><a id="line.4788">     *    4 = left-top corner of a white cell with a black marker dot (pattern origin in case of markers otherwise first corner)</a>
<span class="sourceLineNo">4789</span><a id="line.4789">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">4790</span><a id="line.4790">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">4791</span><a id="line.4791">     *</a>
<span class="sourceLineNo">4792</span><a id="line.4792">     * The function is analog to findchessboardCorners but uses a localized radon</a>
<span class="sourceLineNo">4793</span><a id="line.4793">     * transformation approximated by box filters being more robust to all sort of</a>
<span class="sourceLineNo">4794</span><a id="line.4794">     * noise, faster on larger images and is able to directly return the sub-pixel</a>
<span class="sourceLineNo">4795</span><a id="line.4795">     * position of the internal chessboard corners. The Method is based on the paper</a>
<span class="sourceLineNo">4796</span><a id="line.4796">     * CITE: duda2018 "Accurate Detection and Localization of Checkerboard Corners for</a>
<span class="sourceLineNo">4797</span><a id="line.4797">     * Calibration" demonstrating that the returned sub-pixel positions are more</a>
<span class="sourceLineNo">4798</span><a id="line.4798">     * accurate than the one returned by cornerSubPix allowing a precise camera</a>
<span class="sourceLineNo">4799</span><a id="line.4799">     * calibration for demanding applications.</a>
<span class="sourceLineNo">4800</span><a id="line.4800">     *</a>
<span class="sourceLineNo">4801</span><a id="line.4801">     * In the case, the flags REF: CALIB_CB_LARGER or REF: CALIB_CB_MARKER are given,</a>
<span class="sourceLineNo">4802</span><a id="line.4802">     * the result can be recovered from the optional meta array. Both flags are</a>
<span class="sourceLineNo">4803</span><a id="line.4803">     * helpful to use calibration patterns exceeding the field of view of the camera.</a>
<span class="sourceLineNo">4804</span><a id="line.4804">     * These oversized patterns allow more accurate calibrations as corners can be</a>
<span class="sourceLineNo">4805</span><a id="line.4805">     * utilized, which are as close as possible to the image borders.  For a</a>
<span class="sourceLineNo">4806</span><a id="line.4806">     * consistent coordinate system across all images, the optional marker (see image</a>
<span class="sourceLineNo">4807</span><a id="line.4807">     * below) can be used to move the origin of the board to the location where the</a>
<span class="sourceLineNo">4808</span><a id="line.4808">     * black circle is located.</a>
<span class="sourceLineNo">4809</span><a id="line.4809">     *</a>
<span class="sourceLineNo">4810</span><a id="line.4810">     * &lt;b&gt;Note:&lt;/b&gt; The function requires a white boarder with roughly the same width as one</a>
<span class="sourceLineNo">4811</span><a id="line.4811">     * of the checkerboard fields around the whole board to improve the detection in</a>
<span class="sourceLineNo">4812</span><a id="line.4812">     * various environments. In addition, because of the localized radon</a>
<span class="sourceLineNo">4813</span><a id="line.4813">     * transformation it is beneficial to use round corners for the field corners</a>
<span class="sourceLineNo">4814</span><a id="line.4814">     * which are located on the outside of the board. The following figure illustrates</a>
<span class="sourceLineNo">4815</span><a id="line.4815">     * a sample checkerboard optimized for the detection. However, any other checkerboard</a>
<span class="sourceLineNo">4816</span><a id="line.4816">     * can be used as well.</a>
<span class="sourceLineNo">4817</span><a id="line.4817">     * ![Checkerboard](pics/checkerboard_radon.png)</a>
<span class="sourceLineNo">4818</span><a id="line.4818">     * @return automatically generated</a>
<span class="sourceLineNo">4819</span><a id="line.4819">     */</a>
<span class="sourceLineNo">4820</span><a id="line.4820">    public static boolean findChessboardCornersSBWithMeta(Mat image, Size patternSize, Mat corners, int flags, Mat meta) {</a>
<span class="sourceLineNo">4821</span><a id="line.4821">        return findChessboardCornersSBWithMeta_0(image.nativeObj, patternSize.width, patternSize.height, corners.nativeObj, flags, meta.nativeObj);</a>
<span class="sourceLineNo">4822</span><a id="line.4822">    }</a>
<span class="sourceLineNo">4823</span><a id="line.4823"></a>
<span class="sourceLineNo">4824</span><a id="line.4824"></a>
<span class="sourceLineNo">4825</span><a id="line.4825">    //</a>
<span class="sourceLineNo">4826</span><a id="line.4826">    // C++:  bool cv::findChessboardCornersSB(Mat image, Size patternSize, Mat&amp; corners, int flags = 0)</a>
<span class="sourceLineNo">4827</span><a id="line.4827">    //</a>
<span class="sourceLineNo">4828</span><a id="line.4828"></a>
<span class="sourceLineNo">4829</span><a id="line.4829">    public static boolean findChessboardCornersSB(Mat image, Size patternSize, Mat corners, int flags) {</a>
<span class="sourceLineNo">4830</span><a id="line.4830">        return findChessboardCornersSB_0(image.nativeObj, patternSize.width, patternSize.height, corners.nativeObj, flags);</a>
<span class="sourceLineNo">4831</span><a id="line.4831">    }</a>
<span class="sourceLineNo">4832</span><a id="line.4832"></a>
<span class="sourceLineNo">4833</span><a id="line.4833">    public static boolean findChessboardCornersSB(Mat image, Size patternSize, Mat corners) {</a>
<span class="sourceLineNo">4834</span><a id="line.4834">        return findChessboardCornersSB_1(image.nativeObj, patternSize.width, patternSize.height, corners.nativeObj);</a>
<span class="sourceLineNo">4835</span><a id="line.4835">    }</a>
<span class="sourceLineNo">4836</span><a id="line.4836"></a>
<span class="sourceLineNo">4837</span><a id="line.4837"></a>
<span class="sourceLineNo">4838</span><a id="line.4838">    //</a>
<span class="sourceLineNo">4839</span><a id="line.4839">    // C++:  Scalar cv::estimateChessboardSharpness(Mat image, Size patternSize, Mat corners, float rise_distance = 0.8F, bool vertical = false, Mat&amp; sharpness = Mat())</a>
<span class="sourceLineNo">4840</span><a id="line.4840">    //</a>
<span class="sourceLineNo">4841</span><a id="line.4841"></a>
<span class="sourceLineNo">4842</span><a id="line.4842">    /**</a>
<span class="sourceLineNo">4843</span><a id="line.4843">     * Estimates the sharpness of a detected chessboard.</a>
<span class="sourceLineNo">4844</span><a id="line.4844">     *</a>
<span class="sourceLineNo">4845</span><a id="line.4845">     * Image sharpness, as well as brightness, are a critical parameter for accuracte</a>
<span class="sourceLineNo">4846</span><a id="line.4846">     * camera calibration. For accessing these parameters for filtering out</a>
<span class="sourceLineNo">4847</span><a id="line.4847">     * problematic calibraiton images, this method calculates edge profiles by traveling from</a>
<span class="sourceLineNo">4848</span><a id="line.4848">     * black to white chessboard cell centers. Based on this, the number of pixels is</a>
<span class="sourceLineNo">4849</span><a id="line.4849">     * calculated required to transit from black to white. This width of the</a>
<span class="sourceLineNo">4850</span><a id="line.4850">     * transition area is a good indication of how sharp the chessboard is imaged</a>
<span class="sourceLineNo">4851</span><a id="line.4851">     * and should be below ~3.0 pixels.</a>
<span class="sourceLineNo">4852</span><a id="line.4852">     *</a>
<span class="sourceLineNo">4853</span><a id="line.4853">     * @param image Gray image used to find chessboard corners</a>
<span class="sourceLineNo">4854</span><a id="line.4854">     * @param patternSize Size of a found chessboard pattern</a>
<span class="sourceLineNo">4855</span><a id="line.4855">     * @param corners Corners found by findChessboardCorners(SB)</a>
<span class="sourceLineNo">4856</span><a id="line.4856">     * @param rise_distance Rise distance 0.8 means 10% ... 90% of the final signal strength</a>
<span class="sourceLineNo">4857</span><a id="line.4857">     * @param vertical By default edge responses for horizontal lines are calculated</a>
<span class="sourceLineNo">4858</span><a id="line.4858">     * @param sharpness Optional output array with a sharpness value for calculated edge responses (see description)</a>
<span class="sourceLineNo">4859</span><a id="line.4859">     *</a>
<span class="sourceLineNo">4860</span><a id="line.4860">     * The optional sharpness array is of type CV_32FC1 and has for each calculated</a>
<span class="sourceLineNo">4861</span><a id="line.4861">     * profile one row with the following five entries:</a>
<span class="sourceLineNo">4862</span><a id="line.4862">     * 0 = x coordinate of the underlying edge in the image</a>
<span class="sourceLineNo">4863</span><a id="line.4863">     * 1 = y coordinate of the underlying edge in the image</a>
<span class="sourceLineNo">4864</span><a id="line.4864">     * 2 = width of the transition area (sharpness)</a>
<span class="sourceLineNo">4865</span><a id="line.4865">     * 3 = signal strength in the black cell (min brightness)</a>
<span class="sourceLineNo">4866</span><a id="line.4866">     * 4 = signal strength in the white cell (max brightness)</a>
<span class="sourceLineNo">4867</span><a id="line.4867">     *</a>
<span class="sourceLineNo">4868</span><a id="line.4868">     * @return Scalar(average sharpness, average min brightness, average max brightness,0)</a>
<span class="sourceLineNo">4869</span><a id="line.4869">     */</a>
<span class="sourceLineNo">4870</span><a id="line.4870">    public static Scalar estimateChessboardSharpness(Mat image, Size patternSize, Mat corners, float rise_distance, boolean vertical, Mat sharpness) {</a>
<span class="sourceLineNo">4871</span><a id="line.4871">        return new Scalar(estimateChessboardSharpness_0(image.nativeObj, patternSize.width, patternSize.height, corners.nativeObj, rise_distance, vertical, sharpness.nativeObj));</a>
<span class="sourceLineNo">4872</span><a id="line.4872">    }</a>
<span class="sourceLineNo">4873</span><a id="line.4873"></a>
<span class="sourceLineNo">4874</span><a id="line.4874">    /**</a>
<span class="sourceLineNo">4875</span><a id="line.4875">     * Estimates the sharpness of a detected chessboard.</a>
<span class="sourceLineNo">4876</span><a id="line.4876">     *</a>
<span class="sourceLineNo">4877</span><a id="line.4877">     * Image sharpness, as well as brightness, are a critical parameter for accuracte</a>
<span class="sourceLineNo">4878</span><a id="line.4878">     * camera calibration. For accessing these parameters for filtering out</a>
<span class="sourceLineNo">4879</span><a id="line.4879">     * problematic calibraiton images, this method calculates edge profiles by traveling from</a>
<span class="sourceLineNo">4880</span><a id="line.4880">     * black to white chessboard cell centers. Based on this, the number of pixels is</a>
<span class="sourceLineNo">4881</span><a id="line.4881">     * calculated required to transit from black to white. This width of the</a>
<span class="sourceLineNo">4882</span><a id="line.4882">     * transition area is a good indication of how sharp the chessboard is imaged</a>
<span class="sourceLineNo">4883</span><a id="line.4883">     * and should be below ~3.0 pixels.</a>
<span class="sourceLineNo">4884</span><a id="line.4884">     *</a>
<span class="sourceLineNo">4885</span><a id="line.4885">     * @param image Gray image used to find chessboard corners</a>
<span class="sourceLineNo">4886</span><a id="line.4886">     * @param patternSize Size of a found chessboard pattern</a>
<span class="sourceLineNo">4887</span><a id="line.4887">     * @param corners Corners found by findChessboardCorners(SB)</a>
<span class="sourceLineNo">4888</span><a id="line.4888">     * @param rise_distance Rise distance 0.8 means 10% ... 90% of the final signal strength</a>
<span class="sourceLineNo">4889</span><a id="line.4889">     * @param vertical By default edge responses for horizontal lines are calculated</a>
<span class="sourceLineNo">4890</span><a id="line.4890">     *</a>
<span class="sourceLineNo">4891</span><a id="line.4891">     * The optional sharpness array is of type CV_32FC1 and has for each calculated</a>
<span class="sourceLineNo">4892</span><a id="line.4892">     * profile one row with the following five entries:</a>
<span class="sourceLineNo">4893</span><a id="line.4893">     * 0 = x coordinate of the underlying edge in the image</a>
<span class="sourceLineNo">4894</span><a id="line.4894">     * 1 = y coordinate of the underlying edge in the image</a>
<span class="sourceLineNo">4895</span><a id="line.4895">     * 2 = width of the transition area (sharpness)</a>
<span class="sourceLineNo">4896</span><a id="line.4896">     * 3 = signal strength in the black cell (min brightness)</a>
<span class="sourceLineNo">4897</span><a id="line.4897">     * 4 = signal strength in the white cell (max brightness)</a>
<span class="sourceLineNo">4898</span><a id="line.4898">     *</a>
<span class="sourceLineNo">4899</span><a id="line.4899">     * @return Scalar(average sharpness, average min brightness, average max brightness,0)</a>
<span class="sourceLineNo">4900</span><a id="line.4900">     */</a>
<span class="sourceLineNo">4901</span><a id="line.4901">    public static Scalar estimateChessboardSharpness(Mat image, Size patternSize, Mat corners, float rise_distance, boolean vertical) {</a>
<span class="sourceLineNo">4902</span><a id="line.4902">        return new Scalar(estimateChessboardSharpness_1(image.nativeObj, patternSize.width, patternSize.height, corners.nativeObj, rise_distance, vertical));</a>
<span class="sourceLineNo">4903</span><a id="line.4903">    }</a>
<span class="sourceLineNo">4904</span><a id="line.4904"></a>
<span class="sourceLineNo">4905</span><a id="line.4905">    /**</a>
<span class="sourceLineNo">4906</span><a id="line.4906">     * Estimates the sharpness of a detected chessboard.</a>
<span class="sourceLineNo">4907</span><a id="line.4907">     *</a>
<span class="sourceLineNo">4908</span><a id="line.4908">     * Image sharpness, as well as brightness, are a critical parameter for accuracte</a>
<span class="sourceLineNo">4909</span><a id="line.4909">     * camera calibration. For accessing these parameters for filtering out</a>
<span class="sourceLineNo">4910</span><a id="line.4910">     * problematic calibraiton images, this method calculates edge profiles by traveling from</a>
<span class="sourceLineNo">4911</span><a id="line.4911">     * black to white chessboard cell centers. Based on this, the number of pixels is</a>
<span class="sourceLineNo">4912</span><a id="line.4912">     * calculated required to transit from black to white. This width of the</a>
<span class="sourceLineNo">4913</span><a id="line.4913">     * transition area is a good indication of how sharp the chessboard is imaged</a>
<span class="sourceLineNo">4914</span><a id="line.4914">     * and should be below ~3.0 pixels.</a>
<span class="sourceLineNo">4915</span><a id="line.4915">     *</a>
<span class="sourceLineNo">4916</span><a id="line.4916">     * @param image Gray image used to find chessboard corners</a>
<span class="sourceLineNo">4917</span><a id="line.4917">     * @param patternSize Size of a found chessboard pattern</a>
<span class="sourceLineNo">4918</span><a id="line.4918">     * @param corners Corners found by findChessboardCorners(SB)</a>
<span class="sourceLineNo">4919</span><a id="line.4919">     * @param rise_distance Rise distance 0.8 means 10% ... 90% of the final signal strength</a>
<span class="sourceLineNo">4920</span><a id="line.4920">     *</a>
<span class="sourceLineNo">4921</span><a id="line.4921">     * The optional sharpness array is of type CV_32FC1 and has for each calculated</a>
<span class="sourceLineNo">4922</span><a id="line.4922">     * profile one row with the following five entries:</a>
<span class="sourceLineNo">4923</span><a id="line.4923">     * 0 = x coordinate of the underlying edge in the image</a>
<span class="sourceLineNo">4924</span><a id="line.4924">     * 1 = y coordinate of the underlying edge in the image</a>
<span class="sourceLineNo">4925</span><a id="line.4925">     * 2 = width of the transition area (sharpness)</a>
<span class="sourceLineNo">4926</span><a id="line.4926">     * 3 = signal strength in the black cell (min brightness)</a>
<span class="sourceLineNo">4927</span><a id="line.4927">     * 4 = signal strength in the white cell (max brightness)</a>
<span class="sourceLineNo">4928</span><a id="line.4928">     *</a>
<span class="sourceLineNo">4929</span><a id="line.4929">     * @return Scalar(average sharpness, average min brightness, average max brightness,0)</a>
<span class="sourceLineNo">4930</span><a id="line.4930">     */</a>
<span class="sourceLineNo">4931</span><a id="line.4931">    public static Scalar estimateChessboardSharpness(Mat image, Size patternSize, Mat corners, float rise_distance) {</a>
<span class="sourceLineNo">4932</span><a id="line.4932">        return new Scalar(estimateChessboardSharpness_2(image.nativeObj, patternSize.width, patternSize.height, corners.nativeObj, rise_distance));</a>
<span class="sourceLineNo">4933</span><a id="line.4933">    }</a>
<span class="sourceLineNo">4934</span><a id="line.4934"></a>
<span class="sourceLineNo">4935</span><a id="line.4935">    /**</a>
<span class="sourceLineNo">4936</span><a id="line.4936">     * Estimates the sharpness of a detected chessboard.</a>
<span class="sourceLineNo">4937</span><a id="line.4937">     *</a>
<span class="sourceLineNo">4938</span><a id="line.4938">     * Image sharpness, as well as brightness, are a critical parameter for accuracte</a>
<span class="sourceLineNo">4939</span><a id="line.4939">     * camera calibration. For accessing these parameters for filtering out</a>
<span class="sourceLineNo">4940</span><a id="line.4940">     * problematic calibraiton images, this method calculates edge profiles by traveling from</a>
<span class="sourceLineNo">4941</span><a id="line.4941">     * black to white chessboard cell centers. Based on this, the number of pixels is</a>
<span class="sourceLineNo">4942</span><a id="line.4942">     * calculated required to transit from black to white. This width of the</a>
<span class="sourceLineNo">4943</span><a id="line.4943">     * transition area is a good indication of how sharp the chessboard is imaged</a>
<span class="sourceLineNo">4944</span><a id="line.4944">     * and should be below ~3.0 pixels.</a>
<span class="sourceLineNo">4945</span><a id="line.4945">     *</a>
<span class="sourceLineNo">4946</span><a id="line.4946">     * @param image Gray image used to find chessboard corners</a>
<span class="sourceLineNo">4947</span><a id="line.4947">     * @param patternSize Size of a found chessboard pattern</a>
<span class="sourceLineNo">4948</span><a id="line.4948">     * @param corners Corners found by findChessboardCorners(SB)</a>
<span class="sourceLineNo">4949</span><a id="line.4949">     *</a>
<span class="sourceLineNo">4950</span><a id="line.4950">     * The optional sharpness array is of type CV_32FC1 and has for each calculated</a>
<span class="sourceLineNo">4951</span><a id="line.4951">     * profile one row with the following five entries:</a>
<span class="sourceLineNo">4952</span><a id="line.4952">     * 0 = x coordinate of the underlying edge in the image</a>
<span class="sourceLineNo">4953</span><a id="line.4953">     * 1 = y coordinate of the underlying edge in the image</a>
<span class="sourceLineNo">4954</span><a id="line.4954">     * 2 = width of the transition area (sharpness)</a>
<span class="sourceLineNo">4955</span><a id="line.4955">     * 3 = signal strength in the black cell (min brightness)</a>
<span class="sourceLineNo">4956</span><a id="line.4956">     * 4 = signal strength in the white cell (max brightness)</a>
<span class="sourceLineNo">4957</span><a id="line.4957">     *</a>
<span class="sourceLineNo">4958</span><a id="line.4958">     * @return Scalar(average sharpness, average min brightness, average max brightness,0)</a>
<span class="sourceLineNo">4959</span><a id="line.4959">     */</a>
<span class="sourceLineNo">4960</span><a id="line.4960">    public static Scalar estimateChessboardSharpness(Mat image, Size patternSize, Mat corners) {</a>
<span class="sourceLineNo">4961</span><a id="line.4961">        return new Scalar(estimateChessboardSharpness_3(image.nativeObj, patternSize.width, patternSize.height, corners.nativeObj));</a>
<span class="sourceLineNo">4962</span><a id="line.4962">    }</a>
<span class="sourceLineNo">4963</span><a id="line.4963"></a>
<span class="sourceLineNo">4964</span><a id="line.4964"></a>
<span class="sourceLineNo">4965</span><a id="line.4965">    //</a>
<span class="sourceLineNo">4966</span><a id="line.4966">    // C++:  bool cv::find4QuadCornerSubpix(Mat img, Mat&amp; corners, Size region_size)</a>
<span class="sourceLineNo">4967</span><a id="line.4967">    //</a>
<span class="sourceLineNo">4968</span><a id="line.4968"></a>
<span class="sourceLineNo">4969</span><a id="line.4969">    public static boolean find4QuadCornerSubpix(Mat img, Mat corners, Size region_size) {</a>
<span class="sourceLineNo">4970</span><a id="line.4970">        return find4QuadCornerSubpix_0(img.nativeObj, corners.nativeObj, region_size.width, region_size.height);</a>
<span class="sourceLineNo">4971</span><a id="line.4971">    }</a>
<span class="sourceLineNo">4972</span><a id="line.4972"></a>
<span class="sourceLineNo">4973</span><a id="line.4973"></a>
<span class="sourceLineNo">4974</span><a id="line.4974">    //</a>
<span class="sourceLineNo">4975</span><a id="line.4975">    // C++:  void cv::drawChessboardCorners(Mat&amp; image, Size patternSize, vector_Point2f corners, bool patternWasFound)</a>
<span class="sourceLineNo">4976</span><a id="line.4976">    //</a>
<span class="sourceLineNo">4977</span><a id="line.4977"></a>
<span class="sourceLineNo">4978</span><a id="line.4978">    /**</a>
<span class="sourceLineNo">4979</span><a id="line.4979">     * Renders the detected chessboard corners.</a>
<span class="sourceLineNo">4980</span><a id="line.4980">     *</a>
<span class="sourceLineNo">4981</span><a id="line.4981">     * @param image Destination image. It must be an 8-bit color image.</a>
<span class="sourceLineNo">4982</span><a id="line.4982">     * @param patternSize Number of inner corners per a chessboard row and column</a>
<span class="sourceLineNo">4983</span><a id="line.4983">     * (patternSize = cv::Size(points_per_row,points_per_column)).</a>
<span class="sourceLineNo">4984</span><a id="line.4984">     * @param corners Array of detected corners, the output of findChessboardCorners.</a>
<span class="sourceLineNo">4985</span><a id="line.4985">     * @param patternWasFound Parameter indicating whether the complete board was found or not. The</a>
<span class="sourceLineNo">4986</span><a id="line.4986">     * return value of findChessboardCorners should be passed here.</a>
<span class="sourceLineNo">4987</span><a id="line.4987">     *</a>
<span class="sourceLineNo">4988</span><a id="line.4988">     * The function draws individual chessboard corners detected either as red circles if the board was not</a>
<span class="sourceLineNo">4989</span><a id="line.4989">     * found, or as colored corners connected with lines if the board was found.</a>
<span class="sourceLineNo">4990</span><a id="line.4990">     */</a>
<span class="sourceLineNo">4991</span><a id="line.4991">    public static void drawChessboardCorners(Mat image, Size patternSize, MatOfPoint2f corners, boolean patternWasFound) {</a>
<span class="sourceLineNo">4992</span><a id="line.4992">        Mat corners_mat = corners;</a>
<span class="sourceLineNo">4993</span><a id="line.4993">        drawChessboardCorners_0(image.nativeObj, patternSize.width, patternSize.height, corners_mat.nativeObj, patternWasFound);</a>
<span class="sourceLineNo">4994</span><a id="line.4994">    }</a>
<span class="sourceLineNo">4995</span><a id="line.4995"></a>
<span class="sourceLineNo">4996</span><a id="line.4996"></a>
<span class="sourceLineNo">4997</span><a id="line.4997">    //</a>
<span class="sourceLineNo">4998</span><a id="line.4998">    // C++:  void cv::drawFrameAxes(Mat&amp; image, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, float length, int thickness = 3)</a>
<span class="sourceLineNo">4999</span><a id="line.4999">    //</a>
<span class="sourceLineNo">5000</span><a id="line.5000"></a>
<span class="sourceLineNo">5001</span><a id="line.5001">    /**</a>
<span class="sourceLineNo">5002</span><a id="line.5002">     * Draw axes of the world/object coordinate system from pose estimation. SEE: solvePnP</a>
<span class="sourceLineNo">5003</span><a id="line.5003">     *</a>
<span class="sourceLineNo">5004</span><a id="line.5004">     * @param image Input/output image. It must have 1 or 3 channels. The number of channels is not altered.</a>
<span class="sourceLineNo">5005</span><a id="line.5005">     * @param cameraMatrix Input 3x3 floating-point matrix of camera intrinsic parameters.</a>
<span class="sourceLineNo">5006</span><a id="line.5006">     * \(\cameramatrix{A}\)</a>
<span class="sourceLineNo">5007</span><a id="line.5007">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">5008</span><a id="line.5008">     * \(\distcoeffs\). If the vector is empty, the zero distortion coefficients are assumed.</a>
<span class="sourceLineNo">5009</span><a id="line.5009">     * @param rvec Rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from</a>
<span class="sourceLineNo">5010</span><a id="line.5010">     * the model coordinate system to the camera coordinate system.</a>
<span class="sourceLineNo">5011</span><a id="line.5011">     * @param tvec Translation vector.</a>
<span class="sourceLineNo">5012</span><a id="line.5012">     * @param length Length of the painted axes in the same unit than tvec (usually in meters).</a>
<span class="sourceLineNo">5013</span><a id="line.5013">     * @param thickness Line thickness of the painted axes.</a>
<span class="sourceLineNo">5014</span><a id="line.5014">     *</a>
<span class="sourceLineNo">5015</span><a id="line.5015">     * This function draws the axes of the world/object coordinate system w.r.t. to the camera frame.</a>
<span class="sourceLineNo">5016</span><a id="line.5016">     * OX is drawn in red, OY in green and OZ in blue.</a>
<span class="sourceLineNo">5017</span><a id="line.5017">     */</a>
<span class="sourceLineNo">5018</span><a id="line.5018">    public static void drawFrameAxes(Mat image, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, float length, int thickness) {</a>
<span class="sourceLineNo">5019</span><a id="line.5019">        drawFrameAxes_0(image.nativeObj, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvec.nativeObj, tvec.nativeObj, length, thickness);</a>
<span class="sourceLineNo">5020</span><a id="line.5020">    }</a>
<span class="sourceLineNo">5021</span><a id="line.5021"></a>
<span class="sourceLineNo">5022</span><a id="line.5022">    /**</a>
<span class="sourceLineNo">5023</span><a id="line.5023">     * Draw axes of the world/object coordinate system from pose estimation. SEE: solvePnP</a>
<span class="sourceLineNo">5024</span><a id="line.5024">     *</a>
<span class="sourceLineNo">5025</span><a id="line.5025">     * @param image Input/output image. It must have 1 or 3 channels. The number of channels is not altered.</a>
<span class="sourceLineNo">5026</span><a id="line.5026">     * @param cameraMatrix Input 3x3 floating-point matrix of camera intrinsic parameters.</a>
<span class="sourceLineNo">5027</span><a id="line.5027">     * \(\cameramatrix{A}\)</a>
<span class="sourceLineNo">5028</span><a id="line.5028">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">5029</span><a id="line.5029">     * \(\distcoeffs\). If the vector is empty, the zero distortion coefficients are assumed.</a>
<span class="sourceLineNo">5030</span><a id="line.5030">     * @param rvec Rotation vector (see REF: Rodrigues ) that, together with tvec, brings points from</a>
<span class="sourceLineNo">5031</span><a id="line.5031">     * the model coordinate system to the camera coordinate system.</a>
<span class="sourceLineNo">5032</span><a id="line.5032">     * @param tvec Translation vector.</a>
<span class="sourceLineNo">5033</span><a id="line.5033">     * @param length Length of the painted axes in the same unit than tvec (usually in meters).</a>
<span class="sourceLineNo">5034</span><a id="line.5034">     *</a>
<span class="sourceLineNo">5035</span><a id="line.5035">     * This function draws the axes of the world/object coordinate system w.r.t. to the camera frame.</a>
<span class="sourceLineNo">5036</span><a id="line.5036">     * OX is drawn in red, OY in green and OZ in blue.</a>
<span class="sourceLineNo">5037</span><a id="line.5037">     */</a>
<span class="sourceLineNo">5038</span><a id="line.5038">    public static void drawFrameAxes(Mat image, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, float length) {</a>
<span class="sourceLineNo">5039</span><a id="line.5039">        drawFrameAxes_1(image.nativeObj, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvec.nativeObj, tvec.nativeObj, length);</a>
<span class="sourceLineNo">5040</span><a id="line.5040">    }</a>
<span class="sourceLineNo">5041</span><a id="line.5041"></a>
<span class="sourceLineNo">5042</span><a id="line.5042"></a>
<span class="sourceLineNo">5043</span><a id="line.5043">    //</a>
<span class="sourceLineNo">5044</span><a id="line.5044">    // C++:  bool cv::findCirclesGrid(Mat image, Size patternSize, Mat&amp; centers, int flags, Ptr_FeatureDetector blobDetector, CirclesGridFinderParameters parameters)</a>
<span class="sourceLineNo">5045</span><a id="line.5045">    //</a>
<span class="sourceLineNo">5046</span><a id="line.5046"></a>
<span class="sourceLineNo">5047</span><a id="line.5047">    // Unknown type 'Ptr_FeatureDetector' (I), skipping the function</a>
<span class="sourceLineNo">5048</span><a id="line.5048"></a>
<span class="sourceLineNo">5049</span><a id="line.5049"></a>
<span class="sourceLineNo">5050</span><a id="line.5050">    //</a>
<span class="sourceLineNo">5051</span><a id="line.5051">    // C++:  bool cv::findCirclesGrid(Mat image, Size patternSize, Mat&amp; centers, int flags = CALIB_CB_SYMMETRIC_GRID, Ptr_FeatureDetector blobDetector = SimpleBlobDetector::create())</a>
<span class="sourceLineNo">5052</span><a id="line.5052">    //</a>
<span class="sourceLineNo">5053</span><a id="line.5053"></a>
<span class="sourceLineNo">5054</span><a id="line.5054">    public static boolean findCirclesGrid(Mat image, Size patternSize, Mat centers, int flags) {</a>
<span class="sourceLineNo">5055</span><a id="line.5055">        return findCirclesGrid_0(image.nativeObj, patternSize.width, patternSize.height, centers.nativeObj, flags);</a>
<span class="sourceLineNo">5056</span><a id="line.5056">    }</a>
<span class="sourceLineNo">5057</span><a id="line.5057"></a>
<span class="sourceLineNo">5058</span><a id="line.5058">    public static boolean findCirclesGrid(Mat image, Size patternSize, Mat centers) {</a>
<span class="sourceLineNo">5059</span><a id="line.5059">        return findCirclesGrid_2(image.nativeObj, patternSize.width, patternSize.height, centers.nativeObj);</a>
<span class="sourceLineNo">5060</span><a id="line.5060">    }</a>
<span class="sourceLineNo">5061</span><a id="line.5061"></a>
<span class="sourceLineNo">5062</span><a id="line.5062"></a>
<span class="sourceLineNo">5063</span><a id="line.5063">    //</a>
<span class="sourceLineNo">5064</span><a id="line.5064">    // C++:  double cv::calibrateCamera(vector_Mat objectPoints, vector_Mat imagePoints, Size imageSize, Mat&amp; cameraMatrix, Mat&amp; distCoeffs, vector_Mat&amp; rvecs, vector_Mat&amp; tvecs, Mat&amp; stdDeviationsIntrinsics, Mat&amp; stdDeviationsExtrinsics, Mat&amp; perViewErrors, int flags = 0, TermCriteria criteria = TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON))</a>
<span class="sourceLineNo">5065</span><a id="line.5065">    //</a>
<span class="sourceLineNo">5066</span><a id="line.5066"></a>
<span class="sourceLineNo">5067</span><a id="line.5067">    /**</a>
<span class="sourceLineNo">5068</span><a id="line.5068">     * Finds the camera intrinsic and extrinsic parameters from several views of a calibration</a>
<span class="sourceLineNo">5069</span><a id="line.5069">     * pattern.</a>
<span class="sourceLineNo">5070</span><a id="line.5070">     *</a>
<span class="sourceLineNo">5071</span><a id="line.5071">     * @param objectPoints In the new interface it is a vector of vectors of calibration pattern points in</a>
<span class="sourceLineNo">5072</span><a id="line.5072">     * the calibration pattern coordinate space (e.g. std::vector&amp;lt;std::vector&amp;lt;cv::Vec3f&amp;gt;&amp;gt;). The outer</a>
<span class="sourceLineNo">5073</span><a id="line.5073">     * vector contains as many elements as the number of pattern views. If the same calibration pattern</a>
<span class="sourceLineNo">5074</span><a id="line.5074">     * is shown in each view and it is fully visible, all the vectors will be the same. Although, it is</a>
<span class="sourceLineNo">5075</span><a id="line.5075">     * possible to use partially occluded patterns or even different patterns in different views. Then,</a>
<span class="sourceLineNo">5076</span><a id="line.5076">     * the vectors will be different. Although the points are 3D, they all lie in the calibration pattern's</a>
<span class="sourceLineNo">5077</span><a id="line.5077">     * XY coordinate plane (thus 0 in the Z-coordinate), if the used calibration pattern is a planar rig.</a>
<span class="sourceLineNo">5078</span><a id="line.5078">     * In the old interface all the vectors of object points from different views are concatenated</a>
<span class="sourceLineNo">5079</span><a id="line.5079">     * together.</a>
<span class="sourceLineNo">5080</span><a id="line.5080">     * @param imagePoints In the new interface it is a vector of vectors of the projections of calibration</a>
<span class="sourceLineNo">5081</span><a id="line.5081">     * pattern points (e.g. std::vector&amp;lt;std::vector&amp;lt;cv::Vec2f&amp;gt;&amp;gt;). imagePoints.size() and</a>
<span class="sourceLineNo">5082</span><a id="line.5082">     * objectPoints.size(), and imagePoints[i].size() and objectPoints[i].size() for each i, must be equal,</a>
<span class="sourceLineNo">5083</span><a id="line.5083">     * respectively. In the old interface all the vectors of object points from different views are</a>
<span class="sourceLineNo">5084</span><a id="line.5084">     * concatenated together.</a>
<span class="sourceLineNo">5085</span><a id="line.5085">     * @param imageSize Size of the image used only to initialize the camera intrinsic matrix.</a>
<span class="sourceLineNo">5086</span><a id="line.5086">     * @param cameraMatrix Input/output 3x3 floating-point camera intrinsic matrix</a>
<span class="sourceLineNo">5087</span><a id="line.5087">     * \(\cameramatrix{A}\) . If REF: CALIB_USE_INTRINSIC_GUESS</a>
<span class="sourceLineNo">5088</span><a id="line.5088">     * and/or REF: CALIB_FIX_ASPECT_RATIO are specified, some or all of fx, fy, cx, cy must be</a>
<span class="sourceLineNo">5089</span><a id="line.5089">     * initialized before calling the function.</a>
<span class="sourceLineNo">5090</span><a id="line.5090">     * @param distCoeffs Input/output vector of distortion coefficients</a>
<span class="sourceLineNo">5091</span><a id="line.5091">     * \(\distcoeffs\).</a>
<span class="sourceLineNo">5092</span><a id="line.5092">     * @param rvecs Output vector of rotation vectors (REF: Rodrigues ) estimated for each pattern view</a>
<span class="sourceLineNo">5093</span><a id="line.5093">     * (e.g. std::vector&amp;lt;cv::Mat&amp;gt;&amp;gt;). That is, each i-th rotation vector together with the corresponding</a>
<span class="sourceLineNo">5094</span><a id="line.5094">     * i-th translation vector (see the next output parameter description) brings the calibration pattern</a>
<span class="sourceLineNo">5095</span><a id="line.5095">     * from the object coordinate space (in which object points are specified) to the camera coordinate</a>
<span class="sourceLineNo">5096</span><a id="line.5096">     * space. In more technical terms, the tuple of the i-th rotation and translation vector performs</a>
<span class="sourceLineNo">5097</span><a id="line.5097">     * a change of basis from object coordinate space to camera coordinate space. Due to its duality, this</a>
<span class="sourceLineNo">5098</span><a id="line.5098">     * tuple is equivalent to the position of the calibration pattern with respect to the camera coordinate</a>
<span class="sourceLineNo">5099</span><a id="line.5099">     * space.</a>
<span class="sourceLineNo">5100</span><a id="line.5100">     * @param tvecs Output vector of translation vectors estimated for each pattern view, see parameter</a>
<span class="sourceLineNo">5101</span><a id="line.5101">     * describtion above.</a>
<span class="sourceLineNo">5102</span><a id="line.5102">     * @param stdDeviationsIntrinsics Output vector of standard deviations estimated for intrinsic</a>
<span class="sourceLineNo">5103</span><a id="line.5103">     * parameters. Order of deviations values:</a>
<span class="sourceLineNo">5104</span><a id="line.5104">     * \((f_x, f_y, c_x, c_y, k_1, k_2, p_1, p_2, k_3, k_4, k_5, k_6 , s_1, s_2, s_3,</a>
<span class="sourceLineNo">5105</span><a id="line.5105">     *  s_4, \tau_x, \tau_y)\) If one of parameters is not estimated, it's deviation is equals to zero.</a>
<span class="sourceLineNo">5106</span><a id="line.5106">     * @param stdDeviationsExtrinsics Output vector of standard deviations estimated for extrinsic</a>
<span class="sourceLineNo">5107</span><a id="line.5107">     * parameters. Order of deviations values: \((R_0, T_0, \dotsc , R_{M - 1}, T_{M - 1})\) where M is</a>
<span class="sourceLineNo">5108</span><a id="line.5108">     * the number of pattern views. \(R_i, T_i\) are concatenated 1x3 vectors.</a>
<span class="sourceLineNo">5109</span><a id="line.5109">     *  @param perViewErrors Output vector of the RMS re-projection error estimated for each pattern view.</a>
<span class="sourceLineNo">5110</span><a id="line.5110">     * @param flags Different flags that may be zero or a combination of the following values:</a>
<span class="sourceLineNo">5111</span><a id="line.5111">     * &lt;ul&gt;</a>
<span class="sourceLineNo">5112</span><a id="line.5112">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5113</span><a id="line.5113">     *    REF: CALIB_USE_INTRINSIC_GUESS cameraMatrix contains valid initial values of</a>
<span class="sourceLineNo">5114</span><a id="line.5114">     * fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image</a>
<span class="sourceLineNo">5115</span><a id="line.5115">     * center ( imageSize is used), and focal distances are computed in a least-squares fashion.</a>
<span class="sourceLineNo">5116</span><a id="line.5116">     * Note, that if intrinsic parameters are known, there is no need to use this function just to</a>
<span class="sourceLineNo">5117</span><a id="line.5117">     * estimate extrinsic parameters. Use solvePnP instead.</a>
<span class="sourceLineNo">5118</span><a id="line.5118">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5119</span><a id="line.5119">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5120</span><a id="line.5120">     *    REF: CALIB_FIX_PRINCIPAL_POINT The principal point is not changed during the global</a>
<span class="sourceLineNo">5121</span><a id="line.5121">     * optimization. It stays at the center or at a different location specified when</a>
<span class="sourceLineNo">5122</span><a id="line.5122">     *  REF: CALIB_USE_INTRINSIC_GUESS is set too.</a>
<span class="sourceLineNo">5123</span><a id="line.5123">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5124</span><a id="line.5124">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5125</span><a id="line.5125">     *    REF: CALIB_FIX_ASPECT_RATIO The functions consider only fy as a free parameter. The</a>
<span class="sourceLineNo">5126</span><a id="line.5126">     * ratio fx/fy stays the same as in the input cameraMatrix . When</a>
<span class="sourceLineNo">5127</span><a id="line.5127">     *  REF: CALIB_USE_INTRINSIC_GUESS is not set, the actual input values of fx and fy are</a>
<span class="sourceLineNo">5128</span><a id="line.5128">     * ignored, only their ratio is computed and used further.</a>
<span class="sourceLineNo">5129</span><a id="line.5129">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5130</span><a id="line.5130">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5131</span><a id="line.5131">     *    REF: CALIB_ZERO_TANGENT_DIST Tangential distortion coefficients \((p_1, p_2)\) are set</a>
<span class="sourceLineNo">5132</span><a id="line.5132">     * to zeros and stay zero.</a>
<span class="sourceLineNo">5133</span><a id="line.5133">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5134</span><a id="line.5134">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5135</span><a id="line.5135">     *    REF: CALIB_FIX_K1,..., REF: CALIB_FIX_K6 The corresponding radial distortion</a>
<span class="sourceLineNo">5136</span><a id="line.5136">     * coefficient is not changed during the optimization. If REF: CALIB_USE_INTRINSIC_GUESS is</a>
<span class="sourceLineNo">5137</span><a id="line.5137">     * set, the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0.</a>
<span class="sourceLineNo">5138</span><a id="line.5138">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5139</span><a id="line.5139">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5140</span><a id="line.5140">     *    REF: CALIB_RATIONAL_MODEL Coefficients k4, k5, and k6 are enabled. To provide the</a>
<span class="sourceLineNo">5141</span><a id="line.5141">     * backward compatibility, this extra flag should be explicitly specified to make the</a>
<span class="sourceLineNo">5142</span><a id="line.5142">     * calibration function use the rational model and return 8 coefficients. If the flag is not</a>
<span class="sourceLineNo">5143</span><a id="line.5143">     * set, the function computes and returns only 5 distortion coefficients.</a>
<span class="sourceLineNo">5144</span><a id="line.5144">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5145</span><a id="line.5145">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5146</span><a id="line.5146">     *    REF: CALIB_THIN_PRISM_MODEL Coefficients s1, s2, s3 and s4 are enabled. To provide the</a>
<span class="sourceLineNo">5147</span><a id="line.5147">     * backward compatibility, this extra flag should be explicitly specified to make the</a>
<span class="sourceLineNo">5148</span><a id="line.5148">     * calibration function use the thin prism model and return 12 coefficients. If the flag is not</a>
<span class="sourceLineNo">5149</span><a id="line.5149">     * set, the function computes and returns only 5 distortion coefficients.</a>
<span class="sourceLineNo">5150</span><a id="line.5150">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5151</span><a id="line.5151">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5152</span><a id="line.5152">     *    REF: CALIB_FIX_S1_S2_S3_S4 The thin prism distortion coefficients are not changed during</a>
<span class="sourceLineNo">5153</span><a id="line.5153">     * the optimization. If REF: CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the</a>
<span class="sourceLineNo">5154</span><a id="line.5154">     * supplied distCoeffs matrix is used. Otherwise, it is set to 0.</a>
<span class="sourceLineNo">5155</span><a id="line.5155">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5156</span><a id="line.5156">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5157</span><a id="line.5157">     *    REF: CALIB_TILTED_MODEL Coefficients tauX and tauY are enabled. To provide the</a>
<span class="sourceLineNo">5158</span><a id="line.5158">     * backward compatibility, this extra flag should be explicitly specified to make the</a>
<span class="sourceLineNo">5159</span><a id="line.5159">     * calibration function use the tilted sensor model and return 14 coefficients. If the flag is not</a>
<span class="sourceLineNo">5160</span><a id="line.5160">     * set, the function computes and returns only 5 distortion coefficients.</a>
<span class="sourceLineNo">5161</span><a id="line.5161">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5162</span><a id="line.5162">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5163</span><a id="line.5163">     *    REF: CALIB_FIX_TAUX_TAUY The coefficients of the tilted sensor model are not changed during</a>
<span class="sourceLineNo">5164</span><a id="line.5164">     * the optimization. If REF: CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the</a>
<span class="sourceLineNo">5165</span><a id="line.5165">     * supplied distCoeffs matrix is used. Otherwise, it is set to 0.</a>
<span class="sourceLineNo">5166</span><a id="line.5166">     * @param criteria Termination criteria for the iterative optimization algorithm.</a>
<span class="sourceLineNo">5167</span><a id="line.5167">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5168</span><a id="line.5168">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">5169</span><a id="line.5169">     *</a>
<span class="sourceLineNo">5170</span><a id="line.5170">     * @return the overall RMS re-projection error.</a>
<span class="sourceLineNo">5171</span><a id="line.5171">     *</a>
<span class="sourceLineNo">5172</span><a id="line.5172">     * The function estimates the intrinsic camera parameters and extrinsic parameters for each of the</a>
<span class="sourceLineNo">5173</span><a id="line.5173">     * views. The algorithm is based on CITE: Zhang2000 and CITE: BouguetMCT . The coordinates of 3D object</a>
<span class="sourceLineNo">5174</span><a id="line.5174">     * points and their corresponding 2D projections in each view must be specified. That may be achieved</a>
<span class="sourceLineNo">5175</span><a id="line.5175">     * by using an object with known geometry and easily detectable feature points. Such an object is</a>
<span class="sourceLineNo">5176</span><a id="line.5176">     * called a calibration rig or calibration pattern, and OpenCV has built-in support for a chessboard as</a>
<span class="sourceLineNo">5177</span><a id="line.5177">     * a calibration rig (see REF: findChessboardCorners). Currently, initialization of intrinsic</a>
<span class="sourceLineNo">5178</span><a id="line.5178">     * parameters (when REF: CALIB_USE_INTRINSIC_GUESS is not set) is only implemented for planar calibration</a>
<span class="sourceLineNo">5179</span><a id="line.5179">     * patterns (where Z-coordinates of the object points must be all zeros). 3D calibration rigs can also</a>
<span class="sourceLineNo">5180</span><a id="line.5180">     * be used as long as initial cameraMatrix is provided.</a>
<span class="sourceLineNo">5181</span><a id="line.5181">     *</a>
<span class="sourceLineNo">5182</span><a id="line.5182">     * The algorithm performs the following steps:</a>
<span class="sourceLineNo">5183</span><a id="line.5183">     *</a>
<span class="sourceLineNo">5184</span><a id="line.5184">     * &lt;ul&gt;</a>
<span class="sourceLineNo">5185</span><a id="line.5185">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5186</span><a id="line.5186">     *    Compute the initial intrinsic parameters (the option only available for planar calibration</a>
<span class="sourceLineNo">5187</span><a id="line.5187">     *     patterns) or read them from the input parameters. The distortion coefficients are all set to</a>
<span class="sourceLineNo">5188</span><a id="line.5188">     *     zeros initially unless some of CALIB_FIX_K? are specified.</a>
<span class="sourceLineNo">5189</span><a id="line.5189">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5190</span><a id="line.5190">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">5191</span><a id="line.5191">     *</a>
<span class="sourceLineNo">5192</span><a id="line.5192">     * &lt;ul&gt;</a>
<span class="sourceLineNo">5193</span><a id="line.5193">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5194</span><a id="line.5194">     *    Estimate the initial camera pose as if the intrinsic parameters have been already known. This is</a>
<span class="sourceLineNo">5195</span><a id="line.5195">     *     done using solvePnP .</a>
<span class="sourceLineNo">5196</span><a id="line.5196">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5197</span><a id="line.5197">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">5198</span><a id="line.5198">     *</a>
<span class="sourceLineNo">5199</span><a id="line.5199">     * &lt;ul&gt;</a>
<span class="sourceLineNo">5200</span><a id="line.5200">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5201</span><a id="line.5201">     *    Run the global Levenberg-Marquardt optimization algorithm to minimize the reprojection error,</a>
<span class="sourceLineNo">5202</span><a id="line.5202">     *     that is, the total sum of squared distances between the observed feature points imagePoints and</a>
<span class="sourceLineNo">5203</span><a id="line.5203">     *     the projected (using the current estimates for camera parameters and the poses) object points</a>
<span class="sourceLineNo">5204</span><a id="line.5204">     *     objectPoints. See projectPoints for details.</a>
<span class="sourceLineNo">5205</span><a id="line.5205">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5206</span><a id="line.5206">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">5207</span><a id="line.5207">     *</a>
<span class="sourceLineNo">5208</span><a id="line.5208">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">5209</span><a id="line.5209">     *     If you use a non-square (i.e. non-N-by-N) grid and REF: findChessboardCorners for calibration,</a>
<span class="sourceLineNo">5210</span><a id="line.5210">     *     and REF: calibrateCamera returns bad values (zero distortion coefficients, \(c_x\) and</a>
<span class="sourceLineNo">5211</span><a id="line.5211">     *     \(c_y\) very far from the image center, and/or large differences between \(f_x\) and</a>
<span class="sourceLineNo">5212</span><a id="line.5212">     *     \(f_y\) (ratios of 10:1 or more)), then you are probably using patternSize=cvSize(rows,cols)</a>
<span class="sourceLineNo">5213</span><a id="line.5213">     *     instead of using patternSize=cvSize(cols,rows) in REF: findChessboardCorners.</a>
<span class="sourceLineNo">5214</span><a id="line.5214">     *</a>
<span class="sourceLineNo">5215</span><a id="line.5215">     * SEE:</a>
<span class="sourceLineNo">5216</span><a id="line.5216">     *    calibrateCameraRO, findChessboardCorners, solvePnP, initCameraMatrix2D, stereoCalibrate,</a>
<span class="sourceLineNo">5217</span><a id="line.5217">     *    undistort</a>
<span class="sourceLineNo">5218</span><a id="line.5218">     */</a>
<span class="sourceLineNo">5219</span><a id="line.5219">    public static double calibrateCameraExtended(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List&lt;Mat&gt; rvecs, List&lt;Mat&gt; tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors, int flags, TermCriteria criteria) {</a>
<span class="sourceLineNo">5220</span><a id="line.5220">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">5221</span><a id="line.5221">        Mat imagePoints_mat = Converters.vector_Mat_to_Mat(imagePoints);</a>
<span class="sourceLineNo">5222</span><a id="line.5222">        Mat rvecs_mat = new Mat();</a>
<span class="sourceLineNo">5223</span><a id="line.5223">        Mat tvecs_mat = new Mat();</a>
<span class="sourceLineNo">5224</span><a id="line.5224">        double retVal = calibrateCameraExtended_0(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, imageSize.width, imageSize.height, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvecs_mat.nativeObj, tvecs_mat.nativeObj, stdDeviationsIntrinsics.nativeObj, stdDeviationsExtrinsics.nativeObj, perViewErrors.nativeObj, flags, criteria.type, criteria.maxCount, criteria.epsilon);</a>
<span class="sourceLineNo">5225</span><a id="line.5225">        Converters.Mat_to_vector_Mat(rvecs_mat, rvecs);</a>
<span class="sourceLineNo">5226</span><a id="line.5226">        rvecs_mat.release();</a>
<span class="sourceLineNo">5227</span><a id="line.5227">        Converters.Mat_to_vector_Mat(tvecs_mat, tvecs);</a>
<span class="sourceLineNo">5228</span><a id="line.5228">        tvecs_mat.release();</a>
<span class="sourceLineNo">5229</span><a id="line.5229">        return retVal;</a>
<span class="sourceLineNo">5230</span><a id="line.5230">    }</a>
<span class="sourceLineNo">5231</span><a id="line.5231"></a>
<span class="sourceLineNo">5232</span><a id="line.5232">    /**</a>
<span class="sourceLineNo">5233</span><a id="line.5233">     * Finds the camera intrinsic and extrinsic parameters from several views of a calibration</a>
<span class="sourceLineNo">5234</span><a id="line.5234">     * pattern.</a>
<span class="sourceLineNo">5235</span><a id="line.5235">     *</a>
<span class="sourceLineNo">5236</span><a id="line.5236">     * @param objectPoints In the new interface it is a vector of vectors of calibration pattern points in</a>
<span class="sourceLineNo">5237</span><a id="line.5237">     * the calibration pattern coordinate space (e.g. std::vector&amp;lt;std::vector&amp;lt;cv::Vec3f&amp;gt;&amp;gt;). The outer</a>
<span class="sourceLineNo">5238</span><a id="line.5238">     * vector contains as many elements as the number of pattern views. If the same calibration pattern</a>
<span class="sourceLineNo">5239</span><a id="line.5239">     * is shown in each view and it is fully visible, all the vectors will be the same. Although, it is</a>
<span class="sourceLineNo">5240</span><a id="line.5240">     * possible to use partially occluded patterns or even different patterns in different views. Then,</a>
<span class="sourceLineNo">5241</span><a id="line.5241">     * the vectors will be different. Although the points are 3D, they all lie in the calibration pattern's</a>
<span class="sourceLineNo">5242</span><a id="line.5242">     * XY coordinate plane (thus 0 in the Z-coordinate), if the used calibration pattern is a planar rig.</a>
<span class="sourceLineNo">5243</span><a id="line.5243">     * In the old interface all the vectors of object points from different views are concatenated</a>
<span class="sourceLineNo">5244</span><a id="line.5244">     * together.</a>
<span class="sourceLineNo">5245</span><a id="line.5245">     * @param imagePoints In the new interface it is a vector of vectors of the projections of calibration</a>
<span class="sourceLineNo">5246</span><a id="line.5246">     * pattern points (e.g. std::vector&amp;lt;std::vector&amp;lt;cv::Vec2f&amp;gt;&amp;gt;). imagePoints.size() and</a>
<span class="sourceLineNo">5247</span><a id="line.5247">     * objectPoints.size(), and imagePoints[i].size() and objectPoints[i].size() for each i, must be equal,</a>
<span class="sourceLineNo">5248</span><a id="line.5248">     * respectively. In the old interface all the vectors of object points from different views are</a>
<span class="sourceLineNo">5249</span><a id="line.5249">     * concatenated together.</a>
<span class="sourceLineNo">5250</span><a id="line.5250">     * @param imageSize Size of the image used only to initialize the camera intrinsic matrix.</a>
<span class="sourceLineNo">5251</span><a id="line.5251">     * @param cameraMatrix Input/output 3x3 floating-point camera intrinsic matrix</a>
<span class="sourceLineNo">5252</span><a id="line.5252">     * \(\cameramatrix{A}\) . If REF: CALIB_USE_INTRINSIC_GUESS</a>
<span class="sourceLineNo">5253</span><a id="line.5253">     * and/or REF: CALIB_FIX_ASPECT_RATIO are specified, some or all of fx, fy, cx, cy must be</a>
<span class="sourceLineNo">5254</span><a id="line.5254">     * initialized before calling the function.</a>
<span class="sourceLineNo">5255</span><a id="line.5255">     * @param distCoeffs Input/output vector of distortion coefficients</a>
<span class="sourceLineNo">5256</span><a id="line.5256">     * \(\distcoeffs\).</a>
<span class="sourceLineNo">5257</span><a id="line.5257">     * @param rvecs Output vector of rotation vectors (REF: Rodrigues ) estimated for each pattern view</a>
<span class="sourceLineNo">5258</span><a id="line.5258">     * (e.g. std::vector&amp;lt;cv::Mat&amp;gt;&amp;gt;). That is, each i-th rotation vector together with the corresponding</a>
<span class="sourceLineNo">5259</span><a id="line.5259">     * i-th translation vector (see the next output parameter description) brings the calibration pattern</a>
<span class="sourceLineNo">5260</span><a id="line.5260">     * from the object coordinate space (in which object points are specified) to the camera coordinate</a>
<span class="sourceLineNo">5261</span><a id="line.5261">     * space. In more technical terms, the tuple of the i-th rotation and translation vector performs</a>
<span class="sourceLineNo">5262</span><a id="line.5262">     * a change of basis from object coordinate space to camera coordinate space. Due to its duality, this</a>
<span class="sourceLineNo">5263</span><a id="line.5263">     * tuple is equivalent to the position of the calibration pattern with respect to the camera coordinate</a>
<span class="sourceLineNo">5264</span><a id="line.5264">     * space.</a>
<span class="sourceLineNo">5265</span><a id="line.5265">     * @param tvecs Output vector of translation vectors estimated for each pattern view, see parameter</a>
<span class="sourceLineNo">5266</span><a id="line.5266">     * describtion above.</a>
<span class="sourceLineNo">5267</span><a id="line.5267">     * @param stdDeviationsIntrinsics Output vector of standard deviations estimated for intrinsic</a>
<span class="sourceLineNo">5268</span><a id="line.5268">     * parameters. Order of deviations values:</a>
<span class="sourceLineNo">5269</span><a id="line.5269">     * \((f_x, f_y, c_x, c_y, k_1, k_2, p_1, p_2, k_3, k_4, k_5, k_6 , s_1, s_2, s_3,</a>
<span class="sourceLineNo">5270</span><a id="line.5270">     *  s_4, \tau_x, \tau_y)\) If one of parameters is not estimated, it's deviation is equals to zero.</a>
<span class="sourceLineNo">5271</span><a id="line.5271">     * @param stdDeviationsExtrinsics Output vector of standard deviations estimated for extrinsic</a>
<span class="sourceLineNo">5272</span><a id="line.5272">     * parameters. Order of deviations values: \((R_0, T_0, \dotsc , R_{M - 1}, T_{M - 1})\) where M is</a>
<span class="sourceLineNo">5273</span><a id="line.5273">     * the number of pattern views. \(R_i, T_i\) are concatenated 1x3 vectors.</a>
<span class="sourceLineNo">5274</span><a id="line.5274">     *  @param perViewErrors Output vector of the RMS re-projection error estimated for each pattern view.</a>
<span class="sourceLineNo">5275</span><a id="line.5275">     * @param flags Different flags that may be zero or a combination of the following values:</a>
<span class="sourceLineNo">5276</span><a id="line.5276">     * &lt;ul&gt;</a>
<span class="sourceLineNo">5277</span><a id="line.5277">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5278</span><a id="line.5278">     *    REF: CALIB_USE_INTRINSIC_GUESS cameraMatrix contains valid initial values of</a>
<span class="sourceLineNo">5279</span><a id="line.5279">     * fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image</a>
<span class="sourceLineNo">5280</span><a id="line.5280">     * center ( imageSize is used), and focal distances are computed in a least-squares fashion.</a>
<span class="sourceLineNo">5281</span><a id="line.5281">     * Note, that if intrinsic parameters are known, there is no need to use this function just to</a>
<span class="sourceLineNo">5282</span><a id="line.5282">     * estimate extrinsic parameters. Use solvePnP instead.</a>
<span class="sourceLineNo">5283</span><a id="line.5283">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5284</span><a id="line.5284">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5285</span><a id="line.5285">     *    REF: CALIB_FIX_PRINCIPAL_POINT The principal point is not changed during the global</a>
<span class="sourceLineNo">5286</span><a id="line.5286">     * optimization. It stays at the center or at a different location specified when</a>
<span class="sourceLineNo">5287</span><a id="line.5287">     *  REF: CALIB_USE_INTRINSIC_GUESS is set too.</a>
<span class="sourceLineNo">5288</span><a id="line.5288">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5289</span><a id="line.5289">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5290</span><a id="line.5290">     *    REF: CALIB_FIX_ASPECT_RATIO The functions consider only fy as a free parameter. The</a>
<span class="sourceLineNo">5291</span><a id="line.5291">     * ratio fx/fy stays the same as in the input cameraMatrix . When</a>
<span class="sourceLineNo">5292</span><a id="line.5292">     *  REF: CALIB_USE_INTRINSIC_GUESS is not set, the actual input values of fx and fy are</a>
<span class="sourceLineNo">5293</span><a id="line.5293">     * ignored, only their ratio is computed and used further.</a>
<span class="sourceLineNo">5294</span><a id="line.5294">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5295</span><a id="line.5295">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5296</span><a id="line.5296">     *    REF: CALIB_ZERO_TANGENT_DIST Tangential distortion coefficients \((p_1, p_2)\) are set</a>
<span class="sourceLineNo">5297</span><a id="line.5297">     * to zeros and stay zero.</a>
<span class="sourceLineNo">5298</span><a id="line.5298">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5299</span><a id="line.5299">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5300</span><a id="line.5300">     *    REF: CALIB_FIX_K1,..., REF: CALIB_FIX_K6 The corresponding radial distortion</a>
<span class="sourceLineNo">5301</span><a id="line.5301">     * coefficient is not changed during the optimization. If REF: CALIB_USE_INTRINSIC_GUESS is</a>
<span class="sourceLineNo">5302</span><a id="line.5302">     * set, the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0.</a>
<span class="sourceLineNo">5303</span><a id="line.5303">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5304</span><a id="line.5304">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5305</span><a id="line.5305">     *    REF: CALIB_RATIONAL_MODEL Coefficients k4, k5, and k6 are enabled. To provide the</a>
<span class="sourceLineNo">5306</span><a id="line.5306">     * backward compatibility, this extra flag should be explicitly specified to make the</a>
<span class="sourceLineNo">5307</span><a id="line.5307">     * calibration function use the rational model and return 8 coefficients. If the flag is not</a>
<span class="sourceLineNo">5308</span><a id="line.5308">     * set, the function computes and returns only 5 distortion coefficients.</a>
<span class="sourceLineNo">5309</span><a id="line.5309">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5310</span><a id="line.5310">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5311</span><a id="line.5311">     *    REF: CALIB_THIN_PRISM_MODEL Coefficients s1, s2, s3 and s4 are enabled. To provide the</a>
<span class="sourceLineNo">5312</span><a id="line.5312">     * backward compatibility, this extra flag should be explicitly specified to make the</a>
<span class="sourceLineNo">5313</span><a id="line.5313">     * calibration function use the thin prism model and return 12 coefficients. If the flag is not</a>
<span class="sourceLineNo">5314</span><a id="line.5314">     * set, the function computes and returns only 5 distortion coefficients.</a>
<span class="sourceLineNo">5315</span><a id="line.5315">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5316</span><a id="line.5316">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5317</span><a id="line.5317">     *    REF: CALIB_FIX_S1_S2_S3_S4 The thin prism distortion coefficients are not changed during</a>
<span class="sourceLineNo">5318</span><a id="line.5318">     * the optimization. If REF: CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the</a>
<span class="sourceLineNo">5319</span><a id="line.5319">     * supplied distCoeffs matrix is used. Otherwise, it is set to 0.</a>
<span class="sourceLineNo">5320</span><a id="line.5320">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5321</span><a id="line.5321">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5322</span><a id="line.5322">     *    REF: CALIB_TILTED_MODEL Coefficients tauX and tauY are enabled. To provide the</a>
<span class="sourceLineNo">5323</span><a id="line.5323">     * backward compatibility, this extra flag should be explicitly specified to make the</a>
<span class="sourceLineNo">5324</span><a id="line.5324">     * calibration function use the tilted sensor model and return 14 coefficients. If the flag is not</a>
<span class="sourceLineNo">5325</span><a id="line.5325">     * set, the function computes and returns only 5 distortion coefficients.</a>
<span class="sourceLineNo">5326</span><a id="line.5326">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5327</span><a id="line.5327">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5328</span><a id="line.5328">     *    REF: CALIB_FIX_TAUX_TAUY The coefficients of the tilted sensor model are not changed during</a>
<span class="sourceLineNo">5329</span><a id="line.5329">     * the optimization. If REF: CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the</a>
<span class="sourceLineNo">5330</span><a id="line.5330">     * supplied distCoeffs matrix is used. Otherwise, it is set to 0.</a>
<span class="sourceLineNo">5331</span><a id="line.5331">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5332</span><a id="line.5332">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">5333</span><a id="line.5333">     *</a>
<span class="sourceLineNo">5334</span><a id="line.5334">     * @return the overall RMS re-projection error.</a>
<span class="sourceLineNo">5335</span><a id="line.5335">     *</a>
<span class="sourceLineNo">5336</span><a id="line.5336">     * The function estimates the intrinsic camera parameters and extrinsic parameters for each of the</a>
<span class="sourceLineNo">5337</span><a id="line.5337">     * views. The algorithm is based on CITE: Zhang2000 and CITE: BouguetMCT . The coordinates of 3D object</a>
<span class="sourceLineNo">5338</span><a id="line.5338">     * points and their corresponding 2D projections in each view must be specified. That may be achieved</a>
<span class="sourceLineNo">5339</span><a id="line.5339">     * by using an object with known geometry and easily detectable feature points. Such an object is</a>
<span class="sourceLineNo">5340</span><a id="line.5340">     * called a calibration rig or calibration pattern, and OpenCV has built-in support for a chessboard as</a>
<span class="sourceLineNo">5341</span><a id="line.5341">     * a calibration rig (see REF: findChessboardCorners). Currently, initialization of intrinsic</a>
<span class="sourceLineNo">5342</span><a id="line.5342">     * parameters (when REF: CALIB_USE_INTRINSIC_GUESS is not set) is only implemented for planar calibration</a>
<span class="sourceLineNo">5343</span><a id="line.5343">     * patterns (where Z-coordinates of the object points must be all zeros). 3D calibration rigs can also</a>
<span class="sourceLineNo">5344</span><a id="line.5344">     * be used as long as initial cameraMatrix is provided.</a>
<span class="sourceLineNo">5345</span><a id="line.5345">     *</a>
<span class="sourceLineNo">5346</span><a id="line.5346">     * The algorithm performs the following steps:</a>
<span class="sourceLineNo">5347</span><a id="line.5347">     *</a>
<span class="sourceLineNo">5348</span><a id="line.5348">     * &lt;ul&gt;</a>
<span class="sourceLineNo">5349</span><a id="line.5349">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5350</span><a id="line.5350">     *    Compute the initial intrinsic parameters (the option only available for planar calibration</a>
<span class="sourceLineNo">5351</span><a id="line.5351">     *     patterns) or read them from the input parameters. The distortion coefficients are all set to</a>
<span class="sourceLineNo">5352</span><a id="line.5352">     *     zeros initially unless some of CALIB_FIX_K? are specified.</a>
<span class="sourceLineNo">5353</span><a id="line.5353">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5354</span><a id="line.5354">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">5355</span><a id="line.5355">     *</a>
<span class="sourceLineNo">5356</span><a id="line.5356">     * &lt;ul&gt;</a>
<span class="sourceLineNo">5357</span><a id="line.5357">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5358</span><a id="line.5358">     *    Estimate the initial camera pose as if the intrinsic parameters have been already known. This is</a>
<span class="sourceLineNo">5359</span><a id="line.5359">     *     done using solvePnP .</a>
<span class="sourceLineNo">5360</span><a id="line.5360">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5361</span><a id="line.5361">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">5362</span><a id="line.5362">     *</a>
<span class="sourceLineNo">5363</span><a id="line.5363">     * &lt;ul&gt;</a>
<span class="sourceLineNo">5364</span><a id="line.5364">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5365</span><a id="line.5365">     *    Run the global Levenberg-Marquardt optimization algorithm to minimize the reprojection error,</a>
<span class="sourceLineNo">5366</span><a id="line.5366">     *     that is, the total sum of squared distances between the observed feature points imagePoints and</a>
<span class="sourceLineNo">5367</span><a id="line.5367">     *     the projected (using the current estimates for camera parameters and the poses) object points</a>
<span class="sourceLineNo">5368</span><a id="line.5368">     *     objectPoints. See projectPoints for details.</a>
<span class="sourceLineNo">5369</span><a id="line.5369">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5370</span><a id="line.5370">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">5371</span><a id="line.5371">     *</a>
<span class="sourceLineNo">5372</span><a id="line.5372">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">5373</span><a id="line.5373">     *     If you use a non-square (i.e. non-N-by-N) grid and REF: findChessboardCorners for calibration,</a>
<span class="sourceLineNo">5374</span><a id="line.5374">     *     and REF: calibrateCamera returns bad values (zero distortion coefficients, \(c_x\) and</a>
<span class="sourceLineNo">5375</span><a id="line.5375">     *     \(c_y\) very far from the image center, and/or large differences between \(f_x\) and</a>
<span class="sourceLineNo">5376</span><a id="line.5376">     *     \(f_y\) (ratios of 10:1 or more)), then you are probably using patternSize=cvSize(rows,cols)</a>
<span class="sourceLineNo">5377</span><a id="line.5377">     *     instead of using patternSize=cvSize(cols,rows) in REF: findChessboardCorners.</a>
<span class="sourceLineNo">5378</span><a id="line.5378">     *</a>
<span class="sourceLineNo">5379</span><a id="line.5379">     * SEE:</a>
<span class="sourceLineNo">5380</span><a id="line.5380">     *    calibrateCameraRO, findChessboardCorners, solvePnP, initCameraMatrix2D, stereoCalibrate,</a>
<span class="sourceLineNo">5381</span><a id="line.5381">     *    undistort</a>
<span class="sourceLineNo">5382</span><a id="line.5382">     */</a>
<span class="sourceLineNo">5383</span><a id="line.5383">    public static double calibrateCameraExtended(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List&lt;Mat&gt; rvecs, List&lt;Mat&gt; tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors, int flags) {</a>
<span class="sourceLineNo">5384</span><a id="line.5384">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">5385</span><a id="line.5385">        Mat imagePoints_mat = Converters.vector_Mat_to_Mat(imagePoints);</a>
<span class="sourceLineNo">5386</span><a id="line.5386">        Mat rvecs_mat = new Mat();</a>
<span class="sourceLineNo">5387</span><a id="line.5387">        Mat tvecs_mat = new Mat();</a>
<span class="sourceLineNo">5388</span><a id="line.5388">        double retVal = calibrateCameraExtended_1(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, imageSize.width, imageSize.height, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvecs_mat.nativeObj, tvecs_mat.nativeObj, stdDeviationsIntrinsics.nativeObj, stdDeviationsExtrinsics.nativeObj, perViewErrors.nativeObj, flags);</a>
<span class="sourceLineNo">5389</span><a id="line.5389">        Converters.Mat_to_vector_Mat(rvecs_mat, rvecs);</a>
<span class="sourceLineNo">5390</span><a id="line.5390">        rvecs_mat.release();</a>
<span class="sourceLineNo">5391</span><a id="line.5391">        Converters.Mat_to_vector_Mat(tvecs_mat, tvecs);</a>
<span class="sourceLineNo">5392</span><a id="line.5392">        tvecs_mat.release();</a>
<span class="sourceLineNo">5393</span><a id="line.5393">        return retVal;</a>
<span class="sourceLineNo">5394</span><a id="line.5394">    }</a>
<span class="sourceLineNo">5395</span><a id="line.5395"></a>
<span class="sourceLineNo">5396</span><a id="line.5396">    /**</a>
<span class="sourceLineNo">5397</span><a id="line.5397">     * Finds the camera intrinsic and extrinsic parameters from several views of a calibration</a>
<span class="sourceLineNo">5398</span><a id="line.5398">     * pattern.</a>
<span class="sourceLineNo">5399</span><a id="line.5399">     *</a>
<span class="sourceLineNo">5400</span><a id="line.5400">     * @param objectPoints In the new interface it is a vector of vectors of calibration pattern points in</a>
<span class="sourceLineNo">5401</span><a id="line.5401">     * the calibration pattern coordinate space (e.g. std::vector&amp;lt;std::vector&amp;lt;cv::Vec3f&amp;gt;&amp;gt;). The outer</a>
<span class="sourceLineNo">5402</span><a id="line.5402">     * vector contains as many elements as the number of pattern views. If the same calibration pattern</a>
<span class="sourceLineNo">5403</span><a id="line.5403">     * is shown in each view and it is fully visible, all the vectors will be the same. Although, it is</a>
<span class="sourceLineNo">5404</span><a id="line.5404">     * possible to use partially occluded patterns or even different patterns in different views. Then,</a>
<span class="sourceLineNo">5405</span><a id="line.5405">     * the vectors will be different. Although the points are 3D, they all lie in the calibration pattern's</a>
<span class="sourceLineNo">5406</span><a id="line.5406">     * XY coordinate plane (thus 0 in the Z-coordinate), if the used calibration pattern is a planar rig.</a>
<span class="sourceLineNo">5407</span><a id="line.5407">     * In the old interface all the vectors of object points from different views are concatenated</a>
<span class="sourceLineNo">5408</span><a id="line.5408">     * together.</a>
<span class="sourceLineNo">5409</span><a id="line.5409">     * @param imagePoints In the new interface it is a vector of vectors of the projections of calibration</a>
<span class="sourceLineNo">5410</span><a id="line.5410">     * pattern points (e.g. std::vector&amp;lt;std::vector&amp;lt;cv::Vec2f&amp;gt;&amp;gt;). imagePoints.size() and</a>
<span class="sourceLineNo">5411</span><a id="line.5411">     * objectPoints.size(), and imagePoints[i].size() and objectPoints[i].size() for each i, must be equal,</a>
<span class="sourceLineNo">5412</span><a id="line.5412">     * respectively. In the old interface all the vectors of object points from different views are</a>
<span class="sourceLineNo">5413</span><a id="line.5413">     * concatenated together.</a>
<span class="sourceLineNo">5414</span><a id="line.5414">     * @param imageSize Size of the image used only to initialize the camera intrinsic matrix.</a>
<span class="sourceLineNo">5415</span><a id="line.5415">     * @param cameraMatrix Input/output 3x3 floating-point camera intrinsic matrix</a>
<span class="sourceLineNo">5416</span><a id="line.5416">     * \(\cameramatrix{A}\) . If REF: CALIB_USE_INTRINSIC_GUESS</a>
<span class="sourceLineNo">5417</span><a id="line.5417">     * and/or REF: CALIB_FIX_ASPECT_RATIO are specified, some or all of fx, fy, cx, cy must be</a>
<span class="sourceLineNo">5418</span><a id="line.5418">     * initialized before calling the function.</a>
<span class="sourceLineNo">5419</span><a id="line.5419">     * @param distCoeffs Input/output vector of distortion coefficients</a>
<span class="sourceLineNo">5420</span><a id="line.5420">     * \(\distcoeffs\).</a>
<span class="sourceLineNo">5421</span><a id="line.5421">     * @param rvecs Output vector of rotation vectors (REF: Rodrigues ) estimated for each pattern view</a>
<span class="sourceLineNo">5422</span><a id="line.5422">     * (e.g. std::vector&amp;lt;cv::Mat&amp;gt;&amp;gt;). That is, each i-th rotation vector together with the corresponding</a>
<span class="sourceLineNo">5423</span><a id="line.5423">     * i-th translation vector (see the next output parameter description) brings the calibration pattern</a>
<span class="sourceLineNo">5424</span><a id="line.5424">     * from the object coordinate space (in which object points are specified) to the camera coordinate</a>
<span class="sourceLineNo">5425</span><a id="line.5425">     * space. In more technical terms, the tuple of the i-th rotation and translation vector performs</a>
<span class="sourceLineNo">5426</span><a id="line.5426">     * a change of basis from object coordinate space to camera coordinate space. Due to its duality, this</a>
<span class="sourceLineNo">5427</span><a id="line.5427">     * tuple is equivalent to the position of the calibration pattern with respect to the camera coordinate</a>
<span class="sourceLineNo">5428</span><a id="line.5428">     * space.</a>
<span class="sourceLineNo">5429</span><a id="line.5429">     * @param tvecs Output vector of translation vectors estimated for each pattern view, see parameter</a>
<span class="sourceLineNo">5430</span><a id="line.5430">     * describtion above.</a>
<span class="sourceLineNo">5431</span><a id="line.5431">     * @param stdDeviationsIntrinsics Output vector of standard deviations estimated for intrinsic</a>
<span class="sourceLineNo">5432</span><a id="line.5432">     * parameters. Order of deviations values:</a>
<span class="sourceLineNo">5433</span><a id="line.5433">     * \((f_x, f_y, c_x, c_y, k_1, k_2, p_1, p_2, k_3, k_4, k_5, k_6 , s_1, s_2, s_3,</a>
<span class="sourceLineNo">5434</span><a id="line.5434">     *  s_4, \tau_x, \tau_y)\) If one of parameters is not estimated, it's deviation is equals to zero.</a>
<span class="sourceLineNo">5435</span><a id="line.5435">     * @param stdDeviationsExtrinsics Output vector of standard deviations estimated for extrinsic</a>
<span class="sourceLineNo">5436</span><a id="line.5436">     * parameters. Order of deviations values: \((R_0, T_0, \dotsc , R_{M - 1}, T_{M - 1})\) where M is</a>
<span class="sourceLineNo">5437</span><a id="line.5437">     * the number of pattern views. \(R_i, T_i\) are concatenated 1x3 vectors.</a>
<span class="sourceLineNo">5438</span><a id="line.5438">     *  @param perViewErrors Output vector of the RMS re-projection error estimated for each pattern view.</a>
<span class="sourceLineNo">5439</span><a id="line.5439">     * &lt;ul&gt;</a>
<span class="sourceLineNo">5440</span><a id="line.5440">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5441</span><a id="line.5441">     *    REF: CALIB_USE_INTRINSIC_GUESS cameraMatrix contains valid initial values of</a>
<span class="sourceLineNo">5442</span><a id="line.5442">     * fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image</a>
<span class="sourceLineNo">5443</span><a id="line.5443">     * center ( imageSize is used), and focal distances are computed in a least-squares fashion.</a>
<span class="sourceLineNo">5444</span><a id="line.5444">     * Note, that if intrinsic parameters are known, there is no need to use this function just to</a>
<span class="sourceLineNo">5445</span><a id="line.5445">     * estimate extrinsic parameters. Use solvePnP instead.</a>
<span class="sourceLineNo">5446</span><a id="line.5446">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5447</span><a id="line.5447">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5448</span><a id="line.5448">     *    REF: CALIB_FIX_PRINCIPAL_POINT The principal point is not changed during the global</a>
<span class="sourceLineNo">5449</span><a id="line.5449">     * optimization. It stays at the center or at a different location specified when</a>
<span class="sourceLineNo">5450</span><a id="line.5450">     *  REF: CALIB_USE_INTRINSIC_GUESS is set too.</a>
<span class="sourceLineNo">5451</span><a id="line.5451">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5452</span><a id="line.5452">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5453</span><a id="line.5453">     *    REF: CALIB_FIX_ASPECT_RATIO The functions consider only fy as a free parameter. The</a>
<span class="sourceLineNo">5454</span><a id="line.5454">     * ratio fx/fy stays the same as in the input cameraMatrix . When</a>
<span class="sourceLineNo">5455</span><a id="line.5455">     *  REF: CALIB_USE_INTRINSIC_GUESS is not set, the actual input values of fx and fy are</a>
<span class="sourceLineNo">5456</span><a id="line.5456">     * ignored, only their ratio is computed and used further.</a>
<span class="sourceLineNo">5457</span><a id="line.5457">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5458</span><a id="line.5458">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5459</span><a id="line.5459">     *    REF: CALIB_ZERO_TANGENT_DIST Tangential distortion coefficients \((p_1, p_2)\) are set</a>
<span class="sourceLineNo">5460</span><a id="line.5460">     * to zeros and stay zero.</a>
<span class="sourceLineNo">5461</span><a id="line.5461">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5462</span><a id="line.5462">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5463</span><a id="line.5463">     *    REF: CALIB_FIX_K1,..., REF: CALIB_FIX_K6 The corresponding radial distortion</a>
<span class="sourceLineNo">5464</span><a id="line.5464">     * coefficient is not changed during the optimization. If REF: CALIB_USE_INTRINSIC_GUESS is</a>
<span class="sourceLineNo">5465</span><a id="line.5465">     * set, the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0.</a>
<span class="sourceLineNo">5466</span><a id="line.5466">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5467</span><a id="line.5467">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5468</span><a id="line.5468">     *    REF: CALIB_RATIONAL_MODEL Coefficients k4, k5, and k6 are enabled. To provide the</a>
<span class="sourceLineNo">5469</span><a id="line.5469">     * backward compatibility, this extra flag should be explicitly specified to make the</a>
<span class="sourceLineNo">5470</span><a id="line.5470">     * calibration function use the rational model and return 8 coefficients. If the flag is not</a>
<span class="sourceLineNo">5471</span><a id="line.5471">     * set, the function computes and returns only 5 distortion coefficients.</a>
<span class="sourceLineNo">5472</span><a id="line.5472">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5473</span><a id="line.5473">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5474</span><a id="line.5474">     *    REF: CALIB_THIN_PRISM_MODEL Coefficients s1, s2, s3 and s4 are enabled. To provide the</a>
<span class="sourceLineNo">5475</span><a id="line.5475">     * backward compatibility, this extra flag should be explicitly specified to make the</a>
<span class="sourceLineNo">5476</span><a id="line.5476">     * calibration function use the thin prism model and return 12 coefficients. If the flag is not</a>
<span class="sourceLineNo">5477</span><a id="line.5477">     * set, the function computes and returns only 5 distortion coefficients.</a>
<span class="sourceLineNo">5478</span><a id="line.5478">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5479</span><a id="line.5479">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5480</span><a id="line.5480">     *    REF: CALIB_FIX_S1_S2_S3_S4 The thin prism distortion coefficients are not changed during</a>
<span class="sourceLineNo">5481</span><a id="line.5481">     * the optimization. If REF: CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the</a>
<span class="sourceLineNo">5482</span><a id="line.5482">     * supplied distCoeffs matrix is used. Otherwise, it is set to 0.</a>
<span class="sourceLineNo">5483</span><a id="line.5483">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5484</span><a id="line.5484">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5485</span><a id="line.5485">     *    REF: CALIB_TILTED_MODEL Coefficients tauX and tauY are enabled. To provide the</a>
<span class="sourceLineNo">5486</span><a id="line.5486">     * backward compatibility, this extra flag should be explicitly specified to make the</a>
<span class="sourceLineNo">5487</span><a id="line.5487">     * calibration function use the tilted sensor model and return 14 coefficients. If the flag is not</a>
<span class="sourceLineNo">5488</span><a id="line.5488">     * set, the function computes and returns only 5 distortion coefficients.</a>
<span class="sourceLineNo">5489</span><a id="line.5489">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5490</span><a id="line.5490">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5491</span><a id="line.5491">     *    REF: CALIB_FIX_TAUX_TAUY The coefficients of the tilted sensor model are not changed during</a>
<span class="sourceLineNo">5492</span><a id="line.5492">     * the optimization. If REF: CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the</a>
<span class="sourceLineNo">5493</span><a id="line.5493">     * supplied distCoeffs matrix is used. Otherwise, it is set to 0.</a>
<span class="sourceLineNo">5494</span><a id="line.5494">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5495</span><a id="line.5495">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">5496</span><a id="line.5496">     *</a>
<span class="sourceLineNo">5497</span><a id="line.5497">     * @return the overall RMS re-projection error.</a>
<span class="sourceLineNo">5498</span><a id="line.5498">     *</a>
<span class="sourceLineNo">5499</span><a id="line.5499">     * The function estimates the intrinsic camera parameters and extrinsic parameters for each of the</a>
<span class="sourceLineNo">5500</span><a id="line.5500">     * views. The algorithm is based on CITE: Zhang2000 and CITE: BouguetMCT . The coordinates of 3D object</a>
<span class="sourceLineNo">5501</span><a id="line.5501">     * points and their corresponding 2D projections in each view must be specified. That may be achieved</a>
<span class="sourceLineNo">5502</span><a id="line.5502">     * by using an object with known geometry and easily detectable feature points. Such an object is</a>
<span class="sourceLineNo">5503</span><a id="line.5503">     * called a calibration rig or calibration pattern, and OpenCV has built-in support for a chessboard as</a>
<span class="sourceLineNo">5504</span><a id="line.5504">     * a calibration rig (see REF: findChessboardCorners). Currently, initialization of intrinsic</a>
<span class="sourceLineNo">5505</span><a id="line.5505">     * parameters (when REF: CALIB_USE_INTRINSIC_GUESS is not set) is only implemented for planar calibration</a>
<span class="sourceLineNo">5506</span><a id="line.5506">     * patterns (where Z-coordinates of the object points must be all zeros). 3D calibration rigs can also</a>
<span class="sourceLineNo">5507</span><a id="line.5507">     * be used as long as initial cameraMatrix is provided.</a>
<span class="sourceLineNo">5508</span><a id="line.5508">     *</a>
<span class="sourceLineNo">5509</span><a id="line.5509">     * The algorithm performs the following steps:</a>
<span class="sourceLineNo">5510</span><a id="line.5510">     *</a>
<span class="sourceLineNo">5511</span><a id="line.5511">     * &lt;ul&gt;</a>
<span class="sourceLineNo">5512</span><a id="line.5512">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5513</span><a id="line.5513">     *    Compute the initial intrinsic parameters (the option only available for planar calibration</a>
<span class="sourceLineNo">5514</span><a id="line.5514">     *     patterns) or read them from the input parameters. The distortion coefficients are all set to</a>
<span class="sourceLineNo">5515</span><a id="line.5515">     *     zeros initially unless some of CALIB_FIX_K? are specified.</a>
<span class="sourceLineNo">5516</span><a id="line.5516">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5517</span><a id="line.5517">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">5518</span><a id="line.5518">     *</a>
<span class="sourceLineNo">5519</span><a id="line.5519">     * &lt;ul&gt;</a>
<span class="sourceLineNo">5520</span><a id="line.5520">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5521</span><a id="line.5521">     *    Estimate the initial camera pose as if the intrinsic parameters have been already known. This is</a>
<span class="sourceLineNo">5522</span><a id="line.5522">     *     done using solvePnP .</a>
<span class="sourceLineNo">5523</span><a id="line.5523">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5524</span><a id="line.5524">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">5525</span><a id="line.5525">     *</a>
<span class="sourceLineNo">5526</span><a id="line.5526">     * &lt;ul&gt;</a>
<span class="sourceLineNo">5527</span><a id="line.5527">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5528</span><a id="line.5528">     *    Run the global Levenberg-Marquardt optimization algorithm to minimize the reprojection error,</a>
<span class="sourceLineNo">5529</span><a id="line.5529">     *     that is, the total sum of squared distances between the observed feature points imagePoints and</a>
<span class="sourceLineNo">5530</span><a id="line.5530">     *     the projected (using the current estimates for camera parameters and the poses) object points</a>
<span class="sourceLineNo">5531</span><a id="line.5531">     *     objectPoints. See projectPoints for details.</a>
<span class="sourceLineNo">5532</span><a id="line.5532">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5533</span><a id="line.5533">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">5534</span><a id="line.5534">     *</a>
<span class="sourceLineNo">5535</span><a id="line.5535">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">5536</span><a id="line.5536">     *     If you use a non-square (i.e. non-N-by-N) grid and REF: findChessboardCorners for calibration,</a>
<span class="sourceLineNo">5537</span><a id="line.5537">     *     and REF: calibrateCamera returns bad values (zero distortion coefficients, \(c_x\) and</a>
<span class="sourceLineNo">5538</span><a id="line.5538">     *     \(c_y\) very far from the image center, and/or large differences between \(f_x\) and</a>
<span class="sourceLineNo">5539</span><a id="line.5539">     *     \(f_y\) (ratios of 10:1 or more)), then you are probably using patternSize=cvSize(rows,cols)</a>
<span class="sourceLineNo">5540</span><a id="line.5540">     *     instead of using patternSize=cvSize(cols,rows) in REF: findChessboardCorners.</a>
<span class="sourceLineNo">5541</span><a id="line.5541">     *</a>
<span class="sourceLineNo">5542</span><a id="line.5542">     * SEE:</a>
<span class="sourceLineNo">5543</span><a id="line.5543">     *    calibrateCameraRO, findChessboardCorners, solvePnP, initCameraMatrix2D, stereoCalibrate,</a>
<span class="sourceLineNo">5544</span><a id="line.5544">     *    undistort</a>
<span class="sourceLineNo">5545</span><a id="line.5545">     */</a>
<span class="sourceLineNo">5546</span><a id="line.5546">    public static double calibrateCameraExtended(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List&lt;Mat&gt; rvecs, List&lt;Mat&gt; tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors) {</a>
<span class="sourceLineNo">5547</span><a id="line.5547">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">5548</span><a id="line.5548">        Mat imagePoints_mat = Converters.vector_Mat_to_Mat(imagePoints);</a>
<span class="sourceLineNo">5549</span><a id="line.5549">        Mat rvecs_mat = new Mat();</a>
<span class="sourceLineNo">5550</span><a id="line.5550">        Mat tvecs_mat = new Mat();</a>
<span class="sourceLineNo">5551</span><a id="line.5551">        double retVal = calibrateCameraExtended_2(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, imageSize.width, imageSize.height, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvecs_mat.nativeObj, tvecs_mat.nativeObj, stdDeviationsIntrinsics.nativeObj, stdDeviationsExtrinsics.nativeObj, perViewErrors.nativeObj);</a>
<span class="sourceLineNo">5552</span><a id="line.5552">        Converters.Mat_to_vector_Mat(rvecs_mat, rvecs);</a>
<span class="sourceLineNo">5553</span><a id="line.5553">        rvecs_mat.release();</a>
<span class="sourceLineNo">5554</span><a id="line.5554">        Converters.Mat_to_vector_Mat(tvecs_mat, tvecs);</a>
<span class="sourceLineNo">5555</span><a id="line.5555">        tvecs_mat.release();</a>
<span class="sourceLineNo">5556</span><a id="line.5556">        return retVal;</a>
<span class="sourceLineNo">5557</span><a id="line.5557">    }</a>
<span class="sourceLineNo">5558</span><a id="line.5558"></a>
<span class="sourceLineNo">5559</span><a id="line.5559"></a>
<span class="sourceLineNo">5560</span><a id="line.5560">    //</a>
<span class="sourceLineNo">5561</span><a id="line.5561">    // C++:  double cv::calibrateCamera(vector_Mat objectPoints, vector_Mat imagePoints, Size imageSize, Mat&amp; cameraMatrix, Mat&amp; distCoeffs, vector_Mat&amp; rvecs, vector_Mat&amp; tvecs, int flags = 0, TermCriteria criteria = TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON))</a>
<span class="sourceLineNo">5562</span><a id="line.5562">    //</a>
<span class="sourceLineNo">5563</span><a id="line.5563"></a>
<span class="sourceLineNo">5564</span><a id="line.5564">    public static double calibrateCamera(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List&lt;Mat&gt; rvecs, List&lt;Mat&gt; tvecs, int flags, TermCriteria criteria) {</a>
<span class="sourceLineNo">5565</span><a id="line.5565">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">5566</span><a id="line.5566">        Mat imagePoints_mat = Converters.vector_Mat_to_Mat(imagePoints);</a>
<span class="sourceLineNo">5567</span><a id="line.5567">        Mat rvecs_mat = new Mat();</a>
<span class="sourceLineNo">5568</span><a id="line.5568">        Mat tvecs_mat = new Mat();</a>
<span class="sourceLineNo">5569</span><a id="line.5569">        double retVal = calibrateCamera_0(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, imageSize.width, imageSize.height, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvecs_mat.nativeObj, tvecs_mat.nativeObj, flags, criteria.type, criteria.maxCount, criteria.epsilon);</a>
<span class="sourceLineNo">5570</span><a id="line.5570">        Converters.Mat_to_vector_Mat(rvecs_mat, rvecs);</a>
<span class="sourceLineNo">5571</span><a id="line.5571">        rvecs_mat.release();</a>
<span class="sourceLineNo">5572</span><a id="line.5572">        Converters.Mat_to_vector_Mat(tvecs_mat, tvecs);</a>
<span class="sourceLineNo">5573</span><a id="line.5573">        tvecs_mat.release();</a>
<span class="sourceLineNo">5574</span><a id="line.5574">        return retVal;</a>
<span class="sourceLineNo">5575</span><a id="line.5575">    }</a>
<span class="sourceLineNo">5576</span><a id="line.5576"></a>
<span class="sourceLineNo">5577</span><a id="line.5577">    public static double calibrateCamera(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List&lt;Mat&gt; rvecs, List&lt;Mat&gt; tvecs, int flags) {</a>
<span class="sourceLineNo">5578</span><a id="line.5578">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">5579</span><a id="line.5579">        Mat imagePoints_mat = Converters.vector_Mat_to_Mat(imagePoints);</a>
<span class="sourceLineNo">5580</span><a id="line.5580">        Mat rvecs_mat = new Mat();</a>
<span class="sourceLineNo">5581</span><a id="line.5581">        Mat tvecs_mat = new Mat();</a>
<span class="sourceLineNo">5582</span><a id="line.5582">        double retVal = calibrateCamera_1(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, imageSize.width, imageSize.height, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvecs_mat.nativeObj, tvecs_mat.nativeObj, flags);</a>
<span class="sourceLineNo">5583</span><a id="line.5583">        Converters.Mat_to_vector_Mat(rvecs_mat, rvecs);</a>
<span class="sourceLineNo">5584</span><a id="line.5584">        rvecs_mat.release();</a>
<span class="sourceLineNo">5585</span><a id="line.5585">        Converters.Mat_to_vector_Mat(tvecs_mat, tvecs);</a>
<span class="sourceLineNo">5586</span><a id="line.5586">        tvecs_mat.release();</a>
<span class="sourceLineNo">5587</span><a id="line.5587">        return retVal;</a>
<span class="sourceLineNo">5588</span><a id="line.5588">    }</a>
<span class="sourceLineNo">5589</span><a id="line.5589"></a>
<span class="sourceLineNo">5590</span><a id="line.5590">    public static double calibrateCamera(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List&lt;Mat&gt; rvecs, List&lt;Mat&gt; tvecs) {</a>
<span class="sourceLineNo">5591</span><a id="line.5591">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">5592</span><a id="line.5592">        Mat imagePoints_mat = Converters.vector_Mat_to_Mat(imagePoints);</a>
<span class="sourceLineNo">5593</span><a id="line.5593">        Mat rvecs_mat = new Mat();</a>
<span class="sourceLineNo">5594</span><a id="line.5594">        Mat tvecs_mat = new Mat();</a>
<span class="sourceLineNo">5595</span><a id="line.5595">        double retVal = calibrateCamera_2(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, imageSize.width, imageSize.height, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvecs_mat.nativeObj, tvecs_mat.nativeObj);</a>
<span class="sourceLineNo">5596</span><a id="line.5596">        Converters.Mat_to_vector_Mat(rvecs_mat, rvecs);</a>
<span class="sourceLineNo">5597</span><a id="line.5597">        rvecs_mat.release();</a>
<span class="sourceLineNo">5598</span><a id="line.5598">        Converters.Mat_to_vector_Mat(tvecs_mat, tvecs);</a>
<span class="sourceLineNo">5599</span><a id="line.5599">        tvecs_mat.release();</a>
<span class="sourceLineNo">5600</span><a id="line.5600">        return retVal;</a>
<span class="sourceLineNo">5601</span><a id="line.5601">    }</a>
<span class="sourceLineNo">5602</span><a id="line.5602"></a>
<span class="sourceLineNo">5603</span><a id="line.5603"></a>
<span class="sourceLineNo">5604</span><a id="line.5604">    //</a>
<span class="sourceLineNo">5605</span><a id="line.5605">    // C++:  double cv::calibrateCameraRO(vector_Mat objectPoints, vector_Mat imagePoints, Size imageSize, int iFixedPoint, Mat&amp; cameraMatrix, Mat&amp; distCoeffs, vector_Mat&amp; rvecs, vector_Mat&amp; tvecs, Mat&amp; newObjPoints, Mat&amp; stdDeviationsIntrinsics, Mat&amp; stdDeviationsExtrinsics, Mat&amp; stdDeviationsObjPoints, Mat&amp; perViewErrors, int flags = 0, TermCriteria criteria = TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON))</a>
<span class="sourceLineNo">5606</span><a id="line.5606">    //</a>
<span class="sourceLineNo">5607</span><a id="line.5607"></a>
<span class="sourceLineNo">5608</span><a id="line.5608">    /**</a>
<span class="sourceLineNo">5609</span><a id="line.5609">     * Finds the camera intrinsic and extrinsic parameters from several views of a calibration pattern.</a>
<span class="sourceLineNo">5610</span><a id="line.5610">     *</a>
<span class="sourceLineNo">5611</span><a id="line.5611">     * This function is an extension of calibrateCamera() with the method of releasing object which was</a>
<span class="sourceLineNo">5612</span><a id="line.5612">     * proposed in CITE: strobl2011iccv. In many common cases with inaccurate, unmeasured, roughly planar</a>
<span class="sourceLineNo">5613</span><a id="line.5613">     * targets (calibration plates), this method can dramatically improve the precision of the estimated</a>
<span class="sourceLineNo">5614</span><a id="line.5614">     * camera parameters. Both the object-releasing method and standard method are supported by this</a>
<span class="sourceLineNo">5615</span><a id="line.5615">     * function. Use the parameter &lt;b&gt;iFixedPoint&lt;/b&gt; for method selection. In the internal implementation,</a>
<span class="sourceLineNo">5616</span><a id="line.5616">     * calibrateCamera() is a wrapper for this function.</a>
<span class="sourceLineNo">5617</span><a id="line.5617">     *</a>
<span class="sourceLineNo">5618</span><a id="line.5618">     * @param objectPoints Vector of vectors of calibration pattern points in the calibration pattern</a>
<span class="sourceLineNo">5619</span><a id="line.5619">     * coordinate space. See calibrateCamera() for details. If the method of releasing object to be used,</a>
<span class="sourceLineNo">5620</span><a id="line.5620">     * the identical calibration board must be used in each view and it must be fully visible, and all</a>
<span class="sourceLineNo">5621</span><a id="line.5621">     * objectPoints[i] must be the same and all points should be roughly close to a plane. &lt;b&gt;The calibration</a>
<span class="sourceLineNo">5622</span><a id="line.5622">     * target has to be rigid, or at least static if the camera (rather than the calibration target) is</a>
<span class="sourceLineNo">5623</span><a id="line.5623">     * shifted for grabbing images.&lt;/b&gt;</a>
<span class="sourceLineNo">5624</span><a id="line.5624">     * @param imagePoints Vector of vectors of the projections of calibration pattern points. See</a>
<span class="sourceLineNo">5625</span><a id="line.5625">     * calibrateCamera() for details.</a>
<span class="sourceLineNo">5626</span><a id="line.5626">     * @param imageSize Size of the image used only to initialize the intrinsic camera matrix.</a>
<span class="sourceLineNo">5627</span><a id="line.5627">     * @param iFixedPoint The index of the 3D object point in objectPoints[0] to be fixed. It also acts as</a>
<span class="sourceLineNo">5628</span><a id="line.5628">     * a switch for calibration method selection. If object-releasing method to be used, pass in the</a>
<span class="sourceLineNo">5629</span><a id="line.5629">     * parameter in the range of [1, objectPoints[0].size()-2], otherwise a value out of this range will</a>
<span class="sourceLineNo">5630</span><a id="line.5630">     * make standard calibration method selected. Usually the top-right corner point of the calibration</a>
<span class="sourceLineNo">5631</span><a id="line.5631">     * board grid is recommended to be fixed when object-releasing method being utilized. According to</a>
<span class="sourceLineNo">5632</span><a id="line.5632">     * \cite strobl2011iccv, two other points are also fixed. In this implementation, objectPoints[0].front</a>
<span class="sourceLineNo">5633</span><a id="line.5633">     * and objectPoints[0].back.z are used. With object-releasing method, accurate rvecs, tvecs and</a>
<span class="sourceLineNo">5634</span><a id="line.5634">     * newObjPoints are only possible if coordinates of these three fixed points are accurate enough.</a>
<span class="sourceLineNo">5635</span><a id="line.5635">     * @param cameraMatrix Output 3x3 floating-point camera matrix. See calibrateCamera() for details.</a>
<span class="sourceLineNo">5636</span><a id="line.5636">     * @param distCoeffs Output vector of distortion coefficients. See calibrateCamera() for details.</a>
<span class="sourceLineNo">5637</span><a id="line.5637">     * @param rvecs Output vector of rotation vectors estimated for each pattern view. See calibrateCamera()</a>
<span class="sourceLineNo">5638</span><a id="line.5638">     * for details.</a>
<span class="sourceLineNo">5639</span><a id="line.5639">     * @param tvecs Output vector of translation vectors estimated for each pattern view.</a>
<span class="sourceLineNo">5640</span><a id="line.5640">     * @param newObjPoints The updated output vector of calibration pattern points. The coordinates might</a>
<span class="sourceLineNo">5641</span><a id="line.5641">     * be scaled based on three fixed points. The returned coordinates are accurate only if the above</a>
<span class="sourceLineNo">5642</span><a id="line.5642">     * mentioned three fixed points are accurate. If not needed, noArray() can be passed in. This parameter</a>
<span class="sourceLineNo">5643</span><a id="line.5643">     * is ignored with standard calibration method.</a>
<span class="sourceLineNo">5644</span><a id="line.5644">     * @param stdDeviationsIntrinsics Output vector of standard deviations estimated for intrinsic parameters.</a>
<span class="sourceLineNo">5645</span><a id="line.5645">     * See calibrateCamera() for details.</a>
<span class="sourceLineNo">5646</span><a id="line.5646">     * @param stdDeviationsExtrinsics Output vector of standard deviations estimated for extrinsic parameters.</a>
<span class="sourceLineNo">5647</span><a id="line.5647">     * See calibrateCamera() for details.</a>
<span class="sourceLineNo">5648</span><a id="line.5648">     * @param stdDeviationsObjPoints Output vector of standard deviations estimated for refined coordinates</a>
<span class="sourceLineNo">5649</span><a id="line.5649">     * of calibration pattern points. It has the same size and order as objectPoints[0] vector. This</a>
<span class="sourceLineNo">5650</span><a id="line.5650">     * parameter is ignored with standard calibration method.</a>
<span class="sourceLineNo">5651</span><a id="line.5651">     *  @param perViewErrors Output vector of the RMS re-projection error estimated for each pattern view.</a>
<span class="sourceLineNo">5652</span><a id="line.5652">     * @param flags Different flags that may be zero or a combination of some predefined values. See</a>
<span class="sourceLineNo">5653</span><a id="line.5653">     * calibrateCamera() for details. If the method of releasing object is used, the calibration time may</a>
<span class="sourceLineNo">5654</span><a id="line.5654">     * be much longer. CALIB_USE_QR or CALIB_USE_LU could be used for faster calibration with potentially</a>
<span class="sourceLineNo">5655</span><a id="line.5655">     * less precise and less stable in some rare cases.</a>
<span class="sourceLineNo">5656</span><a id="line.5656">     * @param criteria Termination criteria for the iterative optimization algorithm.</a>
<span class="sourceLineNo">5657</span><a id="line.5657">     *</a>
<span class="sourceLineNo">5658</span><a id="line.5658">     * @return the overall RMS re-projection error.</a>
<span class="sourceLineNo">5659</span><a id="line.5659">     *</a>
<span class="sourceLineNo">5660</span><a id="line.5660">     * The function estimates the intrinsic camera parameters and extrinsic parameters for each of the</a>
<span class="sourceLineNo">5661</span><a id="line.5661">     * views. The algorithm is based on CITE: Zhang2000, CITE: BouguetMCT and CITE: strobl2011iccv. See</a>
<span class="sourceLineNo">5662</span><a id="line.5662">     * calibrateCamera() for other detailed explanations.</a>
<span class="sourceLineNo">5663</span><a id="line.5663">     * SEE:</a>
<span class="sourceLineNo">5664</span><a id="line.5664">     *    calibrateCamera, findChessboardCorners, solvePnP, initCameraMatrix2D, stereoCalibrate, undistort</a>
<span class="sourceLineNo">5665</span><a id="line.5665">     */</a>
<span class="sourceLineNo">5666</span><a id="line.5666">    public static double calibrateCameraROExtended(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List&lt;Mat&gt; rvecs, List&lt;Mat&gt; tvecs, Mat newObjPoints, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat stdDeviationsObjPoints, Mat perViewErrors, int flags, TermCriteria criteria) {</a>
<span class="sourceLineNo">5667</span><a id="line.5667">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">5668</span><a id="line.5668">        Mat imagePoints_mat = Converters.vector_Mat_to_Mat(imagePoints);</a>
<span class="sourceLineNo">5669</span><a id="line.5669">        Mat rvecs_mat = new Mat();</a>
<span class="sourceLineNo">5670</span><a id="line.5670">        Mat tvecs_mat = new Mat();</a>
<span class="sourceLineNo">5671</span><a id="line.5671">        double retVal = calibrateCameraROExtended_0(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, imageSize.width, imageSize.height, iFixedPoint, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvecs_mat.nativeObj, tvecs_mat.nativeObj, newObjPoints.nativeObj, stdDeviationsIntrinsics.nativeObj, stdDeviationsExtrinsics.nativeObj, stdDeviationsObjPoints.nativeObj, perViewErrors.nativeObj, flags, criteria.type, criteria.maxCount, criteria.epsilon);</a>
<span class="sourceLineNo">5672</span><a id="line.5672">        Converters.Mat_to_vector_Mat(rvecs_mat, rvecs);</a>
<span class="sourceLineNo">5673</span><a id="line.5673">        rvecs_mat.release();</a>
<span class="sourceLineNo">5674</span><a id="line.5674">        Converters.Mat_to_vector_Mat(tvecs_mat, tvecs);</a>
<span class="sourceLineNo">5675</span><a id="line.5675">        tvecs_mat.release();</a>
<span class="sourceLineNo">5676</span><a id="line.5676">        return retVal;</a>
<span class="sourceLineNo">5677</span><a id="line.5677">    }</a>
<span class="sourceLineNo">5678</span><a id="line.5678"></a>
<span class="sourceLineNo">5679</span><a id="line.5679">    /**</a>
<span class="sourceLineNo">5680</span><a id="line.5680">     * Finds the camera intrinsic and extrinsic parameters from several views of a calibration pattern.</a>
<span class="sourceLineNo">5681</span><a id="line.5681">     *</a>
<span class="sourceLineNo">5682</span><a id="line.5682">     * This function is an extension of calibrateCamera() with the method of releasing object which was</a>
<span class="sourceLineNo">5683</span><a id="line.5683">     * proposed in CITE: strobl2011iccv. In many common cases with inaccurate, unmeasured, roughly planar</a>
<span class="sourceLineNo">5684</span><a id="line.5684">     * targets (calibration plates), this method can dramatically improve the precision of the estimated</a>
<span class="sourceLineNo">5685</span><a id="line.5685">     * camera parameters. Both the object-releasing method and standard method are supported by this</a>
<span class="sourceLineNo">5686</span><a id="line.5686">     * function. Use the parameter &lt;b&gt;iFixedPoint&lt;/b&gt; for method selection. In the internal implementation,</a>
<span class="sourceLineNo">5687</span><a id="line.5687">     * calibrateCamera() is a wrapper for this function.</a>
<span class="sourceLineNo">5688</span><a id="line.5688">     *</a>
<span class="sourceLineNo">5689</span><a id="line.5689">     * @param objectPoints Vector of vectors of calibration pattern points in the calibration pattern</a>
<span class="sourceLineNo">5690</span><a id="line.5690">     * coordinate space. See calibrateCamera() for details. If the method of releasing object to be used,</a>
<span class="sourceLineNo">5691</span><a id="line.5691">     * the identical calibration board must be used in each view and it must be fully visible, and all</a>
<span class="sourceLineNo">5692</span><a id="line.5692">     * objectPoints[i] must be the same and all points should be roughly close to a plane. &lt;b&gt;The calibration</a>
<span class="sourceLineNo">5693</span><a id="line.5693">     * target has to be rigid, or at least static if the camera (rather than the calibration target) is</a>
<span class="sourceLineNo">5694</span><a id="line.5694">     * shifted for grabbing images.&lt;/b&gt;</a>
<span class="sourceLineNo">5695</span><a id="line.5695">     * @param imagePoints Vector of vectors of the projections of calibration pattern points. See</a>
<span class="sourceLineNo">5696</span><a id="line.5696">     * calibrateCamera() for details.</a>
<span class="sourceLineNo">5697</span><a id="line.5697">     * @param imageSize Size of the image used only to initialize the intrinsic camera matrix.</a>
<span class="sourceLineNo">5698</span><a id="line.5698">     * @param iFixedPoint The index of the 3D object point in objectPoints[0] to be fixed. It also acts as</a>
<span class="sourceLineNo">5699</span><a id="line.5699">     * a switch for calibration method selection. If object-releasing method to be used, pass in the</a>
<span class="sourceLineNo">5700</span><a id="line.5700">     * parameter in the range of [1, objectPoints[0].size()-2], otherwise a value out of this range will</a>
<span class="sourceLineNo">5701</span><a id="line.5701">     * make standard calibration method selected. Usually the top-right corner point of the calibration</a>
<span class="sourceLineNo">5702</span><a id="line.5702">     * board grid is recommended to be fixed when object-releasing method being utilized. According to</a>
<span class="sourceLineNo">5703</span><a id="line.5703">     * \cite strobl2011iccv, two other points are also fixed. In this implementation, objectPoints[0].front</a>
<span class="sourceLineNo">5704</span><a id="line.5704">     * and objectPoints[0].back.z are used. With object-releasing method, accurate rvecs, tvecs and</a>
<span class="sourceLineNo">5705</span><a id="line.5705">     * newObjPoints are only possible if coordinates of these three fixed points are accurate enough.</a>
<span class="sourceLineNo">5706</span><a id="line.5706">     * @param cameraMatrix Output 3x3 floating-point camera matrix. See calibrateCamera() for details.</a>
<span class="sourceLineNo">5707</span><a id="line.5707">     * @param distCoeffs Output vector of distortion coefficients. See calibrateCamera() for details.</a>
<span class="sourceLineNo">5708</span><a id="line.5708">     * @param rvecs Output vector of rotation vectors estimated for each pattern view. See calibrateCamera()</a>
<span class="sourceLineNo">5709</span><a id="line.5709">     * for details.</a>
<span class="sourceLineNo">5710</span><a id="line.5710">     * @param tvecs Output vector of translation vectors estimated for each pattern view.</a>
<span class="sourceLineNo">5711</span><a id="line.5711">     * @param newObjPoints The updated output vector of calibration pattern points. The coordinates might</a>
<span class="sourceLineNo">5712</span><a id="line.5712">     * be scaled based on three fixed points. The returned coordinates are accurate only if the above</a>
<span class="sourceLineNo">5713</span><a id="line.5713">     * mentioned three fixed points are accurate. If not needed, noArray() can be passed in. This parameter</a>
<span class="sourceLineNo">5714</span><a id="line.5714">     * is ignored with standard calibration method.</a>
<span class="sourceLineNo">5715</span><a id="line.5715">     * @param stdDeviationsIntrinsics Output vector of standard deviations estimated for intrinsic parameters.</a>
<span class="sourceLineNo">5716</span><a id="line.5716">     * See calibrateCamera() for details.</a>
<span class="sourceLineNo">5717</span><a id="line.5717">     * @param stdDeviationsExtrinsics Output vector of standard deviations estimated for extrinsic parameters.</a>
<span class="sourceLineNo">5718</span><a id="line.5718">     * See calibrateCamera() for details.</a>
<span class="sourceLineNo">5719</span><a id="line.5719">     * @param stdDeviationsObjPoints Output vector of standard deviations estimated for refined coordinates</a>
<span class="sourceLineNo">5720</span><a id="line.5720">     * of calibration pattern points. It has the same size and order as objectPoints[0] vector. This</a>
<span class="sourceLineNo">5721</span><a id="line.5721">     * parameter is ignored with standard calibration method.</a>
<span class="sourceLineNo">5722</span><a id="line.5722">     *  @param perViewErrors Output vector of the RMS re-projection error estimated for each pattern view.</a>
<span class="sourceLineNo">5723</span><a id="line.5723">     * @param flags Different flags that may be zero or a combination of some predefined values. See</a>
<span class="sourceLineNo">5724</span><a id="line.5724">     * calibrateCamera() for details. If the method of releasing object is used, the calibration time may</a>
<span class="sourceLineNo">5725</span><a id="line.5725">     * be much longer. CALIB_USE_QR or CALIB_USE_LU could be used for faster calibration with potentially</a>
<span class="sourceLineNo">5726</span><a id="line.5726">     * less precise and less stable in some rare cases.</a>
<span class="sourceLineNo">5727</span><a id="line.5727">     *</a>
<span class="sourceLineNo">5728</span><a id="line.5728">     * @return the overall RMS re-projection error.</a>
<span class="sourceLineNo">5729</span><a id="line.5729">     *</a>
<span class="sourceLineNo">5730</span><a id="line.5730">     * The function estimates the intrinsic camera parameters and extrinsic parameters for each of the</a>
<span class="sourceLineNo">5731</span><a id="line.5731">     * views. The algorithm is based on CITE: Zhang2000, CITE: BouguetMCT and CITE: strobl2011iccv. See</a>
<span class="sourceLineNo">5732</span><a id="line.5732">     * calibrateCamera() for other detailed explanations.</a>
<span class="sourceLineNo">5733</span><a id="line.5733">     * SEE:</a>
<span class="sourceLineNo">5734</span><a id="line.5734">     *    calibrateCamera, findChessboardCorners, solvePnP, initCameraMatrix2D, stereoCalibrate, undistort</a>
<span class="sourceLineNo">5735</span><a id="line.5735">     */</a>
<span class="sourceLineNo">5736</span><a id="line.5736">    public static double calibrateCameraROExtended(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List&lt;Mat&gt; rvecs, List&lt;Mat&gt; tvecs, Mat newObjPoints, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat stdDeviationsObjPoints, Mat perViewErrors, int flags) {</a>
<span class="sourceLineNo">5737</span><a id="line.5737">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">5738</span><a id="line.5738">        Mat imagePoints_mat = Converters.vector_Mat_to_Mat(imagePoints);</a>
<span class="sourceLineNo">5739</span><a id="line.5739">        Mat rvecs_mat = new Mat();</a>
<span class="sourceLineNo">5740</span><a id="line.5740">        Mat tvecs_mat = new Mat();</a>
<span class="sourceLineNo">5741</span><a id="line.5741">        double retVal = calibrateCameraROExtended_1(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, imageSize.width, imageSize.height, iFixedPoint, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvecs_mat.nativeObj, tvecs_mat.nativeObj, newObjPoints.nativeObj, stdDeviationsIntrinsics.nativeObj, stdDeviationsExtrinsics.nativeObj, stdDeviationsObjPoints.nativeObj, perViewErrors.nativeObj, flags);</a>
<span class="sourceLineNo">5742</span><a id="line.5742">        Converters.Mat_to_vector_Mat(rvecs_mat, rvecs);</a>
<span class="sourceLineNo">5743</span><a id="line.5743">        rvecs_mat.release();</a>
<span class="sourceLineNo">5744</span><a id="line.5744">        Converters.Mat_to_vector_Mat(tvecs_mat, tvecs);</a>
<span class="sourceLineNo">5745</span><a id="line.5745">        tvecs_mat.release();</a>
<span class="sourceLineNo">5746</span><a id="line.5746">        return retVal;</a>
<span class="sourceLineNo">5747</span><a id="line.5747">    }</a>
<span class="sourceLineNo">5748</span><a id="line.5748"></a>
<span class="sourceLineNo">5749</span><a id="line.5749">    /**</a>
<span class="sourceLineNo">5750</span><a id="line.5750">     * Finds the camera intrinsic and extrinsic parameters from several views of a calibration pattern.</a>
<span class="sourceLineNo">5751</span><a id="line.5751">     *</a>
<span class="sourceLineNo">5752</span><a id="line.5752">     * This function is an extension of calibrateCamera() with the method of releasing object which was</a>
<span class="sourceLineNo">5753</span><a id="line.5753">     * proposed in CITE: strobl2011iccv. In many common cases with inaccurate, unmeasured, roughly planar</a>
<span class="sourceLineNo">5754</span><a id="line.5754">     * targets (calibration plates), this method can dramatically improve the precision of the estimated</a>
<span class="sourceLineNo">5755</span><a id="line.5755">     * camera parameters. Both the object-releasing method and standard method are supported by this</a>
<span class="sourceLineNo">5756</span><a id="line.5756">     * function. Use the parameter &lt;b&gt;iFixedPoint&lt;/b&gt; for method selection. In the internal implementation,</a>
<span class="sourceLineNo">5757</span><a id="line.5757">     * calibrateCamera() is a wrapper for this function.</a>
<span class="sourceLineNo">5758</span><a id="line.5758">     *</a>
<span class="sourceLineNo">5759</span><a id="line.5759">     * @param objectPoints Vector of vectors of calibration pattern points in the calibration pattern</a>
<span class="sourceLineNo">5760</span><a id="line.5760">     * coordinate space. See calibrateCamera() for details. If the method of releasing object to be used,</a>
<span class="sourceLineNo">5761</span><a id="line.5761">     * the identical calibration board must be used in each view and it must be fully visible, and all</a>
<span class="sourceLineNo">5762</span><a id="line.5762">     * objectPoints[i] must be the same and all points should be roughly close to a plane. &lt;b&gt;The calibration</a>
<span class="sourceLineNo">5763</span><a id="line.5763">     * target has to be rigid, or at least static if the camera (rather than the calibration target) is</a>
<span class="sourceLineNo">5764</span><a id="line.5764">     * shifted for grabbing images.&lt;/b&gt;</a>
<span class="sourceLineNo">5765</span><a id="line.5765">     * @param imagePoints Vector of vectors of the projections of calibration pattern points. See</a>
<span class="sourceLineNo">5766</span><a id="line.5766">     * calibrateCamera() for details.</a>
<span class="sourceLineNo">5767</span><a id="line.5767">     * @param imageSize Size of the image used only to initialize the intrinsic camera matrix.</a>
<span class="sourceLineNo">5768</span><a id="line.5768">     * @param iFixedPoint The index of the 3D object point in objectPoints[0] to be fixed. It also acts as</a>
<span class="sourceLineNo">5769</span><a id="line.5769">     * a switch for calibration method selection. If object-releasing method to be used, pass in the</a>
<span class="sourceLineNo">5770</span><a id="line.5770">     * parameter in the range of [1, objectPoints[0].size()-2], otherwise a value out of this range will</a>
<span class="sourceLineNo">5771</span><a id="line.5771">     * make standard calibration method selected. Usually the top-right corner point of the calibration</a>
<span class="sourceLineNo">5772</span><a id="line.5772">     * board grid is recommended to be fixed when object-releasing method being utilized. According to</a>
<span class="sourceLineNo">5773</span><a id="line.5773">     * \cite strobl2011iccv, two other points are also fixed. In this implementation, objectPoints[0].front</a>
<span class="sourceLineNo">5774</span><a id="line.5774">     * and objectPoints[0].back.z are used. With object-releasing method, accurate rvecs, tvecs and</a>
<span class="sourceLineNo">5775</span><a id="line.5775">     * newObjPoints are only possible if coordinates of these three fixed points are accurate enough.</a>
<span class="sourceLineNo">5776</span><a id="line.5776">     * @param cameraMatrix Output 3x3 floating-point camera matrix. See calibrateCamera() for details.</a>
<span class="sourceLineNo">5777</span><a id="line.5777">     * @param distCoeffs Output vector of distortion coefficients. See calibrateCamera() for details.</a>
<span class="sourceLineNo">5778</span><a id="line.5778">     * @param rvecs Output vector of rotation vectors estimated for each pattern view. See calibrateCamera()</a>
<span class="sourceLineNo">5779</span><a id="line.5779">     * for details.</a>
<span class="sourceLineNo">5780</span><a id="line.5780">     * @param tvecs Output vector of translation vectors estimated for each pattern view.</a>
<span class="sourceLineNo">5781</span><a id="line.5781">     * @param newObjPoints The updated output vector of calibration pattern points. The coordinates might</a>
<span class="sourceLineNo">5782</span><a id="line.5782">     * be scaled based on three fixed points. The returned coordinates are accurate only if the above</a>
<span class="sourceLineNo">5783</span><a id="line.5783">     * mentioned three fixed points are accurate. If not needed, noArray() can be passed in. This parameter</a>
<span class="sourceLineNo">5784</span><a id="line.5784">     * is ignored with standard calibration method.</a>
<span class="sourceLineNo">5785</span><a id="line.5785">     * @param stdDeviationsIntrinsics Output vector of standard deviations estimated for intrinsic parameters.</a>
<span class="sourceLineNo">5786</span><a id="line.5786">     * See calibrateCamera() for details.</a>
<span class="sourceLineNo">5787</span><a id="line.5787">     * @param stdDeviationsExtrinsics Output vector of standard deviations estimated for extrinsic parameters.</a>
<span class="sourceLineNo">5788</span><a id="line.5788">     * See calibrateCamera() for details.</a>
<span class="sourceLineNo">5789</span><a id="line.5789">     * @param stdDeviationsObjPoints Output vector of standard deviations estimated for refined coordinates</a>
<span class="sourceLineNo">5790</span><a id="line.5790">     * of calibration pattern points. It has the same size and order as objectPoints[0] vector. This</a>
<span class="sourceLineNo">5791</span><a id="line.5791">     * parameter is ignored with standard calibration method.</a>
<span class="sourceLineNo">5792</span><a id="line.5792">     *  @param perViewErrors Output vector of the RMS re-projection error estimated for each pattern view.</a>
<span class="sourceLineNo">5793</span><a id="line.5793">     * calibrateCamera() for details. If the method of releasing object is used, the calibration time may</a>
<span class="sourceLineNo">5794</span><a id="line.5794">     * be much longer. CALIB_USE_QR or CALIB_USE_LU could be used for faster calibration with potentially</a>
<span class="sourceLineNo">5795</span><a id="line.5795">     * less precise and less stable in some rare cases.</a>
<span class="sourceLineNo">5796</span><a id="line.5796">     *</a>
<span class="sourceLineNo">5797</span><a id="line.5797">     * @return the overall RMS re-projection error.</a>
<span class="sourceLineNo">5798</span><a id="line.5798">     *</a>
<span class="sourceLineNo">5799</span><a id="line.5799">     * The function estimates the intrinsic camera parameters and extrinsic parameters for each of the</a>
<span class="sourceLineNo">5800</span><a id="line.5800">     * views. The algorithm is based on CITE: Zhang2000, CITE: BouguetMCT and CITE: strobl2011iccv. See</a>
<span class="sourceLineNo">5801</span><a id="line.5801">     * calibrateCamera() for other detailed explanations.</a>
<span class="sourceLineNo">5802</span><a id="line.5802">     * SEE:</a>
<span class="sourceLineNo">5803</span><a id="line.5803">     *    calibrateCamera, findChessboardCorners, solvePnP, initCameraMatrix2D, stereoCalibrate, undistort</a>
<span class="sourceLineNo">5804</span><a id="line.5804">     */</a>
<span class="sourceLineNo">5805</span><a id="line.5805">    public static double calibrateCameraROExtended(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List&lt;Mat&gt; rvecs, List&lt;Mat&gt; tvecs, Mat newObjPoints, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat stdDeviationsObjPoints, Mat perViewErrors) {</a>
<span class="sourceLineNo">5806</span><a id="line.5806">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">5807</span><a id="line.5807">        Mat imagePoints_mat = Converters.vector_Mat_to_Mat(imagePoints);</a>
<span class="sourceLineNo">5808</span><a id="line.5808">        Mat rvecs_mat = new Mat();</a>
<span class="sourceLineNo">5809</span><a id="line.5809">        Mat tvecs_mat = new Mat();</a>
<span class="sourceLineNo">5810</span><a id="line.5810">        double retVal = calibrateCameraROExtended_2(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, imageSize.width, imageSize.height, iFixedPoint, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvecs_mat.nativeObj, tvecs_mat.nativeObj, newObjPoints.nativeObj, stdDeviationsIntrinsics.nativeObj, stdDeviationsExtrinsics.nativeObj, stdDeviationsObjPoints.nativeObj, perViewErrors.nativeObj);</a>
<span class="sourceLineNo">5811</span><a id="line.5811">        Converters.Mat_to_vector_Mat(rvecs_mat, rvecs);</a>
<span class="sourceLineNo">5812</span><a id="line.5812">        rvecs_mat.release();</a>
<span class="sourceLineNo">5813</span><a id="line.5813">        Converters.Mat_to_vector_Mat(tvecs_mat, tvecs);</a>
<span class="sourceLineNo">5814</span><a id="line.5814">        tvecs_mat.release();</a>
<span class="sourceLineNo">5815</span><a id="line.5815">        return retVal;</a>
<span class="sourceLineNo">5816</span><a id="line.5816">    }</a>
<span class="sourceLineNo">5817</span><a id="line.5817"></a>
<span class="sourceLineNo">5818</span><a id="line.5818"></a>
<span class="sourceLineNo">5819</span><a id="line.5819">    //</a>
<span class="sourceLineNo">5820</span><a id="line.5820">    // C++:  double cv::calibrateCameraRO(vector_Mat objectPoints, vector_Mat imagePoints, Size imageSize, int iFixedPoint, Mat&amp; cameraMatrix, Mat&amp; distCoeffs, vector_Mat&amp; rvecs, vector_Mat&amp; tvecs, Mat&amp; newObjPoints, int flags = 0, TermCriteria criteria = TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON))</a>
<span class="sourceLineNo">5821</span><a id="line.5821">    //</a>
<span class="sourceLineNo">5822</span><a id="line.5822"></a>
<span class="sourceLineNo">5823</span><a id="line.5823">    public static double calibrateCameraRO(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List&lt;Mat&gt; rvecs, List&lt;Mat&gt; tvecs, Mat newObjPoints, int flags, TermCriteria criteria) {</a>
<span class="sourceLineNo">5824</span><a id="line.5824">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">5825</span><a id="line.5825">        Mat imagePoints_mat = Converters.vector_Mat_to_Mat(imagePoints);</a>
<span class="sourceLineNo">5826</span><a id="line.5826">        Mat rvecs_mat = new Mat();</a>
<span class="sourceLineNo">5827</span><a id="line.5827">        Mat tvecs_mat = new Mat();</a>
<span class="sourceLineNo">5828</span><a id="line.5828">        double retVal = calibrateCameraRO_0(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, imageSize.width, imageSize.height, iFixedPoint, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvecs_mat.nativeObj, tvecs_mat.nativeObj, newObjPoints.nativeObj, flags, criteria.type, criteria.maxCount, criteria.epsilon);</a>
<span class="sourceLineNo">5829</span><a id="line.5829">        Converters.Mat_to_vector_Mat(rvecs_mat, rvecs);</a>
<span class="sourceLineNo">5830</span><a id="line.5830">        rvecs_mat.release();</a>
<span class="sourceLineNo">5831</span><a id="line.5831">        Converters.Mat_to_vector_Mat(tvecs_mat, tvecs);</a>
<span class="sourceLineNo">5832</span><a id="line.5832">        tvecs_mat.release();</a>
<span class="sourceLineNo">5833</span><a id="line.5833">        return retVal;</a>
<span class="sourceLineNo">5834</span><a id="line.5834">    }</a>
<span class="sourceLineNo">5835</span><a id="line.5835"></a>
<span class="sourceLineNo">5836</span><a id="line.5836">    public static double calibrateCameraRO(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List&lt;Mat&gt; rvecs, List&lt;Mat&gt; tvecs, Mat newObjPoints, int flags) {</a>
<span class="sourceLineNo">5837</span><a id="line.5837">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">5838</span><a id="line.5838">        Mat imagePoints_mat = Converters.vector_Mat_to_Mat(imagePoints);</a>
<span class="sourceLineNo">5839</span><a id="line.5839">        Mat rvecs_mat = new Mat();</a>
<span class="sourceLineNo">5840</span><a id="line.5840">        Mat tvecs_mat = new Mat();</a>
<span class="sourceLineNo">5841</span><a id="line.5841">        double retVal = calibrateCameraRO_1(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, imageSize.width, imageSize.height, iFixedPoint, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvecs_mat.nativeObj, tvecs_mat.nativeObj, newObjPoints.nativeObj, flags);</a>
<span class="sourceLineNo">5842</span><a id="line.5842">        Converters.Mat_to_vector_Mat(rvecs_mat, rvecs);</a>
<span class="sourceLineNo">5843</span><a id="line.5843">        rvecs_mat.release();</a>
<span class="sourceLineNo">5844</span><a id="line.5844">        Converters.Mat_to_vector_Mat(tvecs_mat, tvecs);</a>
<span class="sourceLineNo">5845</span><a id="line.5845">        tvecs_mat.release();</a>
<span class="sourceLineNo">5846</span><a id="line.5846">        return retVal;</a>
<span class="sourceLineNo">5847</span><a id="line.5847">    }</a>
<span class="sourceLineNo">5848</span><a id="line.5848"></a>
<span class="sourceLineNo">5849</span><a id="line.5849">    public static double calibrateCameraRO(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List&lt;Mat&gt; rvecs, List&lt;Mat&gt; tvecs, Mat newObjPoints) {</a>
<span class="sourceLineNo">5850</span><a id="line.5850">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">5851</span><a id="line.5851">        Mat imagePoints_mat = Converters.vector_Mat_to_Mat(imagePoints);</a>
<span class="sourceLineNo">5852</span><a id="line.5852">        Mat rvecs_mat = new Mat();</a>
<span class="sourceLineNo">5853</span><a id="line.5853">        Mat tvecs_mat = new Mat();</a>
<span class="sourceLineNo">5854</span><a id="line.5854">        double retVal = calibrateCameraRO_2(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, imageSize.width, imageSize.height, iFixedPoint, cameraMatrix.nativeObj, distCoeffs.nativeObj, rvecs_mat.nativeObj, tvecs_mat.nativeObj, newObjPoints.nativeObj);</a>
<span class="sourceLineNo">5855</span><a id="line.5855">        Converters.Mat_to_vector_Mat(rvecs_mat, rvecs);</a>
<span class="sourceLineNo">5856</span><a id="line.5856">        rvecs_mat.release();</a>
<span class="sourceLineNo">5857</span><a id="line.5857">        Converters.Mat_to_vector_Mat(tvecs_mat, tvecs);</a>
<span class="sourceLineNo">5858</span><a id="line.5858">        tvecs_mat.release();</a>
<span class="sourceLineNo">5859</span><a id="line.5859">        return retVal;</a>
<span class="sourceLineNo">5860</span><a id="line.5860">    }</a>
<span class="sourceLineNo">5861</span><a id="line.5861"></a>
<span class="sourceLineNo">5862</span><a id="line.5862"></a>
<span class="sourceLineNo">5863</span><a id="line.5863">    //</a>
<span class="sourceLineNo">5864</span><a id="line.5864">    // C++:  void cv::calibrationMatrixValues(Mat cameraMatrix, Size imageSize, double apertureWidth, double apertureHeight, double&amp; fovx, double&amp; fovy, double&amp; focalLength, Point2d&amp; principalPoint, double&amp; aspectRatio)</a>
<span class="sourceLineNo">5865</span><a id="line.5865">    //</a>
<span class="sourceLineNo">5866</span><a id="line.5866"></a>
<span class="sourceLineNo">5867</span><a id="line.5867">    /**</a>
<span class="sourceLineNo">5868</span><a id="line.5868">     * Computes useful camera characteristics from the camera intrinsic matrix.</a>
<span class="sourceLineNo">5869</span><a id="line.5869">     *</a>
<span class="sourceLineNo">5870</span><a id="line.5870">     * @param cameraMatrix Input camera intrinsic matrix that can be estimated by calibrateCamera or</a>
<span class="sourceLineNo">5871</span><a id="line.5871">     * stereoCalibrate .</a>
<span class="sourceLineNo">5872</span><a id="line.5872">     * @param imageSize Input image size in pixels.</a>
<span class="sourceLineNo">5873</span><a id="line.5873">     * @param apertureWidth Physical width in mm of the sensor.</a>
<span class="sourceLineNo">5874</span><a id="line.5874">     * @param apertureHeight Physical height in mm of the sensor.</a>
<span class="sourceLineNo">5875</span><a id="line.5875">     * @param fovx Output field of view in degrees along the horizontal sensor axis.</a>
<span class="sourceLineNo">5876</span><a id="line.5876">     * @param fovy Output field of view in degrees along the vertical sensor axis.</a>
<span class="sourceLineNo">5877</span><a id="line.5877">     * @param focalLength Focal length of the lens in mm.</a>
<span class="sourceLineNo">5878</span><a id="line.5878">     * @param principalPoint Principal point in mm.</a>
<span class="sourceLineNo">5879</span><a id="line.5879">     * @param aspectRatio \(f_y/f_x\)</a>
<span class="sourceLineNo">5880</span><a id="line.5880">     *</a>
<span class="sourceLineNo">5881</span><a id="line.5881">     * The function computes various useful camera characteristics from the previously estimated camera</a>
<span class="sourceLineNo">5882</span><a id="line.5882">     * matrix.</a>
<span class="sourceLineNo">5883</span><a id="line.5883">     *</a>
<span class="sourceLineNo">5884</span><a id="line.5884">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">5885</span><a id="line.5885">     *    Do keep in mind that the unity measure 'mm' stands for whatever unit of measure one chooses for</a>
<span class="sourceLineNo">5886</span><a id="line.5886">     *     the chessboard pitch (it can thus be any value).</a>
<span class="sourceLineNo">5887</span><a id="line.5887">     */</a>
<span class="sourceLineNo">5888</span><a id="line.5888">    public static void calibrationMatrixValues(Mat cameraMatrix, Size imageSize, double apertureWidth, double apertureHeight, double[] fovx, double[] fovy, double[] focalLength, Point principalPoint, double[] aspectRatio) {</a>
<span class="sourceLineNo">5889</span><a id="line.5889">        double[] fovx_out = new double[1];</a>
<span class="sourceLineNo">5890</span><a id="line.5890">        double[] fovy_out = new double[1];</a>
<span class="sourceLineNo">5891</span><a id="line.5891">        double[] focalLength_out = new double[1];</a>
<span class="sourceLineNo">5892</span><a id="line.5892">        double[] principalPoint_out = new double[2];</a>
<span class="sourceLineNo">5893</span><a id="line.5893">        double[] aspectRatio_out = new double[1];</a>
<span class="sourceLineNo">5894</span><a id="line.5894">        calibrationMatrixValues_0(cameraMatrix.nativeObj, imageSize.width, imageSize.height, apertureWidth, apertureHeight, fovx_out, fovy_out, focalLength_out, principalPoint_out, aspectRatio_out);</a>
<span class="sourceLineNo">5895</span><a id="line.5895">        if(fovx!=null) fovx[0] = (double)fovx_out[0];</a>
<span class="sourceLineNo">5896</span><a id="line.5896">        if(fovy!=null) fovy[0] = (double)fovy_out[0];</a>
<span class="sourceLineNo">5897</span><a id="line.5897">        if(focalLength!=null) focalLength[0] = (double)focalLength_out[0];</a>
<span class="sourceLineNo">5898</span><a id="line.5898">        if(principalPoint!=null){ principalPoint.x = principalPoint_out[0]; principalPoint.y = principalPoint_out[1]; } </a>
<span class="sourceLineNo">5899</span><a id="line.5899">        if(aspectRatio!=null) aspectRatio[0] = (double)aspectRatio_out[0];</a>
<span class="sourceLineNo">5900</span><a id="line.5900">    }</a>
<span class="sourceLineNo">5901</span><a id="line.5901"></a>
<span class="sourceLineNo">5902</span><a id="line.5902"></a>
<span class="sourceLineNo">5903</span><a id="line.5903">    //</a>
<span class="sourceLineNo">5904</span><a id="line.5904">    // C++:  double cv::stereoCalibrate(vector_Mat objectPoints, vector_Mat imagePoints1, vector_Mat imagePoints2, Mat&amp; cameraMatrix1, Mat&amp; distCoeffs1, Mat&amp; cameraMatrix2, Mat&amp; distCoeffs2, Size imageSize, Mat&amp; R, Mat&amp; T, Mat&amp; E, Mat&amp; F, Mat&amp; perViewErrors, int flags = CALIB_FIX_INTRINSIC, TermCriteria criteria = TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6))</a>
<span class="sourceLineNo">5905</span><a id="line.5905">    //</a>
<span class="sourceLineNo">5906</span><a id="line.5906"></a>
<span class="sourceLineNo">5907</span><a id="line.5907">    /**</a>
<span class="sourceLineNo">5908</span><a id="line.5908">     * Calibrates a stereo camera set up. This function finds the intrinsic parameters</a>
<span class="sourceLineNo">5909</span><a id="line.5909">     * for each of the two cameras and the extrinsic parameters between the two cameras.</a>
<span class="sourceLineNo">5910</span><a id="line.5910">     *</a>
<span class="sourceLineNo">5911</span><a id="line.5911">     * @param objectPoints Vector of vectors of the calibration pattern points. The same structure as</a>
<span class="sourceLineNo">5912</span><a id="line.5912">     * in REF: calibrateCamera. For each pattern view, both cameras need to see the same object</a>
<span class="sourceLineNo">5913</span><a id="line.5913">     * points. Therefore, objectPoints.size(), imagePoints1.size(), and imagePoints2.size() need to be</a>
<span class="sourceLineNo">5914</span><a id="line.5914">     * equal as well as objectPoints[i].size(), imagePoints1[i].size(), and imagePoints2[i].size() need to</a>
<span class="sourceLineNo">5915</span><a id="line.5915">     * be equal for each i.</a>
<span class="sourceLineNo">5916</span><a id="line.5916">     * @param imagePoints1 Vector of vectors of the projections of the calibration pattern points,</a>
<span class="sourceLineNo">5917</span><a id="line.5917">     * observed by the first camera. The same structure as in REF: calibrateCamera.</a>
<span class="sourceLineNo">5918</span><a id="line.5918">     * @param imagePoints2 Vector of vectors of the projections of the calibration pattern points,</a>
<span class="sourceLineNo">5919</span><a id="line.5919">     * observed by the second camera. The same structure as in REF: calibrateCamera.</a>
<span class="sourceLineNo">5920</span><a id="line.5920">     * @param cameraMatrix1 Input/output camera intrinsic matrix for the first camera, the same as in</a>
<span class="sourceLineNo">5921</span><a id="line.5921">     * REF: calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below.</a>
<span class="sourceLineNo">5922</span><a id="line.5922">     * @param distCoeffs1 Input/output vector of distortion coefficients, the same as in</a>
<span class="sourceLineNo">5923</span><a id="line.5923">     * REF: calibrateCamera.</a>
<span class="sourceLineNo">5924</span><a id="line.5924">     * @param cameraMatrix2 Input/output second camera intrinsic matrix for the second camera. See description for</a>
<span class="sourceLineNo">5925</span><a id="line.5925">     * cameraMatrix1.</a>
<span class="sourceLineNo">5926</span><a id="line.5926">     * @param distCoeffs2 Input/output lens distortion coefficients for the second camera. See</a>
<span class="sourceLineNo">5927</span><a id="line.5927">     * description for distCoeffs1.</a>
<span class="sourceLineNo">5928</span><a id="line.5928">     * @param imageSize Size of the image used only to initialize the camera intrinsic matrices.</a>
<span class="sourceLineNo">5929</span><a id="line.5929">     * @param R Output rotation matrix. Together with the translation vector T, this matrix brings</a>
<span class="sourceLineNo">5930</span><a id="line.5930">     * points given in the first camera's coordinate system to points in the second camera's</a>
<span class="sourceLineNo">5931</span><a id="line.5931">     * coordinate system. In more technical terms, the tuple of R and T performs a change of basis</a>
<span class="sourceLineNo">5932</span><a id="line.5932">     * from the first camera's coordinate system to the second camera's coordinate system. Due to its</a>
<span class="sourceLineNo">5933</span><a id="line.5933">     * duality, this tuple is equivalent to the position of the first camera with respect to the</a>
<span class="sourceLineNo">5934</span><a id="line.5934">     * second camera coordinate system.</a>
<span class="sourceLineNo">5935</span><a id="line.5935">     * @param T Output translation vector, see description above.</a>
<span class="sourceLineNo">5936</span><a id="line.5936">     * @param E Output essential matrix.</a>
<span class="sourceLineNo">5937</span><a id="line.5937">     * @param F Output fundamental matrix.</a>
<span class="sourceLineNo">5938</span><a id="line.5938">     * @param perViewErrors Output vector of the RMS re-projection error estimated for each pattern view.</a>
<span class="sourceLineNo">5939</span><a id="line.5939">     * @param flags Different flags that may be zero or a combination of the following values:</a>
<span class="sourceLineNo">5940</span><a id="line.5940">     * &lt;ul&gt;</a>
<span class="sourceLineNo">5941</span><a id="line.5941">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5942</span><a id="line.5942">     *    REF: CALIB_FIX_INTRINSIC Fix cameraMatrix? and distCoeffs? so that only R, T, E, and F</a>
<span class="sourceLineNo">5943</span><a id="line.5943">     * matrices are estimated.</a>
<span class="sourceLineNo">5944</span><a id="line.5944">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5945</span><a id="line.5945">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5946</span><a id="line.5946">     *    REF: CALIB_USE_INTRINSIC_GUESS Optimize some or all of the intrinsic parameters</a>
<span class="sourceLineNo">5947</span><a id="line.5947">     * according to the specified flags. Initial values are provided by the user.</a>
<span class="sourceLineNo">5948</span><a id="line.5948">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5949</span><a id="line.5949">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5950</span><a id="line.5950">     *    REF: CALIB_USE_EXTRINSIC_GUESS R and T contain valid initial values that are optimized further.</a>
<span class="sourceLineNo">5951</span><a id="line.5951">     * Otherwise R and T are initialized to the median value of the pattern views (each dimension separately).</a>
<span class="sourceLineNo">5952</span><a id="line.5952">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5953</span><a id="line.5953">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5954</span><a id="line.5954">     *    REF: CALIB_FIX_PRINCIPAL_POINT Fix the principal points during the optimization.</a>
<span class="sourceLineNo">5955</span><a id="line.5955">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5956</span><a id="line.5956">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5957</span><a id="line.5957">     *    REF: CALIB_FIX_FOCAL_LENGTH Fix \(f^{(j)}_x\) and \(f^{(j)}_y\) .</a>
<span class="sourceLineNo">5958</span><a id="line.5958">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5959</span><a id="line.5959">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5960</span><a id="line.5960">     *    REF: CALIB_FIX_ASPECT_RATIO Optimize \(f^{(j)}_y\) . Fix the ratio \(f^{(j)}_x/f^{(j)}_y\)</a>
<span class="sourceLineNo">5961</span><a id="line.5961">     * .</a>
<span class="sourceLineNo">5962</span><a id="line.5962">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5963</span><a id="line.5963">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5964</span><a id="line.5964">     *    REF: CALIB_SAME_FOCAL_LENGTH Enforce \(f^{(0)}_x=f^{(1)}_x\) and \(f^{(0)}_y=f^{(1)}_y\) .</a>
<span class="sourceLineNo">5965</span><a id="line.5965">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5966</span><a id="line.5966">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5967</span><a id="line.5967">     *    REF: CALIB_ZERO_TANGENT_DIST Set tangential distortion coefficients for each camera to</a>
<span class="sourceLineNo">5968</span><a id="line.5968">     * zeros and fix there.</a>
<span class="sourceLineNo">5969</span><a id="line.5969">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5970</span><a id="line.5970">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5971</span><a id="line.5971">     *    REF: CALIB_FIX_K1,..., REF: CALIB_FIX_K6 Do not change the corresponding radial</a>
<span class="sourceLineNo">5972</span><a id="line.5972">     * distortion coefficient during the optimization. If REF: CALIB_USE_INTRINSIC_GUESS is set,</a>
<span class="sourceLineNo">5973</span><a id="line.5973">     * the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0.</a>
<span class="sourceLineNo">5974</span><a id="line.5974">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5975</span><a id="line.5975">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5976</span><a id="line.5976">     *    REF: CALIB_RATIONAL_MODEL Enable coefficients k4, k5, and k6. To provide the backward</a>
<span class="sourceLineNo">5977</span><a id="line.5977">     * compatibility, this extra flag should be explicitly specified to make the calibration</a>
<span class="sourceLineNo">5978</span><a id="line.5978">     * function use the rational model and return 8 coefficients. If the flag is not set, the</a>
<span class="sourceLineNo">5979</span><a id="line.5979">     * function computes and returns only 5 distortion coefficients.</a>
<span class="sourceLineNo">5980</span><a id="line.5980">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5981</span><a id="line.5981">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5982</span><a id="line.5982">     *    REF: CALIB_THIN_PRISM_MODEL Coefficients s1, s2, s3 and s4 are enabled. To provide the</a>
<span class="sourceLineNo">5983</span><a id="line.5983">     * backward compatibility, this extra flag should be explicitly specified to make the</a>
<span class="sourceLineNo">5984</span><a id="line.5984">     * calibration function use the thin prism model and return 12 coefficients. If the flag is not</a>
<span class="sourceLineNo">5985</span><a id="line.5985">     * set, the function computes and returns only 5 distortion coefficients.</a>
<span class="sourceLineNo">5986</span><a id="line.5986">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5987</span><a id="line.5987">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5988</span><a id="line.5988">     *    REF: CALIB_FIX_S1_S2_S3_S4 The thin prism distortion coefficients are not changed during</a>
<span class="sourceLineNo">5989</span><a id="line.5989">     * the optimization. If REF: CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the</a>
<span class="sourceLineNo">5990</span><a id="line.5990">     * supplied distCoeffs matrix is used. Otherwise, it is set to 0.</a>
<span class="sourceLineNo">5991</span><a id="line.5991">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5992</span><a id="line.5992">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5993</span><a id="line.5993">     *    REF: CALIB_TILTED_MODEL Coefficients tauX and tauY are enabled. To provide the</a>
<span class="sourceLineNo">5994</span><a id="line.5994">     * backward compatibility, this extra flag should be explicitly specified to make the</a>
<span class="sourceLineNo">5995</span><a id="line.5995">     * calibration function use the tilted sensor model and return 14 coefficients. If the flag is not</a>
<span class="sourceLineNo">5996</span><a id="line.5996">     * set, the function computes and returns only 5 distortion coefficients.</a>
<span class="sourceLineNo">5997</span><a id="line.5997">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">5998</span><a id="line.5998">     *   &lt;li&gt;</a>
<span class="sourceLineNo">5999</span><a id="line.5999">     *    REF: CALIB_FIX_TAUX_TAUY The coefficients of the tilted sensor model are not changed during</a>
<span class="sourceLineNo">6000</span><a id="line.6000">     * the optimization. If REF: CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the</a>
<span class="sourceLineNo">6001</span><a id="line.6001">     * supplied distCoeffs matrix is used. Otherwise, it is set to 0.</a>
<span class="sourceLineNo">6002</span><a id="line.6002">     * @param criteria Termination criteria for the iterative optimization algorithm.</a>
<span class="sourceLineNo">6003</span><a id="line.6003">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6004</span><a id="line.6004">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">6005</span><a id="line.6005">     *</a>
<span class="sourceLineNo">6006</span><a id="line.6006">     * The function estimates the transformation between two cameras making a stereo pair. If one computes</a>
<span class="sourceLineNo">6007</span><a id="line.6007">     * the poses of an object relative to the first camera and to the second camera,</a>
<span class="sourceLineNo">6008</span><a id="line.6008">     * ( \(R_1\),\(T_1\) ) and (\(R_2\),\(T_2\)), respectively, for a stereo camera where the</a>
<span class="sourceLineNo">6009</span><a id="line.6009">     * relative position and orientation between the two cameras are fixed, then those poses definitely</a>
<span class="sourceLineNo">6010</span><a id="line.6010">     * relate to each other. This means, if the relative position and orientation (\(R\),\(T\)) of the</a>
<span class="sourceLineNo">6011</span><a id="line.6011">     * two cameras is known, it is possible to compute (\(R_2\),\(T_2\)) when (\(R_1\),\(T_1\)) is</a>
<span class="sourceLineNo">6012</span><a id="line.6012">     * given. This is what the described function does. It computes (\(R\),\(T\)) such that:</a>
<span class="sourceLineNo">6013</span><a id="line.6013">     *</a>
<span class="sourceLineNo">6014</span><a id="line.6014">     * \(R_2=R R_1\)</a>
<span class="sourceLineNo">6015</span><a id="line.6015">     * \(T_2=R T_1 + T.\)</a>
<span class="sourceLineNo">6016</span><a id="line.6016">     *</a>
<span class="sourceLineNo">6017</span><a id="line.6017">     * Therefore, one can compute the coordinate representation of a 3D point for the second camera's</a>
<span class="sourceLineNo">6018</span><a id="line.6018">     * coordinate system when given the point's coordinate representation in the first camera's coordinate</a>
<span class="sourceLineNo">6019</span><a id="line.6019">     * system:</a>
<span class="sourceLineNo">6020</span><a id="line.6020">     *</a>
<span class="sourceLineNo">6021</span><a id="line.6021">     * \(\begin{bmatrix}</a>
<span class="sourceLineNo">6022</span><a id="line.6022">     * X_2 \\</a>
<span class="sourceLineNo">6023</span><a id="line.6023">     * Y_2 \\</a>
<span class="sourceLineNo">6024</span><a id="line.6024">     * Z_2 \\</a>
<span class="sourceLineNo">6025</span><a id="line.6025">     * 1</a>
<span class="sourceLineNo">6026</span><a id="line.6026">     * \end{bmatrix} = \begin{bmatrix}</a>
<span class="sourceLineNo">6027</span><a id="line.6027">     * R &amp;amp; T \\</a>
<span class="sourceLineNo">6028</span><a id="line.6028">     * 0 &amp;amp; 1</a>
<span class="sourceLineNo">6029</span><a id="line.6029">     * \end{bmatrix} \begin{bmatrix}</a>
<span class="sourceLineNo">6030</span><a id="line.6030">     * X_1 \\</a>
<span class="sourceLineNo">6031</span><a id="line.6031">     * Y_1 \\</a>
<span class="sourceLineNo">6032</span><a id="line.6032">     * Z_1 \\</a>
<span class="sourceLineNo">6033</span><a id="line.6033">     * 1</a>
<span class="sourceLineNo">6034</span><a id="line.6034">     * \end{bmatrix}.\)</a>
<span class="sourceLineNo">6035</span><a id="line.6035">     *</a>
<span class="sourceLineNo">6036</span><a id="line.6036">     *</a>
<span class="sourceLineNo">6037</span><a id="line.6037">     * Optionally, it computes the essential matrix E:</a>
<span class="sourceLineNo">6038</span><a id="line.6038">     *</a>
<span class="sourceLineNo">6039</span><a id="line.6039">     * \(E= \vecthreethree{0}{-T_2}{T_1}{T_2}{0}{-T_0}{-T_1}{T_0}{0} R\)</a>
<span class="sourceLineNo">6040</span><a id="line.6040">     *</a>
<span class="sourceLineNo">6041</span><a id="line.6041">     * where \(T_i\) are components of the translation vector \(T\) : \(T=[T_0, T_1, T_2]^T\) .</a>
<span class="sourceLineNo">6042</span><a id="line.6042">     * And the function can also compute the fundamental matrix F:</a>
<span class="sourceLineNo">6043</span><a id="line.6043">     *</a>
<span class="sourceLineNo">6044</span><a id="line.6044">     * \(F = cameraMatrix2^{-T}\cdot E \cdot cameraMatrix1^{-1}\)</a>
<span class="sourceLineNo">6045</span><a id="line.6045">     *</a>
<span class="sourceLineNo">6046</span><a id="line.6046">     * Besides the stereo-related information, the function can also perform a full calibration of each of</a>
<span class="sourceLineNo">6047</span><a id="line.6047">     * the two cameras. However, due to the high dimensionality of the parameter space and noise in the</a>
<span class="sourceLineNo">6048</span><a id="line.6048">     * input data, the function can diverge from the correct solution. If the intrinsic parameters can be</a>
<span class="sourceLineNo">6049</span><a id="line.6049">     * estimated with high accuracy for each of the cameras individually (for example, using</a>
<span class="sourceLineNo">6050</span><a id="line.6050">     * calibrateCamera ), you are recommended to do so and then pass REF: CALIB_FIX_INTRINSIC flag to the</a>
<span class="sourceLineNo">6051</span><a id="line.6051">     * function along with the computed intrinsic parameters. Otherwise, if all the parameters are</a>
<span class="sourceLineNo">6052</span><a id="line.6052">     * estimated at once, it makes sense to restrict some parameters, for example, pass</a>
<span class="sourceLineNo">6053</span><a id="line.6053">     *  REF: CALIB_SAME_FOCAL_LENGTH and REF: CALIB_ZERO_TANGENT_DIST flags, which is usually a</a>
<span class="sourceLineNo">6054</span><a id="line.6054">     * reasonable assumption.</a>
<span class="sourceLineNo">6055</span><a id="line.6055">     *</a>
<span class="sourceLineNo">6056</span><a id="line.6056">     * Similarly to calibrateCamera, the function minimizes the total re-projection error for all the</a>
<span class="sourceLineNo">6057</span><a id="line.6057">     * points in all the available views from both cameras. The function returns the final value of the</a>
<span class="sourceLineNo">6058</span><a id="line.6058">     * re-projection error.</a>
<span class="sourceLineNo">6059</span><a id="line.6059">     * @return automatically generated</a>
<span class="sourceLineNo">6060</span><a id="line.6060">     */</a>
<span class="sourceLineNo">6061</span><a id="line.6061">    public static double stereoCalibrateExtended(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints1, List&lt;Mat&gt; imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F, Mat perViewErrors, int flags, TermCriteria criteria) {</a>
<span class="sourceLineNo">6062</span><a id="line.6062">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">6063</span><a id="line.6063">        Mat imagePoints1_mat = Converters.vector_Mat_to_Mat(imagePoints1);</a>
<span class="sourceLineNo">6064</span><a id="line.6064">        Mat imagePoints2_mat = Converters.vector_Mat_to_Mat(imagePoints2);</a>
<span class="sourceLineNo">6065</span><a id="line.6065">        return stereoCalibrateExtended_0(objectPoints_mat.nativeObj, imagePoints1_mat.nativeObj, imagePoints2_mat.nativeObj, cameraMatrix1.nativeObj, distCoeffs1.nativeObj, cameraMatrix2.nativeObj, distCoeffs2.nativeObj, imageSize.width, imageSize.height, R.nativeObj, T.nativeObj, E.nativeObj, F.nativeObj, perViewErrors.nativeObj, flags, criteria.type, criteria.maxCount, criteria.epsilon);</a>
<span class="sourceLineNo">6066</span><a id="line.6066">    }</a>
<span class="sourceLineNo">6067</span><a id="line.6067"></a>
<span class="sourceLineNo">6068</span><a id="line.6068">    /**</a>
<span class="sourceLineNo">6069</span><a id="line.6069">     * Calibrates a stereo camera set up. This function finds the intrinsic parameters</a>
<span class="sourceLineNo">6070</span><a id="line.6070">     * for each of the two cameras and the extrinsic parameters between the two cameras.</a>
<span class="sourceLineNo">6071</span><a id="line.6071">     *</a>
<span class="sourceLineNo">6072</span><a id="line.6072">     * @param objectPoints Vector of vectors of the calibration pattern points. The same structure as</a>
<span class="sourceLineNo">6073</span><a id="line.6073">     * in REF: calibrateCamera. For each pattern view, both cameras need to see the same object</a>
<span class="sourceLineNo">6074</span><a id="line.6074">     * points. Therefore, objectPoints.size(), imagePoints1.size(), and imagePoints2.size() need to be</a>
<span class="sourceLineNo">6075</span><a id="line.6075">     * equal as well as objectPoints[i].size(), imagePoints1[i].size(), and imagePoints2[i].size() need to</a>
<span class="sourceLineNo">6076</span><a id="line.6076">     * be equal for each i.</a>
<span class="sourceLineNo">6077</span><a id="line.6077">     * @param imagePoints1 Vector of vectors of the projections of the calibration pattern points,</a>
<span class="sourceLineNo">6078</span><a id="line.6078">     * observed by the first camera. The same structure as in REF: calibrateCamera.</a>
<span class="sourceLineNo">6079</span><a id="line.6079">     * @param imagePoints2 Vector of vectors of the projections of the calibration pattern points,</a>
<span class="sourceLineNo">6080</span><a id="line.6080">     * observed by the second camera. The same structure as in REF: calibrateCamera.</a>
<span class="sourceLineNo">6081</span><a id="line.6081">     * @param cameraMatrix1 Input/output camera intrinsic matrix for the first camera, the same as in</a>
<span class="sourceLineNo">6082</span><a id="line.6082">     * REF: calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below.</a>
<span class="sourceLineNo">6083</span><a id="line.6083">     * @param distCoeffs1 Input/output vector of distortion coefficients, the same as in</a>
<span class="sourceLineNo">6084</span><a id="line.6084">     * REF: calibrateCamera.</a>
<span class="sourceLineNo">6085</span><a id="line.6085">     * @param cameraMatrix2 Input/output second camera intrinsic matrix for the second camera. See description for</a>
<span class="sourceLineNo">6086</span><a id="line.6086">     * cameraMatrix1.</a>
<span class="sourceLineNo">6087</span><a id="line.6087">     * @param distCoeffs2 Input/output lens distortion coefficients for the second camera. See</a>
<span class="sourceLineNo">6088</span><a id="line.6088">     * description for distCoeffs1.</a>
<span class="sourceLineNo">6089</span><a id="line.6089">     * @param imageSize Size of the image used only to initialize the camera intrinsic matrices.</a>
<span class="sourceLineNo">6090</span><a id="line.6090">     * @param R Output rotation matrix. Together with the translation vector T, this matrix brings</a>
<span class="sourceLineNo">6091</span><a id="line.6091">     * points given in the first camera's coordinate system to points in the second camera's</a>
<span class="sourceLineNo">6092</span><a id="line.6092">     * coordinate system. In more technical terms, the tuple of R and T performs a change of basis</a>
<span class="sourceLineNo">6093</span><a id="line.6093">     * from the first camera's coordinate system to the second camera's coordinate system. Due to its</a>
<span class="sourceLineNo">6094</span><a id="line.6094">     * duality, this tuple is equivalent to the position of the first camera with respect to the</a>
<span class="sourceLineNo">6095</span><a id="line.6095">     * second camera coordinate system.</a>
<span class="sourceLineNo">6096</span><a id="line.6096">     * @param T Output translation vector, see description above.</a>
<span class="sourceLineNo">6097</span><a id="line.6097">     * @param E Output essential matrix.</a>
<span class="sourceLineNo">6098</span><a id="line.6098">     * @param F Output fundamental matrix.</a>
<span class="sourceLineNo">6099</span><a id="line.6099">     * @param perViewErrors Output vector of the RMS re-projection error estimated for each pattern view.</a>
<span class="sourceLineNo">6100</span><a id="line.6100">     * @param flags Different flags that may be zero or a combination of the following values:</a>
<span class="sourceLineNo">6101</span><a id="line.6101">     * &lt;ul&gt;</a>
<span class="sourceLineNo">6102</span><a id="line.6102">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6103</span><a id="line.6103">     *    REF: CALIB_FIX_INTRINSIC Fix cameraMatrix? and distCoeffs? so that only R, T, E, and F</a>
<span class="sourceLineNo">6104</span><a id="line.6104">     * matrices are estimated.</a>
<span class="sourceLineNo">6105</span><a id="line.6105">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6106</span><a id="line.6106">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6107</span><a id="line.6107">     *    REF: CALIB_USE_INTRINSIC_GUESS Optimize some or all of the intrinsic parameters</a>
<span class="sourceLineNo">6108</span><a id="line.6108">     * according to the specified flags. Initial values are provided by the user.</a>
<span class="sourceLineNo">6109</span><a id="line.6109">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6110</span><a id="line.6110">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6111</span><a id="line.6111">     *    REF: CALIB_USE_EXTRINSIC_GUESS R and T contain valid initial values that are optimized further.</a>
<span class="sourceLineNo">6112</span><a id="line.6112">     * Otherwise R and T are initialized to the median value of the pattern views (each dimension separately).</a>
<span class="sourceLineNo">6113</span><a id="line.6113">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6114</span><a id="line.6114">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6115</span><a id="line.6115">     *    REF: CALIB_FIX_PRINCIPAL_POINT Fix the principal points during the optimization.</a>
<span class="sourceLineNo">6116</span><a id="line.6116">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6117</span><a id="line.6117">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6118</span><a id="line.6118">     *    REF: CALIB_FIX_FOCAL_LENGTH Fix \(f^{(j)}_x\) and \(f^{(j)}_y\) .</a>
<span class="sourceLineNo">6119</span><a id="line.6119">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6120</span><a id="line.6120">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6121</span><a id="line.6121">     *    REF: CALIB_FIX_ASPECT_RATIO Optimize \(f^{(j)}_y\) . Fix the ratio \(f^{(j)}_x/f^{(j)}_y\)</a>
<span class="sourceLineNo">6122</span><a id="line.6122">     * .</a>
<span class="sourceLineNo">6123</span><a id="line.6123">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6124</span><a id="line.6124">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6125</span><a id="line.6125">     *    REF: CALIB_SAME_FOCAL_LENGTH Enforce \(f^{(0)}_x=f^{(1)}_x\) and \(f^{(0)}_y=f^{(1)}_y\) .</a>
<span class="sourceLineNo">6126</span><a id="line.6126">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6127</span><a id="line.6127">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6128</span><a id="line.6128">     *    REF: CALIB_ZERO_TANGENT_DIST Set tangential distortion coefficients for each camera to</a>
<span class="sourceLineNo">6129</span><a id="line.6129">     * zeros and fix there.</a>
<span class="sourceLineNo">6130</span><a id="line.6130">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6131</span><a id="line.6131">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6132</span><a id="line.6132">     *    REF: CALIB_FIX_K1,..., REF: CALIB_FIX_K6 Do not change the corresponding radial</a>
<span class="sourceLineNo">6133</span><a id="line.6133">     * distortion coefficient during the optimization. If REF: CALIB_USE_INTRINSIC_GUESS is set,</a>
<span class="sourceLineNo">6134</span><a id="line.6134">     * the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0.</a>
<span class="sourceLineNo">6135</span><a id="line.6135">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6136</span><a id="line.6136">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6137</span><a id="line.6137">     *    REF: CALIB_RATIONAL_MODEL Enable coefficients k4, k5, and k6. To provide the backward</a>
<span class="sourceLineNo">6138</span><a id="line.6138">     * compatibility, this extra flag should be explicitly specified to make the calibration</a>
<span class="sourceLineNo">6139</span><a id="line.6139">     * function use the rational model and return 8 coefficients. If the flag is not set, the</a>
<span class="sourceLineNo">6140</span><a id="line.6140">     * function computes and returns only 5 distortion coefficients.</a>
<span class="sourceLineNo">6141</span><a id="line.6141">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6142</span><a id="line.6142">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6143</span><a id="line.6143">     *    REF: CALIB_THIN_PRISM_MODEL Coefficients s1, s2, s3 and s4 are enabled. To provide the</a>
<span class="sourceLineNo">6144</span><a id="line.6144">     * backward compatibility, this extra flag should be explicitly specified to make the</a>
<span class="sourceLineNo">6145</span><a id="line.6145">     * calibration function use the thin prism model and return 12 coefficients. If the flag is not</a>
<span class="sourceLineNo">6146</span><a id="line.6146">     * set, the function computes and returns only 5 distortion coefficients.</a>
<span class="sourceLineNo">6147</span><a id="line.6147">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6148</span><a id="line.6148">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6149</span><a id="line.6149">     *    REF: CALIB_FIX_S1_S2_S3_S4 The thin prism distortion coefficients are not changed during</a>
<span class="sourceLineNo">6150</span><a id="line.6150">     * the optimization. If REF: CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the</a>
<span class="sourceLineNo">6151</span><a id="line.6151">     * supplied distCoeffs matrix is used. Otherwise, it is set to 0.</a>
<span class="sourceLineNo">6152</span><a id="line.6152">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6153</span><a id="line.6153">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6154</span><a id="line.6154">     *    REF: CALIB_TILTED_MODEL Coefficients tauX and tauY are enabled. To provide the</a>
<span class="sourceLineNo">6155</span><a id="line.6155">     * backward compatibility, this extra flag should be explicitly specified to make the</a>
<span class="sourceLineNo">6156</span><a id="line.6156">     * calibration function use the tilted sensor model and return 14 coefficients. If the flag is not</a>
<span class="sourceLineNo">6157</span><a id="line.6157">     * set, the function computes and returns only 5 distortion coefficients.</a>
<span class="sourceLineNo">6158</span><a id="line.6158">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6159</span><a id="line.6159">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6160</span><a id="line.6160">     *    REF: CALIB_FIX_TAUX_TAUY The coefficients of the tilted sensor model are not changed during</a>
<span class="sourceLineNo">6161</span><a id="line.6161">     * the optimization. If REF: CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the</a>
<span class="sourceLineNo">6162</span><a id="line.6162">     * supplied distCoeffs matrix is used. Otherwise, it is set to 0.</a>
<span class="sourceLineNo">6163</span><a id="line.6163">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6164</span><a id="line.6164">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">6165</span><a id="line.6165">     *</a>
<span class="sourceLineNo">6166</span><a id="line.6166">     * The function estimates the transformation between two cameras making a stereo pair. If one computes</a>
<span class="sourceLineNo">6167</span><a id="line.6167">     * the poses of an object relative to the first camera and to the second camera,</a>
<span class="sourceLineNo">6168</span><a id="line.6168">     * ( \(R_1\),\(T_1\) ) and (\(R_2\),\(T_2\)), respectively, for a stereo camera where the</a>
<span class="sourceLineNo">6169</span><a id="line.6169">     * relative position and orientation between the two cameras are fixed, then those poses definitely</a>
<span class="sourceLineNo">6170</span><a id="line.6170">     * relate to each other. This means, if the relative position and orientation (\(R\),\(T\)) of the</a>
<span class="sourceLineNo">6171</span><a id="line.6171">     * two cameras is known, it is possible to compute (\(R_2\),\(T_2\)) when (\(R_1\),\(T_1\)) is</a>
<span class="sourceLineNo">6172</span><a id="line.6172">     * given. This is what the described function does. It computes (\(R\),\(T\)) such that:</a>
<span class="sourceLineNo">6173</span><a id="line.6173">     *</a>
<span class="sourceLineNo">6174</span><a id="line.6174">     * \(R_2=R R_1\)</a>
<span class="sourceLineNo">6175</span><a id="line.6175">     * \(T_2=R T_1 + T.\)</a>
<span class="sourceLineNo">6176</span><a id="line.6176">     *</a>
<span class="sourceLineNo">6177</span><a id="line.6177">     * Therefore, one can compute the coordinate representation of a 3D point for the second camera's</a>
<span class="sourceLineNo">6178</span><a id="line.6178">     * coordinate system when given the point's coordinate representation in the first camera's coordinate</a>
<span class="sourceLineNo">6179</span><a id="line.6179">     * system:</a>
<span class="sourceLineNo">6180</span><a id="line.6180">     *</a>
<span class="sourceLineNo">6181</span><a id="line.6181">     * \(\begin{bmatrix}</a>
<span class="sourceLineNo">6182</span><a id="line.6182">     * X_2 \\</a>
<span class="sourceLineNo">6183</span><a id="line.6183">     * Y_2 \\</a>
<span class="sourceLineNo">6184</span><a id="line.6184">     * Z_2 \\</a>
<span class="sourceLineNo">6185</span><a id="line.6185">     * 1</a>
<span class="sourceLineNo">6186</span><a id="line.6186">     * \end{bmatrix} = \begin{bmatrix}</a>
<span class="sourceLineNo">6187</span><a id="line.6187">     * R &amp;amp; T \\</a>
<span class="sourceLineNo">6188</span><a id="line.6188">     * 0 &amp;amp; 1</a>
<span class="sourceLineNo">6189</span><a id="line.6189">     * \end{bmatrix} \begin{bmatrix}</a>
<span class="sourceLineNo">6190</span><a id="line.6190">     * X_1 \\</a>
<span class="sourceLineNo">6191</span><a id="line.6191">     * Y_1 \\</a>
<span class="sourceLineNo">6192</span><a id="line.6192">     * Z_1 \\</a>
<span class="sourceLineNo">6193</span><a id="line.6193">     * 1</a>
<span class="sourceLineNo">6194</span><a id="line.6194">     * \end{bmatrix}.\)</a>
<span class="sourceLineNo">6195</span><a id="line.6195">     *</a>
<span class="sourceLineNo">6196</span><a id="line.6196">     *</a>
<span class="sourceLineNo">6197</span><a id="line.6197">     * Optionally, it computes the essential matrix E:</a>
<span class="sourceLineNo">6198</span><a id="line.6198">     *</a>
<span class="sourceLineNo">6199</span><a id="line.6199">     * \(E= \vecthreethree{0}{-T_2}{T_1}{T_2}{0}{-T_0}{-T_1}{T_0}{0} R\)</a>
<span class="sourceLineNo">6200</span><a id="line.6200">     *</a>
<span class="sourceLineNo">6201</span><a id="line.6201">     * where \(T_i\) are components of the translation vector \(T\) : \(T=[T_0, T_1, T_2]^T\) .</a>
<span class="sourceLineNo">6202</span><a id="line.6202">     * And the function can also compute the fundamental matrix F:</a>
<span class="sourceLineNo">6203</span><a id="line.6203">     *</a>
<span class="sourceLineNo">6204</span><a id="line.6204">     * \(F = cameraMatrix2^{-T}\cdot E \cdot cameraMatrix1^{-1}\)</a>
<span class="sourceLineNo">6205</span><a id="line.6205">     *</a>
<span class="sourceLineNo">6206</span><a id="line.6206">     * Besides the stereo-related information, the function can also perform a full calibration of each of</a>
<span class="sourceLineNo">6207</span><a id="line.6207">     * the two cameras. However, due to the high dimensionality of the parameter space and noise in the</a>
<span class="sourceLineNo">6208</span><a id="line.6208">     * input data, the function can diverge from the correct solution. If the intrinsic parameters can be</a>
<span class="sourceLineNo">6209</span><a id="line.6209">     * estimated with high accuracy for each of the cameras individually (for example, using</a>
<span class="sourceLineNo">6210</span><a id="line.6210">     * calibrateCamera ), you are recommended to do so and then pass REF: CALIB_FIX_INTRINSIC flag to the</a>
<span class="sourceLineNo">6211</span><a id="line.6211">     * function along with the computed intrinsic parameters. Otherwise, if all the parameters are</a>
<span class="sourceLineNo">6212</span><a id="line.6212">     * estimated at once, it makes sense to restrict some parameters, for example, pass</a>
<span class="sourceLineNo">6213</span><a id="line.6213">     *  REF: CALIB_SAME_FOCAL_LENGTH and REF: CALIB_ZERO_TANGENT_DIST flags, which is usually a</a>
<span class="sourceLineNo">6214</span><a id="line.6214">     * reasonable assumption.</a>
<span class="sourceLineNo">6215</span><a id="line.6215">     *</a>
<span class="sourceLineNo">6216</span><a id="line.6216">     * Similarly to calibrateCamera, the function minimizes the total re-projection error for all the</a>
<span class="sourceLineNo">6217</span><a id="line.6217">     * points in all the available views from both cameras. The function returns the final value of the</a>
<span class="sourceLineNo">6218</span><a id="line.6218">     * re-projection error.</a>
<span class="sourceLineNo">6219</span><a id="line.6219">     * @return automatically generated</a>
<span class="sourceLineNo">6220</span><a id="line.6220">     */</a>
<span class="sourceLineNo">6221</span><a id="line.6221">    public static double stereoCalibrateExtended(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints1, List&lt;Mat&gt; imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F, Mat perViewErrors, int flags) {</a>
<span class="sourceLineNo">6222</span><a id="line.6222">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">6223</span><a id="line.6223">        Mat imagePoints1_mat = Converters.vector_Mat_to_Mat(imagePoints1);</a>
<span class="sourceLineNo">6224</span><a id="line.6224">        Mat imagePoints2_mat = Converters.vector_Mat_to_Mat(imagePoints2);</a>
<span class="sourceLineNo">6225</span><a id="line.6225">        return stereoCalibrateExtended_1(objectPoints_mat.nativeObj, imagePoints1_mat.nativeObj, imagePoints2_mat.nativeObj, cameraMatrix1.nativeObj, distCoeffs1.nativeObj, cameraMatrix2.nativeObj, distCoeffs2.nativeObj, imageSize.width, imageSize.height, R.nativeObj, T.nativeObj, E.nativeObj, F.nativeObj, perViewErrors.nativeObj, flags);</a>
<span class="sourceLineNo">6226</span><a id="line.6226">    }</a>
<span class="sourceLineNo">6227</span><a id="line.6227"></a>
<span class="sourceLineNo">6228</span><a id="line.6228">    /**</a>
<span class="sourceLineNo">6229</span><a id="line.6229">     * Calibrates a stereo camera set up. This function finds the intrinsic parameters</a>
<span class="sourceLineNo">6230</span><a id="line.6230">     * for each of the two cameras and the extrinsic parameters between the two cameras.</a>
<span class="sourceLineNo">6231</span><a id="line.6231">     *</a>
<span class="sourceLineNo">6232</span><a id="line.6232">     * @param objectPoints Vector of vectors of the calibration pattern points. The same structure as</a>
<span class="sourceLineNo">6233</span><a id="line.6233">     * in REF: calibrateCamera. For each pattern view, both cameras need to see the same object</a>
<span class="sourceLineNo">6234</span><a id="line.6234">     * points. Therefore, objectPoints.size(), imagePoints1.size(), and imagePoints2.size() need to be</a>
<span class="sourceLineNo">6235</span><a id="line.6235">     * equal as well as objectPoints[i].size(), imagePoints1[i].size(), and imagePoints2[i].size() need to</a>
<span class="sourceLineNo">6236</span><a id="line.6236">     * be equal for each i.</a>
<span class="sourceLineNo">6237</span><a id="line.6237">     * @param imagePoints1 Vector of vectors of the projections of the calibration pattern points,</a>
<span class="sourceLineNo">6238</span><a id="line.6238">     * observed by the first camera. The same structure as in REF: calibrateCamera.</a>
<span class="sourceLineNo">6239</span><a id="line.6239">     * @param imagePoints2 Vector of vectors of the projections of the calibration pattern points,</a>
<span class="sourceLineNo">6240</span><a id="line.6240">     * observed by the second camera. The same structure as in REF: calibrateCamera.</a>
<span class="sourceLineNo">6241</span><a id="line.6241">     * @param cameraMatrix1 Input/output camera intrinsic matrix for the first camera, the same as in</a>
<span class="sourceLineNo">6242</span><a id="line.6242">     * REF: calibrateCamera. Furthermore, for the stereo case, additional flags may be used, see below.</a>
<span class="sourceLineNo">6243</span><a id="line.6243">     * @param distCoeffs1 Input/output vector of distortion coefficients, the same as in</a>
<span class="sourceLineNo">6244</span><a id="line.6244">     * REF: calibrateCamera.</a>
<span class="sourceLineNo">6245</span><a id="line.6245">     * @param cameraMatrix2 Input/output second camera intrinsic matrix for the second camera. See description for</a>
<span class="sourceLineNo">6246</span><a id="line.6246">     * cameraMatrix1.</a>
<span class="sourceLineNo">6247</span><a id="line.6247">     * @param distCoeffs2 Input/output lens distortion coefficients for the second camera. See</a>
<span class="sourceLineNo">6248</span><a id="line.6248">     * description for distCoeffs1.</a>
<span class="sourceLineNo">6249</span><a id="line.6249">     * @param imageSize Size of the image used only to initialize the camera intrinsic matrices.</a>
<span class="sourceLineNo">6250</span><a id="line.6250">     * @param R Output rotation matrix. Together with the translation vector T, this matrix brings</a>
<span class="sourceLineNo">6251</span><a id="line.6251">     * points given in the first camera's coordinate system to points in the second camera's</a>
<span class="sourceLineNo">6252</span><a id="line.6252">     * coordinate system. In more technical terms, the tuple of R and T performs a change of basis</a>
<span class="sourceLineNo">6253</span><a id="line.6253">     * from the first camera's coordinate system to the second camera's coordinate system. Due to its</a>
<span class="sourceLineNo">6254</span><a id="line.6254">     * duality, this tuple is equivalent to the position of the first camera with respect to the</a>
<span class="sourceLineNo">6255</span><a id="line.6255">     * second camera coordinate system.</a>
<span class="sourceLineNo">6256</span><a id="line.6256">     * @param T Output translation vector, see description above.</a>
<span class="sourceLineNo">6257</span><a id="line.6257">     * @param E Output essential matrix.</a>
<span class="sourceLineNo">6258</span><a id="line.6258">     * @param F Output fundamental matrix.</a>
<span class="sourceLineNo">6259</span><a id="line.6259">     * @param perViewErrors Output vector of the RMS re-projection error estimated for each pattern view.</a>
<span class="sourceLineNo">6260</span><a id="line.6260">     * &lt;ul&gt;</a>
<span class="sourceLineNo">6261</span><a id="line.6261">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6262</span><a id="line.6262">     *    REF: CALIB_FIX_INTRINSIC Fix cameraMatrix? and distCoeffs? so that only R, T, E, and F</a>
<span class="sourceLineNo">6263</span><a id="line.6263">     * matrices are estimated.</a>
<span class="sourceLineNo">6264</span><a id="line.6264">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6265</span><a id="line.6265">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6266</span><a id="line.6266">     *    REF: CALIB_USE_INTRINSIC_GUESS Optimize some or all of the intrinsic parameters</a>
<span class="sourceLineNo">6267</span><a id="line.6267">     * according to the specified flags. Initial values are provided by the user.</a>
<span class="sourceLineNo">6268</span><a id="line.6268">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6269</span><a id="line.6269">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6270</span><a id="line.6270">     *    REF: CALIB_USE_EXTRINSIC_GUESS R and T contain valid initial values that are optimized further.</a>
<span class="sourceLineNo">6271</span><a id="line.6271">     * Otherwise R and T are initialized to the median value of the pattern views (each dimension separately).</a>
<span class="sourceLineNo">6272</span><a id="line.6272">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6273</span><a id="line.6273">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6274</span><a id="line.6274">     *    REF: CALIB_FIX_PRINCIPAL_POINT Fix the principal points during the optimization.</a>
<span class="sourceLineNo">6275</span><a id="line.6275">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6276</span><a id="line.6276">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6277</span><a id="line.6277">     *    REF: CALIB_FIX_FOCAL_LENGTH Fix \(f^{(j)}_x\) and \(f^{(j)}_y\) .</a>
<span class="sourceLineNo">6278</span><a id="line.6278">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6279</span><a id="line.6279">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6280</span><a id="line.6280">     *    REF: CALIB_FIX_ASPECT_RATIO Optimize \(f^{(j)}_y\) . Fix the ratio \(f^{(j)}_x/f^{(j)}_y\)</a>
<span class="sourceLineNo">6281</span><a id="line.6281">     * .</a>
<span class="sourceLineNo">6282</span><a id="line.6282">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6283</span><a id="line.6283">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6284</span><a id="line.6284">     *    REF: CALIB_SAME_FOCAL_LENGTH Enforce \(f^{(0)}_x=f^{(1)}_x\) and \(f^{(0)}_y=f^{(1)}_y\) .</a>
<span class="sourceLineNo">6285</span><a id="line.6285">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6286</span><a id="line.6286">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6287</span><a id="line.6287">     *    REF: CALIB_ZERO_TANGENT_DIST Set tangential distortion coefficients for each camera to</a>
<span class="sourceLineNo">6288</span><a id="line.6288">     * zeros and fix there.</a>
<span class="sourceLineNo">6289</span><a id="line.6289">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6290</span><a id="line.6290">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6291</span><a id="line.6291">     *    REF: CALIB_FIX_K1,..., REF: CALIB_FIX_K6 Do not change the corresponding radial</a>
<span class="sourceLineNo">6292</span><a id="line.6292">     * distortion coefficient during the optimization. If REF: CALIB_USE_INTRINSIC_GUESS is set,</a>
<span class="sourceLineNo">6293</span><a id="line.6293">     * the coefficient from the supplied distCoeffs matrix is used. Otherwise, it is set to 0.</a>
<span class="sourceLineNo">6294</span><a id="line.6294">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6295</span><a id="line.6295">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6296</span><a id="line.6296">     *    REF: CALIB_RATIONAL_MODEL Enable coefficients k4, k5, and k6. To provide the backward</a>
<span class="sourceLineNo">6297</span><a id="line.6297">     * compatibility, this extra flag should be explicitly specified to make the calibration</a>
<span class="sourceLineNo">6298</span><a id="line.6298">     * function use the rational model and return 8 coefficients. If the flag is not set, the</a>
<span class="sourceLineNo">6299</span><a id="line.6299">     * function computes and returns only 5 distortion coefficients.</a>
<span class="sourceLineNo">6300</span><a id="line.6300">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6301</span><a id="line.6301">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6302</span><a id="line.6302">     *    REF: CALIB_THIN_PRISM_MODEL Coefficients s1, s2, s3 and s4 are enabled. To provide the</a>
<span class="sourceLineNo">6303</span><a id="line.6303">     * backward compatibility, this extra flag should be explicitly specified to make the</a>
<span class="sourceLineNo">6304</span><a id="line.6304">     * calibration function use the thin prism model and return 12 coefficients. If the flag is not</a>
<span class="sourceLineNo">6305</span><a id="line.6305">     * set, the function computes and returns only 5 distortion coefficients.</a>
<span class="sourceLineNo">6306</span><a id="line.6306">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6307</span><a id="line.6307">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6308</span><a id="line.6308">     *    REF: CALIB_FIX_S1_S2_S3_S4 The thin prism distortion coefficients are not changed during</a>
<span class="sourceLineNo">6309</span><a id="line.6309">     * the optimization. If REF: CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the</a>
<span class="sourceLineNo">6310</span><a id="line.6310">     * supplied distCoeffs matrix is used. Otherwise, it is set to 0.</a>
<span class="sourceLineNo">6311</span><a id="line.6311">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6312</span><a id="line.6312">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6313</span><a id="line.6313">     *    REF: CALIB_TILTED_MODEL Coefficients tauX and tauY are enabled. To provide the</a>
<span class="sourceLineNo">6314</span><a id="line.6314">     * backward compatibility, this extra flag should be explicitly specified to make the</a>
<span class="sourceLineNo">6315</span><a id="line.6315">     * calibration function use the tilted sensor model and return 14 coefficients. If the flag is not</a>
<span class="sourceLineNo">6316</span><a id="line.6316">     * set, the function computes and returns only 5 distortion coefficients.</a>
<span class="sourceLineNo">6317</span><a id="line.6317">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6318</span><a id="line.6318">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6319</span><a id="line.6319">     *    REF: CALIB_FIX_TAUX_TAUY The coefficients of the tilted sensor model are not changed during</a>
<span class="sourceLineNo">6320</span><a id="line.6320">     * the optimization. If REF: CALIB_USE_INTRINSIC_GUESS is set, the coefficient from the</a>
<span class="sourceLineNo">6321</span><a id="line.6321">     * supplied distCoeffs matrix is used. Otherwise, it is set to 0.</a>
<span class="sourceLineNo">6322</span><a id="line.6322">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6323</span><a id="line.6323">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">6324</span><a id="line.6324">     *</a>
<span class="sourceLineNo">6325</span><a id="line.6325">     * The function estimates the transformation between two cameras making a stereo pair. If one computes</a>
<span class="sourceLineNo">6326</span><a id="line.6326">     * the poses of an object relative to the first camera and to the second camera,</a>
<span class="sourceLineNo">6327</span><a id="line.6327">     * ( \(R_1\),\(T_1\) ) and (\(R_2\),\(T_2\)), respectively, for a stereo camera where the</a>
<span class="sourceLineNo">6328</span><a id="line.6328">     * relative position and orientation between the two cameras are fixed, then those poses definitely</a>
<span class="sourceLineNo">6329</span><a id="line.6329">     * relate to each other. This means, if the relative position and orientation (\(R\),\(T\)) of the</a>
<span class="sourceLineNo">6330</span><a id="line.6330">     * two cameras is known, it is possible to compute (\(R_2\),\(T_2\)) when (\(R_1\),\(T_1\)) is</a>
<span class="sourceLineNo">6331</span><a id="line.6331">     * given. This is what the described function does. It computes (\(R\),\(T\)) such that:</a>
<span class="sourceLineNo">6332</span><a id="line.6332">     *</a>
<span class="sourceLineNo">6333</span><a id="line.6333">     * \(R_2=R R_1\)</a>
<span class="sourceLineNo">6334</span><a id="line.6334">     * \(T_2=R T_1 + T.\)</a>
<span class="sourceLineNo">6335</span><a id="line.6335">     *</a>
<span class="sourceLineNo">6336</span><a id="line.6336">     * Therefore, one can compute the coordinate representation of a 3D point for the second camera's</a>
<span class="sourceLineNo">6337</span><a id="line.6337">     * coordinate system when given the point's coordinate representation in the first camera's coordinate</a>
<span class="sourceLineNo">6338</span><a id="line.6338">     * system:</a>
<span class="sourceLineNo">6339</span><a id="line.6339">     *</a>
<span class="sourceLineNo">6340</span><a id="line.6340">     * \(\begin{bmatrix}</a>
<span class="sourceLineNo">6341</span><a id="line.6341">     * X_2 \\</a>
<span class="sourceLineNo">6342</span><a id="line.6342">     * Y_2 \\</a>
<span class="sourceLineNo">6343</span><a id="line.6343">     * Z_2 \\</a>
<span class="sourceLineNo">6344</span><a id="line.6344">     * 1</a>
<span class="sourceLineNo">6345</span><a id="line.6345">     * \end{bmatrix} = \begin{bmatrix}</a>
<span class="sourceLineNo">6346</span><a id="line.6346">     * R &amp;amp; T \\</a>
<span class="sourceLineNo">6347</span><a id="line.6347">     * 0 &amp;amp; 1</a>
<span class="sourceLineNo">6348</span><a id="line.6348">     * \end{bmatrix} \begin{bmatrix}</a>
<span class="sourceLineNo">6349</span><a id="line.6349">     * X_1 \\</a>
<span class="sourceLineNo">6350</span><a id="line.6350">     * Y_1 \\</a>
<span class="sourceLineNo">6351</span><a id="line.6351">     * Z_1 \\</a>
<span class="sourceLineNo">6352</span><a id="line.6352">     * 1</a>
<span class="sourceLineNo">6353</span><a id="line.6353">     * \end{bmatrix}.\)</a>
<span class="sourceLineNo">6354</span><a id="line.6354">     *</a>
<span class="sourceLineNo">6355</span><a id="line.6355">     *</a>
<span class="sourceLineNo">6356</span><a id="line.6356">     * Optionally, it computes the essential matrix E:</a>
<span class="sourceLineNo">6357</span><a id="line.6357">     *</a>
<span class="sourceLineNo">6358</span><a id="line.6358">     * \(E= \vecthreethree{0}{-T_2}{T_1}{T_2}{0}{-T_0}{-T_1}{T_0}{0} R\)</a>
<span class="sourceLineNo">6359</span><a id="line.6359">     *</a>
<span class="sourceLineNo">6360</span><a id="line.6360">     * where \(T_i\) are components of the translation vector \(T\) : \(T=[T_0, T_1, T_2]^T\) .</a>
<span class="sourceLineNo">6361</span><a id="line.6361">     * And the function can also compute the fundamental matrix F:</a>
<span class="sourceLineNo">6362</span><a id="line.6362">     *</a>
<span class="sourceLineNo">6363</span><a id="line.6363">     * \(F = cameraMatrix2^{-T}\cdot E \cdot cameraMatrix1^{-1}\)</a>
<span class="sourceLineNo">6364</span><a id="line.6364">     *</a>
<span class="sourceLineNo">6365</span><a id="line.6365">     * Besides the stereo-related information, the function can also perform a full calibration of each of</a>
<span class="sourceLineNo">6366</span><a id="line.6366">     * the two cameras. However, due to the high dimensionality of the parameter space and noise in the</a>
<span class="sourceLineNo">6367</span><a id="line.6367">     * input data, the function can diverge from the correct solution. If the intrinsic parameters can be</a>
<span class="sourceLineNo">6368</span><a id="line.6368">     * estimated with high accuracy for each of the cameras individually (for example, using</a>
<span class="sourceLineNo">6369</span><a id="line.6369">     * calibrateCamera ), you are recommended to do so and then pass REF: CALIB_FIX_INTRINSIC flag to the</a>
<span class="sourceLineNo">6370</span><a id="line.6370">     * function along with the computed intrinsic parameters. Otherwise, if all the parameters are</a>
<span class="sourceLineNo">6371</span><a id="line.6371">     * estimated at once, it makes sense to restrict some parameters, for example, pass</a>
<span class="sourceLineNo">6372</span><a id="line.6372">     *  REF: CALIB_SAME_FOCAL_LENGTH and REF: CALIB_ZERO_TANGENT_DIST flags, which is usually a</a>
<span class="sourceLineNo">6373</span><a id="line.6373">     * reasonable assumption.</a>
<span class="sourceLineNo">6374</span><a id="line.6374">     *</a>
<span class="sourceLineNo">6375</span><a id="line.6375">     * Similarly to calibrateCamera, the function minimizes the total re-projection error for all the</a>
<span class="sourceLineNo">6376</span><a id="line.6376">     * points in all the available views from both cameras. The function returns the final value of the</a>
<span class="sourceLineNo">6377</span><a id="line.6377">     * re-projection error.</a>
<span class="sourceLineNo">6378</span><a id="line.6378">     * @return automatically generated</a>
<span class="sourceLineNo">6379</span><a id="line.6379">     */</a>
<span class="sourceLineNo">6380</span><a id="line.6380">    public static double stereoCalibrateExtended(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints1, List&lt;Mat&gt; imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F, Mat perViewErrors) {</a>
<span class="sourceLineNo">6381</span><a id="line.6381">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">6382</span><a id="line.6382">        Mat imagePoints1_mat = Converters.vector_Mat_to_Mat(imagePoints1);</a>
<span class="sourceLineNo">6383</span><a id="line.6383">        Mat imagePoints2_mat = Converters.vector_Mat_to_Mat(imagePoints2);</a>
<span class="sourceLineNo">6384</span><a id="line.6384">        return stereoCalibrateExtended_2(objectPoints_mat.nativeObj, imagePoints1_mat.nativeObj, imagePoints2_mat.nativeObj, cameraMatrix1.nativeObj, distCoeffs1.nativeObj, cameraMatrix2.nativeObj, distCoeffs2.nativeObj, imageSize.width, imageSize.height, R.nativeObj, T.nativeObj, E.nativeObj, F.nativeObj, perViewErrors.nativeObj);</a>
<span class="sourceLineNo">6385</span><a id="line.6385">    }</a>
<span class="sourceLineNo">6386</span><a id="line.6386"></a>
<span class="sourceLineNo">6387</span><a id="line.6387"></a>
<span class="sourceLineNo">6388</span><a id="line.6388">    //</a>
<span class="sourceLineNo">6389</span><a id="line.6389">    // C++:  double cv::stereoCalibrate(vector_Mat objectPoints, vector_Mat imagePoints1, vector_Mat imagePoints2, Mat&amp; cameraMatrix1, Mat&amp; distCoeffs1, Mat&amp; cameraMatrix2, Mat&amp; distCoeffs2, Size imageSize, Mat&amp; R, Mat&amp; T, Mat&amp; E, Mat&amp; F, int flags = CALIB_FIX_INTRINSIC, TermCriteria criteria = TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6))</a>
<span class="sourceLineNo">6390</span><a id="line.6390">    //</a>
<span class="sourceLineNo">6391</span><a id="line.6391"></a>
<span class="sourceLineNo">6392</span><a id="line.6392">    public static double stereoCalibrate(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints1, List&lt;Mat&gt; imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F, int flags, TermCriteria criteria) {</a>
<span class="sourceLineNo">6393</span><a id="line.6393">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">6394</span><a id="line.6394">        Mat imagePoints1_mat = Converters.vector_Mat_to_Mat(imagePoints1);</a>
<span class="sourceLineNo">6395</span><a id="line.6395">        Mat imagePoints2_mat = Converters.vector_Mat_to_Mat(imagePoints2);</a>
<span class="sourceLineNo">6396</span><a id="line.6396">        return stereoCalibrate_0(objectPoints_mat.nativeObj, imagePoints1_mat.nativeObj, imagePoints2_mat.nativeObj, cameraMatrix1.nativeObj, distCoeffs1.nativeObj, cameraMatrix2.nativeObj, distCoeffs2.nativeObj, imageSize.width, imageSize.height, R.nativeObj, T.nativeObj, E.nativeObj, F.nativeObj, flags, criteria.type, criteria.maxCount, criteria.epsilon);</a>
<span class="sourceLineNo">6397</span><a id="line.6397">    }</a>
<span class="sourceLineNo">6398</span><a id="line.6398"></a>
<span class="sourceLineNo">6399</span><a id="line.6399">    public static double stereoCalibrate(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints1, List&lt;Mat&gt; imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F, int flags) {</a>
<span class="sourceLineNo">6400</span><a id="line.6400">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">6401</span><a id="line.6401">        Mat imagePoints1_mat = Converters.vector_Mat_to_Mat(imagePoints1);</a>
<span class="sourceLineNo">6402</span><a id="line.6402">        Mat imagePoints2_mat = Converters.vector_Mat_to_Mat(imagePoints2);</a>
<span class="sourceLineNo">6403</span><a id="line.6403">        return stereoCalibrate_1(objectPoints_mat.nativeObj, imagePoints1_mat.nativeObj, imagePoints2_mat.nativeObj, cameraMatrix1.nativeObj, distCoeffs1.nativeObj, cameraMatrix2.nativeObj, distCoeffs2.nativeObj, imageSize.width, imageSize.height, R.nativeObj, T.nativeObj, E.nativeObj, F.nativeObj, flags);</a>
<span class="sourceLineNo">6404</span><a id="line.6404">    }</a>
<span class="sourceLineNo">6405</span><a id="line.6405"></a>
<span class="sourceLineNo">6406</span><a id="line.6406">    public static double stereoCalibrate(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints1, List&lt;Mat&gt; imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F) {</a>
<span class="sourceLineNo">6407</span><a id="line.6407">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">6408</span><a id="line.6408">        Mat imagePoints1_mat = Converters.vector_Mat_to_Mat(imagePoints1);</a>
<span class="sourceLineNo">6409</span><a id="line.6409">        Mat imagePoints2_mat = Converters.vector_Mat_to_Mat(imagePoints2);</a>
<span class="sourceLineNo">6410</span><a id="line.6410">        return stereoCalibrate_2(objectPoints_mat.nativeObj, imagePoints1_mat.nativeObj, imagePoints2_mat.nativeObj, cameraMatrix1.nativeObj, distCoeffs1.nativeObj, cameraMatrix2.nativeObj, distCoeffs2.nativeObj, imageSize.width, imageSize.height, R.nativeObj, T.nativeObj, E.nativeObj, F.nativeObj);</a>
<span class="sourceLineNo">6411</span><a id="line.6411">    }</a>
<span class="sourceLineNo">6412</span><a id="line.6412"></a>
<span class="sourceLineNo">6413</span><a id="line.6413"></a>
<span class="sourceLineNo">6414</span><a id="line.6414">    //</a>
<span class="sourceLineNo">6415</span><a id="line.6415">    // C++:  void cv::stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat&amp; R1, Mat&amp; R2, Mat&amp; P1, Mat&amp; P2, Mat&amp; Q, int flags = CALIB_ZERO_DISPARITY, double alpha = -1, Size newImageSize = Size(), Rect* validPixROI1 = 0, Rect* validPixROI2 = 0)</a>
<span class="sourceLineNo">6416</span><a id="line.6416">    //</a>
<span class="sourceLineNo">6417</span><a id="line.6417"></a>
<span class="sourceLineNo">6418</span><a id="line.6418">    /**</a>
<span class="sourceLineNo">6419</span><a id="line.6419">     * Computes rectification transforms for each head of a calibrated stereo camera.</a>
<span class="sourceLineNo">6420</span><a id="line.6420">     *</a>
<span class="sourceLineNo">6421</span><a id="line.6421">     * @param cameraMatrix1 First camera intrinsic matrix.</a>
<span class="sourceLineNo">6422</span><a id="line.6422">     * @param distCoeffs1 First camera distortion parameters.</a>
<span class="sourceLineNo">6423</span><a id="line.6423">     * @param cameraMatrix2 Second camera intrinsic matrix.</a>
<span class="sourceLineNo">6424</span><a id="line.6424">     * @param distCoeffs2 Second camera distortion parameters.</a>
<span class="sourceLineNo">6425</span><a id="line.6425">     * @param imageSize Size of the image used for stereo calibration.</a>
<span class="sourceLineNo">6426</span><a id="line.6426">     * @param R Rotation matrix from the coordinate system of the first camera to the second camera,</a>
<span class="sourceLineNo">6427</span><a id="line.6427">     * see REF: stereoCalibrate.</a>
<span class="sourceLineNo">6428</span><a id="line.6428">     * @param T Translation vector from the coordinate system of the first camera to the second camera,</a>
<span class="sourceLineNo">6429</span><a id="line.6429">     * see REF: stereoCalibrate.</a>
<span class="sourceLineNo">6430</span><a id="line.6430">     * @param R1 Output 3x3 rectification transform (rotation matrix) for the first camera. This matrix</a>
<span class="sourceLineNo">6431</span><a id="line.6431">     * brings points given in the unrectified first camera's coordinate system to points in the rectified</a>
<span class="sourceLineNo">6432</span><a id="line.6432">     * first camera's coordinate system. In more technical terms, it performs a change of basis from the</a>
<span class="sourceLineNo">6433</span><a id="line.6433">     * unrectified first camera's coordinate system to the rectified first camera's coordinate system.</a>
<span class="sourceLineNo">6434</span><a id="line.6434">     * @param R2 Output 3x3 rectification transform (rotation matrix) for the second camera. This matrix</a>
<span class="sourceLineNo">6435</span><a id="line.6435">     * brings points given in the unrectified second camera's coordinate system to points in the rectified</a>
<span class="sourceLineNo">6436</span><a id="line.6436">     * second camera's coordinate system. In more technical terms, it performs a change of basis from the</a>
<span class="sourceLineNo">6437</span><a id="line.6437">     * unrectified second camera's coordinate system to the rectified second camera's coordinate system.</a>
<span class="sourceLineNo">6438</span><a id="line.6438">     * @param P1 Output 3x4 projection matrix in the new (rectified) coordinate systems for the first</a>
<span class="sourceLineNo">6439</span><a id="line.6439">     * camera, i.e. it projects points given in the rectified first camera coordinate system into the</a>
<span class="sourceLineNo">6440</span><a id="line.6440">     * rectified first camera's image.</a>
<span class="sourceLineNo">6441</span><a id="line.6441">     * @param P2 Output 3x4 projection matrix in the new (rectified) coordinate systems for the second</a>
<span class="sourceLineNo">6442</span><a id="line.6442">     * camera, i.e. it projects points given in the rectified first camera coordinate system into the</a>
<span class="sourceLineNo">6443</span><a id="line.6443">     * rectified second camera's image.</a>
<span class="sourceLineNo">6444</span><a id="line.6444">     * @param Q Output \(4 \times 4\) disparity-to-depth mapping matrix (see REF: reprojectImageTo3D).</a>
<span class="sourceLineNo">6445</span><a id="line.6445">     * @param flags Operation flags that may be zero or REF: CALIB_ZERO_DISPARITY . If the flag is set,</a>
<span class="sourceLineNo">6446</span><a id="line.6446">     * the function makes the principal points of each camera have the same pixel coordinates in the</a>
<span class="sourceLineNo">6447</span><a id="line.6447">     * rectified views. And if the flag is not set, the function may still shift the images in the</a>
<span class="sourceLineNo">6448</span><a id="line.6448">     * horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the</a>
<span class="sourceLineNo">6449</span><a id="line.6449">     * useful image area.</a>
<span class="sourceLineNo">6450</span><a id="line.6450">     * @param alpha Free scaling parameter. If it is -1 or absent, the function performs the default</a>
<span class="sourceLineNo">6451</span><a id="line.6451">     * scaling. Otherwise, the parameter should be between 0 and 1. alpha=0 means that the rectified</a>
<span class="sourceLineNo">6452</span><a id="line.6452">     * images are zoomed and shifted so that only valid pixels are visible (no black areas after</a>
<span class="sourceLineNo">6453</span><a id="line.6453">     * rectification). alpha=1 means that the rectified image is decimated and shifted so that all the</a>
<span class="sourceLineNo">6454</span><a id="line.6454">     * pixels from the original images from the cameras are retained in the rectified images (no source</a>
<span class="sourceLineNo">6455</span><a id="line.6455">     * image pixels are lost). Any intermediate value yields an intermediate result between</a>
<span class="sourceLineNo">6456</span><a id="line.6456">     * those two extreme cases.</a>
<span class="sourceLineNo">6457</span><a id="line.6457">     * @param newImageSize New image resolution after rectification. The same size should be passed to</a>
<span class="sourceLineNo">6458</span><a id="line.6458">     * initUndistortRectifyMap (see the stereo_calib.cpp sample in OpenCV samples directory). When (0,0)</a>
<span class="sourceLineNo">6459</span><a id="line.6459">     * is passed (default), it is set to the original imageSize . Setting it to a larger value can help you</a>
<span class="sourceLineNo">6460</span><a id="line.6460">     * preserve details in the original image, especially when there is a big radial distortion.</a>
<span class="sourceLineNo">6461</span><a id="line.6461">     * @param validPixROI1 Optional output rectangles inside the rectified images where all the pixels</a>
<span class="sourceLineNo">6462</span><a id="line.6462">     * are valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they are likely to be smaller</a>
<span class="sourceLineNo">6463</span><a id="line.6463">     * (see the picture below).</a>
<span class="sourceLineNo">6464</span><a id="line.6464">     * @param validPixROI2 Optional output rectangles inside the rectified images where all the pixels</a>
<span class="sourceLineNo">6465</span><a id="line.6465">     * are valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they are likely to be smaller</a>
<span class="sourceLineNo">6466</span><a id="line.6466">     * (see the picture below).</a>
<span class="sourceLineNo">6467</span><a id="line.6467">     *</a>
<span class="sourceLineNo">6468</span><a id="line.6468">     * The function computes the rotation matrices for each camera that (virtually) make both camera image</a>
<span class="sourceLineNo">6469</span><a id="line.6469">     * planes the same plane. Consequently, this makes all the epipolar lines parallel and thus simplifies</a>
<span class="sourceLineNo">6470</span><a id="line.6470">     * the dense stereo correspondence problem. The function takes the matrices computed by stereoCalibrate</a>
<span class="sourceLineNo">6471</span><a id="line.6471">     * as input. As output, it provides two rotation matrices and also two projection matrices in the new</a>
<span class="sourceLineNo">6472</span><a id="line.6472">     * coordinates. The function distinguishes the following two cases:</a>
<span class="sourceLineNo">6473</span><a id="line.6473">     *</a>
<span class="sourceLineNo">6474</span><a id="line.6474">     * &lt;ul&gt;</a>
<span class="sourceLineNo">6475</span><a id="line.6475">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6476</span><a id="line.6476">     *    &lt;b&gt;Horizontal stereo&lt;/b&gt;: the first and the second camera views are shifted relative to each other</a>
<span class="sourceLineNo">6477</span><a id="line.6477">     *     mainly along the x-axis (with possible small vertical shift). In the rectified images, the</a>
<span class="sourceLineNo">6478</span><a id="line.6478">     *     corresponding epipolar lines in the left and right cameras are horizontal and have the same</a>
<span class="sourceLineNo">6479</span><a id="line.6479">     *     y-coordinate. P1 and P2 look like:</a>
<span class="sourceLineNo">6480</span><a id="line.6480">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6481</span><a id="line.6481">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">6482</span><a id="line.6482">     *</a>
<span class="sourceLineNo">6483</span><a id="line.6483">     *     \(\texttt{P1} = \begin{bmatrix}</a>
<span class="sourceLineNo">6484</span><a id="line.6484">     *                         f &amp;amp; 0 &amp;amp; cx_1 &amp;amp; 0 \\</a>
<span class="sourceLineNo">6485</span><a id="line.6485">     *                         0 &amp;amp; f &amp;amp; cy &amp;amp; 0 \\</a>
<span class="sourceLineNo">6486</span><a id="line.6486">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">6487</span><a id="line.6487">     *                      \end{bmatrix}\)</a>
<span class="sourceLineNo">6488</span><a id="line.6488">     *</a>
<span class="sourceLineNo">6489</span><a id="line.6489">     *     \(\texttt{P2} = \begin{bmatrix}</a>
<span class="sourceLineNo">6490</span><a id="line.6490">     *                         f &amp;amp; 0 &amp;amp; cx_2 &amp;amp; T_x*f \\</a>
<span class="sourceLineNo">6491</span><a id="line.6491">     *                         0 &amp;amp; f &amp;amp; cy &amp;amp; 0 \\</a>
<span class="sourceLineNo">6492</span><a id="line.6492">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">6493</span><a id="line.6493">     *                      \end{bmatrix} ,\)</a>
<span class="sourceLineNo">6494</span><a id="line.6494">     *</a>
<span class="sourceLineNo">6495</span><a id="line.6495">     *     where \(T_x\) is a horizontal shift between the cameras and \(cx_1=cx_2\) if</a>
<span class="sourceLineNo">6496</span><a id="line.6496">     *     REF: CALIB_ZERO_DISPARITY is set.</a>
<span class="sourceLineNo">6497</span><a id="line.6497">     *</a>
<span class="sourceLineNo">6498</span><a id="line.6498">     * &lt;ul&gt;</a>
<span class="sourceLineNo">6499</span><a id="line.6499">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6500</span><a id="line.6500">     *    &lt;b&gt;Vertical stereo&lt;/b&gt;: the first and the second camera views are shifted relative to each other</a>
<span class="sourceLineNo">6501</span><a id="line.6501">     *     mainly in the vertical direction (and probably a bit in the horizontal direction too). The epipolar</a>
<span class="sourceLineNo">6502</span><a id="line.6502">     *     lines in the rectified images are vertical and have the same x-coordinate. P1 and P2 look like:</a>
<span class="sourceLineNo">6503</span><a id="line.6503">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6504</span><a id="line.6504">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">6505</span><a id="line.6505">     *</a>
<span class="sourceLineNo">6506</span><a id="line.6506">     *     \(\texttt{P1} = \begin{bmatrix}</a>
<span class="sourceLineNo">6507</span><a id="line.6507">     *                         f &amp;amp; 0 &amp;amp; cx &amp;amp; 0 \\</a>
<span class="sourceLineNo">6508</span><a id="line.6508">     *                         0 &amp;amp; f &amp;amp; cy_1 &amp;amp; 0 \\</a>
<span class="sourceLineNo">6509</span><a id="line.6509">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">6510</span><a id="line.6510">     *                      \end{bmatrix}\)</a>
<span class="sourceLineNo">6511</span><a id="line.6511">     *</a>
<span class="sourceLineNo">6512</span><a id="line.6512">     *     \(\texttt{P2} = \begin{bmatrix}</a>
<span class="sourceLineNo">6513</span><a id="line.6513">     *                         f &amp;amp; 0 &amp;amp; cx &amp;amp; 0 \\</a>
<span class="sourceLineNo">6514</span><a id="line.6514">     *                         0 &amp;amp; f &amp;amp; cy_2 &amp;amp; T_y*f \\</a>
<span class="sourceLineNo">6515</span><a id="line.6515">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">6516</span><a id="line.6516">     *                      \end{bmatrix},\)</a>
<span class="sourceLineNo">6517</span><a id="line.6517">     *</a>
<span class="sourceLineNo">6518</span><a id="line.6518">     *     where \(T_y\) is a vertical shift between the cameras and \(cy_1=cy_2\) if</a>
<span class="sourceLineNo">6519</span><a id="line.6519">     *     REF: CALIB_ZERO_DISPARITY is set.</a>
<span class="sourceLineNo">6520</span><a id="line.6520">     *</a>
<span class="sourceLineNo">6521</span><a id="line.6521">     * As you can see, the first three columns of P1 and P2 will effectively be the new "rectified" camera</a>
<span class="sourceLineNo">6522</span><a id="line.6522">     * matrices. The matrices, together with R1 and R2 , can then be passed to initUndistortRectifyMap to</a>
<span class="sourceLineNo">6523</span><a id="line.6523">     * initialize the rectification map for each camera.</a>
<span class="sourceLineNo">6524</span><a id="line.6524">     *</a>
<span class="sourceLineNo">6525</span><a id="line.6525">     * See below the screenshot from the stereo_calib.cpp sample. Some red horizontal lines pass through</a>
<span class="sourceLineNo">6526</span><a id="line.6526">     * the corresponding image regions. This means that the images are well rectified, which is what most</a>
<span class="sourceLineNo">6527</span><a id="line.6527">     * stereo correspondence algorithms rely on. The green rectangles are roi1 and roi2 . You see that</a>
<span class="sourceLineNo">6528</span><a id="line.6528">     * their interiors are all valid pixels.</a>
<span class="sourceLineNo">6529</span><a id="line.6529">     *</a>
<span class="sourceLineNo">6530</span><a id="line.6530">     * ![image](pics/stereo_undistort.jpg)</a>
<span class="sourceLineNo">6531</span><a id="line.6531">     */</a>
<span class="sourceLineNo">6532</span><a id="line.6532">    public static void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, double alpha, Size newImageSize, Rect validPixROI1, Rect validPixROI2) {</a>
<span class="sourceLineNo">6533</span><a id="line.6533">        double[] validPixROI1_out = new double[4];</a>
<span class="sourceLineNo">6534</span><a id="line.6534">        double[] validPixROI2_out = new double[4];</a>
<span class="sourceLineNo">6535</span><a id="line.6535">        stereoRectify_0(cameraMatrix1.nativeObj, distCoeffs1.nativeObj, cameraMatrix2.nativeObj, distCoeffs2.nativeObj, imageSize.width, imageSize.height, R.nativeObj, T.nativeObj, R1.nativeObj, R2.nativeObj, P1.nativeObj, P2.nativeObj, Q.nativeObj, flags, alpha, newImageSize.width, newImageSize.height, validPixROI1_out, validPixROI2_out);</a>
<span class="sourceLineNo">6536</span><a id="line.6536">        if(validPixROI1!=null){ validPixROI1.x = (int)validPixROI1_out[0]; validPixROI1.y = (int)validPixROI1_out[1]; validPixROI1.width = (int)validPixROI1_out[2]; validPixROI1.height = (int)validPixROI1_out[3]; } </a>
<span class="sourceLineNo">6537</span><a id="line.6537">        if(validPixROI2!=null){ validPixROI2.x = (int)validPixROI2_out[0]; validPixROI2.y = (int)validPixROI2_out[1]; validPixROI2.width = (int)validPixROI2_out[2]; validPixROI2.height = (int)validPixROI2_out[3]; } </a>
<span class="sourceLineNo">6538</span><a id="line.6538">    }</a>
<span class="sourceLineNo">6539</span><a id="line.6539"></a>
<span class="sourceLineNo">6540</span><a id="line.6540">    /**</a>
<span class="sourceLineNo">6541</span><a id="line.6541">     * Computes rectification transforms for each head of a calibrated stereo camera.</a>
<span class="sourceLineNo">6542</span><a id="line.6542">     *</a>
<span class="sourceLineNo">6543</span><a id="line.6543">     * @param cameraMatrix1 First camera intrinsic matrix.</a>
<span class="sourceLineNo">6544</span><a id="line.6544">     * @param distCoeffs1 First camera distortion parameters.</a>
<span class="sourceLineNo">6545</span><a id="line.6545">     * @param cameraMatrix2 Second camera intrinsic matrix.</a>
<span class="sourceLineNo">6546</span><a id="line.6546">     * @param distCoeffs2 Second camera distortion parameters.</a>
<span class="sourceLineNo">6547</span><a id="line.6547">     * @param imageSize Size of the image used for stereo calibration.</a>
<span class="sourceLineNo">6548</span><a id="line.6548">     * @param R Rotation matrix from the coordinate system of the first camera to the second camera,</a>
<span class="sourceLineNo">6549</span><a id="line.6549">     * see REF: stereoCalibrate.</a>
<span class="sourceLineNo">6550</span><a id="line.6550">     * @param T Translation vector from the coordinate system of the first camera to the second camera,</a>
<span class="sourceLineNo">6551</span><a id="line.6551">     * see REF: stereoCalibrate.</a>
<span class="sourceLineNo">6552</span><a id="line.6552">     * @param R1 Output 3x3 rectification transform (rotation matrix) for the first camera. This matrix</a>
<span class="sourceLineNo">6553</span><a id="line.6553">     * brings points given in the unrectified first camera's coordinate system to points in the rectified</a>
<span class="sourceLineNo">6554</span><a id="line.6554">     * first camera's coordinate system. In more technical terms, it performs a change of basis from the</a>
<span class="sourceLineNo">6555</span><a id="line.6555">     * unrectified first camera's coordinate system to the rectified first camera's coordinate system.</a>
<span class="sourceLineNo">6556</span><a id="line.6556">     * @param R2 Output 3x3 rectification transform (rotation matrix) for the second camera. This matrix</a>
<span class="sourceLineNo">6557</span><a id="line.6557">     * brings points given in the unrectified second camera's coordinate system to points in the rectified</a>
<span class="sourceLineNo">6558</span><a id="line.6558">     * second camera's coordinate system. In more technical terms, it performs a change of basis from the</a>
<span class="sourceLineNo">6559</span><a id="line.6559">     * unrectified second camera's coordinate system to the rectified second camera's coordinate system.</a>
<span class="sourceLineNo">6560</span><a id="line.6560">     * @param P1 Output 3x4 projection matrix in the new (rectified) coordinate systems for the first</a>
<span class="sourceLineNo">6561</span><a id="line.6561">     * camera, i.e. it projects points given in the rectified first camera coordinate system into the</a>
<span class="sourceLineNo">6562</span><a id="line.6562">     * rectified first camera's image.</a>
<span class="sourceLineNo">6563</span><a id="line.6563">     * @param P2 Output 3x4 projection matrix in the new (rectified) coordinate systems for the second</a>
<span class="sourceLineNo">6564</span><a id="line.6564">     * camera, i.e. it projects points given in the rectified first camera coordinate system into the</a>
<span class="sourceLineNo">6565</span><a id="line.6565">     * rectified second camera's image.</a>
<span class="sourceLineNo">6566</span><a id="line.6566">     * @param Q Output \(4 \times 4\) disparity-to-depth mapping matrix (see REF: reprojectImageTo3D).</a>
<span class="sourceLineNo">6567</span><a id="line.6567">     * @param flags Operation flags that may be zero or REF: CALIB_ZERO_DISPARITY . If the flag is set,</a>
<span class="sourceLineNo">6568</span><a id="line.6568">     * the function makes the principal points of each camera have the same pixel coordinates in the</a>
<span class="sourceLineNo">6569</span><a id="line.6569">     * rectified views. And if the flag is not set, the function may still shift the images in the</a>
<span class="sourceLineNo">6570</span><a id="line.6570">     * horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the</a>
<span class="sourceLineNo">6571</span><a id="line.6571">     * useful image area.</a>
<span class="sourceLineNo">6572</span><a id="line.6572">     * @param alpha Free scaling parameter. If it is -1 or absent, the function performs the default</a>
<span class="sourceLineNo">6573</span><a id="line.6573">     * scaling. Otherwise, the parameter should be between 0 and 1. alpha=0 means that the rectified</a>
<span class="sourceLineNo">6574</span><a id="line.6574">     * images are zoomed and shifted so that only valid pixels are visible (no black areas after</a>
<span class="sourceLineNo">6575</span><a id="line.6575">     * rectification). alpha=1 means that the rectified image is decimated and shifted so that all the</a>
<span class="sourceLineNo">6576</span><a id="line.6576">     * pixels from the original images from the cameras are retained in the rectified images (no source</a>
<span class="sourceLineNo">6577</span><a id="line.6577">     * image pixels are lost). Any intermediate value yields an intermediate result between</a>
<span class="sourceLineNo">6578</span><a id="line.6578">     * those two extreme cases.</a>
<span class="sourceLineNo">6579</span><a id="line.6579">     * @param newImageSize New image resolution after rectification. The same size should be passed to</a>
<span class="sourceLineNo">6580</span><a id="line.6580">     * initUndistortRectifyMap (see the stereo_calib.cpp sample in OpenCV samples directory). When (0,0)</a>
<span class="sourceLineNo">6581</span><a id="line.6581">     * is passed (default), it is set to the original imageSize . Setting it to a larger value can help you</a>
<span class="sourceLineNo">6582</span><a id="line.6582">     * preserve details in the original image, especially when there is a big radial distortion.</a>
<span class="sourceLineNo">6583</span><a id="line.6583">     * @param validPixROI1 Optional output rectangles inside the rectified images where all the pixels</a>
<span class="sourceLineNo">6584</span><a id="line.6584">     * are valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they are likely to be smaller</a>
<span class="sourceLineNo">6585</span><a id="line.6585">     * (see the picture below).</a>
<span class="sourceLineNo">6586</span><a id="line.6586">     * are valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they are likely to be smaller</a>
<span class="sourceLineNo">6587</span><a id="line.6587">     * (see the picture below).</a>
<span class="sourceLineNo">6588</span><a id="line.6588">     *</a>
<span class="sourceLineNo">6589</span><a id="line.6589">     * The function computes the rotation matrices for each camera that (virtually) make both camera image</a>
<span class="sourceLineNo">6590</span><a id="line.6590">     * planes the same plane. Consequently, this makes all the epipolar lines parallel and thus simplifies</a>
<span class="sourceLineNo">6591</span><a id="line.6591">     * the dense stereo correspondence problem. The function takes the matrices computed by stereoCalibrate</a>
<span class="sourceLineNo">6592</span><a id="line.6592">     * as input. As output, it provides two rotation matrices and also two projection matrices in the new</a>
<span class="sourceLineNo">6593</span><a id="line.6593">     * coordinates. The function distinguishes the following two cases:</a>
<span class="sourceLineNo">6594</span><a id="line.6594">     *</a>
<span class="sourceLineNo">6595</span><a id="line.6595">     * &lt;ul&gt;</a>
<span class="sourceLineNo">6596</span><a id="line.6596">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6597</span><a id="line.6597">     *    &lt;b&gt;Horizontal stereo&lt;/b&gt;: the first and the second camera views are shifted relative to each other</a>
<span class="sourceLineNo">6598</span><a id="line.6598">     *     mainly along the x-axis (with possible small vertical shift). In the rectified images, the</a>
<span class="sourceLineNo">6599</span><a id="line.6599">     *     corresponding epipolar lines in the left and right cameras are horizontal and have the same</a>
<span class="sourceLineNo">6600</span><a id="line.6600">     *     y-coordinate. P1 and P2 look like:</a>
<span class="sourceLineNo">6601</span><a id="line.6601">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6602</span><a id="line.6602">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">6603</span><a id="line.6603">     *</a>
<span class="sourceLineNo">6604</span><a id="line.6604">     *     \(\texttt{P1} = \begin{bmatrix}</a>
<span class="sourceLineNo">6605</span><a id="line.6605">     *                         f &amp;amp; 0 &amp;amp; cx_1 &amp;amp; 0 \\</a>
<span class="sourceLineNo">6606</span><a id="line.6606">     *                         0 &amp;amp; f &amp;amp; cy &amp;amp; 0 \\</a>
<span class="sourceLineNo">6607</span><a id="line.6607">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">6608</span><a id="line.6608">     *                      \end{bmatrix}\)</a>
<span class="sourceLineNo">6609</span><a id="line.6609">     *</a>
<span class="sourceLineNo">6610</span><a id="line.6610">     *     \(\texttt{P2} = \begin{bmatrix}</a>
<span class="sourceLineNo">6611</span><a id="line.6611">     *                         f &amp;amp; 0 &amp;amp; cx_2 &amp;amp; T_x*f \\</a>
<span class="sourceLineNo">6612</span><a id="line.6612">     *                         0 &amp;amp; f &amp;amp; cy &amp;amp; 0 \\</a>
<span class="sourceLineNo">6613</span><a id="line.6613">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">6614</span><a id="line.6614">     *                      \end{bmatrix} ,\)</a>
<span class="sourceLineNo">6615</span><a id="line.6615">     *</a>
<span class="sourceLineNo">6616</span><a id="line.6616">     *     where \(T_x\) is a horizontal shift between the cameras and \(cx_1=cx_2\) if</a>
<span class="sourceLineNo">6617</span><a id="line.6617">     *     REF: CALIB_ZERO_DISPARITY is set.</a>
<span class="sourceLineNo">6618</span><a id="line.6618">     *</a>
<span class="sourceLineNo">6619</span><a id="line.6619">     * &lt;ul&gt;</a>
<span class="sourceLineNo">6620</span><a id="line.6620">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6621</span><a id="line.6621">     *    &lt;b&gt;Vertical stereo&lt;/b&gt;: the first and the second camera views are shifted relative to each other</a>
<span class="sourceLineNo">6622</span><a id="line.6622">     *     mainly in the vertical direction (and probably a bit in the horizontal direction too). The epipolar</a>
<span class="sourceLineNo">6623</span><a id="line.6623">     *     lines in the rectified images are vertical and have the same x-coordinate. P1 and P2 look like:</a>
<span class="sourceLineNo">6624</span><a id="line.6624">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6625</span><a id="line.6625">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">6626</span><a id="line.6626">     *</a>
<span class="sourceLineNo">6627</span><a id="line.6627">     *     \(\texttt{P1} = \begin{bmatrix}</a>
<span class="sourceLineNo">6628</span><a id="line.6628">     *                         f &amp;amp; 0 &amp;amp; cx &amp;amp; 0 \\</a>
<span class="sourceLineNo">6629</span><a id="line.6629">     *                         0 &amp;amp; f &amp;amp; cy_1 &amp;amp; 0 \\</a>
<span class="sourceLineNo">6630</span><a id="line.6630">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">6631</span><a id="line.6631">     *                      \end{bmatrix}\)</a>
<span class="sourceLineNo">6632</span><a id="line.6632">     *</a>
<span class="sourceLineNo">6633</span><a id="line.6633">     *     \(\texttt{P2} = \begin{bmatrix}</a>
<span class="sourceLineNo">6634</span><a id="line.6634">     *                         f &amp;amp; 0 &amp;amp; cx &amp;amp; 0 \\</a>
<span class="sourceLineNo">6635</span><a id="line.6635">     *                         0 &amp;amp; f &amp;amp; cy_2 &amp;amp; T_y*f \\</a>
<span class="sourceLineNo">6636</span><a id="line.6636">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">6637</span><a id="line.6637">     *                      \end{bmatrix},\)</a>
<span class="sourceLineNo">6638</span><a id="line.6638">     *</a>
<span class="sourceLineNo">6639</span><a id="line.6639">     *     where \(T_y\) is a vertical shift between the cameras and \(cy_1=cy_2\) if</a>
<span class="sourceLineNo">6640</span><a id="line.6640">     *     REF: CALIB_ZERO_DISPARITY is set.</a>
<span class="sourceLineNo">6641</span><a id="line.6641">     *</a>
<span class="sourceLineNo">6642</span><a id="line.6642">     * As you can see, the first three columns of P1 and P2 will effectively be the new "rectified" camera</a>
<span class="sourceLineNo">6643</span><a id="line.6643">     * matrices. The matrices, together with R1 and R2 , can then be passed to initUndistortRectifyMap to</a>
<span class="sourceLineNo">6644</span><a id="line.6644">     * initialize the rectification map for each camera.</a>
<span class="sourceLineNo">6645</span><a id="line.6645">     *</a>
<span class="sourceLineNo">6646</span><a id="line.6646">     * See below the screenshot from the stereo_calib.cpp sample. Some red horizontal lines pass through</a>
<span class="sourceLineNo">6647</span><a id="line.6647">     * the corresponding image regions. This means that the images are well rectified, which is what most</a>
<span class="sourceLineNo">6648</span><a id="line.6648">     * stereo correspondence algorithms rely on. The green rectangles are roi1 and roi2 . You see that</a>
<span class="sourceLineNo">6649</span><a id="line.6649">     * their interiors are all valid pixels.</a>
<span class="sourceLineNo">6650</span><a id="line.6650">     *</a>
<span class="sourceLineNo">6651</span><a id="line.6651">     * ![image](pics/stereo_undistort.jpg)</a>
<span class="sourceLineNo">6652</span><a id="line.6652">     */</a>
<span class="sourceLineNo">6653</span><a id="line.6653">    public static void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, double alpha, Size newImageSize, Rect validPixROI1) {</a>
<span class="sourceLineNo">6654</span><a id="line.6654">        double[] validPixROI1_out = new double[4];</a>
<span class="sourceLineNo">6655</span><a id="line.6655">        stereoRectify_1(cameraMatrix1.nativeObj, distCoeffs1.nativeObj, cameraMatrix2.nativeObj, distCoeffs2.nativeObj, imageSize.width, imageSize.height, R.nativeObj, T.nativeObj, R1.nativeObj, R2.nativeObj, P1.nativeObj, P2.nativeObj, Q.nativeObj, flags, alpha, newImageSize.width, newImageSize.height, validPixROI1_out);</a>
<span class="sourceLineNo">6656</span><a id="line.6656">        if(validPixROI1!=null){ validPixROI1.x = (int)validPixROI1_out[0]; validPixROI1.y = (int)validPixROI1_out[1]; validPixROI1.width = (int)validPixROI1_out[2]; validPixROI1.height = (int)validPixROI1_out[3]; } </a>
<span class="sourceLineNo">6657</span><a id="line.6657">    }</a>
<span class="sourceLineNo">6658</span><a id="line.6658"></a>
<span class="sourceLineNo">6659</span><a id="line.6659">    /**</a>
<span class="sourceLineNo">6660</span><a id="line.6660">     * Computes rectification transforms for each head of a calibrated stereo camera.</a>
<span class="sourceLineNo">6661</span><a id="line.6661">     *</a>
<span class="sourceLineNo">6662</span><a id="line.6662">     * @param cameraMatrix1 First camera intrinsic matrix.</a>
<span class="sourceLineNo">6663</span><a id="line.6663">     * @param distCoeffs1 First camera distortion parameters.</a>
<span class="sourceLineNo">6664</span><a id="line.6664">     * @param cameraMatrix2 Second camera intrinsic matrix.</a>
<span class="sourceLineNo">6665</span><a id="line.6665">     * @param distCoeffs2 Second camera distortion parameters.</a>
<span class="sourceLineNo">6666</span><a id="line.6666">     * @param imageSize Size of the image used for stereo calibration.</a>
<span class="sourceLineNo">6667</span><a id="line.6667">     * @param R Rotation matrix from the coordinate system of the first camera to the second camera,</a>
<span class="sourceLineNo">6668</span><a id="line.6668">     * see REF: stereoCalibrate.</a>
<span class="sourceLineNo">6669</span><a id="line.6669">     * @param T Translation vector from the coordinate system of the first camera to the second camera,</a>
<span class="sourceLineNo">6670</span><a id="line.6670">     * see REF: stereoCalibrate.</a>
<span class="sourceLineNo">6671</span><a id="line.6671">     * @param R1 Output 3x3 rectification transform (rotation matrix) for the first camera. This matrix</a>
<span class="sourceLineNo">6672</span><a id="line.6672">     * brings points given in the unrectified first camera's coordinate system to points in the rectified</a>
<span class="sourceLineNo">6673</span><a id="line.6673">     * first camera's coordinate system. In more technical terms, it performs a change of basis from the</a>
<span class="sourceLineNo">6674</span><a id="line.6674">     * unrectified first camera's coordinate system to the rectified first camera's coordinate system.</a>
<span class="sourceLineNo">6675</span><a id="line.6675">     * @param R2 Output 3x3 rectification transform (rotation matrix) for the second camera. This matrix</a>
<span class="sourceLineNo">6676</span><a id="line.6676">     * brings points given in the unrectified second camera's coordinate system to points in the rectified</a>
<span class="sourceLineNo">6677</span><a id="line.6677">     * second camera's coordinate system. In more technical terms, it performs a change of basis from the</a>
<span class="sourceLineNo">6678</span><a id="line.6678">     * unrectified second camera's coordinate system to the rectified second camera's coordinate system.</a>
<span class="sourceLineNo">6679</span><a id="line.6679">     * @param P1 Output 3x4 projection matrix in the new (rectified) coordinate systems for the first</a>
<span class="sourceLineNo">6680</span><a id="line.6680">     * camera, i.e. it projects points given in the rectified first camera coordinate system into the</a>
<span class="sourceLineNo">6681</span><a id="line.6681">     * rectified first camera's image.</a>
<span class="sourceLineNo">6682</span><a id="line.6682">     * @param P2 Output 3x4 projection matrix in the new (rectified) coordinate systems for the second</a>
<span class="sourceLineNo">6683</span><a id="line.6683">     * camera, i.e. it projects points given in the rectified first camera coordinate system into the</a>
<span class="sourceLineNo">6684</span><a id="line.6684">     * rectified second camera's image.</a>
<span class="sourceLineNo">6685</span><a id="line.6685">     * @param Q Output \(4 \times 4\) disparity-to-depth mapping matrix (see REF: reprojectImageTo3D).</a>
<span class="sourceLineNo">6686</span><a id="line.6686">     * @param flags Operation flags that may be zero or REF: CALIB_ZERO_DISPARITY . If the flag is set,</a>
<span class="sourceLineNo">6687</span><a id="line.6687">     * the function makes the principal points of each camera have the same pixel coordinates in the</a>
<span class="sourceLineNo">6688</span><a id="line.6688">     * rectified views. And if the flag is not set, the function may still shift the images in the</a>
<span class="sourceLineNo">6689</span><a id="line.6689">     * horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the</a>
<span class="sourceLineNo">6690</span><a id="line.6690">     * useful image area.</a>
<span class="sourceLineNo">6691</span><a id="line.6691">     * @param alpha Free scaling parameter. If it is -1 or absent, the function performs the default</a>
<span class="sourceLineNo">6692</span><a id="line.6692">     * scaling. Otherwise, the parameter should be between 0 and 1. alpha=0 means that the rectified</a>
<span class="sourceLineNo">6693</span><a id="line.6693">     * images are zoomed and shifted so that only valid pixels are visible (no black areas after</a>
<span class="sourceLineNo">6694</span><a id="line.6694">     * rectification). alpha=1 means that the rectified image is decimated and shifted so that all the</a>
<span class="sourceLineNo">6695</span><a id="line.6695">     * pixels from the original images from the cameras are retained in the rectified images (no source</a>
<span class="sourceLineNo">6696</span><a id="line.6696">     * image pixels are lost). Any intermediate value yields an intermediate result between</a>
<span class="sourceLineNo">6697</span><a id="line.6697">     * those two extreme cases.</a>
<span class="sourceLineNo">6698</span><a id="line.6698">     * @param newImageSize New image resolution after rectification. The same size should be passed to</a>
<span class="sourceLineNo">6699</span><a id="line.6699">     * initUndistortRectifyMap (see the stereo_calib.cpp sample in OpenCV samples directory). When (0,0)</a>
<span class="sourceLineNo">6700</span><a id="line.6700">     * is passed (default), it is set to the original imageSize . Setting it to a larger value can help you</a>
<span class="sourceLineNo">6701</span><a id="line.6701">     * preserve details in the original image, especially when there is a big radial distortion.</a>
<span class="sourceLineNo">6702</span><a id="line.6702">     * are valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they are likely to be smaller</a>
<span class="sourceLineNo">6703</span><a id="line.6703">     * (see the picture below).</a>
<span class="sourceLineNo">6704</span><a id="line.6704">     * are valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they are likely to be smaller</a>
<span class="sourceLineNo">6705</span><a id="line.6705">     * (see the picture below).</a>
<span class="sourceLineNo">6706</span><a id="line.6706">     *</a>
<span class="sourceLineNo">6707</span><a id="line.6707">     * The function computes the rotation matrices for each camera that (virtually) make both camera image</a>
<span class="sourceLineNo">6708</span><a id="line.6708">     * planes the same plane. Consequently, this makes all the epipolar lines parallel and thus simplifies</a>
<span class="sourceLineNo">6709</span><a id="line.6709">     * the dense stereo correspondence problem. The function takes the matrices computed by stereoCalibrate</a>
<span class="sourceLineNo">6710</span><a id="line.6710">     * as input. As output, it provides two rotation matrices and also two projection matrices in the new</a>
<span class="sourceLineNo">6711</span><a id="line.6711">     * coordinates. The function distinguishes the following two cases:</a>
<span class="sourceLineNo">6712</span><a id="line.6712">     *</a>
<span class="sourceLineNo">6713</span><a id="line.6713">     * &lt;ul&gt;</a>
<span class="sourceLineNo">6714</span><a id="line.6714">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6715</span><a id="line.6715">     *    &lt;b&gt;Horizontal stereo&lt;/b&gt;: the first and the second camera views are shifted relative to each other</a>
<span class="sourceLineNo">6716</span><a id="line.6716">     *     mainly along the x-axis (with possible small vertical shift). In the rectified images, the</a>
<span class="sourceLineNo">6717</span><a id="line.6717">     *     corresponding epipolar lines in the left and right cameras are horizontal and have the same</a>
<span class="sourceLineNo">6718</span><a id="line.6718">     *     y-coordinate. P1 and P2 look like:</a>
<span class="sourceLineNo">6719</span><a id="line.6719">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6720</span><a id="line.6720">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">6721</span><a id="line.6721">     *</a>
<span class="sourceLineNo">6722</span><a id="line.6722">     *     \(\texttt{P1} = \begin{bmatrix}</a>
<span class="sourceLineNo">6723</span><a id="line.6723">     *                         f &amp;amp; 0 &amp;amp; cx_1 &amp;amp; 0 \\</a>
<span class="sourceLineNo">6724</span><a id="line.6724">     *                         0 &amp;amp; f &amp;amp; cy &amp;amp; 0 \\</a>
<span class="sourceLineNo">6725</span><a id="line.6725">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">6726</span><a id="line.6726">     *                      \end{bmatrix}\)</a>
<span class="sourceLineNo">6727</span><a id="line.6727">     *</a>
<span class="sourceLineNo">6728</span><a id="line.6728">     *     \(\texttt{P2} = \begin{bmatrix}</a>
<span class="sourceLineNo">6729</span><a id="line.6729">     *                         f &amp;amp; 0 &amp;amp; cx_2 &amp;amp; T_x*f \\</a>
<span class="sourceLineNo">6730</span><a id="line.6730">     *                         0 &amp;amp; f &amp;amp; cy &amp;amp; 0 \\</a>
<span class="sourceLineNo">6731</span><a id="line.6731">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">6732</span><a id="line.6732">     *                      \end{bmatrix} ,\)</a>
<span class="sourceLineNo">6733</span><a id="line.6733">     *</a>
<span class="sourceLineNo">6734</span><a id="line.6734">     *     where \(T_x\) is a horizontal shift between the cameras and \(cx_1=cx_2\) if</a>
<span class="sourceLineNo">6735</span><a id="line.6735">     *     REF: CALIB_ZERO_DISPARITY is set.</a>
<span class="sourceLineNo">6736</span><a id="line.6736">     *</a>
<span class="sourceLineNo">6737</span><a id="line.6737">     * &lt;ul&gt;</a>
<span class="sourceLineNo">6738</span><a id="line.6738">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6739</span><a id="line.6739">     *    &lt;b&gt;Vertical stereo&lt;/b&gt;: the first and the second camera views are shifted relative to each other</a>
<span class="sourceLineNo">6740</span><a id="line.6740">     *     mainly in the vertical direction (and probably a bit in the horizontal direction too). The epipolar</a>
<span class="sourceLineNo">6741</span><a id="line.6741">     *     lines in the rectified images are vertical and have the same x-coordinate. P1 and P2 look like:</a>
<span class="sourceLineNo">6742</span><a id="line.6742">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6743</span><a id="line.6743">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">6744</span><a id="line.6744">     *</a>
<span class="sourceLineNo">6745</span><a id="line.6745">     *     \(\texttt{P1} = \begin{bmatrix}</a>
<span class="sourceLineNo">6746</span><a id="line.6746">     *                         f &amp;amp; 0 &amp;amp; cx &amp;amp; 0 \\</a>
<span class="sourceLineNo">6747</span><a id="line.6747">     *                         0 &amp;amp; f &amp;amp; cy_1 &amp;amp; 0 \\</a>
<span class="sourceLineNo">6748</span><a id="line.6748">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">6749</span><a id="line.6749">     *                      \end{bmatrix}\)</a>
<span class="sourceLineNo">6750</span><a id="line.6750">     *</a>
<span class="sourceLineNo">6751</span><a id="line.6751">     *     \(\texttt{P2} = \begin{bmatrix}</a>
<span class="sourceLineNo">6752</span><a id="line.6752">     *                         f &amp;amp; 0 &amp;amp; cx &amp;amp; 0 \\</a>
<span class="sourceLineNo">6753</span><a id="line.6753">     *                         0 &amp;amp; f &amp;amp; cy_2 &amp;amp; T_y*f \\</a>
<span class="sourceLineNo">6754</span><a id="line.6754">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">6755</span><a id="line.6755">     *                      \end{bmatrix},\)</a>
<span class="sourceLineNo">6756</span><a id="line.6756">     *</a>
<span class="sourceLineNo">6757</span><a id="line.6757">     *     where \(T_y\) is a vertical shift between the cameras and \(cy_1=cy_2\) if</a>
<span class="sourceLineNo">6758</span><a id="line.6758">     *     REF: CALIB_ZERO_DISPARITY is set.</a>
<span class="sourceLineNo">6759</span><a id="line.6759">     *</a>
<span class="sourceLineNo">6760</span><a id="line.6760">     * As you can see, the first three columns of P1 and P2 will effectively be the new "rectified" camera</a>
<span class="sourceLineNo">6761</span><a id="line.6761">     * matrices. The matrices, together with R1 and R2 , can then be passed to initUndistortRectifyMap to</a>
<span class="sourceLineNo">6762</span><a id="line.6762">     * initialize the rectification map for each camera.</a>
<span class="sourceLineNo">6763</span><a id="line.6763">     *</a>
<span class="sourceLineNo">6764</span><a id="line.6764">     * See below the screenshot from the stereo_calib.cpp sample. Some red horizontal lines pass through</a>
<span class="sourceLineNo">6765</span><a id="line.6765">     * the corresponding image regions. This means that the images are well rectified, which is what most</a>
<span class="sourceLineNo">6766</span><a id="line.6766">     * stereo correspondence algorithms rely on. The green rectangles are roi1 and roi2 . You see that</a>
<span class="sourceLineNo">6767</span><a id="line.6767">     * their interiors are all valid pixels.</a>
<span class="sourceLineNo">6768</span><a id="line.6768">     *</a>
<span class="sourceLineNo">6769</span><a id="line.6769">     * ![image](pics/stereo_undistort.jpg)</a>
<span class="sourceLineNo">6770</span><a id="line.6770">     */</a>
<span class="sourceLineNo">6771</span><a id="line.6771">    public static void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, double alpha, Size newImageSize) {</a>
<span class="sourceLineNo">6772</span><a id="line.6772">        stereoRectify_2(cameraMatrix1.nativeObj, distCoeffs1.nativeObj, cameraMatrix2.nativeObj, distCoeffs2.nativeObj, imageSize.width, imageSize.height, R.nativeObj, T.nativeObj, R1.nativeObj, R2.nativeObj, P1.nativeObj, P2.nativeObj, Q.nativeObj, flags, alpha, newImageSize.width, newImageSize.height);</a>
<span class="sourceLineNo">6773</span><a id="line.6773">    }</a>
<span class="sourceLineNo">6774</span><a id="line.6774"></a>
<span class="sourceLineNo">6775</span><a id="line.6775">    /**</a>
<span class="sourceLineNo">6776</span><a id="line.6776">     * Computes rectification transforms for each head of a calibrated stereo camera.</a>
<span class="sourceLineNo">6777</span><a id="line.6777">     *</a>
<span class="sourceLineNo">6778</span><a id="line.6778">     * @param cameraMatrix1 First camera intrinsic matrix.</a>
<span class="sourceLineNo">6779</span><a id="line.6779">     * @param distCoeffs1 First camera distortion parameters.</a>
<span class="sourceLineNo">6780</span><a id="line.6780">     * @param cameraMatrix2 Second camera intrinsic matrix.</a>
<span class="sourceLineNo">6781</span><a id="line.6781">     * @param distCoeffs2 Second camera distortion parameters.</a>
<span class="sourceLineNo">6782</span><a id="line.6782">     * @param imageSize Size of the image used for stereo calibration.</a>
<span class="sourceLineNo">6783</span><a id="line.6783">     * @param R Rotation matrix from the coordinate system of the first camera to the second camera,</a>
<span class="sourceLineNo">6784</span><a id="line.6784">     * see REF: stereoCalibrate.</a>
<span class="sourceLineNo">6785</span><a id="line.6785">     * @param T Translation vector from the coordinate system of the first camera to the second camera,</a>
<span class="sourceLineNo">6786</span><a id="line.6786">     * see REF: stereoCalibrate.</a>
<span class="sourceLineNo">6787</span><a id="line.6787">     * @param R1 Output 3x3 rectification transform (rotation matrix) for the first camera. This matrix</a>
<span class="sourceLineNo">6788</span><a id="line.6788">     * brings points given in the unrectified first camera's coordinate system to points in the rectified</a>
<span class="sourceLineNo">6789</span><a id="line.6789">     * first camera's coordinate system. In more technical terms, it performs a change of basis from the</a>
<span class="sourceLineNo">6790</span><a id="line.6790">     * unrectified first camera's coordinate system to the rectified first camera's coordinate system.</a>
<span class="sourceLineNo">6791</span><a id="line.6791">     * @param R2 Output 3x3 rectification transform (rotation matrix) for the second camera. This matrix</a>
<span class="sourceLineNo">6792</span><a id="line.6792">     * brings points given in the unrectified second camera's coordinate system to points in the rectified</a>
<span class="sourceLineNo">6793</span><a id="line.6793">     * second camera's coordinate system. In more technical terms, it performs a change of basis from the</a>
<span class="sourceLineNo">6794</span><a id="line.6794">     * unrectified second camera's coordinate system to the rectified second camera's coordinate system.</a>
<span class="sourceLineNo">6795</span><a id="line.6795">     * @param P1 Output 3x4 projection matrix in the new (rectified) coordinate systems for the first</a>
<span class="sourceLineNo">6796</span><a id="line.6796">     * camera, i.e. it projects points given in the rectified first camera coordinate system into the</a>
<span class="sourceLineNo">6797</span><a id="line.6797">     * rectified first camera's image.</a>
<span class="sourceLineNo">6798</span><a id="line.6798">     * @param P2 Output 3x4 projection matrix in the new (rectified) coordinate systems for the second</a>
<span class="sourceLineNo">6799</span><a id="line.6799">     * camera, i.e. it projects points given in the rectified first camera coordinate system into the</a>
<span class="sourceLineNo">6800</span><a id="line.6800">     * rectified second camera's image.</a>
<span class="sourceLineNo">6801</span><a id="line.6801">     * @param Q Output \(4 \times 4\) disparity-to-depth mapping matrix (see REF: reprojectImageTo3D).</a>
<span class="sourceLineNo">6802</span><a id="line.6802">     * @param flags Operation flags that may be zero or REF: CALIB_ZERO_DISPARITY . If the flag is set,</a>
<span class="sourceLineNo">6803</span><a id="line.6803">     * the function makes the principal points of each camera have the same pixel coordinates in the</a>
<span class="sourceLineNo">6804</span><a id="line.6804">     * rectified views. And if the flag is not set, the function may still shift the images in the</a>
<span class="sourceLineNo">6805</span><a id="line.6805">     * horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the</a>
<span class="sourceLineNo">6806</span><a id="line.6806">     * useful image area.</a>
<span class="sourceLineNo">6807</span><a id="line.6807">     * @param alpha Free scaling parameter. If it is -1 or absent, the function performs the default</a>
<span class="sourceLineNo">6808</span><a id="line.6808">     * scaling. Otherwise, the parameter should be between 0 and 1. alpha=0 means that the rectified</a>
<span class="sourceLineNo">6809</span><a id="line.6809">     * images are zoomed and shifted so that only valid pixels are visible (no black areas after</a>
<span class="sourceLineNo">6810</span><a id="line.6810">     * rectification). alpha=1 means that the rectified image is decimated and shifted so that all the</a>
<span class="sourceLineNo">6811</span><a id="line.6811">     * pixels from the original images from the cameras are retained in the rectified images (no source</a>
<span class="sourceLineNo">6812</span><a id="line.6812">     * image pixels are lost). Any intermediate value yields an intermediate result between</a>
<span class="sourceLineNo">6813</span><a id="line.6813">     * those two extreme cases.</a>
<span class="sourceLineNo">6814</span><a id="line.6814">     * initUndistortRectifyMap (see the stereo_calib.cpp sample in OpenCV samples directory). When (0,0)</a>
<span class="sourceLineNo">6815</span><a id="line.6815">     * is passed (default), it is set to the original imageSize . Setting it to a larger value can help you</a>
<span class="sourceLineNo">6816</span><a id="line.6816">     * preserve details in the original image, especially when there is a big radial distortion.</a>
<span class="sourceLineNo">6817</span><a id="line.6817">     * are valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they are likely to be smaller</a>
<span class="sourceLineNo">6818</span><a id="line.6818">     * (see the picture below).</a>
<span class="sourceLineNo">6819</span><a id="line.6819">     * are valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they are likely to be smaller</a>
<span class="sourceLineNo">6820</span><a id="line.6820">     * (see the picture below).</a>
<span class="sourceLineNo">6821</span><a id="line.6821">     *</a>
<span class="sourceLineNo">6822</span><a id="line.6822">     * The function computes the rotation matrices for each camera that (virtually) make both camera image</a>
<span class="sourceLineNo">6823</span><a id="line.6823">     * planes the same plane. Consequently, this makes all the epipolar lines parallel and thus simplifies</a>
<span class="sourceLineNo">6824</span><a id="line.6824">     * the dense stereo correspondence problem. The function takes the matrices computed by stereoCalibrate</a>
<span class="sourceLineNo">6825</span><a id="line.6825">     * as input. As output, it provides two rotation matrices and also two projection matrices in the new</a>
<span class="sourceLineNo">6826</span><a id="line.6826">     * coordinates. The function distinguishes the following two cases:</a>
<span class="sourceLineNo">6827</span><a id="line.6827">     *</a>
<span class="sourceLineNo">6828</span><a id="line.6828">     * &lt;ul&gt;</a>
<span class="sourceLineNo">6829</span><a id="line.6829">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6830</span><a id="line.6830">     *    &lt;b&gt;Horizontal stereo&lt;/b&gt;: the first and the second camera views are shifted relative to each other</a>
<span class="sourceLineNo">6831</span><a id="line.6831">     *     mainly along the x-axis (with possible small vertical shift). In the rectified images, the</a>
<span class="sourceLineNo">6832</span><a id="line.6832">     *     corresponding epipolar lines in the left and right cameras are horizontal and have the same</a>
<span class="sourceLineNo">6833</span><a id="line.6833">     *     y-coordinate. P1 and P2 look like:</a>
<span class="sourceLineNo">6834</span><a id="line.6834">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6835</span><a id="line.6835">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">6836</span><a id="line.6836">     *</a>
<span class="sourceLineNo">6837</span><a id="line.6837">     *     \(\texttt{P1} = \begin{bmatrix}</a>
<span class="sourceLineNo">6838</span><a id="line.6838">     *                         f &amp;amp; 0 &amp;amp; cx_1 &amp;amp; 0 \\</a>
<span class="sourceLineNo">6839</span><a id="line.6839">     *                         0 &amp;amp; f &amp;amp; cy &amp;amp; 0 \\</a>
<span class="sourceLineNo">6840</span><a id="line.6840">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">6841</span><a id="line.6841">     *                      \end{bmatrix}\)</a>
<span class="sourceLineNo">6842</span><a id="line.6842">     *</a>
<span class="sourceLineNo">6843</span><a id="line.6843">     *     \(\texttt{P2} = \begin{bmatrix}</a>
<span class="sourceLineNo">6844</span><a id="line.6844">     *                         f &amp;amp; 0 &amp;amp; cx_2 &amp;amp; T_x*f \\</a>
<span class="sourceLineNo">6845</span><a id="line.6845">     *                         0 &amp;amp; f &amp;amp; cy &amp;amp; 0 \\</a>
<span class="sourceLineNo">6846</span><a id="line.6846">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">6847</span><a id="line.6847">     *                      \end{bmatrix} ,\)</a>
<span class="sourceLineNo">6848</span><a id="line.6848">     *</a>
<span class="sourceLineNo">6849</span><a id="line.6849">     *     where \(T_x\) is a horizontal shift between the cameras and \(cx_1=cx_2\) if</a>
<span class="sourceLineNo">6850</span><a id="line.6850">     *     REF: CALIB_ZERO_DISPARITY is set.</a>
<span class="sourceLineNo">6851</span><a id="line.6851">     *</a>
<span class="sourceLineNo">6852</span><a id="line.6852">     * &lt;ul&gt;</a>
<span class="sourceLineNo">6853</span><a id="line.6853">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6854</span><a id="line.6854">     *    &lt;b&gt;Vertical stereo&lt;/b&gt;: the first and the second camera views are shifted relative to each other</a>
<span class="sourceLineNo">6855</span><a id="line.6855">     *     mainly in the vertical direction (and probably a bit in the horizontal direction too). The epipolar</a>
<span class="sourceLineNo">6856</span><a id="line.6856">     *     lines in the rectified images are vertical and have the same x-coordinate. P1 and P2 look like:</a>
<span class="sourceLineNo">6857</span><a id="line.6857">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6858</span><a id="line.6858">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">6859</span><a id="line.6859">     *</a>
<span class="sourceLineNo">6860</span><a id="line.6860">     *     \(\texttt{P1} = \begin{bmatrix}</a>
<span class="sourceLineNo">6861</span><a id="line.6861">     *                         f &amp;amp; 0 &amp;amp; cx &amp;amp; 0 \\</a>
<span class="sourceLineNo">6862</span><a id="line.6862">     *                         0 &amp;amp; f &amp;amp; cy_1 &amp;amp; 0 \\</a>
<span class="sourceLineNo">6863</span><a id="line.6863">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">6864</span><a id="line.6864">     *                      \end{bmatrix}\)</a>
<span class="sourceLineNo">6865</span><a id="line.6865">     *</a>
<span class="sourceLineNo">6866</span><a id="line.6866">     *     \(\texttt{P2} = \begin{bmatrix}</a>
<span class="sourceLineNo">6867</span><a id="line.6867">     *                         f &amp;amp; 0 &amp;amp; cx &amp;amp; 0 \\</a>
<span class="sourceLineNo">6868</span><a id="line.6868">     *                         0 &amp;amp; f &amp;amp; cy_2 &amp;amp; T_y*f \\</a>
<span class="sourceLineNo">6869</span><a id="line.6869">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">6870</span><a id="line.6870">     *                      \end{bmatrix},\)</a>
<span class="sourceLineNo">6871</span><a id="line.6871">     *</a>
<span class="sourceLineNo">6872</span><a id="line.6872">     *     where \(T_y\) is a vertical shift between the cameras and \(cy_1=cy_2\) if</a>
<span class="sourceLineNo">6873</span><a id="line.6873">     *     REF: CALIB_ZERO_DISPARITY is set.</a>
<span class="sourceLineNo">6874</span><a id="line.6874">     *</a>
<span class="sourceLineNo">6875</span><a id="line.6875">     * As you can see, the first three columns of P1 and P2 will effectively be the new "rectified" camera</a>
<span class="sourceLineNo">6876</span><a id="line.6876">     * matrices. The matrices, together with R1 and R2 , can then be passed to initUndistortRectifyMap to</a>
<span class="sourceLineNo">6877</span><a id="line.6877">     * initialize the rectification map for each camera.</a>
<span class="sourceLineNo">6878</span><a id="line.6878">     *</a>
<span class="sourceLineNo">6879</span><a id="line.6879">     * See below the screenshot from the stereo_calib.cpp sample. Some red horizontal lines pass through</a>
<span class="sourceLineNo">6880</span><a id="line.6880">     * the corresponding image regions. This means that the images are well rectified, which is what most</a>
<span class="sourceLineNo">6881</span><a id="line.6881">     * stereo correspondence algorithms rely on. The green rectangles are roi1 and roi2 . You see that</a>
<span class="sourceLineNo">6882</span><a id="line.6882">     * their interiors are all valid pixels.</a>
<span class="sourceLineNo">6883</span><a id="line.6883">     *</a>
<span class="sourceLineNo">6884</span><a id="line.6884">     * ![image](pics/stereo_undistort.jpg)</a>
<span class="sourceLineNo">6885</span><a id="line.6885">     */</a>
<span class="sourceLineNo">6886</span><a id="line.6886">    public static void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, double alpha) {</a>
<span class="sourceLineNo">6887</span><a id="line.6887">        stereoRectify_3(cameraMatrix1.nativeObj, distCoeffs1.nativeObj, cameraMatrix2.nativeObj, distCoeffs2.nativeObj, imageSize.width, imageSize.height, R.nativeObj, T.nativeObj, R1.nativeObj, R2.nativeObj, P1.nativeObj, P2.nativeObj, Q.nativeObj, flags, alpha);</a>
<span class="sourceLineNo">6888</span><a id="line.6888">    }</a>
<span class="sourceLineNo">6889</span><a id="line.6889"></a>
<span class="sourceLineNo">6890</span><a id="line.6890">    /**</a>
<span class="sourceLineNo">6891</span><a id="line.6891">     * Computes rectification transforms for each head of a calibrated stereo camera.</a>
<span class="sourceLineNo">6892</span><a id="line.6892">     *</a>
<span class="sourceLineNo">6893</span><a id="line.6893">     * @param cameraMatrix1 First camera intrinsic matrix.</a>
<span class="sourceLineNo">6894</span><a id="line.6894">     * @param distCoeffs1 First camera distortion parameters.</a>
<span class="sourceLineNo">6895</span><a id="line.6895">     * @param cameraMatrix2 Second camera intrinsic matrix.</a>
<span class="sourceLineNo">6896</span><a id="line.6896">     * @param distCoeffs2 Second camera distortion parameters.</a>
<span class="sourceLineNo">6897</span><a id="line.6897">     * @param imageSize Size of the image used for stereo calibration.</a>
<span class="sourceLineNo">6898</span><a id="line.6898">     * @param R Rotation matrix from the coordinate system of the first camera to the second camera,</a>
<span class="sourceLineNo">6899</span><a id="line.6899">     * see REF: stereoCalibrate.</a>
<span class="sourceLineNo">6900</span><a id="line.6900">     * @param T Translation vector from the coordinate system of the first camera to the second camera,</a>
<span class="sourceLineNo">6901</span><a id="line.6901">     * see REF: stereoCalibrate.</a>
<span class="sourceLineNo">6902</span><a id="line.6902">     * @param R1 Output 3x3 rectification transform (rotation matrix) for the first camera. This matrix</a>
<span class="sourceLineNo">6903</span><a id="line.6903">     * brings points given in the unrectified first camera's coordinate system to points in the rectified</a>
<span class="sourceLineNo">6904</span><a id="line.6904">     * first camera's coordinate system. In more technical terms, it performs a change of basis from the</a>
<span class="sourceLineNo">6905</span><a id="line.6905">     * unrectified first camera's coordinate system to the rectified first camera's coordinate system.</a>
<span class="sourceLineNo">6906</span><a id="line.6906">     * @param R2 Output 3x3 rectification transform (rotation matrix) for the second camera. This matrix</a>
<span class="sourceLineNo">6907</span><a id="line.6907">     * brings points given in the unrectified second camera's coordinate system to points in the rectified</a>
<span class="sourceLineNo">6908</span><a id="line.6908">     * second camera's coordinate system. In more technical terms, it performs a change of basis from the</a>
<span class="sourceLineNo">6909</span><a id="line.6909">     * unrectified second camera's coordinate system to the rectified second camera's coordinate system.</a>
<span class="sourceLineNo">6910</span><a id="line.6910">     * @param P1 Output 3x4 projection matrix in the new (rectified) coordinate systems for the first</a>
<span class="sourceLineNo">6911</span><a id="line.6911">     * camera, i.e. it projects points given in the rectified first camera coordinate system into the</a>
<span class="sourceLineNo">6912</span><a id="line.6912">     * rectified first camera's image.</a>
<span class="sourceLineNo">6913</span><a id="line.6913">     * @param P2 Output 3x4 projection matrix in the new (rectified) coordinate systems for the second</a>
<span class="sourceLineNo">6914</span><a id="line.6914">     * camera, i.e. it projects points given in the rectified first camera coordinate system into the</a>
<span class="sourceLineNo">6915</span><a id="line.6915">     * rectified second camera's image.</a>
<span class="sourceLineNo">6916</span><a id="line.6916">     * @param Q Output \(4 \times 4\) disparity-to-depth mapping matrix (see REF: reprojectImageTo3D).</a>
<span class="sourceLineNo">6917</span><a id="line.6917">     * @param flags Operation flags that may be zero or REF: CALIB_ZERO_DISPARITY . If the flag is set,</a>
<span class="sourceLineNo">6918</span><a id="line.6918">     * the function makes the principal points of each camera have the same pixel coordinates in the</a>
<span class="sourceLineNo">6919</span><a id="line.6919">     * rectified views. And if the flag is not set, the function may still shift the images in the</a>
<span class="sourceLineNo">6920</span><a id="line.6920">     * horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the</a>
<span class="sourceLineNo">6921</span><a id="line.6921">     * useful image area.</a>
<span class="sourceLineNo">6922</span><a id="line.6922">     * scaling. Otherwise, the parameter should be between 0 and 1. alpha=0 means that the rectified</a>
<span class="sourceLineNo">6923</span><a id="line.6923">     * images are zoomed and shifted so that only valid pixels are visible (no black areas after</a>
<span class="sourceLineNo">6924</span><a id="line.6924">     * rectification). alpha=1 means that the rectified image is decimated and shifted so that all the</a>
<span class="sourceLineNo">6925</span><a id="line.6925">     * pixels from the original images from the cameras are retained in the rectified images (no source</a>
<span class="sourceLineNo">6926</span><a id="line.6926">     * image pixels are lost). Any intermediate value yields an intermediate result between</a>
<span class="sourceLineNo">6927</span><a id="line.6927">     * those two extreme cases.</a>
<span class="sourceLineNo">6928</span><a id="line.6928">     * initUndistortRectifyMap (see the stereo_calib.cpp sample in OpenCV samples directory). When (0,0)</a>
<span class="sourceLineNo">6929</span><a id="line.6929">     * is passed (default), it is set to the original imageSize . Setting it to a larger value can help you</a>
<span class="sourceLineNo">6930</span><a id="line.6930">     * preserve details in the original image, especially when there is a big radial distortion.</a>
<span class="sourceLineNo">6931</span><a id="line.6931">     * are valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they are likely to be smaller</a>
<span class="sourceLineNo">6932</span><a id="line.6932">     * (see the picture below).</a>
<span class="sourceLineNo">6933</span><a id="line.6933">     * are valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they are likely to be smaller</a>
<span class="sourceLineNo">6934</span><a id="line.6934">     * (see the picture below).</a>
<span class="sourceLineNo">6935</span><a id="line.6935">     *</a>
<span class="sourceLineNo">6936</span><a id="line.6936">     * The function computes the rotation matrices for each camera that (virtually) make both camera image</a>
<span class="sourceLineNo">6937</span><a id="line.6937">     * planes the same plane. Consequently, this makes all the epipolar lines parallel and thus simplifies</a>
<span class="sourceLineNo">6938</span><a id="line.6938">     * the dense stereo correspondence problem. The function takes the matrices computed by stereoCalibrate</a>
<span class="sourceLineNo">6939</span><a id="line.6939">     * as input. As output, it provides two rotation matrices and also two projection matrices in the new</a>
<span class="sourceLineNo">6940</span><a id="line.6940">     * coordinates. The function distinguishes the following two cases:</a>
<span class="sourceLineNo">6941</span><a id="line.6941">     *</a>
<span class="sourceLineNo">6942</span><a id="line.6942">     * &lt;ul&gt;</a>
<span class="sourceLineNo">6943</span><a id="line.6943">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6944</span><a id="line.6944">     *    &lt;b&gt;Horizontal stereo&lt;/b&gt;: the first and the second camera views are shifted relative to each other</a>
<span class="sourceLineNo">6945</span><a id="line.6945">     *     mainly along the x-axis (with possible small vertical shift). In the rectified images, the</a>
<span class="sourceLineNo">6946</span><a id="line.6946">     *     corresponding epipolar lines in the left and right cameras are horizontal and have the same</a>
<span class="sourceLineNo">6947</span><a id="line.6947">     *     y-coordinate. P1 and P2 look like:</a>
<span class="sourceLineNo">6948</span><a id="line.6948">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6949</span><a id="line.6949">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">6950</span><a id="line.6950">     *</a>
<span class="sourceLineNo">6951</span><a id="line.6951">     *     \(\texttt{P1} = \begin{bmatrix}</a>
<span class="sourceLineNo">6952</span><a id="line.6952">     *                         f &amp;amp; 0 &amp;amp; cx_1 &amp;amp; 0 \\</a>
<span class="sourceLineNo">6953</span><a id="line.6953">     *                         0 &amp;amp; f &amp;amp; cy &amp;amp; 0 \\</a>
<span class="sourceLineNo">6954</span><a id="line.6954">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">6955</span><a id="line.6955">     *                      \end{bmatrix}\)</a>
<span class="sourceLineNo">6956</span><a id="line.6956">     *</a>
<span class="sourceLineNo">6957</span><a id="line.6957">     *     \(\texttt{P2} = \begin{bmatrix}</a>
<span class="sourceLineNo">6958</span><a id="line.6958">     *                         f &amp;amp; 0 &amp;amp; cx_2 &amp;amp; T_x*f \\</a>
<span class="sourceLineNo">6959</span><a id="line.6959">     *                         0 &amp;amp; f &amp;amp; cy &amp;amp; 0 \\</a>
<span class="sourceLineNo">6960</span><a id="line.6960">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">6961</span><a id="line.6961">     *                      \end{bmatrix} ,\)</a>
<span class="sourceLineNo">6962</span><a id="line.6962">     *</a>
<span class="sourceLineNo">6963</span><a id="line.6963">     *     where \(T_x\) is a horizontal shift between the cameras and \(cx_1=cx_2\) if</a>
<span class="sourceLineNo">6964</span><a id="line.6964">     *     REF: CALIB_ZERO_DISPARITY is set.</a>
<span class="sourceLineNo">6965</span><a id="line.6965">     *</a>
<span class="sourceLineNo">6966</span><a id="line.6966">     * &lt;ul&gt;</a>
<span class="sourceLineNo">6967</span><a id="line.6967">     *   &lt;li&gt;</a>
<span class="sourceLineNo">6968</span><a id="line.6968">     *    &lt;b&gt;Vertical stereo&lt;/b&gt;: the first and the second camera views are shifted relative to each other</a>
<span class="sourceLineNo">6969</span><a id="line.6969">     *     mainly in the vertical direction (and probably a bit in the horizontal direction too). The epipolar</a>
<span class="sourceLineNo">6970</span><a id="line.6970">     *     lines in the rectified images are vertical and have the same x-coordinate. P1 and P2 look like:</a>
<span class="sourceLineNo">6971</span><a id="line.6971">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">6972</span><a id="line.6972">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">6973</span><a id="line.6973">     *</a>
<span class="sourceLineNo">6974</span><a id="line.6974">     *     \(\texttt{P1} = \begin{bmatrix}</a>
<span class="sourceLineNo">6975</span><a id="line.6975">     *                         f &amp;amp; 0 &amp;amp; cx &amp;amp; 0 \\</a>
<span class="sourceLineNo">6976</span><a id="line.6976">     *                         0 &amp;amp; f &amp;amp; cy_1 &amp;amp; 0 \\</a>
<span class="sourceLineNo">6977</span><a id="line.6977">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">6978</span><a id="line.6978">     *                      \end{bmatrix}\)</a>
<span class="sourceLineNo">6979</span><a id="line.6979">     *</a>
<span class="sourceLineNo">6980</span><a id="line.6980">     *     \(\texttt{P2} = \begin{bmatrix}</a>
<span class="sourceLineNo">6981</span><a id="line.6981">     *                         f &amp;amp; 0 &amp;amp; cx &amp;amp; 0 \\</a>
<span class="sourceLineNo">6982</span><a id="line.6982">     *                         0 &amp;amp; f &amp;amp; cy_2 &amp;amp; T_y*f \\</a>
<span class="sourceLineNo">6983</span><a id="line.6983">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">6984</span><a id="line.6984">     *                      \end{bmatrix},\)</a>
<span class="sourceLineNo">6985</span><a id="line.6985">     *</a>
<span class="sourceLineNo">6986</span><a id="line.6986">     *     where \(T_y\) is a vertical shift between the cameras and \(cy_1=cy_2\) if</a>
<span class="sourceLineNo">6987</span><a id="line.6987">     *     REF: CALIB_ZERO_DISPARITY is set.</a>
<span class="sourceLineNo">6988</span><a id="line.6988">     *</a>
<span class="sourceLineNo">6989</span><a id="line.6989">     * As you can see, the first three columns of P1 and P2 will effectively be the new "rectified" camera</a>
<span class="sourceLineNo">6990</span><a id="line.6990">     * matrices. The matrices, together with R1 and R2 , can then be passed to initUndistortRectifyMap to</a>
<span class="sourceLineNo">6991</span><a id="line.6991">     * initialize the rectification map for each camera.</a>
<span class="sourceLineNo">6992</span><a id="line.6992">     *</a>
<span class="sourceLineNo">6993</span><a id="line.6993">     * See below the screenshot from the stereo_calib.cpp sample. Some red horizontal lines pass through</a>
<span class="sourceLineNo">6994</span><a id="line.6994">     * the corresponding image regions. This means that the images are well rectified, which is what most</a>
<span class="sourceLineNo">6995</span><a id="line.6995">     * stereo correspondence algorithms rely on. The green rectangles are roi1 and roi2 . You see that</a>
<span class="sourceLineNo">6996</span><a id="line.6996">     * their interiors are all valid pixels.</a>
<span class="sourceLineNo">6997</span><a id="line.6997">     *</a>
<span class="sourceLineNo">6998</span><a id="line.6998">     * ![image](pics/stereo_undistort.jpg)</a>
<span class="sourceLineNo">6999</span><a id="line.6999">     */</a>
<span class="sourceLineNo">7000</span><a id="line.7000">    public static void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags) {</a>
<span class="sourceLineNo">7001</span><a id="line.7001">        stereoRectify_4(cameraMatrix1.nativeObj, distCoeffs1.nativeObj, cameraMatrix2.nativeObj, distCoeffs2.nativeObj, imageSize.width, imageSize.height, R.nativeObj, T.nativeObj, R1.nativeObj, R2.nativeObj, P1.nativeObj, P2.nativeObj, Q.nativeObj, flags);</a>
<span class="sourceLineNo">7002</span><a id="line.7002">    }</a>
<span class="sourceLineNo">7003</span><a id="line.7003"></a>
<span class="sourceLineNo">7004</span><a id="line.7004">    /**</a>
<span class="sourceLineNo">7005</span><a id="line.7005">     * Computes rectification transforms for each head of a calibrated stereo camera.</a>
<span class="sourceLineNo">7006</span><a id="line.7006">     *</a>
<span class="sourceLineNo">7007</span><a id="line.7007">     * @param cameraMatrix1 First camera intrinsic matrix.</a>
<span class="sourceLineNo">7008</span><a id="line.7008">     * @param distCoeffs1 First camera distortion parameters.</a>
<span class="sourceLineNo">7009</span><a id="line.7009">     * @param cameraMatrix2 Second camera intrinsic matrix.</a>
<span class="sourceLineNo">7010</span><a id="line.7010">     * @param distCoeffs2 Second camera distortion parameters.</a>
<span class="sourceLineNo">7011</span><a id="line.7011">     * @param imageSize Size of the image used for stereo calibration.</a>
<span class="sourceLineNo">7012</span><a id="line.7012">     * @param R Rotation matrix from the coordinate system of the first camera to the second camera,</a>
<span class="sourceLineNo">7013</span><a id="line.7013">     * see REF: stereoCalibrate.</a>
<span class="sourceLineNo">7014</span><a id="line.7014">     * @param T Translation vector from the coordinate system of the first camera to the second camera,</a>
<span class="sourceLineNo">7015</span><a id="line.7015">     * see REF: stereoCalibrate.</a>
<span class="sourceLineNo">7016</span><a id="line.7016">     * @param R1 Output 3x3 rectification transform (rotation matrix) for the first camera. This matrix</a>
<span class="sourceLineNo">7017</span><a id="line.7017">     * brings points given in the unrectified first camera's coordinate system to points in the rectified</a>
<span class="sourceLineNo">7018</span><a id="line.7018">     * first camera's coordinate system. In more technical terms, it performs a change of basis from the</a>
<span class="sourceLineNo">7019</span><a id="line.7019">     * unrectified first camera's coordinate system to the rectified first camera's coordinate system.</a>
<span class="sourceLineNo">7020</span><a id="line.7020">     * @param R2 Output 3x3 rectification transform (rotation matrix) for the second camera. This matrix</a>
<span class="sourceLineNo">7021</span><a id="line.7021">     * brings points given in the unrectified second camera's coordinate system to points in the rectified</a>
<span class="sourceLineNo">7022</span><a id="line.7022">     * second camera's coordinate system. In more technical terms, it performs a change of basis from the</a>
<span class="sourceLineNo">7023</span><a id="line.7023">     * unrectified second camera's coordinate system to the rectified second camera's coordinate system.</a>
<span class="sourceLineNo">7024</span><a id="line.7024">     * @param P1 Output 3x4 projection matrix in the new (rectified) coordinate systems for the first</a>
<span class="sourceLineNo">7025</span><a id="line.7025">     * camera, i.e. it projects points given in the rectified first camera coordinate system into the</a>
<span class="sourceLineNo">7026</span><a id="line.7026">     * rectified first camera's image.</a>
<span class="sourceLineNo">7027</span><a id="line.7027">     * @param P2 Output 3x4 projection matrix in the new (rectified) coordinate systems for the second</a>
<span class="sourceLineNo">7028</span><a id="line.7028">     * camera, i.e. it projects points given in the rectified first camera coordinate system into the</a>
<span class="sourceLineNo">7029</span><a id="line.7029">     * rectified second camera's image.</a>
<span class="sourceLineNo">7030</span><a id="line.7030">     * @param Q Output \(4 \times 4\) disparity-to-depth mapping matrix (see REF: reprojectImageTo3D).</a>
<span class="sourceLineNo">7031</span><a id="line.7031">     * the function makes the principal points of each camera have the same pixel coordinates in the</a>
<span class="sourceLineNo">7032</span><a id="line.7032">     * rectified views. And if the flag is not set, the function may still shift the images in the</a>
<span class="sourceLineNo">7033</span><a id="line.7033">     * horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the</a>
<span class="sourceLineNo">7034</span><a id="line.7034">     * useful image area.</a>
<span class="sourceLineNo">7035</span><a id="line.7035">     * scaling. Otherwise, the parameter should be between 0 and 1. alpha=0 means that the rectified</a>
<span class="sourceLineNo">7036</span><a id="line.7036">     * images are zoomed and shifted so that only valid pixels are visible (no black areas after</a>
<span class="sourceLineNo">7037</span><a id="line.7037">     * rectification). alpha=1 means that the rectified image is decimated and shifted so that all the</a>
<span class="sourceLineNo">7038</span><a id="line.7038">     * pixels from the original images from the cameras are retained in the rectified images (no source</a>
<span class="sourceLineNo">7039</span><a id="line.7039">     * image pixels are lost). Any intermediate value yields an intermediate result between</a>
<span class="sourceLineNo">7040</span><a id="line.7040">     * those two extreme cases.</a>
<span class="sourceLineNo">7041</span><a id="line.7041">     * initUndistortRectifyMap (see the stereo_calib.cpp sample in OpenCV samples directory). When (0,0)</a>
<span class="sourceLineNo">7042</span><a id="line.7042">     * is passed (default), it is set to the original imageSize . Setting it to a larger value can help you</a>
<span class="sourceLineNo">7043</span><a id="line.7043">     * preserve details in the original image, especially when there is a big radial distortion.</a>
<span class="sourceLineNo">7044</span><a id="line.7044">     * are valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they are likely to be smaller</a>
<span class="sourceLineNo">7045</span><a id="line.7045">     * (see the picture below).</a>
<span class="sourceLineNo">7046</span><a id="line.7046">     * are valid. If alpha=0 , the ROIs cover the whole images. Otherwise, they are likely to be smaller</a>
<span class="sourceLineNo">7047</span><a id="line.7047">     * (see the picture below).</a>
<span class="sourceLineNo">7048</span><a id="line.7048">     *</a>
<span class="sourceLineNo">7049</span><a id="line.7049">     * The function computes the rotation matrices for each camera that (virtually) make both camera image</a>
<span class="sourceLineNo">7050</span><a id="line.7050">     * planes the same plane. Consequently, this makes all the epipolar lines parallel and thus simplifies</a>
<span class="sourceLineNo">7051</span><a id="line.7051">     * the dense stereo correspondence problem. The function takes the matrices computed by stereoCalibrate</a>
<span class="sourceLineNo">7052</span><a id="line.7052">     * as input. As output, it provides two rotation matrices and also two projection matrices in the new</a>
<span class="sourceLineNo">7053</span><a id="line.7053">     * coordinates. The function distinguishes the following two cases:</a>
<span class="sourceLineNo">7054</span><a id="line.7054">     *</a>
<span class="sourceLineNo">7055</span><a id="line.7055">     * &lt;ul&gt;</a>
<span class="sourceLineNo">7056</span><a id="line.7056">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7057</span><a id="line.7057">     *    &lt;b&gt;Horizontal stereo&lt;/b&gt;: the first and the second camera views are shifted relative to each other</a>
<span class="sourceLineNo">7058</span><a id="line.7058">     *     mainly along the x-axis (with possible small vertical shift). In the rectified images, the</a>
<span class="sourceLineNo">7059</span><a id="line.7059">     *     corresponding epipolar lines in the left and right cameras are horizontal and have the same</a>
<span class="sourceLineNo">7060</span><a id="line.7060">     *     y-coordinate. P1 and P2 look like:</a>
<span class="sourceLineNo">7061</span><a id="line.7061">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7062</span><a id="line.7062">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">7063</span><a id="line.7063">     *</a>
<span class="sourceLineNo">7064</span><a id="line.7064">     *     \(\texttt{P1} = \begin{bmatrix}</a>
<span class="sourceLineNo">7065</span><a id="line.7065">     *                         f &amp;amp; 0 &amp;amp; cx_1 &amp;amp; 0 \\</a>
<span class="sourceLineNo">7066</span><a id="line.7066">     *                         0 &amp;amp; f &amp;amp; cy &amp;amp; 0 \\</a>
<span class="sourceLineNo">7067</span><a id="line.7067">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">7068</span><a id="line.7068">     *                      \end{bmatrix}\)</a>
<span class="sourceLineNo">7069</span><a id="line.7069">     *</a>
<span class="sourceLineNo">7070</span><a id="line.7070">     *     \(\texttt{P2} = \begin{bmatrix}</a>
<span class="sourceLineNo">7071</span><a id="line.7071">     *                         f &amp;amp; 0 &amp;amp; cx_2 &amp;amp; T_x*f \\</a>
<span class="sourceLineNo">7072</span><a id="line.7072">     *                         0 &amp;amp; f &amp;amp; cy &amp;amp; 0 \\</a>
<span class="sourceLineNo">7073</span><a id="line.7073">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">7074</span><a id="line.7074">     *                      \end{bmatrix} ,\)</a>
<span class="sourceLineNo">7075</span><a id="line.7075">     *</a>
<span class="sourceLineNo">7076</span><a id="line.7076">     *     where \(T_x\) is a horizontal shift between the cameras and \(cx_1=cx_2\) if</a>
<span class="sourceLineNo">7077</span><a id="line.7077">     *     REF: CALIB_ZERO_DISPARITY is set.</a>
<span class="sourceLineNo">7078</span><a id="line.7078">     *</a>
<span class="sourceLineNo">7079</span><a id="line.7079">     * &lt;ul&gt;</a>
<span class="sourceLineNo">7080</span><a id="line.7080">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7081</span><a id="line.7081">     *    &lt;b&gt;Vertical stereo&lt;/b&gt;: the first and the second camera views are shifted relative to each other</a>
<span class="sourceLineNo">7082</span><a id="line.7082">     *     mainly in the vertical direction (and probably a bit in the horizontal direction too). The epipolar</a>
<span class="sourceLineNo">7083</span><a id="line.7083">     *     lines in the rectified images are vertical and have the same x-coordinate. P1 and P2 look like:</a>
<span class="sourceLineNo">7084</span><a id="line.7084">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7085</span><a id="line.7085">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">7086</span><a id="line.7086">     *</a>
<span class="sourceLineNo">7087</span><a id="line.7087">     *     \(\texttt{P1} = \begin{bmatrix}</a>
<span class="sourceLineNo">7088</span><a id="line.7088">     *                         f &amp;amp; 0 &amp;amp; cx &amp;amp; 0 \\</a>
<span class="sourceLineNo">7089</span><a id="line.7089">     *                         0 &amp;amp; f &amp;amp; cy_1 &amp;amp; 0 \\</a>
<span class="sourceLineNo">7090</span><a id="line.7090">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">7091</span><a id="line.7091">     *                      \end{bmatrix}\)</a>
<span class="sourceLineNo">7092</span><a id="line.7092">     *</a>
<span class="sourceLineNo">7093</span><a id="line.7093">     *     \(\texttt{P2} = \begin{bmatrix}</a>
<span class="sourceLineNo">7094</span><a id="line.7094">     *                         f &amp;amp; 0 &amp;amp; cx &amp;amp; 0 \\</a>
<span class="sourceLineNo">7095</span><a id="line.7095">     *                         0 &amp;amp; f &amp;amp; cy_2 &amp;amp; T_y*f \\</a>
<span class="sourceLineNo">7096</span><a id="line.7096">     *                         0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0</a>
<span class="sourceLineNo">7097</span><a id="line.7097">     *                      \end{bmatrix},\)</a>
<span class="sourceLineNo">7098</span><a id="line.7098">     *</a>
<span class="sourceLineNo">7099</span><a id="line.7099">     *     where \(T_y\) is a vertical shift between the cameras and \(cy_1=cy_2\) if</a>
<span class="sourceLineNo">7100</span><a id="line.7100">     *     REF: CALIB_ZERO_DISPARITY is set.</a>
<span class="sourceLineNo">7101</span><a id="line.7101">     *</a>
<span class="sourceLineNo">7102</span><a id="line.7102">     * As you can see, the first three columns of P1 and P2 will effectively be the new "rectified" camera</a>
<span class="sourceLineNo">7103</span><a id="line.7103">     * matrices. The matrices, together with R1 and R2 , can then be passed to initUndistortRectifyMap to</a>
<span class="sourceLineNo">7104</span><a id="line.7104">     * initialize the rectification map for each camera.</a>
<span class="sourceLineNo">7105</span><a id="line.7105">     *</a>
<span class="sourceLineNo">7106</span><a id="line.7106">     * See below the screenshot from the stereo_calib.cpp sample. Some red horizontal lines pass through</a>
<span class="sourceLineNo">7107</span><a id="line.7107">     * the corresponding image regions. This means that the images are well rectified, which is what most</a>
<span class="sourceLineNo">7108</span><a id="line.7108">     * stereo correspondence algorithms rely on. The green rectangles are roi1 and roi2 . You see that</a>
<span class="sourceLineNo">7109</span><a id="line.7109">     * their interiors are all valid pixels.</a>
<span class="sourceLineNo">7110</span><a id="line.7110">     *</a>
<span class="sourceLineNo">7111</span><a id="line.7111">     * ![image](pics/stereo_undistort.jpg)</a>
<span class="sourceLineNo">7112</span><a id="line.7112">     */</a>
<span class="sourceLineNo">7113</span><a id="line.7113">    public static void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q) {</a>
<span class="sourceLineNo">7114</span><a id="line.7114">        stereoRectify_5(cameraMatrix1.nativeObj, distCoeffs1.nativeObj, cameraMatrix2.nativeObj, distCoeffs2.nativeObj, imageSize.width, imageSize.height, R.nativeObj, T.nativeObj, R1.nativeObj, R2.nativeObj, P1.nativeObj, P2.nativeObj, Q.nativeObj);</a>
<span class="sourceLineNo">7115</span><a id="line.7115">    }</a>
<span class="sourceLineNo">7116</span><a id="line.7116"></a>
<span class="sourceLineNo">7117</span><a id="line.7117"></a>
<span class="sourceLineNo">7118</span><a id="line.7118">    //</a>
<span class="sourceLineNo">7119</span><a id="line.7119">    // C++:  bool cv::stereoRectifyUncalibrated(Mat points1, Mat points2, Mat F, Size imgSize, Mat&amp; H1, Mat&amp; H2, double threshold = 5)</a>
<span class="sourceLineNo">7120</span><a id="line.7120">    //</a>
<span class="sourceLineNo">7121</span><a id="line.7121"></a>
<span class="sourceLineNo">7122</span><a id="line.7122">    /**</a>
<span class="sourceLineNo">7123</span><a id="line.7123">     * Computes a rectification transform for an uncalibrated stereo camera.</a>
<span class="sourceLineNo">7124</span><a id="line.7124">     *</a>
<span class="sourceLineNo">7125</span><a id="line.7125">     * @param points1 Array of feature points in the first image.</a>
<span class="sourceLineNo">7126</span><a id="line.7126">     * @param points2 The corresponding points in the second image. The same formats as in</a>
<span class="sourceLineNo">7127</span><a id="line.7127">     * findFundamentalMat are supported.</a>
<span class="sourceLineNo">7128</span><a id="line.7128">     * @param F Input fundamental matrix. It can be computed from the same set of point pairs using</a>
<span class="sourceLineNo">7129</span><a id="line.7129">     * findFundamentalMat .</a>
<span class="sourceLineNo">7130</span><a id="line.7130">     * @param imgSize Size of the image.</a>
<span class="sourceLineNo">7131</span><a id="line.7131">     * @param H1 Output rectification homography matrix for the first image.</a>
<span class="sourceLineNo">7132</span><a id="line.7132">     * @param H2 Output rectification homography matrix for the second image.</a>
<span class="sourceLineNo">7133</span><a id="line.7133">     * @param threshold Optional threshold used to filter out the outliers. If the parameter is greater</a>
<span class="sourceLineNo">7134</span><a id="line.7134">     * than zero, all the point pairs that do not comply with the epipolar geometry (that is, the points</a>
<span class="sourceLineNo">7135</span><a id="line.7135">     * for which \(|\texttt{points2[i]}^T*\texttt{F}*\texttt{points1[i]}|&amp;gt;\texttt{threshold}\) ) are</a>
<span class="sourceLineNo">7136</span><a id="line.7136">     * rejected prior to computing the homographies. Otherwise, all the points are considered inliers.</a>
<span class="sourceLineNo">7137</span><a id="line.7137">     *</a>
<span class="sourceLineNo">7138</span><a id="line.7138">     * The function computes the rectification transformations without knowing intrinsic parameters of the</a>
<span class="sourceLineNo">7139</span><a id="line.7139">     * cameras and their relative position in the space, which explains the suffix "uncalibrated". Another</a>
<span class="sourceLineNo">7140</span><a id="line.7140">     * related difference from stereoRectify is that the function outputs not the rectification</a>
<span class="sourceLineNo">7141</span><a id="line.7141">     * transformations in the object (3D) space, but the planar perspective transformations encoded by the</a>
<span class="sourceLineNo">7142</span><a id="line.7142">     * homography matrices H1 and H2 . The function implements the algorithm CITE: Hartley99 .</a>
<span class="sourceLineNo">7143</span><a id="line.7143">     *</a>
<span class="sourceLineNo">7144</span><a id="line.7144">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">7145</span><a id="line.7145">     *    While the algorithm does not need to know the intrinsic parameters of the cameras, it heavily</a>
<span class="sourceLineNo">7146</span><a id="line.7146">     *     depends on the epipolar geometry. Therefore, if the camera lenses have a significant distortion,</a>
<span class="sourceLineNo">7147</span><a id="line.7147">     *     it would be better to correct it before computing the fundamental matrix and calling this</a>
<span class="sourceLineNo">7148</span><a id="line.7148">     *     function. For example, distortion coefficients can be estimated for each head of stereo camera</a>
<span class="sourceLineNo">7149</span><a id="line.7149">     *     separately by using calibrateCamera . Then, the images can be corrected using undistort , or</a>
<span class="sourceLineNo">7150</span><a id="line.7150">     *     just the point coordinates can be corrected with undistortPoints .</a>
<span class="sourceLineNo">7151</span><a id="line.7151">     * @return automatically generated</a>
<span class="sourceLineNo">7152</span><a id="line.7152">     */</a>
<span class="sourceLineNo">7153</span><a id="line.7153">    public static boolean stereoRectifyUncalibrated(Mat points1, Mat points2, Mat F, Size imgSize, Mat H1, Mat H2, double threshold) {</a>
<span class="sourceLineNo">7154</span><a id="line.7154">        return stereoRectifyUncalibrated_0(points1.nativeObj, points2.nativeObj, F.nativeObj, imgSize.width, imgSize.height, H1.nativeObj, H2.nativeObj, threshold);</a>
<span class="sourceLineNo">7155</span><a id="line.7155">    }</a>
<span class="sourceLineNo">7156</span><a id="line.7156"></a>
<span class="sourceLineNo">7157</span><a id="line.7157">    /**</a>
<span class="sourceLineNo">7158</span><a id="line.7158">     * Computes a rectification transform for an uncalibrated stereo camera.</a>
<span class="sourceLineNo">7159</span><a id="line.7159">     *</a>
<span class="sourceLineNo">7160</span><a id="line.7160">     * @param points1 Array of feature points in the first image.</a>
<span class="sourceLineNo">7161</span><a id="line.7161">     * @param points2 The corresponding points in the second image. The same formats as in</a>
<span class="sourceLineNo">7162</span><a id="line.7162">     * findFundamentalMat are supported.</a>
<span class="sourceLineNo">7163</span><a id="line.7163">     * @param F Input fundamental matrix. It can be computed from the same set of point pairs using</a>
<span class="sourceLineNo">7164</span><a id="line.7164">     * findFundamentalMat .</a>
<span class="sourceLineNo">7165</span><a id="line.7165">     * @param imgSize Size of the image.</a>
<span class="sourceLineNo">7166</span><a id="line.7166">     * @param H1 Output rectification homography matrix for the first image.</a>
<span class="sourceLineNo">7167</span><a id="line.7167">     * @param H2 Output rectification homography matrix for the second image.</a>
<span class="sourceLineNo">7168</span><a id="line.7168">     * than zero, all the point pairs that do not comply with the epipolar geometry (that is, the points</a>
<span class="sourceLineNo">7169</span><a id="line.7169">     * for which \(|\texttt{points2[i]}^T*\texttt{F}*\texttt{points1[i]}|&amp;gt;\texttt{threshold}\) ) are</a>
<span class="sourceLineNo">7170</span><a id="line.7170">     * rejected prior to computing the homographies. Otherwise, all the points are considered inliers.</a>
<span class="sourceLineNo">7171</span><a id="line.7171">     *</a>
<span class="sourceLineNo">7172</span><a id="line.7172">     * The function computes the rectification transformations without knowing intrinsic parameters of the</a>
<span class="sourceLineNo">7173</span><a id="line.7173">     * cameras and their relative position in the space, which explains the suffix "uncalibrated". Another</a>
<span class="sourceLineNo">7174</span><a id="line.7174">     * related difference from stereoRectify is that the function outputs not the rectification</a>
<span class="sourceLineNo">7175</span><a id="line.7175">     * transformations in the object (3D) space, but the planar perspective transformations encoded by the</a>
<span class="sourceLineNo">7176</span><a id="line.7176">     * homography matrices H1 and H2 . The function implements the algorithm CITE: Hartley99 .</a>
<span class="sourceLineNo">7177</span><a id="line.7177">     *</a>
<span class="sourceLineNo">7178</span><a id="line.7178">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">7179</span><a id="line.7179">     *    While the algorithm does not need to know the intrinsic parameters of the cameras, it heavily</a>
<span class="sourceLineNo">7180</span><a id="line.7180">     *     depends on the epipolar geometry. Therefore, if the camera lenses have a significant distortion,</a>
<span class="sourceLineNo">7181</span><a id="line.7181">     *     it would be better to correct it before computing the fundamental matrix and calling this</a>
<span class="sourceLineNo">7182</span><a id="line.7182">     *     function. For example, distortion coefficients can be estimated for each head of stereo camera</a>
<span class="sourceLineNo">7183</span><a id="line.7183">     *     separately by using calibrateCamera . Then, the images can be corrected using undistort , or</a>
<span class="sourceLineNo">7184</span><a id="line.7184">     *     just the point coordinates can be corrected with undistortPoints .</a>
<span class="sourceLineNo">7185</span><a id="line.7185">     * @return automatically generated</a>
<span class="sourceLineNo">7186</span><a id="line.7186">     */</a>
<span class="sourceLineNo">7187</span><a id="line.7187">    public static boolean stereoRectifyUncalibrated(Mat points1, Mat points2, Mat F, Size imgSize, Mat H1, Mat H2) {</a>
<span class="sourceLineNo">7188</span><a id="line.7188">        return stereoRectifyUncalibrated_1(points1.nativeObj, points2.nativeObj, F.nativeObj, imgSize.width, imgSize.height, H1.nativeObj, H2.nativeObj);</a>
<span class="sourceLineNo">7189</span><a id="line.7189">    }</a>
<span class="sourceLineNo">7190</span><a id="line.7190"></a>
<span class="sourceLineNo">7191</span><a id="line.7191"></a>
<span class="sourceLineNo">7192</span><a id="line.7192">    //</a>
<span class="sourceLineNo">7193</span><a id="line.7193">    // C++:  float cv::rectify3Collinear(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Mat cameraMatrix3, Mat distCoeffs3, vector_Mat imgpt1, vector_Mat imgpt3, Size imageSize, Mat R12, Mat T12, Mat R13, Mat T13, Mat&amp; R1, Mat&amp; R2, Mat&amp; R3, Mat&amp; P1, Mat&amp; P2, Mat&amp; P3, Mat&amp; Q, double alpha, Size newImgSize, Rect* roi1, Rect* roi2, int flags)</a>
<span class="sourceLineNo">7194</span><a id="line.7194">    //</a>
<span class="sourceLineNo">7195</span><a id="line.7195"></a>
<span class="sourceLineNo">7196</span><a id="line.7196">    public static float rectify3Collinear(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Mat cameraMatrix3, Mat distCoeffs3, List&lt;Mat&gt; imgpt1, List&lt;Mat&gt; imgpt3, Size imageSize, Mat R12, Mat T12, Mat R13, Mat T13, Mat R1, Mat R2, Mat R3, Mat P1, Mat P2, Mat P3, Mat Q, double alpha, Size newImgSize, Rect roi1, Rect roi2, int flags) {</a>
<span class="sourceLineNo">7197</span><a id="line.7197">        Mat imgpt1_mat = Converters.vector_Mat_to_Mat(imgpt1);</a>
<span class="sourceLineNo">7198</span><a id="line.7198">        Mat imgpt3_mat = Converters.vector_Mat_to_Mat(imgpt3);</a>
<span class="sourceLineNo">7199</span><a id="line.7199">        double[] roi1_out = new double[4];</a>
<span class="sourceLineNo">7200</span><a id="line.7200">        double[] roi2_out = new double[4];</a>
<span class="sourceLineNo">7201</span><a id="line.7201">        float retVal = rectify3Collinear_0(cameraMatrix1.nativeObj, distCoeffs1.nativeObj, cameraMatrix2.nativeObj, distCoeffs2.nativeObj, cameraMatrix3.nativeObj, distCoeffs3.nativeObj, imgpt1_mat.nativeObj, imgpt3_mat.nativeObj, imageSize.width, imageSize.height, R12.nativeObj, T12.nativeObj, R13.nativeObj, T13.nativeObj, R1.nativeObj, R2.nativeObj, R3.nativeObj, P1.nativeObj, P2.nativeObj, P3.nativeObj, Q.nativeObj, alpha, newImgSize.width, newImgSize.height, roi1_out, roi2_out, flags);</a>
<span class="sourceLineNo">7202</span><a id="line.7202">        if(roi1!=null){ roi1.x = (int)roi1_out[0]; roi1.y = (int)roi1_out[1]; roi1.width = (int)roi1_out[2]; roi1.height = (int)roi1_out[3]; } </a>
<span class="sourceLineNo">7203</span><a id="line.7203">        if(roi2!=null){ roi2.x = (int)roi2_out[0]; roi2.y = (int)roi2_out[1]; roi2.width = (int)roi2_out[2]; roi2.height = (int)roi2_out[3]; } </a>
<span class="sourceLineNo">7204</span><a id="line.7204">        return retVal;</a>
<span class="sourceLineNo">7205</span><a id="line.7205">    }</a>
<span class="sourceLineNo">7206</span><a id="line.7206"></a>
<span class="sourceLineNo">7207</span><a id="line.7207"></a>
<span class="sourceLineNo">7208</span><a id="line.7208">    //</a>
<span class="sourceLineNo">7209</span><a id="line.7209">    // C++:  Mat cv::getOptimalNewCameraMatrix(Mat cameraMatrix, Mat distCoeffs, Size imageSize, double alpha, Size newImgSize = Size(), Rect* validPixROI = 0, bool centerPrincipalPoint = false)</a>
<span class="sourceLineNo">7210</span><a id="line.7210">    //</a>
<span class="sourceLineNo">7211</span><a id="line.7211"></a>
<span class="sourceLineNo">7212</span><a id="line.7212">    /**</a>
<span class="sourceLineNo">7213</span><a id="line.7213">     * Returns the new camera intrinsic matrix based on the free scaling parameter.</a>
<span class="sourceLineNo">7214</span><a id="line.7214">     *</a>
<span class="sourceLineNo">7215</span><a id="line.7215">     * @param cameraMatrix Input camera intrinsic matrix.</a>
<span class="sourceLineNo">7216</span><a id="line.7216">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">7217</span><a id="line.7217">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">7218</span><a id="line.7218">     * assumed.</a>
<span class="sourceLineNo">7219</span><a id="line.7219">     * @param imageSize Original image size.</a>
<span class="sourceLineNo">7220</span><a id="line.7220">     * @param alpha Free scaling parameter between 0 (when all the pixels in the undistorted image are</a>
<span class="sourceLineNo">7221</span><a id="line.7221">     * valid) and 1 (when all the source image pixels are retained in the undistorted image). See</a>
<span class="sourceLineNo">7222</span><a id="line.7222">     * stereoRectify for details.</a>
<span class="sourceLineNo">7223</span><a id="line.7223">     * @param newImgSize Image size after rectification. By default, it is set to imageSize .</a>
<span class="sourceLineNo">7224</span><a id="line.7224">     * @param validPixROI Optional output rectangle that outlines all-good-pixels region in the</a>
<span class="sourceLineNo">7225</span><a id="line.7225">     * undistorted image. See roi1, roi2 description in stereoRectify .</a>
<span class="sourceLineNo">7226</span><a id="line.7226">     * @param centerPrincipalPoint Optional flag that indicates whether in the new camera intrinsic matrix the</a>
<span class="sourceLineNo">7227</span><a id="line.7227">     * principal point should be at the image center or not. By default, the principal point is chosen to</a>
<span class="sourceLineNo">7228</span><a id="line.7228">     * best fit a subset of the source image (determined by alpha) to the corrected image.</a>
<span class="sourceLineNo">7229</span><a id="line.7229">     * @return new_camera_matrix Output new camera intrinsic matrix.</a>
<span class="sourceLineNo">7230</span><a id="line.7230">     *</a>
<span class="sourceLineNo">7231</span><a id="line.7231">     * The function computes and returns the optimal new camera intrinsic matrix based on the free scaling parameter.</a>
<span class="sourceLineNo">7232</span><a id="line.7232">     * By varying this parameter, you may retrieve only sensible pixels alpha=0 , keep all the original</a>
<span class="sourceLineNo">7233</span><a id="line.7233">     * image pixels if there is valuable information in the corners alpha=1 , or get something in between.</a>
<span class="sourceLineNo">7234</span><a id="line.7234">     * When alpha&amp;gt;0 , the undistorted result is likely to have some black pixels corresponding to</a>
<span class="sourceLineNo">7235</span><a id="line.7235">     * "virtual" pixels outside of the captured distorted image. The original camera intrinsic matrix, distortion</a>
<span class="sourceLineNo">7236</span><a id="line.7236">     * coefficients, the computed new camera intrinsic matrix, and newImageSize should be passed to</a>
<span class="sourceLineNo">7237</span><a id="line.7237">     * initUndistortRectifyMap to produce the maps for remap .</a>
<span class="sourceLineNo">7238</span><a id="line.7238">     */</a>
<span class="sourceLineNo">7239</span><a id="line.7239">    public static Mat getOptimalNewCameraMatrix(Mat cameraMatrix, Mat distCoeffs, Size imageSize, double alpha, Size newImgSize, Rect validPixROI, boolean centerPrincipalPoint) {</a>
<span class="sourceLineNo">7240</span><a id="line.7240">        double[] validPixROI_out = new double[4];</a>
<span class="sourceLineNo">7241</span><a id="line.7241">        Mat retVal = new Mat(getOptimalNewCameraMatrix_0(cameraMatrix.nativeObj, distCoeffs.nativeObj, imageSize.width, imageSize.height, alpha, newImgSize.width, newImgSize.height, validPixROI_out, centerPrincipalPoint));</a>
<span class="sourceLineNo">7242</span><a id="line.7242">        if(validPixROI!=null){ validPixROI.x = (int)validPixROI_out[0]; validPixROI.y = (int)validPixROI_out[1]; validPixROI.width = (int)validPixROI_out[2]; validPixROI.height = (int)validPixROI_out[3]; } </a>
<span class="sourceLineNo">7243</span><a id="line.7243">        return retVal;</a>
<span class="sourceLineNo">7244</span><a id="line.7244">    }</a>
<span class="sourceLineNo">7245</span><a id="line.7245"></a>
<span class="sourceLineNo">7246</span><a id="line.7246">    /**</a>
<span class="sourceLineNo">7247</span><a id="line.7247">     * Returns the new camera intrinsic matrix based on the free scaling parameter.</a>
<span class="sourceLineNo">7248</span><a id="line.7248">     *</a>
<span class="sourceLineNo">7249</span><a id="line.7249">     * @param cameraMatrix Input camera intrinsic matrix.</a>
<span class="sourceLineNo">7250</span><a id="line.7250">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">7251</span><a id="line.7251">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">7252</span><a id="line.7252">     * assumed.</a>
<span class="sourceLineNo">7253</span><a id="line.7253">     * @param imageSize Original image size.</a>
<span class="sourceLineNo">7254</span><a id="line.7254">     * @param alpha Free scaling parameter between 0 (when all the pixels in the undistorted image are</a>
<span class="sourceLineNo">7255</span><a id="line.7255">     * valid) and 1 (when all the source image pixels are retained in the undistorted image). See</a>
<span class="sourceLineNo">7256</span><a id="line.7256">     * stereoRectify for details.</a>
<span class="sourceLineNo">7257</span><a id="line.7257">     * @param newImgSize Image size after rectification. By default, it is set to imageSize .</a>
<span class="sourceLineNo">7258</span><a id="line.7258">     * @param validPixROI Optional output rectangle that outlines all-good-pixels region in the</a>
<span class="sourceLineNo">7259</span><a id="line.7259">     * undistorted image. See roi1, roi2 description in stereoRectify .</a>
<span class="sourceLineNo">7260</span><a id="line.7260">     * principal point should be at the image center or not. By default, the principal point is chosen to</a>
<span class="sourceLineNo">7261</span><a id="line.7261">     * best fit a subset of the source image (determined by alpha) to the corrected image.</a>
<span class="sourceLineNo">7262</span><a id="line.7262">     * @return new_camera_matrix Output new camera intrinsic matrix.</a>
<span class="sourceLineNo">7263</span><a id="line.7263">     *</a>
<span class="sourceLineNo">7264</span><a id="line.7264">     * The function computes and returns the optimal new camera intrinsic matrix based on the free scaling parameter.</a>
<span class="sourceLineNo">7265</span><a id="line.7265">     * By varying this parameter, you may retrieve only sensible pixels alpha=0 , keep all the original</a>
<span class="sourceLineNo">7266</span><a id="line.7266">     * image pixels if there is valuable information in the corners alpha=1 , or get something in between.</a>
<span class="sourceLineNo">7267</span><a id="line.7267">     * When alpha&amp;gt;0 , the undistorted result is likely to have some black pixels corresponding to</a>
<span class="sourceLineNo">7268</span><a id="line.7268">     * "virtual" pixels outside of the captured distorted image. The original camera intrinsic matrix, distortion</a>
<span class="sourceLineNo">7269</span><a id="line.7269">     * coefficients, the computed new camera intrinsic matrix, and newImageSize should be passed to</a>
<span class="sourceLineNo">7270</span><a id="line.7270">     * initUndistortRectifyMap to produce the maps for remap .</a>
<span class="sourceLineNo">7271</span><a id="line.7271">     */</a>
<span class="sourceLineNo">7272</span><a id="line.7272">    public static Mat getOptimalNewCameraMatrix(Mat cameraMatrix, Mat distCoeffs, Size imageSize, double alpha, Size newImgSize, Rect validPixROI) {</a>
<span class="sourceLineNo">7273</span><a id="line.7273">        double[] validPixROI_out = new double[4];</a>
<span class="sourceLineNo">7274</span><a id="line.7274">        Mat retVal = new Mat(getOptimalNewCameraMatrix_1(cameraMatrix.nativeObj, distCoeffs.nativeObj, imageSize.width, imageSize.height, alpha, newImgSize.width, newImgSize.height, validPixROI_out));</a>
<span class="sourceLineNo">7275</span><a id="line.7275">        if(validPixROI!=null){ validPixROI.x = (int)validPixROI_out[0]; validPixROI.y = (int)validPixROI_out[1]; validPixROI.width = (int)validPixROI_out[2]; validPixROI.height = (int)validPixROI_out[3]; } </a>
<span class="sourceLineNo">7276</span><a id="line.7276">        return retVal;</a>
<span class="sourceLineNo">7277</span><a id="line.7277">    }</a>
<span class="sourceLineNo">7278</span><a id="line.7278"></a>
<span class="sourceLineNo">7279</span><a id="line.7279">    /**</a>
<span class="sourceLineNo">7280</span><a id="line.7280">     * Returns the new camera intrinsic matrix based on the free scaling parameter.</a>
<span class="sourceLineNo">7281</span><a id="line.7281">     *</a>
<span class="sourceLineNo">7282</span><a id="line.7282">     * @param cameraMatrix Input camera intrinsic matrix.</a>
<span class="sourceLineNo">7283</span><a id="line.7283">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">7284</span><a id="line.7284">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">7285</span><a id="line.7285">     * assumed.</a>
<span class="sourceLineNo">7286</span><a id="line.7286">     * @param imageSize Original image size.</a>
<span class="sourceLineNo">7287</span><a id="line.7287">     * @param alpha Free scaling parameter between 0 (when all the pixels in the undistorted image are</a>
<span class="sourceLineNo">7288</span><a id="line.7288">     * valid) and 1 (when all the source image pixels are retained in the undistorted image). See</a>
<span class="sourceLineNo">7289</span><a id="line.7289">     * stereoRectify for details.</a>
<span class="sourceLineNo">7290</span><a id="line.7290">     * @param newImgSize Image size after rectification. By default, it is set to imageSize .</a>
<span class="sourceLineNo">7291</span><a id="line.7291">     * undistorted image. See roi1, roi2 description in stereoRectify .</a>
<span class="sourceLineNo">7292</span><a id="line.7292">     * principal point should be at the image center or not. By default, the principal point is chosen to</a>
<span class="sourceLineNo">7293</span><a id="line.7293">     * best fit a subset of the source image (determined by alpha) to the corrected image.</a>
<span class="sourceLineNo">7294</span><a id="line.7294">     * @return new_camera_matrix Output new camera intrinsic matrix.</a>
<span class="sourceLineNo">7295</span><a id="line.7295">     *</a>
<span class="sourceLineNo">7296</span><a id="line.7296">     * The function computes and returns the optimal new camera intrinsic matrix based on the free scaling parameter.</a>
<span class="sourceLineNo">7297</span><a id="line.7297">     * By varying this parameter, you may retrieve only sensible pixels alpha=0 , keep all the original</a>
<span class="sourceLineNo">7298</span><a id="line.7298">     * image pixels if there is valuable information in the corners alpha=1 , or get something in between.</a>
<span class="sourceLineNo">7299</span><a id="line.7299">     * When alpha&amp;gt;0 , the undistorted result is likely to have some black pixels corresponding to</a>
<span class="sourceLineNo">7300</span><a id="line.7300">     * "virtual" pixels outside of the captured distorted image. The original camera intrinsic matrix, distortion</a>
<span class="sourceLineNo">7301</span><a id="line.7301">     * coefficients, the computed new camera intrinsic matrix, and newImageSize should be passed to</a>
<span class="sourceLineNo">7302</span><a id="line.7302">     * initUndistortRectifyMap to produce the maps for remap .</a>
<span class="sourceLineNo">7303</span><a id="line.7303">     */</a>
<span class="sourceLineNo">7304</span><a id="line.7304">    public static Mat getOptimalNewCameraMatrix(Mat cameraMatrix, Mat distCoeffs, Size imageSize, double alpha, Size newImgSize) {</a>
<span class="sourceLineNo">7305</span><a id="line.7305">        return new Mat(getOptimalNewCameraMatrix_2(cameraMatrix.nativeObj, distCoeffs.nativeObj, imageSize.width, imageSize.height, alpha, newImgSize.width, newImgSize.height));</a>
<span class="sourceLineNo">7306</span><a id="line.7306">    }</a>
<span class="sourceLineNo">7307</span><a id="line.7307"></a>
<span class="sourceLineNo">7308</span><a id="line.7308">    /**</a>
<span class="sourceLineNo">7309</span><a id="line.7309">     * Returns the new camera intrinsic matrix based on the free scaling parameter.</a>
<span class="sourceLineNo">7310</span><a id="line.7310">     *</a>
<span class="sourceLineNo">7311</span><a id="line.7311">     * @param cameraMatrix Input camera intrinsic matrix.</a>
<span class="sourceLineNo">7312</span><a id="line.7312">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">7313</span><a id="line.7313">     * \(\distcoeffs\). If the vector is NULL/empty, the zero distortion coefficients are</a>
<span class="sourceLineNo">7314</span><a id="line.7314">     * assumed.</a>
<span class="sourceLineNo">7315</span><a id="line.7315">     * @param imageSize Original image size.</a>
<span class="sourceLineNo">7316</span><a id="line.7316">     * @param alpha Free scaling parameter between 0 (when all the pixels in the undistorted image are</a>
<span class="sourceLineNo">7317</span><a id="line.7317">     * valid) and 1 (when all the source image pixels are retained in the undistorted image). See</a>
<span class="sourceLineNo">7318</span><a id="line.7318">     * stereoRectify for details.</a>
<span class="sourceLineNo">7319</span><a id="line.7319">     * undistorted image. See roi1, roi2 description in stereoRectify .</a>
<span class="sourceLineNo">7320</span><a id="line.7320">     * principal point should be at the image center or not. By default, the principal point is chosen to</a>
<span class="sourceLineNo">7321</span><a id="line.7321">     * best fit a subset of the source image (determined by alpha) to the corrected image.</a>
<span class="sourceLineNo">7322</span><a id="line.7322">     * @return new_camera_matrix Output new camera intrinsic matrix.</a>
<span class="sourceLineNo">7323</span><a id="line.7323">     *</a>
<span class="sourceLineNo">7324</span><a id="line.7324">     * The function computes and returns the optimal new camera intrinsic matrix based on the free scaling parameter.</a>
<span class="sourceLineNo">7325</span><a id="line.7325">     * By varying this parameter, you may retrieve only sensible pixels alpha=0 , keep all the original</a>
<span class="sourceLineNo">7326</span><a id="line.7326">     * image pixels if there is valuable information in the corners alpha=1 , or get something in between.</a>
<span class="sourceLineNo">7327</span><a id="line.7327">     * When alpha&amp;gt;0 , the undistorted result is likely to have some black pixels corresponding to</a>
<span class="sourceLineNo">7328</span><a id="line.7328">     * "virtual" pixels outside of the captured distorted image. The original camera intrinsic matrix, distortion</a>
<span class="sourceLineNo">7329</span><a id="line.7329">     * coefficients, the computed new camera intrinsic matrix, and newImageSize should be passed to</a>
<span class="sourceLineNo">7330</span><a id="line.7330">     * initUndistortRectifyMap to produce the maps for remap .</a>
<span class="sourceLineNo">7331</span><a id="line.7331">     */</a>
<span class="sourceLineNo">7332</span><a id="line.7332">    public static Mat getOptimalNewCameraMatrix(Mat cameraMatrix, Mat distCoeffs, Size imageSize, double alpha) {</a>
<span class="sourceLineNo">7333</span><a id="line.7333">        return new Mat(getOptimalNewCameraMatrix_3(cameraMatrix.nativeObj, distCoeffs.nativeObj, imageSize.width, imageSize.height, alpha));</a>
<span class="sourceLineNo">7334</span><a id="line.7334">    }</a>
<span class="sourceLineNo">7335</span><a id="line.7335"></a>
<span class="sourceLineNo">7336</span><a id="line.7336"></a>
<span class="sourceLineNo">7337</span><a id="line.7337">    //</a>
<span class="sourceLineNo">7338</span><a id="line.7338">    // C++:  void cv::calibrateHandEye(vector_Mat R_gripper2base, vector_Mat t_gripper2base, vector_Mat R_target2cam, vector_Mat t_target2cam, Mat&amp; R_cam2gripper, Mat&amp; t_cam2gripper, HandEyeCalibrationMethod method = CALIB_HAND_EYE_TSAI)</a>
<span class="sourceLineNo">7339</span><a id="line.7339">    //</a>
<span class="sourceLineNo">7340</span><a id="line.7340"></a>
<span class="sourceLineNo">7341</span><a id="line.7341">    /**</a>
<span class="sourceLineNo">7342</span><a id="line.7342">     * Computes Hand-Eye calibration: \(_{}^{g}\textrm{T}_c\)</a>
<span class="sourceLineNo">7343</span><a id="line.7343">     *</a>
<span class="sourceLineNo">7344</span><a id="line.7344">     * @param R_gripper2base Rotation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7345</span><a id="line.7345">     * expressed in the gripper frame to the robot base frame (\(_{}^{b}\textrm{T}_g\)).</a>
<span class="sourceLineNo">7346</span><a id="line.7346">     * This is a vector ({@code vector&amp;lt;Mat&amp;gt;}) that contains the rotation, {@code (3x3)} rotation matrices or {@code (3x1)} rotation vectors,</a>
<span class="sourceLineNo">7347</span><a id="line.7347">     * for all the transformations from gripper frame to robot base frame.</a>
<span class="sourceLineNo">7348</span><a id="line.7348">     * @param t_gripper2base Translation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7349</span><a id="line.7349">     * expressed in the gripper frame to the robot base frame (\(_{}^{b}\textrm{T}_g\)).</a>
<span class="sourceLineNo">7350</span><a id="line.7350">     * This is a vector ({@code vector&amp;lt;Mat&amp;gt;}) that contains the {@code (3x1)} translation vectors for all the transformations</a>
<span class="sourceLineNo">7351</span><a id="line.7351">     * from gripper frame to robot base frame.</a>
<span class="sourceLineNo">7352</span><a id="line.7352">     * @param R_target2cam Rotation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7353</span><a id="line.7353">     * expressed in the target frame to the camera frame (\(_{}^{c}\textrm{T}_t\)).</a>
<span class="sourceLineNo">7354</span><a id="line.7354">     * This is a vector ({@code vector&amp;lt;Mat&amp;gt;}) that contains the rotation, {@code (3x3)} rotation matrices or {@code (3x1)} rotation vectors,</a>
<span class="sourceLineNo">7355</span><a id="line.7355">     * for all the transformations from calibration target frame to camera frame.</a>
<span class="sourceLineNo">7356</span><a id="line.7356">     * @param t_target2cam Rotation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7357</span><a id="line.7357">     * expressed in the target frame to the camera frame (\(_{}^{c}\textrm{T}_t\)).</a>
<span class="sourceLineNo">7358</span><a id="line.7358">     * This is a vector ({@code vector&amp;lt;Mat&amp;gt;}) that contains the {@code (3x1)} translation vectors for all the transformations</a>
<span class="sourceLineNo">7359</span><a id="line.7359">     * from calibration target frame to camera frame.</a>
<span class="sourceLineNo">7360</span><a id="line.7360">     * @param R_cam2gripper Estimated {@code (3x3)} rotation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7361</span><a id="line.7361">     * expressed in the camera frame to the gripper frame (\(_{}^{g}\textrm{T}_c\)).</a>
<span class="sourceLineNo">7362</span><a id="line.7362">     * @param t_cam2gripper Estimated {@code (3x1)} translation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7363</span><a id="line.7363">     * expressed in the camera frame to the gripper frame (\(_{}^{g}\textrm{T}_c\)).</a>
<span class="sourceLineNo">7364</span><a id="line.7364">     * @param method One of the implemented Hand-Eye calibration method, see cv::HandEyeCalibrationMethod</a>
<span class="sourceLineNo">7365</span><a id="line.7365">     *</a>
<span class="sourceLineNo">7366</span><a id="line.7366">     * The function performs the Hand-Eye calibration using various methods. One approach consists in estimating the</a>
<span class="sourceLineNo">7367</span><a id="line.7367">     * rotation then the translation (separable solutions) and the following methods are implemented:</a>
<span class="sourceLineNo">7368</span><a id="line.7368">     * &lt;ul&gt;</a>
<span class="sourceLineNo">7369</span><a id="line.7369">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7370</span><a id="line.7370">     *    R. Tsai, R. Lenz A New Technique for Fully Autonomous and Efficient 3D Robotics Hand/EyeCalibration \cite Tsai89</a>
<span class="sourceLineNo">7371</span><a id="line.7371">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7372</span><a id="line.7372">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7373</span><a id="line.7373">     *    F. Park, B. Martin Robot Sensor Calibration: Solving AX = XB on the Euclidean Group \cite Park94</a>
<span class="sourceLineNo">7374</span><a id="line.7374">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7375</span><a id="line.7375">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7376</span><a id="line.7376">     *    R. Horaud, F. Dornaika Hand-Eye Calibration \cite Horaud95</a>
<span class="sourceLineNo">7377</span><a id="line.7377">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7378</span><a id="line.7378">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">7379</span><a id="line.7379">     *</a>
<span class="sourceLineNo">7380</span><a id="line.7380">     * Another approach consists in estimating simultaneously the rotation and the translation (simultaneous solutions),</a>
<span class="sourceLineNo">7381</span><a id="line.7381">     * with the following implemented methods:</a>
<span class="sourceLineNo">7382</span><a id="line.7382">     * &lt;ul&gt;</a>
<span class="sourceLineNo">7383</span><a id="line.7383">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7384</span><a id="line.7384">     *    N. Andreff, R. Horaud, B. Espiau On-line Hand-Eye Calibration \cite Andreff99</a>
<span class="sourceLineNo">7385</span><a id="line.7385">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7386</span><a id="line.7386">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7387</span><a id="line.7387">     *    K. Daniilidis Hand-Eye Calibration Using Dual Quaternions \cite Daniilidis98</a>
<span class="sourceLineNo">7388</span><a id="line.7388">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7389</span><a id="line.7389">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">7390</span><a id="line.7390">     *</a>
<span class="sourceLineNo">7391</span><a id="line.7391">     * The following picture describes the Hand-Eye calibration problem where the transformation between a camera ("eye")</a>
<span class="sourceLineNo">7392</span><a id="line.7392">     * mounted on a robot gripper ("hand") has to be estimated. This configuration is called eye-in-hand.</a>
<span class="sourceLineNo">7393</span><a id="line.7393">     *</a>
<span class="sourceLineNo">7394</span><a id="line.7394">     * The eye-to-hand configuration consists in a static camera observing a calibration pattern mounted on the robot</a>
<span class="sourceLineNo">7395</span><a id="line.7395">     * end-effector. The transformation from the camera to the robot base frame can then be estimated by inputting</a>
<span class="sourceLineNo">7396</span><a id="line.7396">     * the suitable transformations to the function, see below.</a>
<span class="sourceLineNo">7397</span><a id="line.7397">     *</a>
<span class="sourceLineNo">7398</span><a id="line.7398">     * ![](pics/hand-eye_figure.png)</a>
<span class="sourceLineNo">7399</span><a id="line.7399">     *</a>
<span class="sourceLineNo">7400</span><a id="line.7400">     * The calibration procedure is the following:</a>
<span class="sourceLineNo">7401</span><a id="line.7401">     * &lt;ul&gt;</a>
<span class="sourceLineNo">7402</span><a id="line.7402">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7403</span><a id="line.7403">     *    a static calibration pattern is used to estimate the transformation between the target frame</a>
<span class="sourceLineNo">7404</span><a id="line.7404">     *   and the camera frame</a>
<span class="sourceLineNo">7405</span><a id="line.7405">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7406</span><a id="line.7406">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7407</span><a id="line.7407">     *    the robot gripper is moved in order to acquire several poses</a>
<span class="sourceLineNo">7408</span><a id="line.7408">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7409</span><a id="line.7409">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7410</span><a id="line.7410">     *    for each pose, the homogeneous transformation between the gripper frame and the robot base frame is recorded using for</a>
<span class="sourceLineNo">7411</span><a id="line.7411">     *   instance the robot kinematics</a>
<span class="sourceLineNo">7412</span><a id="line.7412">     * \(</a>
<span class="sourceLineNo">7413</span><a id="line.7413">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7414</span><a id="line.7414">     *     X_b\\</a>
<span class="sourceLineNo">7415</span><a id="line.7415">     *     Y_b\\</a>
<span class="sourceLineNo">7416</span><a id="line.7416">     *     Z_b\\</a>
<span class="sourceLineNo">7417</span><a id="line.7417">     *     1</a>
<span class="sourceLineNo">7418</span><a id="line.7418">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7419</span><a id="line.7419">     *     =</a>
<span class="sourceLineNo">7420</span><a id="line.7420">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7421</span><a id="line.7421">     *     _{}^{b}\textrm{R}_g &amp;amp; _{}^{b}\textrm{t}_g \\</a>
<span class="sourceLineNo">7422</span><a id="line.7422">     *     0_{1 \times 3} &amp;amp; 1</a>
<span class="sourceLineNo">7423</span><a id="line.7423">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7424</span><a id="line.7424">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7425</span><a id="line.7425">     *     X_g\\</a>
<span class="sourceLineNo">7426</span><a id="line.7426">     *     Y_g\\</a>
<span class="sourceLineNo">7427</span><a id="line.7427">     *     Z_g\\</a>
<span class="sourceLineNo">7428</span><a id="line.7428">     *     1</a>
<span class="sourceLineNo">7429</span><a id="line.7429">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7430</span><a id="line.7430">     * \)</a>
<span class="sourceLineNo">7431</span><a id="line.7431">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7432</span><a id="line.7432">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7433</span><a id="line.7433">     *    for each pose, the homogeneous transformation between the calibration target frame and the camera frame is recorded using</a>
<span class="sourceLineNo">7434</span><a id="line.7434">     *   for instance a pose estimation method (PnP) from 2D-3D point correspondences</a>
<span class="sourceLineNo">7435</span><a id="line.7435">     * \(</a>
<span class="sourceLineNo">7436</span><a id="line.7436">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7437</span><a id="line.7437">     *     X_c\\</a>
<span class="sourceLineNo">7438</span><a id="line.7438">     *     Y_c\\</a>
<span class="sourceLineNo">7439</span><a id="line.7439">     *     Z_c\\</a>
<span class="sourceLineNo">7440</span><a id="line.7440">     *     1</a>
<span class="sourceLineNo">7441</span><a id="line.7441">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7442</span><a id="line.7442">     *     =</a>
<span class="sourceLineNo">7443</span><a id="line.7443">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7444</span><a id="line.7444">     *     _{}^{c}\textrm{R}_t &amp;amp; _{}^{c}\textrm{t}_t \\</a>
<span class="sourceLineNo">7445</span><a id="line.7445">     *     0_{1 \times 3} &amp;amp; 1</a>
<span class="sourceLineNo">7446</span><a id="line.7446">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7447</span><a id="line.7447">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7448</span><a id="line.7448">     *     X_t\\</a>
<span class="sourceLineNo">7449</span><a id="line.7449">     *     Y_t\\</a>
<span class="sourceLineNo">7450</span><a id="line.7450">     *     Z_t\\</a>
<span class="sourceLineNo">7451</span><a id="line.7451">     *     1</a>
<span class="sourceLineNo">7452</span><a id="line.7452">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7453</span><a id="line.7453">     * \)</a>
<span class="sourceLineNo">7454</span><a id="line.7454">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7455</span><a id="line.7455">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">7456</span><a id="line.7456">     *</a>
<span class="sourceLineNo">7457</span><a id="line.7457">     * The Hand-Eye calibration procedure returns the following homogeneous transformation</a>
<span class="sourceLineNo">7458</span><a id="line.7458">     * \(</a>
<span class="sourceLineNo">7459</span><a id="line.7459">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7460</span><a id="line.7460">     *     X_g\\</a>
<span class="sourceLineNo">7461</span><a id="line.7461">     *     Y_g\\</a>
<span class="sourceLineNo">7462</span><a id="line.7462">     *     Z_g\\</a>
<span class="sourceLineNo">7463</span><a id="line.7463">     *     1</a>
<span class="sourceLineNo">7464</span><a id="line.7464">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7465</span><a id="line.7465">     *     =</a>
<span class="sourceLineNo">7466</span><a id="line.7466">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7467</span><a id="line.7467">     *     _{}^{g}\textrm{R}_c &amp;amp; _{}^{g}\textrm{t}_c \\</a>
<span class="sourceLineNo">7468</span><a id="line.7468">     *     0_{1 \times 3} &amp;amp; 1</a>
<span class="sourceLineNo">7469</span><a id="line.7469">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7470</span><a id="line.7470">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7471</span><a id="line.7471">     *     X_c\\</a>
<span class="sourceLineNo">7472</span><a id="line.7472">     *     Y_c\\</a>
<span class="sourceLineNo">7473</span><a id="line.7473">     *     Z_c\\</a>
<span class="sourceLineNo">7474</span><a id="line.7474">     *     1</a>
<span class="sourceLineNo">7475</span><a id="line.7475">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7476</span><a id="line.7476">     * \)</a>
<span class="sourceLineNo">7477</span><a id="line.7477">     *</a>
<span class="sourceLineNo">7478</span><a id="line.7478">     * This problem is also known as solving the \(\mathbf{A}\mathbf{X}=\mathbf{X}\mathbf{B}\) equation:</a>
<span class="sourceLineNo">7479</span><a id="line.7479">     * &lt;ul&gt;</a>
<span class="sourceLineNo">7480</span><a id="line.7480">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7481</span><a id="line.7481">     *    for an eye-in-hand configuration</a>
<span class="sourceLineNo">7482</span><a id="line.7482">     * \(</a>
<span class="sourceLineNo">7483</span><a id="line.7483">     *     \begin{align*}</a>
<span class="sourceLineNo">7484</span><a id="line.7484">     *     ^{b}{\textrm{T}_g}^{(1)} \hspace{0.2em} ^{g}\textrm{T}_c \hspace{0.2em} ^{c}{\textrm{T}_t}^{(1)} &amp;amp;=</a>
<span class="sourceLineNo">7485</span><a id="line.7485">     *     \hspace{0.1em} ^{b}{\textrm{T}_g}^{(2)} \hspace{0.2em} ^{g}\textrm{T}_c \hspace{0.2em} ^{c}{\textrm{T}_t}^{(2)} \\</a>
<span class="sourceLineNo">7486</span><a id="line.7486">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7487</span><a id="line.7487">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">7488</span><a id="line.7488">     *</a>
<span class="sourceLineNo">7489</span><a id="line.7489">     *     (^{b}{\textrm{T}_g}^{(2)})^{-1} \hspace{0.2em} ^{b}{\textrm{T}_g}^{(1)} \hspace{0.2em} ^{g}\textrm{T}_c &amp;amp;=</a>
<span class="sourceLineNo">7490</span><a id="line.7490">     *     \hspace{0.1em} ^{g}\textrm{T}_c \hspace{0.2em} ^{c}{\textrm{T}_t}^{(2)} (^{c}{\textrm{T}_t}^{(1)})^{-1} \\</a>
<span class="sourceLineNo">7491</span><a id="line.7491">     *</a>
<span class="sourceLineNo">7492</span><a id="line.7492">     *     \textrm{A}_i \textrm{X} &amp;amp;= \textrm{X} \textrm{B}_i \\</a>
<span class="sourceLineNo">7493</span><a id="line.7493">     *     \end{align*}</a>
<span class="sourceLineNo">7494</span><a id="line.7494">     * \)</a>
<span class="sourceLineNo">7495</span><a id="line.7495">     *</a>
<span class="sourceLineNo">7496</span><a id="line.7496">     * &lt;ul&gt;</a>
<span class="sourceLineNo">7497</span><a id="line.7497">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7498</span><a id="line.7498">     *    for an eye-to-hand configuration</a>
<span class="sourceLineNo">7499</span><a id="line.7499">     * \(</a>
<span class="sourceLineNo">7500</span><a id="line.7500">     *     \begin{align*}</a>
<span class="sourceLineNo">7501</span><a id="line.7501">     *     ^{g}{\textrm{T}_b}^{(1)} \hspace{0.2em} ^{b}\textrm{T}_c \hspace{0.2em} ^{c}{\textrm{T}_t}^{(1)} &amp;amp;=</a>
<span class="sourceLineNo">7502</span><a id="line.7502">     *     \hspace{0.1em} ^{g}{\textrm{T}_b}^{(2)} \hspace{0.2em} ^{b}\textrm{T}_c \hspace{0.2em} ^{c}{\textrm{T}_t}^{(2)} \\</a>
<span class="sourceLineNo">7503</span><a id="line.7503">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7504</span><a id="line.7504">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">7505</span><a id="line.7505">     *</a>
<span class="sourceLineNo">7506</span><a id="line.7506">     *     (^{g}{\textrm{T}_b}^{(2)})^{-1} \hspace{0.2em} ^{g}{\textrm{T}_b}^{(1)} \hspace{0.2em} ^{b}\textrm{T}_c &amp;amp;=</a>
<span class="sourceLineNo">7507</span><a id="line.7507">     *     \hspace{0.1em} ^{b}\textrm{T}_c \hspace{0.2em} ^{c}{\textrm{T}_t}^{(2)} (^{c}{\textrm{T}_t}^{(1)})^{-1} \\</a>
<span class="sourceLineNo">7508</span><a id="line.7508">     *</a>
<span class="sourceLineNo">7509</span><a id="line.7509">     *     \textrm{A}_i \textrm{X} &amp;amp;= \textrm{X} \textrm{B}_i \\</a>
<span class="sourceLineNo">7510</span><a id="line.7510">     *     \end{align*}</a>
<span class="sourceLineNo">7511</span><a id="line.7511">     * \)</a>
<span class="sourceLineNo">7512</span><a id="line.7512">     *</a>
<span class="sourceLineNo">7513</span><a id="line.7513">     * \note</a>
<span class="sourceLineNo">7514</span><a id="line.7514">     * Additional information can be found on this [website](http://campar.in.tum.de/Chair/HandEyeCalibration).</a>
<span class="sourceLineNo">7515</span><a id="line.7515">     * \note</a>
<span class="sourceLineNo">7516</span><a id="line.7516">     * A minimum of 2 motions with non parallel rotation axes are necessary to determine the hand-eye transformation.</a>
<span class="sourceLineNo">7517</span><a id="line.7517">     * So at least 3 different poses are required, but it is strongly recommended to use many more poses.</a>
<span class="sourceLineNo">7518</span><a id="line.7518">     */</a>
<span class="sourceLineNo">7519</span><a id="line.7519">    public static void calibrateHandEye(List&lt;Mat&gt; R_gripper2base, List&lt;Mat&gt; t_gripper2base, List&lt;Mat&gt; R_target2cam, List&lt;Mat&gt; t_target2cam, Mat R_cam2gripper, Mat t_cam2gripper, int method) {</a>
<span class="sourceLineNo">7520</span><a id="line.7520">        Mat R_gripper2base_mat = Converters.vector_Mat_to_Mat(R_gripper2base);</a>
<span class="sourceLineNo">7521</span><a id="line.7521">        Mat t_gripper2base_mat = Converters.vector_Mat_to_Mat(t_gripper2base);</a>
<span class="sourceLineNo">7522</span><a id="line.7522">        Mat R_target2cam_mat = Converters.vector_Mat_to_Mat(R_target2cam);</a>
<span class="sourceLineNo">7523</span><a id="line.7523">        Mat t_target2cam_mat = Converters.vector_Mat_to_Mat(t_target2cam);</a>
<span class="sourceLineNo">7524</span><a id="line.7524">        calibrateHandEye_0(R_gripper2base_mat.nativeObj, t_gripper2base_mat.nativeObj, R_target2cam_mat.nativeObj, t_target2cam_mat.nativeObj, R_cam2gripper.nativeObj, t_cam2gripper.nativeObj, method);</a>
<span class="sourceLineNo">7525</span><a id="line.7525">    }</a>
<span class="sourceLineNo">7526</span><a id="line.7526"></a>
<span class="sourceLineNo">7527</span><a id="line.7527">    /**</a>
<span class="sourceLineNo">7528</span><a id="line.7528">     * Computes Hand-Eye calibration: \(_{}^{g}\textrm{T}_c\)</a>
<span class="sourceLineNo">7529</span><a id="line.7529">     *</a>
<span class="sourceLineNo">7530</span><a id="line.7530">     * @param R_gripper2base Rotation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7531</span><a id="line.7531">     * expressed in the gripper frame to the robot base frame (\(_{}^{b}\textrm{T}_g\)).</a>
<span class="sourceLineNo">7532</span><a id="line.7532">     * This is a vector ({@code vector&amp;lt;Mat&amp;gt;}) that contains the rotation, {@code (3x3)} rotation matrices or {@code (3x1)} rotation vectors,</a>
<span class="sourceLineNo">7533</span><a id="line.7533">     * for all the transformations from gripper frame to robot base frame.</a>
<span class="sourceLineNo">7534</span><a id="line.7534">     * @param t_gripper2base Translation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7535</span><a id="line.7535">     * expressed in the gripper frame to the robot base frame (\(_{}^{b}\textrm{T}_g\)).</a>
<span class="sourceLineNo">7536</span><a id="line.7536">     * This is a vector ({@code vector&amp;lt;Mat&amp;gt;}) that contains the {@code (3x1)} translation vectors for all the transformations</a>
<span class="sourceLineNo">7537</span><a id="line.7537">     * from gripper frame to robot base frame.</a>
<span class="sourceLineNo">7538</span><a id="line.7538">     * @param R_target2cam Rotation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7539</span><a id="line.7539">     * expressed in the target frame to the camera frame (\(_{}^{c}\textrm{T}_t\)).</a>
<span class="sourceLineNo">7540</span><a id="line.7540">     * This is a vector ({@code vector&amp;lt;Mat&amp;gt;}) that contains the rotation, {@code (3x3)} rotation matrices or {@code (3x1)} rotation vectors,</a>
<span class="sourceLineNo">7541</span><a id="line.7541">     * for all the transformations from calibration target frame to camera frame.</a>
<span class="sourceLineNo">7542</span><a id="line.7542">     * @param t_target2cam Rotation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7543</span><a id="line.7543">     * expressed in the target frame to the camera frame (\(_{}^{c}\textrm{T}_t\)).</a>
<span class="sourceLineNo">7544</span><a id="line.7544">     * This is a vector ({@code vector&amp;lt;Mat&amp;gt;}) that contains the {@code (3x1)} translation vectors for all the transformations</a>
<span class="sourceLineNo">7545</span><a id="line.7545">     * from calibration target frame to camera frame.</a>
<span class="sourceLineNo">7546</span><a id="line.7546">     * @param R_cam2gripper Estimated {@code (3x3)} rotation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7547</span><a id="line.7547">     * expressed in the camera frame to the gripper frame (\(_{}^{g}\textrm{T}_c\)).</a>
<span class="sourceLineNo">7548</span><a id="line.7548">     * @param t_cam2gripper Estimated {@code (3x1)} translation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7549</span><a id="line.7549">     * expressed in the camera frame to the gripper frame (\(_{}^{g}\textrm{T}_c\)).</a>
<span class="sourceLineNo">7550</span><a id="line.7550">     *</a>
<span class="sourceLineNo">7551</span><a id="line.7551">     * The function performs the Hand-Eye calibration using various methods. One approach consists in estimating the</a>
<span class="sourceLineNo">7552</span><a id="line.7552">     * rotation then the translation (separable solutions) and the following methods are implemented:</a>
<span class="sourceLineNo">7553</span><a id="line.7553">     * &lt;ul&gt;</a>
<span class="sourceLineNo">7554</span><a id="line.7554">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7555</span><a id="line.7555">     *    R. Tsai, R. Lenz A New Technique for Fully Autonomous and Efficient 3D Robotics Hand/EyeCalibration \cite Tsai89</a>
<span class="sourceLineNo">7556</span><a id="line.7556">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7557</span><a id="line.7557">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7558</span><a id="line.7558">     *    F. Park, B. Martin Robot Sensor Calibration: Solving AX = XB on the Euclidean Group \cite Park94</a>
<span class="sourceLineNo">7559</span><a id="line.7559">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7560</span><a id="line.7560">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7561</span><a id="line.7561">     *    R. Horaud, F. Dornaika Hand-Eye Calibration \cite Horaud95</a>
<span class="sourceLineNo">7562</span><a id="line.7562">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7563</span><a id="line.7563">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">7564</span><a id="line.7564">     *</a>
<span class="sourceLineNo">7565</span><a id="line.7565">     * Another approach consists in estimating simultaneously the rotation and the translation (simultaneous solutions),</a>
<span class="sourceLineNo">7566</span><a id="line.7566">     * with the following implemented methods:</a>
<span class="sourceLineNo">7567</span><a id="line.7567">     * &lt;ul&gt;</a>
<span class="sourceLineNo">7568</span><a id="line.7568">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7569</span><a id="line.7569">     *    N. Andreff, R. Horaud, B. Espiau On-line Hand-Eye Calibration \cite Andreff99</a>
<span class="sourceLineNo">7570</span><a id="line.7570">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7571</span><a id="line.7571">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7572</span><a id="line.7572">     *    K. Daniilidis Hand-Eye Calibration Using Dual Quaternions \cite Daniilidis98</a>
<span class="sourceLineNo">7573</span><a id="line.7573">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7574</span><a id="line.7574">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">7575</span><a id="line.7575">     *</a>
<span class="sourceLineNo">7576</span><a id="line.7576">     * The following picture describes the Hand-Eye calibration problem where the transformation between a camera ("eye")</a>
<span class="sourceLineNo">7577</span><a id="line.7577">     * mounted on a robot gripper ("hand") has to be estimated. This configuration is called eye-in-hand.</a>
<span class="sourceLineNo">7578</span><a id="line.7578">     *</a>
<span class="sourceLineNo">7579</span><a id="line.7579">     * The eye-to-hand configuration consists in a static camera observing a calibration pattern mounted on the robot</a>
<span class="sourceLineNo">7580</span><a id="line.7580">     * end-effector. The transformation from the camera to the robot base frame can then be estimated by inputting</a>
<span class="sourceLineNo">7581</span><a id="line.7581">     * the suitable transformations to the function, see below.</a>
<span class="sourceLineNo">7582</span><a id="line.7582">     *</a>
<span class="sourceLineNo">7583</span><a id="line.7583">     * ![](pics/hand-eye_figure.png)</a>
<span class="sourceLineNo">7584</span><a id="line.7584">     *</a>
<span class="sourceLineNo">7585</span><a id="line.7585">     * The calibration procedure is the following:</a>
<span class="sourceLineNo">7586</span><a id="line.7586">     * &lt;ul&gt;</a>
<span class="sourceLineNo">7587</span><a id="line.7587">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7588</span><a id="line.7588">     *    a static calibration pattern is used to estimate the transformation between the target frame</a>
<span class="sourceLineNo">7589</span><a id="line.7589">     *   and the camera frame</a>
<span class="sourceLineNo">7590</span><a id="line.7590">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7591</span><a id="line.7591">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7592</span><a id="line.7592">     *    the robot gripper is moved in order to acquire several poses</a>
<span class="sourceLineNo">7593</span><a id="line.7593">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7594</span><a id="line.7594">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7595</span><a id="line.7595">     *    for each pose, the homogeneous transformation between the gripper frame and the robot base frame is recorded using for</a>
<span class="sourceLineNo">7596</span><a id="line.7596">     *   instance the robot kinematics</a>
<span class="sourceLineNo">7597</span><a id="line.7597">     * \(</a>
<span class="sourceLineNo">7598</span><a id="line.7598">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7599</span><a id="line.7599">     *     X_b\\</a>
<span class="sourceLineNo">7600</span><a id="line.7600">     *     Y_b\\</a>
<span class="sourceLineNo">7601</span><a id="line.7601">     *     Z_b\\</a>
<span class="sourceLineNo">7602</span><a id="line.7602">     *     1</a>
<span class="sourceLineNo">7603</span><a id="line.7603">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7604</span><a id="line.7604">     *     =</a>
<span class="sourceLineNo">7605</span><a id="line.7605">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7606</span><a id="line.7606">     *     _{}^{b}\textrm{R}_g &amp;amp; _{}^{b}\textrm{t}_g \\</a>
<span class="sourceLineNo">7607</span><a id="line.7607">     *     0_{1 \times 3} &amp;amp; 1</a>
<span class="sourceLineNo">7608</span><a id="line.7608">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7609</span><a id="line.7609">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7610</span><a id="line.7610">     *     X_g\\</a>
<span class="sourceLineNo">7611</span><a id="line.7611">     *     Y_g\\</a>
<span class="sourceLineNo">7612</span><a id="line.7612">     *     Z_g\\</a>
<span class="sourceLineNo">7613</span><a id="line.7613">     *     1</a>
<span class="sourceLineNo">7614</span><a id="line.7614">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7615</span><a id="line.7615">     * \)</a>
<span class="sourceLineNo">7616</span><a id="line.7616">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7617</span><a id="line.7617">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7618</span><a id="line.7618">     *    for each pose, the homogeneous transformation between the calibration target frame and the camera frame is recorded using</a>
<span class="sourceLineNo">7619</span><a id="line.7619">     *   for instance a pose estimation method (PnP) from 2D-3D point correspondences</a>
<span class="sourceLineNo">7620</span><a id="line.7620">     * \(</a>
<span class="sourceLineNo">7621</span><a id="line.7621">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7622</span><a id="line.7622">     *     X_c\\</a>
<span class="sourceLineNo">7623</span><a id="line.7623">     *     Y_c\\</a>
<span class="sourceLineNo">7624</span><a id="line.7624">     *     Z_c\\</a>
<span class="sourceLineNo">7625</span><a id="line.7625">     *     1</a>
<span class="sourceLineNo">7626</span><a id="line.7626">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7627</span><a id="line.7627">     *     =</a>
<span class="sourceLineNo">7628</span><a id="line.7628">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7629</span><a id="line.7629">     *     _{}^{c}\textrm{R}_t &amp;amp; _{}^{c}\textrm{t}_t \\</a>
<span class="sourceLineNo">7630</span><a id="line.7630">     *     0_{1 \times 3} &amp;amp; 1</a>
<span class="sourceLineNo">7631</span><a id="line.7631">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7632</span><a id="line.7632">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7633</span><a id="line.7633">     *     X_t\\</a>
<span class="sourceLineNo">7634</span><a id="line.7634">     *     Y_t\\</a>
<span class="sourceLineNo">7635</span><a id="line.7635">     *     Z_t\\</a>
<span class="sourceLineNo">7636</span><a id="line.7636">     *     1</a>
<span class="sourceLineNo">7637</span><a id="line.7637">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7638</span><a id="line.7638">     * \)</a>
<span class="sourceLineNo">7639</span><a id="line.7639">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7640</span><a id="line.7640">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">7641</span><a id="line.7641">     *</a>
<span class="sourceLineNo">7642</span><a id="line.7642">     * The Hand-Eye calibration procedure returns the following homogeneous transformation</a>
<span class="sourceLineNo">7643</span><a id="line.7643">     * \(</a>
<span class="sourceLineNo">7644</span><a id="line.7644">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7645</span><a id="line.7645">     *     X_g\\</a>
<span class="sourceLineNo">7646</span><a id="line.7646">     *     Y_g\\</a>
<span class="sourceLineNo">7647</span><a id="line.7647">     *     Z_g\\</a>
<span class="sourceLineNo">7648</span><a id="line.7648">     *     1</a>
<span class="sourceLineNo">7649</span><a id="line.7649">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7650</span><a id="line.7650">     *     =</a>
<span class="sourceLineNo">7651</span><a id="line.7651">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7652</span><a id="line.7652">     *     _{}^{g}\textrm{R}_c &amp;amp; _{}^{g}\textrm{t}_c \\</a>
<span class="sourceLineNo">7653</span><a id="line.7653">     *     0_{1 \times 3} &amp;amp; 1</a>
<span class="sourceLineNo">7654</span><a id="line.7654">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7655</span><a id="line.7655">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7656</span><a id="line.7656">     *     X_c\\</a>
<span class="sourceLineNo">7657</span><a id="line.7657">     *     Y_c\\</a>
<span class="sourceLineNo">7658</span><a id="line.7658">     *     Z_c\\</a>
<span class="sourceLineNo">7659</span><a id="line.7659">     *     1</a>
<span class="sourceLineNo">7660</span><a id="line.7660">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7661</span><a id="line.7661">     * \)</a>
<span class="sourceLineNo">7662</span><a id="line.7662">     *</a>
<span class="sourceLineNo">7663</span><a id="line.7663">     * This problem is also known as solving the \(\mathbf{A}\mathbf{X}=\mathbf{X}\mathbf{B}\) equation:</a>
<span class="sourceLineNo">7664</span><a id="line.7664">     * &lt;ul&gt;</a>
<span class="sourceLineNo">7665</span><a id="line.7665">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7666</span><a id="line.7666">     *    for an eye-in-hand configuration</a>
<span class="sourceLineNo">7667</span><a id="line.7667">     * \(</a>
<span class="sourceLineNo">7668</span><a id="line.7668">     *     \begin{align*}</a>
<span class="sourceLineNo">7669</span><a id="line.7669">     *     ^{b}{\textrm{T}_g}^{(1)} \hspace{0.2em} ^{g}\textrm{T}_c \hspace{0.2em} ^{c}{\textrm{T}_t}^{(1)} &amp;amp;=</a>
<span class="sourceLineNo">7670</span><a id="line.7670">     *     \hspace{0.1em} ^{b}{\textrm{T}_g}^{(2)} \hspace{0.2em} ^{g}\textrm{T}_c \hspace{0.2em} ^{c}{\textrm{T}_t}^{(2)} \\</a>
<span class="sourceLineNo">7671</span><a id="line.7671">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7672</span><a id="line.7672">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">7673</span><a id="line.7673">     *</a>
<span class="sourceLineNo">7674</span><a id="line.7674">     *     (^{b}{\textrm{T}_g}^{(2)})^{-1} \hspace{0.2em} ^{b}{\textrm{T}_g}^{(1)} \hspace{0.2em} ^{g}\textrm{T}_c &amp;amp;=</a>
<span class="sourceLineNo">7675</span><a id="line.7675">     *     \hspace{0.1em} ^{g}\textrm{T}_c \hspace{0.2em} ^{c}{\textrm{T}_t}^{(2)} (^{c}{\textrm{T}_t}^{(1)})^{-1} \\</a>
<span class="sourceLineNo">7676</span><a id="line.7676">     *</a>
<span class="sourceLineNo">7677</span><a id="line.7677">     *     \textrm{A}_i \textrm{X} &amp;amp;= \textrm{X} \textrm{B}_i \\</a>
<span class="sourceLineNo">7678</span><a id="line.7678">     *     \end{align*}</a>
<span class="sourceLineNo">7679</span><a id="line.7679">     * \)</a>
<span class="sourceLineNo">7680</span><a id="line.7680">     *</a>
<span class="sourceLineNo">7681</span><a id="line.7681">     * &lt;ul&gt;</a>
<span class="sourceLineNo">7682</span><a id="line.7682">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7683</span><a id="line.7683">     *    for an eye-to-hand configuration</a>
<span class="sourceLineNo">7684</span><a id="line.7684">     * \(</a>
<span class="sourceLineNo">7685</span><a id="line.7685">     *     \begin{align*}</a>
<span class="sourceLineNo">7686</span><a id="line.7686">     *     ^{g}{\textrm{T}_b}^{(1)} \hspace{0.2em} ^{b}\textrm{T}_c \hspace{0.2em} ^{c}{\textrm{T}_t}^{(1)} &amp;amp;=</a>
<span class="sourceLineNo">7687</span><a id="line.7687">     *     \hspace{0.1em} ^{g}{\textrm{T}_b}^{(2)} \hspace{0.2em} ^{b}\textrm{T}_c \hspace{0.2em} ^{c}{\textrm{T}_t}^{(2)} \\</a>
<span class="sourceLineNo">7688</span><a id="line.7688">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7689</span><a id="line.7689">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">7690</span><a id="line.7690">     *</a>
<span class="sourceLineNo">7691</span><a id="line.7691">     *     (^{g}{\textrm{T}_b}^{(2)})^{-1} \hspace{0.2em} ^{g}{\textrm{T}_b}^{(1)} \hspace{0.2em} ^{b}\textrm{T}_c &amp;amp;=</a>
<span class="sourceLineNo">7692</span><a id="line.7692">     *     \hspace{0.1em} ^{b}\textrm{T}_c \hspace{0.2em} ^{c}{\textrm{T}_t}^{(2)} (^{c}{\textrm{T}_t}^{(1)})^{-1} \\</a>
<span class="sourceLineNo">7693</span><a id="line.7693">     *</a>
<span class="sourceLineNo">7694</span><a id="line.7694">     *     \textrm{A}_i \textrm{X} &amp;amp;= \textrm{X} \textrm{B}_i \\</a>
<span class="sourceLineNo">7695</span><a id="line.7695">     *     \end{align*}</a>
<span class="sourceLineNo">7696</span><a id="line.7696">     * \)</a>
<span class="sourceLineNo">7697</span><a id="line.7697">     *</a>
<span class="sourceLineNo">7698</span><a id="line.7698">     * \note</a>
<span class="sourceLineNo">7699</span><a id="line.7699">     * Additional information can be found on this [website](http://campar.in.tum.de/Chair/HandEyeCalibration).</a>
<span class="sourceLineNo">7700</span><a id="line.7700">     * \note</a>
<span class="sourceLineNo">7701</span><a id="line.7701">     * A minimum of 2 motions with non parallel rotation axes are necessary to determine the hand-eye transformation.</a>
<span class="sourceLineNo">7702</span><a id="line.7702">     * So at least 3 different poses are required, but it is strongly recommended to use many more poses.</a>
<span class="sourceLineNo">7703</span><a id="line.7703">     */</a>
<span class="sourceLineNo">7704</span><a id="line.7704">    public static void calibrateHandEye(List&lt;Mat&gt; R_gripper2base, List&lt;Mat&gt; t_gripper2base, List&lt;Mat&gt; R_target2cam, List&lt;Mat&gt; t_target2cam, Mat R_cam2gripper, Mat t_cam2gripper) {</a>
<span class="sourceLineNo">7705</span><a id="line.7705">        Mat R_gripper2base_mat = Converters.vector_Mat_to_Mat(R_gripper2base);</a>
<span class="sourceLineNo">7706</span><a id="line.7706">        Mat t_gripper2base_mat = Converters.vector_Mat_to_Mat(t_gripper2base);</a>
<span class="sourceLineNo">7707</span><a id="line.7707">        Mat R_target2cam_mat = Converters.vector_Mat_to_Mat(R_target2cam);</a>
<span class="sourceLineNo">7708</span><a id="line.7708">        Mat t_target2cam_mat = Converters.vector_Mat_to_Mat(t_target2cam);</a>
<span class="sourceLineNo">7709</span><a id="line.7709">        calibrateHandEye_1(R_gripper2base_mat.nativeObj, t_gripper2base_mat.nativeObj, R_target2cam_mat.nativeObj, t_target2cam_mat.nativeObj, R_cam2gripper.nativeObj, t_cam2gripper.nativeObj);</a>
<span class="sourceLineNo">7710</span><a id="line.7710">    }</a>
<span class="sourceLineNo">7711</span><a id="line.7711"></a>
<span class="sourceLineNo">7712</span><a id="line.7712"></a>
<span class="sourceLineNo">7713</span><a id="line.7713">    //</a>
<span class="sourceLineNo">7714</span><a id="line.7714">    // C++:  void cv::calibrateRobotWorldHandEye(vector_Mat R_world2cam, vector_Mat t_world2cam, vector_Mat R_base2gripper, vector_Mat t_base2gripper, Mat&amp; R_base2world, Mat&amp; t_base2world, Mat&amp; R_gripper2cam, Mat&amp; t_gripper2cam, RobotWorldHandEyeCalibrationMethod method = CALIB_ROBOT_WORLD_HAND_EYE_SHAH)</a>
<span class="sourceLineNo">7715</span><a id="line.7715">    //</a>
<span class="sourceLineNo">7716</span><a id="line.7716"></a>
<span class="sourceLineNo">7717</span><a id="line.7717">    /**</a>
<span class="sourceLineNo">7718</span><a id="line.7718">     * Computes Robot-World/Hand-Eye calibration: \(_{}^{w}\textrm{T}_b\) and \(_{}^{c}\textrm{T}_g\)</a>
<span class="sourceLineNo">7719</span><a id="line.7719">     *</a>
<span class="sourceLineNo">7720</span><a id="line.7720">     * @param R_world2cam Rotation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7721</span><a id="line.7721">     * expressed in the world frame to the camera frame (\(_{}^{c}\textrm{T}_w\)).</a>
<span class="sourceLineNo">7722</span><a id="line.7722">     * This is a vector ({@code vector&amp;lt;Mat&amp;gt;}) that contains the rotation, {@code (3x3)} rotation matrices or {@code (3x1)} rotation vectors,</a>
<span class="sourceLineNo">7723</span><a id="line.7723">     * for all the transformations from world frame to the camera frame.</a>
<span class="sourceLineNo">7724</span><a id="line.7724">     * @param t_world2cam Translation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7725</span><a id="line.7725">     * expressed in the world frame to the camera frame (\(_{}^{c}\textrm{T}_w\)).</a>
<span class="sourceLineNo">7726</span><a id="line.7726">     * This is a vector ({@code vector&amp;lt;Mat&amp;gt;}) that contains the {@code (3x1)} translation vectors for all the transformations</a>
<span class="sourceLineNo">7727</span><a id="line.7727">     * from world frame to the camera frame.</a>
<span class="sourceLineNo">7728</span><a id="line.7728">     * @param R_base2gripper Rotation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7729</span><a id="line.7729">     * expressed in the robot base frame to the gripper frame (\(_{}^{g}\textrm{T}_b\)).</a>
<span class="sourceLineNo">7730</span><a id="line.7730">     * This is a vector ({@code vector&amp;lt;Mat&amp;gt;}) that contains the rotation, {@code (3x3)} rotation matrices or {@code (3x1)} rotation vectors,</a>
<span class="sourceLineNo">7731</span><a id="line.7731">     * for all the transformations from robot base frame to the gripper frame.</a>
<span class="sourceLineNo">7732</span><a id="line.7732">     * @param t_base2gripper Rotation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7733</span><a id="line.7733">     * expressed in the robot base frame to the gripper frame (\(_{}^{g}\textrm{T}_b\)).</a>
<span class="sourceLineNo">7734</span><a id="line.7734">     * This is a vector ({@code vector&amp;lt;Mat&amp;gt;}) that contains the {@code (3x1)} translation vectors for all the transformations</a>
<span class="sourceLineNo">7735</span><a id="line.7735">     * from robot base frame to the gripper frame.</a>
<span class="sourceLineNo">7736</span><a id="line.7736">     * @param R_base2world Estimated {@code (3x3)} rotation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7737</span><a id="line.7737">     * expressed in the robot base frame to the world frame (\(_{}^{w}\textrm{T}_b\)).</a>
<span class="sourceLineNo">7738</span><a id="line.7738">     * @param t_base2world Estimated {@code (3x1)} translation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7739</span><a id="line.7739">     * expressed in the robot base frame to the world frame (\(_{}^{w}\textrm{T}_b\)).</a>
<span class="sourceLineNo">7740</span><a id="line.7740">     * @param R_gripper2cam Estimated {@code (3x3)} rotation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7741</span><a id="line.7741">     * expressed in the gripper frame to the camera frame (\(_{}^{c}\textrm{T}_g\)).</a>
<span class="sourceLineNo">7742</span><a id="line.7742">     * @param t_gripper2cam Estimated {@code (3x1)} translation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7743</span><a id="line.7743">     * expressed in the gripper frame to the camera frame (\(_{}^{c}\textrm{T}_g\)).</a>
<span class="sourceLineNo">7744</span><a id="line.7744">     * @param method One of the implemented Robot-World/Hand-Eye calibration method, see cv::RobotWorldHandEyeCalibrationMethod</a>
<span class="sourceLineNo">7745</span><a id="line.7745">     *</a>
<span class="sourceLineNo">7746</span><a id="line.7746">     * The function performs the Robot-World/Hand-Eye calibration using various methods. One approach consists in estimating the</a>
<span class="sourceLineNo">7747</span><a id="line.7747">     * rotation then the translation (separable solutions):</a>
<span class="sourceLineNo">7748</span><a id="line.7748">     * &lt;ul&gt;</a>
<span class="sourceLineNo">7749</span><a id="line.7749">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7750</span><a id="line.7750">     *    M. Shah, Solving the robot-world/hand-eye calibration problem using the kronecker product \cite Shah2013SolvingTR</a>
<span class="sourceLineNo">7751</span><a id="line.7751">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7752</span><a id="line.7752">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">7753</span><a id="line.7753">     *</a>
<span class="sourceLineNo">7754</span><a id="line.7754">     * Another approach consists in estimating simultaneously the rotation and the translation (simultaneous solutions),</a>
<span class="sourceLineNo">7755</span><a id="line.7755">     * with the following implemented method:</a>
<span class="sourceLineNo">7756</span><a id="line.7756">     * &lt;ul&gt;</a>
<span class="sourceLineNo">7757</span><a id="line.7757">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7758</span><a id="line.7758">     *    A. Li, L. Wang, and D. Wu, Simultaneous robot-world and hand-eye calibration using dual-quaternions and kronecker product \cite Li2010SimultaneousRA</a>
<span class="sourceLineNo">7759</span><a id="line.7759">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7760</span><a id="line.7760">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">7761</span><a id="line.7761">     *</a>
<span class="sourceLineNo">7762</span><a id="line.7762">     * The following picture describes the Robot-World/Hand-Eye calibration problem where the transformations between a robot and a world frame</a>
<span class="sourceLineNo">7763</span><a id="line.7763">     * and between a robot gripper ("hand") and a camera ("eye") mounted at the robot end-effector have to be estimated.</a>
<span class="sourceLineNo">7764</span><a id="line.7764">     *</a>
<span class="sourceLineNo">7765</span><a id="line.7765">     * ![](pics/robot-world_hand-eye_figure.png)</a>
<span class="sourceLineNo">7766</span><a id="line.7766">     *</a>
<span class="sourceLineNo">7767</span><a id="line.7767">     * The calibration procedure is the following:</a>
<span class="sourceLineNo">7768</span><a id="line.7768">     * &lt;ul&gt;</a>
<span class="sourceLineNo">7769</span><a id="line.7769">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7770</span><a id="line.7770">     *    a static calibration pattern is used to estimate the transformation between the target frame</a>
<span class="sourceLineNo">7771</span><a id="line.7771">     *   and the camera frame</a>
<span class="sourceLineNo">7772</span><a id="line.7772">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7773</span><a id="line.7773">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7774</span><a id="line.7774">     *    the robot gripper is moved in order to acquire several poses</a>
<span class="sourceLineNo">7775</span><a id="line.7775">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7776</span><a id="line.7776">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7777</span><a id="line.7777">     *    for each pose, the homogeneous transformation between the gripper frame and the robot base frame is recorded using for</a>
<span class="sourceLineNo">7778</span><a id="line.7778">     *   instance the robot kinematics</a>
<span class="sourceLineNo">7779</span><a id="line.7779">     * \(</a>
<span class="sourceLineNo">7780</span><a id="line.7780">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7781</span><a id="line.7781">     *     X_g\\</a>
<span class="sourceLineNo">7782</span><a id="line.7782">     *     Y_g\\</a>
<span class="sourceLineNo">7783</span><a id="line.7783">     *     Z_g\\</a>
<span class="sourceLineNo">7784</span><a id="line.7784">     *     1</a>
<span class="sourceLineNo">7785</span><a id="line.7785">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7786</span><a id="line.7786">     *     =</a>
<span class="sourceLineNo">7787</span><a id="line.7787">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7788</span><a id="line.7788">     *     _{}^{g}\textrm{R}_b &amp;amp; _{}^{g}\textrm{t}_b \\</a>
<span class="sourceLineNo">7789</span><a id="line.7789">     *     0_{1 \times 3} &amp;amp; 1</a>
<span class="sourceLineNo">7790</span><a id="line.7790">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7791</span><a id="line.7791">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7792</span><a id="line.7792">     *     X_b\\</a>
<span class="sourceLineNo">7793</span><a id="line.7793">     *     Y_b\\</a>
<span class="sourceLineNo">7794</span><a id="line.7794">     *     Z_b\\</a>
<span class="sourceLineNo">7795</span><a id="line.7795">     *     1</a>
<span class="sourceLineNo">7796</span><a id="line.7796">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7797</span><a id="line.7797">     * \)</a>
<span class="sourceLineNo">7798</span><a id="line.7798">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7799</span><a id="line.7799">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7800</span><a id="line.7800">     *    for each pose, the homogeneous transformation between the calibration target frame (the world frame) and the camera frame is recorded using</a>
<span class="sourceLineNo">7801</span><a id="line.7801">     *   for instance a pose estimation method (PnP) from 2D-3D point correspondences</a>
<span class="sourceLineNo">7802</span><a id="line.7802">     * \(</a>
<span class="sourceLineNo">7803</span><a id="line.7803">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7804</span><a id="line.7804">     *     X_c\\</a>
<span class="sourceLineNo">7805</span><a id="line.7805">     *     Y_c\\</a>
<span class="sourceLineNo">7806</span><a id="line.7806">     *     Z_c\\</a>
<span class="sourceLineNo">7807</span><a id="line.7807">     *     1</a>
<span class="sourceLineNo">7808</span><a id="line.7808">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7809</span><a id="line.7809">     *     =</a>
<span class="sourceLineNo">7810</span><a id="line.7810">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7811</span><a id="line.7811">     *     _{}^{c}\textrm{R}_w &amp;amp; _{}^{c}\textrm{t}_w \\</a>
<span class="sourceLineNo">7812</span><a id="line.7812">     *     0_{1 \times 3} &amp;amp; 1</a>
<span class="sourceLineNo">7813</span><a id="line.7813">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7814</span><a id="line.7814">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7815</span><a id="line.7815">     *     X_w\\</a>
<span class="sourceLineNo">7816</span><a id="line.7816">     *     Y_w\\</a>
<span class="sourceLineNo">7817</span><a id="line.7817">     *     Z_w\\</a>
<span class="sourceLineNo">7818</span><a id="line.7818">     *     1</a>
<span class="sourceLineNo">7819</span><a id="line.7819">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7820</span><a id="line.7820">     * \)</a>
<span class="sourceLineNo">7821</span><a id="line.7821">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7822</span><a id="line.7822">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">7823</span><a id="line.7823">     *</a>
<span class="sourceLineNo">7824</span><a id="line.7824">     * The Robot-World/Hand-Eye calibration procedure returns the following homogeneous transformations</a>
<span class="sourceLineNo">7825</span><a id="line.7825">     * \(</a>
<span class="sourceLineNo">7826</span><a id="line.7826">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7827</span><a id="line.7827">     *     X_w\\</a>
<span class="sourceLineNo">7828</span><a id="line.7828">     *     Y_w\\</a>
<span class="sourceLineNo">7829</span><a id="line.7829">     *     Z_w\\</a>
<span class="sourceLineNo">7830</span><a id="line.7830">     *     1</a>
<span class="sourceLineNo">7831</span><a id="line.7831">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7832</span><a id="line.7832">     *     =</a>
<span class="sourceLineNo">7833</span><a id="line.7833">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7834</span><a id="line.7834">     *     _{}^{w}\textrm{R}_b &amp;amp; _{}^{w}\textrm{t}_b \\</a>
<span class="sourceLineNo">7835</span><a id="line.7835">     *     0_{1 \times 3} &amp;amp; 1</a>
<span class="sourceLineNo">7836</span><a id="line.7836">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7837</span><a id="line.7837">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7838</span><a id="line.7838">     *     X_b\\</a>
<span class="sourceLineNo">7839</span><a id="line.7839">     *     Y_b\\</a>
<span class="sourceLineNo">7840</span><a id="line.7840">     *     Z_b\\</a>
<span class="sourceLineNo">7841</span><a id="line.7841">     *     1</a>
<span class="sourceLineNo">7842</span><a id="line.7842">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7843</span><a id="line.7843">     * \)</a>
<span class="sourceLineNo">7844</span><a id="line.7844">     * \(</a>
<span class="sourceLineNo">7845</span><a id="line.7845">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7846</span><a id="line.7846">     *     X_c\\</a>
<span class="sourceLineNo">7847</span><a id="line.7847">     *     Y_c\\</a>
<span class="sourceLineNo">7848</span><a id="line.7848">     *     Z_c\\</a>
<span class="sourceLineNo">7849</span><a id="line.7849">     *     1</a>
<span class="sourceLineNo">7850</span><a id="line.7850">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7851</span><a id="line.7851">     *     =</a>
<span class="sourceLineNo">7852</span><a id="line.7852">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7853</span><a id="line.7853">     *     _{}^{c}\textrm{R}_g &amp;amp; _{}^{c}\textrm{t}_g \\</a>
<span class="sourceLineNo">7854</span><a id="line.7854">     *     0_{1 \times 3} &amp;amp; 1</a>
<span class="sourceLineNo">7855</span><a id="line.7855">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7856</span><a id="line.7856">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7857</span><a id="line.7857">     *     X_g\\</a>
<span class="sourceLineNo">7858</span><a id="line.7858">     *     Y_g\\</a>
<span class="sourceLineNo">7859</span><a id="line.7859">     *     Z_g\\</a>
<span class="sourceLineNo">7860</span><a id="line.7860">     *     1</a>
<span class="sourceLineNo">7861</span><a id="line.7861">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7862</span><a id="line.7862">     * \)</a>
<span class="sourceLineNo">7863</span><a id="line.7863">     *</a>
<span class="sourceLineNo">7864</span><a id="line.7864">     * This problem is also known as solving the \(\mathbf{A}\mathbf{X}=\mathbf{Z}\mathbf{B}\) equation, with:</a>
<span class="sourceLineNo">7865</span><a id="line.7865">     * &lt;ul&gt;</a>
<span class="sourceLineNo">7866</span><a id="line.7866">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7867</span><a id="line.7867">     *    \(\mathbf{A} \Leftrightarrow \hspace{0.1em} _{}^{c}\textrm{T}_w\)</a>
<span class="sourceLineNo">7868</span><a id="line.7868">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7869</span><a id="line.7869">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7870</span><a id="line.7870">     *    \(\mathbf{X} \Leftrightarrow \hspace{0.1em} _{}^{w}\textrm{T}_b\)</a>
<span class="sourceLineNo">7871</span><a id="line.7871">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7872</span><a id="line.7872">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7873</span><a id="line.7873">     *    \(\mathbf{Z} \Leftrightarrow \hspace{0.1em} _{}^{c}\textrm{T}_g\)</a>
<span class="sourceLineNo">7874</span><a id="line.7874">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7875</span><a id="line.7875">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7876</span><a id="line.7876">     *    \(\mathbf{B} \Leftrightarrow \hspace{0.1em} _{}^{g}\textrm{T}_b\)</a>
<span class="sourceLineNo">7877</span><a id="line.7877">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7878</span><a id="line.7878">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">7879</span><a id="line.7879">     *</a>
<span class="sourceLineNo">7880</span><a id="line.7880">     * \note</a>
<span class="sourceLineNo">7881</span><a id="line.7881">     * At least 3 measurements are required (input vectors size must be greater or equal to 3).</a>
<span class="sourceLineNo">7882</span><a id="line.7882">     */</a>
<span class="sourceLineNo">7883</span><a id="line.7883">    public static void calibrateRobotWorldHandEye(List&lt;Mat&gt; R_world2cam, List&lt;Mat&gt; t_world2cam, List&lt;Mat&gt; R_base2gripper, List&lt;Mat&gt; t_base2gripper, Mat R_base2world, Mat t_base2world, Mat R_gripper2cam, Mat t_gripper2cam, int method) {</a>
<span class="sourceLineNo">7884</span><a id="line.7884">        Mat R_world2cam_mat = Converters.vector_Mat_to_Mat(R_world2cam);</a>
<span class="sourceLineNo">7885</span><a id="line.7885">        Mat t_world2cam_mat = Converters.vector_Mat_to_Mat(t_world2cam);</a>
<span class="sourceLineNo">7886</span><a id="line.7886">        Mat R_base2gripper_mat = Converters.vector_Mat_to_Mat(R_base2gripper);</a>
<span class="sourceLineNo">7887</span><a id="line.7887">        Mat t_base2gripper_mat = Converters.vector_Mat_to_Mat(t_base2gripper);</a>
<span class="sourceLineNo">7888</span><a id="line.7888">        calibrateRobotWorldHandEye_0(R_world2cam_mat.nativeObj, t_world2cam_mat.nativeObj, R_base2gripper_mat.nativeObj, t_base2gripper_mat.nativeObj, R_base2world.nativeObj, t_base2world.nativeObj, R_gripper2cam.nativeObj, t_gripper2cam.nativeObj, method);</a>
<span class="sourceLineNo">7889</span><a id="line.7889">    }</a>
<span class="sourceLineNo">7890</span><a id="line.7890"></a>
<span class="sourceLineNo">7891</span><a id="line.7891">    /**</a>
<span class="sourceLineNo">7892</span><a id="line.7892">     * Computes Robot-World/Hand-Eye calibration: \(_{}^{w}\textrm{T}_b\) and \(_{}^{c}\textrm{T}_g\)</a>
<span class="sourceLineNo">7893</span><a id="line.7893">     *</a>
<span class="sourceLineNo">7894</span><a id="line.7894">     * @param R_world2cam Rotation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7895</span><a id="line.7895">     * expressed in the world frame to the camera frame (\(_{}^{c}\textrm{T}_w\)).</a>
<span class="sourceLineNo">7896</span><a id="line.7896">     * This is a vector ({@code vector&amp;lt;Mat&amp;gt;}) that contains the rotation, {@code (3x3)} rotation matrices or {@code (3x1)} rotation vectors,</a>
<span class="sourceLineNo">7897</span><a id="line.7897">     * for all the transformations from world frame to the camera frame.</a>
<span class="sourceLineNo">7898</span><a id="line.7898">     * @param t_world2cam Translation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7899</span><a id="line.7899">     * expressed in the world frame to the camera frame (\(_{}^{c}\textrm{T}_w\)).</a>
<span class="sourceLineNo">7900</span><a id="line.7900">     * This is a vector ({@code vector&amp;lt;Mat&amp;gt;}) that contains the {@code (3x1)} translation vectors for all the transformations</a>
<span class="sourceLineNo">7901</span><a id="line.7901">     * from world frame to the camera frame.</a>
<span class="sourceLineNo">7902</span><a id="line.7902">     * @param R_base2gripper Rotation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7903</span><a id="line.7903">     * expressed in the robot base frame to the gripper frame (\(_{}^{g}\textrm{T}_b\)).</a>
<span class="sourceLineNo">7904</span><a id="line.7904">     * This is a vector ({@code vector&amp;lt;Mat&amp;gt;}) that contains the rotation, {@code (3x3)} rotation matrices or {@code (3x1)} rotation vectors,</a>
<span class="sourceLineNo">7905</span><a id="line.7905">     * for all the transformations from robot base frame to the gripper frame.</a>
<span class="sourceLineNo">7906</span><a id="line.7906">     * @param t_base2gripper Rotation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7907</span><a id="line.7907">     * expressed in the robot base frame to the gripper frame (\(_{}^{g}\textrm{T}_b\)).</a>
<span class="sourceLineNo">7908</span><a id="line.7908">     * This is a vector ({@code vector&amp;lt;Mat&amp;gt;}) that contains the {@code (3x1)} translation vectors for all the transformations</a>
<span class="sourceLineNo">7909</span><a id="line.7909">     * from robot base frame to the gripper frame.</a>
<span class="sourceLineNo">7910</span><a id="line.7910">     * @param R_base2world Estimated {@code (3x3)} rotation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7911</span><a id="line.7911">     * expressed in the robot base frame to the world frame (\(_{}^{w}\textrm{T}_b\)).</a>
<span class="sourceLineNo">7912</span><a id="line.7912">     * @param t_base2world Estimated {@code (3x1)} translation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7913</span><a id="line.7913">     * expressed in the robot base frame to the world frame (\(_{}^{w}\textrm{T}_b\)).</a>
<span class="sourceLineNo">7914</span><a id="line.7914">     * @param R_gripper2cam Estimated {@code (3x3)} rotation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7915</span><a id="line.7915">     * expressed in the gripper frame to the camera frame (\(_{}^{c}\textrm{T}_g\)).</a>
<span class="sourceLineNo">7916</span><a id="line.7916">     * @param t_gripper2cam Estimated {@code (3x1)} translation part extracted from the homogeneous matrix that transforms a point</a>
<span class="sourceLineNo">7917</span><a id="line.7917">     * expressed in the gripper frame to the camera frame (\(_{}^{c}\textrm{T}_g\)).</a>
<span class="sourceLineNo">7918</span><a id="line.7918">     *</a>
<span class="sourceLineNo">7919</span><a id="line.7919">     * The function performs the Robot-World/Hand-Eye calibration using various methods. One approach consists in estimating the</a>
<span class="sourceLineNo">7920</span><a id="line.7920">     * rotation then the translation (separable solutions):</a>
<span class="sourceLineNo">7921</span><a id="line.7921">     * &lt;ul&gt;</a>
<span class="sourceLineNo">7922</span><a id="line.7922">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7923</span><a id="line.7923">     *    M. Shah, Solving the robot-world/hand-eye calibration problem using the kronecker product \cite Shah2013SolvingTR</a>
<span class="sourceLineNo">7924</span><a id="line.7924">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7925</span><a id="line.7925">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">7926</span><a id="line.7926">     *</a>
<span class="sourceLineNo">7927</span><a id="line.7927">     * Another approach consists in estimating simultaneously the rotation and the translation (simultaneous solutions),</a>
<span class="sourceLineNo">7928</span><a id="line.7928">     * with the following implemented method:</a>
<span class="sourceLineNo">7929</span><a id="line.7929">     * &lt;ul&gt;</a>
<span class="sourceLineNo">7930</span><a id="line.7930">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7931</span><a id="line.7931">     *    A. Li, L. Wang, and D. Wu, Simultaneous robot-world and hand-eye calibration using dual-quaternions and kronecker product \cite Li2010SimultaneousRA</a>
<span class="sourceLineNo">7932</span><a id="line.7932">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7933</span><a id="line.7933">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">7934</span><a id="line.7934">     *</a>
<span class="sourceLineNo">7935</span><a id="line.7935">     * The following picture describes the Robot-World/Hand-Eye calibration problem where the transformations between a robot and a world frame</a>
<span class="sourceLineNo">7936</span><a id="line.7936">     * and between a robot gripper ("hand") and a camera ("eye") mounted at the robot end-effector have to be estimated.</a>
<span class="sourceLineNo">7937</span><a id="line.7937">     *</a>
<span class="sourceLineNo">7938</span><a id="line.7938">     * ![](pics/robot-world_hand-eye_figure.png)</a>
<span class="sourceLineNo">7939</span><a id="line.7939">     *</a>
<span class="sourceLineNo">7940</span><a id="line.7940">     * The calibration procedure is the following:</a>
<span class="sourceLineNo">7941</span><a id="line.7941">     * &lt;ul&gt;</a>
<span class="sourceLineNo">7942</span><a id="line.7942">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7943</span><a id="line.7943">     *    a static calibration pattern is used to estimate the transformation between the target frame</a>
<span class="sourceLineNo">7944</span><a id="line.7944">     *   and the camera frame</a>
<span class="sourceLineNo">7945</span><a id="line.7945">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7946</span><a id="line.7946">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7947</span><a id="line.7947">     *    the robot gripper is moved in order to acquire several poses</a>
<span class="sourceLineNo">7948</span><a id="line.7948">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7949</span><a id="line.7949">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7950</span><a id="line.7950">     *    for each pose, the homogeneous transformation between the gripper frame and the robot base frame is recorded using for</a>
<span class="sourceLineNo">7951</span><a id="line.7951">     *   instance the robot kinematics</a>
<span class="sourceLineNo">7952</span><a id="line.7952">     * \(</a>
<span class="sourceLineNo">7953</span><a id="line.7953">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7954</span><a id="line.7954">     *     X_g\\</a>
<span class="sourceLineNo">7955</span><a id="line.7955">     *     Y_g\\</a>
<span class="sourceLineNo">7956</span><a id="line.7956">     *     Z_g\\</a>
<span class="sourceLineNo">7957</span><a id="line.7957">     *     1</a>
<span class="sourceLineNo">7958</span><a id="line.7958">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7959</span><a id="line.7959">     *     =</a>
<span class="sourceLineNo">7960</span><a id="line.7960">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7961</span><a id="line.7961">     *     _{}^{g}\textrm{R}_b &amp;amp; _{}^{g}\textrm{t}_b \\</a>
<span class="sourceLineNo">7962</span><a id="line.7962">     *     0_{1 \times 3} &amp;amp; 1</a>
<span class="sourceLineNo">7963</span><a id="line.7963">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7964</span><a id="line.7964">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7965</span><a id="line.7965">     *     X_b\\</a>
<span class="sourceLineNo">7966</span><a id="line.7966">     *     Y_b\\</a>
<span class="sourceLineNo">7967</span><a id="line.7967">     *     Z_b\\</a>
<span class="sourceLineNo">7968</span><a id="line.7968">     *     1</a>
<span class="sourceLineNo">7969</span><a id="line.7969">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7970</span><a id="line.7970">     * \)</a>
<span class="sourceLineNo">7971</span><a id="line.7971">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7972</span><a id="line.7972">     *   &lt;li&gt;</a>
<span class="sourceLineNo">7973</span><a id="line.7973">     *    for each pose, the homogeneous transformation between the calibration target frame (the world frame) and the camera frame is recorded using</a>
<span class="sourceLineNo">7974</span><a id="line.7974">     *   for instance a pose estimation method (PnP) from 2D-3D point correspondences</a>
<span class="sourceLineNo">7975</span><a id="line.7975">     * \(</a>
<span class="sourceLineNo">7976</span><a id="line.7976">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7977</span><a id="line.7977">     *     X_c\\</a>
<span class="sourceLineNo">7978</span><a id="line.7978">     *     Y_c\\</a>
<span class="sourceLineNo">7979</span><a id="line.7979">     *     Z_c\\</a>
<span class="sourceLineNo">7980</span><a id="line.7980">     *     1</a>
<span class="sourceLineNo">7981</span><a id="line.7981">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7982</span><a id="line.7982">     *     =</a>
<span class="sourceLineNo">7983</span><a id="line.7983">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7984</span><a id="line.7984">     *     _{}^{c}\textrm{R}_w &amp;amp; _{}^{c}\textrm{t}_w \\</a>
<span class="sourceLineNo">7985</span><a id="line.7985">     *     0_{1 \times 3} &amp;amp; 1</a>
<span class="sourceLineNo">7986</span><a id="line.7986">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7987</span><a id="line.7987">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">7988</span><a id="line.7988">     *     X_w\\</a>
<span class="sourceLineNo">7989</span><a id="line.7989">     *     Y_w\\</a>
<span class="sourceLineNo">7990</span><a id="line.7990">     *     Z_w\\</a>
<span class="sourceLineNo">7991</span><a id="line.7991">     *     1</a>
<span class="sourceLineNo">7992</span><a id="line.7992">     *     \end{bmatrix}</a>
<span class="sourceLineNo">7993</span><a id="line.7993">     * \)</a>
<span class="sourceLineNo">7994</span><a id="line.7994">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">7995</span><a id="line.7995">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">7996</span><a id="line.7996">     *</a>
<span class="sourceLineNo">7997</span><a id="line.7997">     * The Robot-World/Hand-Eye calibration procedure returns the following homogeneous transformations</a>
<span class="sourceLineNo">7998</span><a id="line.7998">     * \(</a>
<span class="sourceLineNo">7999</span><a id="line.7999">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">8000</span><a id="line.8000">     *     X_w\\</a>
<span class="sourceLineNo">8001</span><a id="line.8001">     *     Y_w\\</a>
<span class="sourceLineNo">8002</span><a id="line.8002">     *     Z_w\\</a>
<span class="sourceLineNo">8003</span><a id="line.8003">     *     1</a>
<span class="sourceLineNo">8004</span><a id="line.8004">     *     \end{bmatrix}</a>
<span class="sourceLineNo">8005</span><a id="line.8005">     *     =</a>
<span class="sourceLineNo">8006</span><a id="line.8006">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">8007</span><a id="line.8007">     *     _{}^{w}\textrm{R}_b &amp;amp; _{}^{w}\textrm{t}_b \\</a>
<span class="sourceLineNo">8008</span><a id="line.8008">     *     0_{1 \times 3} &amp;amp; 1</a>
<span class="sourceLineNo">8009</span><a id="line.8009">     *     \end{bmatrix}</a>
<span class="sourceLineNo">8010</span><a id="line.8010">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">8011</span><a id="line.8011">     *     X_b\\</a>
<span class="sourceLineNo">8012</span><a id="line.8012">     *     Y_b\\</a>
<span class="sourceLineNo">8013</span><a id="line.8013">     *     Z_b\\</a>
<span class="sourceLineNo">8014</span><a id="line.8014">     *     1</a>
<span class="sourceLineNo">8015</span><a id="line.8015">     *     \end{bmatrix}</a>
<span class="sourceLineNo">8016</span><a id="line.8016">     * \)</a>
<span class="sourceLineNo">8017</span><a id="line.8017">     * \(</a>
<span class="sourceLineNo">8018</span><a id="line.8018">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">8019</span><a id="line.8019">     *     X_c\\</a>
<span class="sourceLineNo">8020</span><a id="line.8020">     *     Y_c\\</a>
<span class="sourceLineNo">8021</span><a id="line.8021">     *     Z_c\\</a>
<span class="sourceLineNo">8022</span><a id="line.8022">     *     1</a>
<span class="sourceLineNo">8023</span><a id="line.8023">     *     \end{bmatrix}</a>
<span class="sourceLineNo">8024</span><a id="line.8024">     *     =</a>
<span class="sourceLineNo">8025</span><a id="line.8025">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">8026</span><a id="line.8026">     *     _{}^{c}\textrm{R}_g &amp;amp; _{}^{c}\textrm{t}_g \\</a>
<span class="sourceLineNo">8027</span><a id="line.8027">     *     0_{1 \times 3} &amp;amp; 1</a>
<span class="sourceLineNo">8028</span><a id="line.8028">     *     \end{bmatrix}</a>
<span class="sourceLineNo">8029</span><a id="line.8029">     *     \begin{bmatrix}</a>
<span class="sourceLineNo">8030</span><a id="line.8030">     *     X_g\\</a>
<span class="sourceLineNo">8031</span><a id="line.8031">     *     Y_g\\</a>
<span class="sourceLineNo">8032</span><a id="line.8032">     *     Z_g\\</a>
<span class="sourceLineNo">8033</span><a id="line.8033">     *     1</a>
<span class="sourceLineNo">8034</span><a id="line.8034">     *     \end{bmatrix}</a>
<span class="sourceLineNo">8035</span><a id="line.8035">     * \)</a>
<span class="sourceLineNo">8036</span><a id="line.8036">     *</a>
<span class="sourceLineNo">8037</span><a id="line.8037">     * This problem is also known as solving the \(\mathbf{A}\mathbf{X}=\mathbf{Z}\mathbf{B}\) equation, with:</a>
<span class="sourceLineNo">8038</span><a id="line.8038">     * &lt;ul&gt;</a>
<span class="sourceLineNo">8039</span><a id="line.8039">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8040</span><a id="line.8040">     *    \(\mathbf{A} \Leftrightarrow \hspace{0.1em} _{}^{c}\textrm{T}_w\)</a>
<span class="sourceLineNo">8041</span><a id="line.8041">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8042</span><a id="line.8042">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8043</span><a id="line.8043">     *    \(\mathbf{X} \Leftrightarrow \hspace{0.1em} _{}^{w}\textrm{T}_b\)</a>
<span class="sourceLineNo">8044</span><a id="line.8044">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8045</span><a id="line.8045">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8046</span><a id="line.8046">     *    \(\mathbf{Z} \Leftrightarrow \hspace{0.1em} _{}^{c}\textrm{T}_g\)</a>
<span class="sourceLineNo">8047</span><a id="line.8047">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8048</span><a id="line.8048">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8049</span><a id="line.8049">     *    \(\mathbf{B} \Leftrightarrow \hspace{0.1em} _{}^{g}\textrm{T}_b\)</a>
<span class="sourceLineNo">8050</span><a id="line.8050">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8051</span><a id="line.8051">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">8052</span><a id="line.8052">     *</a>
<span class="sourceLineNo">8053</span><a id="line.8053">     * \note</a>
<span class="sourceLineNo">8054</span><a id="line.8054">     * At least 3 measurements are required (input vectors size must be greater or equal to 3).</a>
<span class="sourceLineNo">8055</span><a id="line.8055">     */</a>
<span class="sourceLineNo">8056</span><a id="line.8056">    public static void calibrateRobotWorldHandEye(List&lt;Mat&gt; R_world2cam, List&lt;Mat&gt; t_world2cam, List&lt;Mat&gt; R_base2gripper, List&lt;Mat&gt; t_base2gripper, Mat R_base2world, Mat t_base2world, Mat R_gripper2cam, Mat t_gripper2cam) {</a>
<span class="sourceLineNo">8057</span><a id="line.8057">        Mat R_world2cam_mat = Converters.vector_Mat_to_Mat(R_world2cam);</a>
<span class="sourceLineNo">8058</span><a id="line.8058">        Mat t_world2cam_mat = Converters.vector_Mat_to_Mat(t_world2cam);</a>
<span class="sourceLineNo">8059</span><a id="line.8059">        Mat R_base2gripper_mat = Converters.vector_Mat_to_Mat(R_base2gripper);</a>
<span class="sourceLineNo">8060</span><a id="line.8060">        Mat t_base2gripper_mat = Converters.vector_Mat_to_Mat(t_base2gripper);</a>
<span class="sourceLineNo">8061</span><a id="line.8061">        calibrateRobotWorldHandEye_1(R_world2cam_mat.nativeObj, t_world2cam_mat.nativeObj, R_base2gripper_mat.nativeObj, t_base2gripper_mat.nativeObj, R_base2world.nativeObj, t_base2world.nativeObj, R_gripper2cam.nativeObj, t_gripper2cam.nativeObj);</a>
<span class="sourceLineNo">8062</span><a id="line.8062">    }</a>
<span class="sourceLineNo">8063</span><a id="line.8063"></a>
<span class="sourceLineNo">8064</span><a id="line.8064"></a>
<span class="sourceLineNo">8065</span><a id="line.8065">    //</a>
<span class="sourceLineNo">8066</span><a id="line.8066">    // C++:  void cv::convertPointsToHomogeneous(Mat src, Mat&amp; dst)</a>
<span class="sourceLineNo">8067</span><a id="line.8067">    //</a>
<span class="sourceLineNo">8068</span><a id="line.8068"></a>
<span class="sourceLineNo">8069</span><a id="line.8069">    /**</a>
<span class="sourceLineNo">8070</span><a id="line.8070">     * Converts points from Euclidean to homogeneous space.</a>
<span class="sourceLineNo">8071</span><a id="line.8071">     *</a>
<span class="sourceLineNo">8072</span><a id="line.8072">     * @param src Input vector of N-dimensional points.</a>
<span class="sourceLineNo">8073</span><a id="line.8073">     * @param dst Output vector of N+1-dimensional points.</a>
<span class="sourceLineNo">8074</span><a id="line.8074">     *</a>
<span class="sourceLineNo">8075</span><a id="line.8075">     * The function converts points from Euclidean to homogeneous space by appending 1's to the tuple of</a>
<span class="sourceLineNo">8076</span><a id="line.8076">     * point coordinates. That is, each point (x1, x2, ..., xn) is converted to (x1, x2, ..., xn, 1).</a>
<span class="sourceLineNo">8077</span><a id="line.8077">     */</a>
<span class="sourceLineNo">8078</span><a id="line.8078">    public static void convertPointsToHomogeneous(Mat src, Mat dst) {</a>
<span class="sourceLineNo">8079</span><a id="line.8079">        convertPointsToHomogeneous_0(src.nativeObj, dst.nativeObj);</a>
<span class="sourceLineNo">8080</span><a id="line.8080">    }</a>
<span class="sourceLineNo">8081</span><a id="line.8081"></a>
<span class="sourceLineNo">8082</span><a id="line.8082"></a>
<span class="sourceLineNo">8083</span><a id="line.8083">    //</a>
<span class="sourceLineNo">8084</span><a id="line.8084">    // C++:  void cv::convertPointsFromHomogeneous(Mat src, Mat&amp; dst)</a>
<span class="sourceLineNo">8085</span><a id="line.8085">    //</a>
<span class="sourceLineNo">8086</span><a id="line.8086"></a>
<span class="sourceLineNo">8087</span><a id="line.8087">    /**</a>
<span class="sourceLineNo">8088</span><a id="line.8088">     * Converts points from homogeneous to Euclidean space.</a>
<span class="sourceLineNo">8089</span><a id="line.8089">     *</a>
<span class="sourceLineNo">8090</span><a id="line.8090">     * @param src Input vector of N-dimensional points.</a>
<span class="sourceLineNo">8091</span><a id="line.8091">     * @param dst Output vector of N-1-dimensional points.</a>
<span class="sourceLineNo">8092</span><a id="line.8092">     *</a>
<span class="sourceLineNo">8093</span><a id="line.8093">     * The function converts points homogeneous to Euclidean space using perspective projection. That is,</a>
<span class="sourceLineNo">8094</span><a id="line.8094">     * each point (x1, x2, ... x(n-1), xn) is converted to (x1/xn, x2/xn, ..., x(n-1)/xn). When xn=0, the</a>
<span class="sourceLineNo">8095</span><a id="line.8095">     * output point coordinates will be (0,0,0,...).</a>
<span class="sourceLineNo">8096</span><a id="line.8096">     */</a>
<span class="sourceLineNo">8097</span><a id="line.8097">    public static void convertPointsFromHomogeneous(Mat src, Mat dst) {</a>
<span class="sourceLineNo">8098</span><a id="line.8098">        convertPointsFromHomogeneous_0(src.nativeObj, dst.nativeObj);</a>
<span class="sourceLineNo">8099</span><a id="line.8099">    }</a>
<span class="sourceLineNo">8100</span><a id="line.8100"></a>
<span class="sourceLineNo">8101</span><a id="line.8101"></a>
<span class="sourceLineNo">8102</span><a id="line.8102">    //</a>
<span class="sourceLineNo">8103</span><a id="line.8103">    // C++:  Mat cv::findFundamentalMat(vector_Point2f points1, vector_Point2f points2, int method, double ransacReprojThreshold, double confidence, int maxIters, Mat&amp; mask = Mat())</a>
<span class="sourceLineNo">8104</span><a id="line.8104">    //</a>
<span class="sourceLineNo">8105</span><a id="line.8105"></a>
<span class="sourceLineNo">8106</span><a id="line.8106">    /**</a>
<span class="sourceLineNo">8107</span><a id="line.8107">     * Calculates a fundamental matrix from the corresponding points in two images.</a>
<span class="sourceLineNo">8108</span><a id="line.8108">     *</a>
<span class="sourceLineNo">8109</span><a id="line.8109">     * @param points1 Array of N points from the first image. The point coordinates should be</a>
<span class="sourceLineNo">8110</span><a id="line.8110">     * floating-point (single or double precision).</a>
<span class="sourceLineNo">8111</span><a id="line.8111">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">8112</span><a id="line.8112">     * @param method Method for computing a fundamental matrix.</a>
<span class="sourceLineNo">8113</span><a id="line.8113">     * &lt;ul&gt;</a>
<span class="sourceLineNo">8114</span><a id="line.8114">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8115</span><a id="line.8115">     *    REF: FM_7POINT for a 7-point algorithm. \(N = 7\)</a>
<span class="sourceLineNo">8116</span><a id="line.8116">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8117</span><a id="line.8117">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8118</span><a id="line.8118">     *    REF: FM_8POINT for an 8-point algorithm. \(N \ge 8\)</a>
<span class="sourceLineNo">8119</span><a id="line.8119">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8120</span><a id="line.8120">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8121</span><a id="line.8121">     *    REF: FM_RANSAC for the RANSAC algorithm. \(N \ge 8\)</a>
<span class="sourceLineNo">8122</span><a id="line.8122">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8123</span><a id="line.8123">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8124</span><a id="line.8124">     *    REF: FM_LMEDS for the LMedS algorithm. \(N \ge 8\)</a>
<span class="sourceLineNo">8125</span><a id="line.8125">     * @param ransacReprojThreshold Parameter used only for RANSAC. It is the maximum distance from a point to an epipolar</a>
<span class="sourceLineNo">8126</span><a id="line.8126">     * line in pixels, beyond which the point is considered an outlier and is not used for computing the</a>
<span class="sourceLineNo">8127</span><a id="line.8127">     * final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the</a>
<span class="sourceLineNo">8128</span><a id="line.8128">     * point localization, image resolution, and the image noise.</a>
<span class="sourceLineNo">8129</span><a id="line.8129">     * @param confidence Parameter used for the RANSAC and LMedS methods only. It specifies a desirable level</a>
<span class="sourceLineNo">8130</span><a id="line.8130">     * of confidence (probability) that the estimated matrix is correct.</a>
<span class="sourceLineNo">8131</span><a id="line.8131">     * @param mask optional output mask</a>
<span class="sourceLineNo">8132</span><a id="line.8132">     * @param maxIters The maximum number of robust method iterations.</a>
<span class="sourceLineNo">8133</span><a id="line.8133">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8134</span><a id="line.8134">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">8135</span><a id="line.8135">     *</a>
<span class="sourceLineNo">8136</span><a id="line.8136">     * The epipolar geometry is described by the following equation:</a>
<span class="sourceLineNo">8137</span><a id="line.8137">     *</a>
<span class="sourceLineNo">8138</span><a id="line.8138">     * \([p_2; 1]^T F [p_1; 1] = 0\)</a>
<span class="sourceLineNo">8139</span><a id="line.8139">     *</a>
<span class="sourceLineNo">8140</span><a id="line.8140">     * where \(F\) is a fundamental matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the</a>
<span class="sourceLineNo">8141</span><a id="line.8141">     * second images, respectively.</a>
<span class="sourceLineNo">8142</span><a id="line.8142">     *</a>
<span class="sourceLineNo">8143</span><a id="line.8143">     * The function calculates the fundamental matrix using one of four methods listed above and returns</a>
<span class="sourceLineNo">8144</span><a id="line.8144">     * the found fundamental matrix. Normally just one matrix is found. But in case of the 7-point</a>
<span class="sourceLineNo">8145</span><a id="line.8145">     * algorithm, the function may return up to 3 solutions ( \(9 \times 3\) matrix that stores all 3</a>
<span class="sourceLineNo">8146</span><a id="line.8146">     * matrices sequentially).</a>
<span class="sourceLineNo">8147</span><a id="line.8147">     *</a>
<span class="sourceLineNo">8148</span><a id="line.8148">     * The calculated fundamental matrix may be passed further to computeCorrespondEpilines that finds the</a>
<span class="sourceLineNo">8149</span><a id="line.8149">     * epipolar lines corresponding to the specified points. It can also be passed to</a>
<span class="sourceLineNo">8150</span><a id="line.8150">     * stereoRectifyUncalibrated to compute the rectification transformation. :</a>
<span class="sourceLineNo">8151</span><a id="line.8151">     * &lt;code&gt;</a>
<span class="sourceLineNo">8152</span><a id="line.8152">     *     // Example. Estimation of fundamental matrix using the RANSAC algorithm</a>
<span class="sourceLineNo">8153</span><a id="line.8153">     *     int point_count = 100;</a>
<span class="sourceLineNo">8154</span><a id="line.8154">     *     vector&amp;lt;Point2f&amp;gt; points1(point_count);</a>
<span class="sourceLineNo">8155</span><a id="line.8155">     *     vector&amp;lt;Point2f&amp;gt; points2(point_count);</a>
<span class="sourceLineNo">8156</span><a id="line.8156">     *</a>
<span class="sourceLineNo">8157</span><a id="line.8157">     *     // initialize the points here ...</a>
<span class="sourceLineNo">8158</span><a id="line.8158">     *     for( int i = 0; i &amp;lt; point_count; i++ )</a>
<span class="sourceLineNo">8159</span><a id="line.8159">     *     {</a>
<span class="sourceLineNo">8160</span><a id="line.8160">     *         points1[i] = ...;</a>
<span class="sourceLineNo">8161</span><a id="line.8161">     *         points2[i] = ...;</a>
<span class="sourceLineNo">8162</span><a id="line.8162">     *     }</a>
<span class="sourceLineNo">8163</span><a id="line.8163">     *</a>
<span class="sourceLineNo">8164</span><a id="line.8164">     *     Mat fundamental_matrix =</a>
<span class="sourceLineNo">8165</span><a id="line.8165">     *      findFundamentalMat(points1, points2, FM_RANSAC, 3, 0.99);</a>
<span class="sourceLineNo">8166</span><a id="line.8166">     * &lt;/code&gt;</a>
<span class="sourceLineNo">8167</span><a id="line.8167">     * @return automatically generated</a>
<span class="sourceLineNo">8168</span><a id="line.8168">     */</a>
<span class="sourceLineNo">8169</span><a id="line.8169">    public static Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, int method, double ransacReprojThreshold, double confidence, int maxIters, Mat mask) {</a>
<span class="sourceLineNo">8170</span><a id="line.8170">        Mat points1_mat = points1;</a>
<span class="sourceLineNo">8171</span><a id="line.8171">        Mat points2_mat = points2;</a>
<span class="sourceLineNo">8172</span><a id="line.8172">        return new Mat(findFundamentalMat_0(points1_mat.nativeObj, points2_mat.nativeObj, method, ransacReprojThreshold, confidence, maxIters, mask.nativeObj));</a>
<span class="sourceLineNo">8173</span><a id="line.8173">    }</a>
<span class="sourceLineNo">8174</span><a id="line.8174"></a>
<span class="sourceLineNo">8175</span><a id="line.8175">    /**</a>
<span class="sourceLineNo">8176</span><a id="line.8176">     * Calculates a fundamental matrix from the corresponding points in two images.</a>
<span class="sourceLineNo">8177</span><a id="line.8177">     *</a>
<span class="sourceLineNo">8178</span><a id="line.8178">     * @param points1 Array of N points from the first image. The point coordinates should be</a>
<span class="sourceLineNo">8179</span><a id="line.8179">     * floating-point (single or double precision).</a>
<span class="sourceLineNo">8180</span><a id="line.8180">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">8181</span><a id="line.8181">     * @param method Method for computing a fundamental matrix.</a>
<span class="sourceLineNo">8182</span><a id="line.8182">     * &lt;ul&gt;</a>
<span class="sourceLineNo">8183</span><a id="line.8183">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8184</span><a id="line.8184">     *    REF: FM_7POINT for a 7-point algorithm. \(N = 7\)</a>
<span class="sourceLineNo">8185</span><a id="line.8185">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8186</span><a id="line.8186">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8187</span><a id="line.8187">     *    REF: FM_8POINT for an 8-point algorithm. \(N \ge 8\)</a>
<span class="sourceLineNo">8188</span><a id="line.8188">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8189</span><a id="line.8189">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8190</span><a id="line.8190">     *    REF: FM_RANSAC for the RANSAC algorithm. \(N \ge 8\)</a>
<span class="sourceLineNo">8191</span><a id="line.8191">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8192</span><a id="line.8192">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8193</span><a id="line.8193">     *    REF: FM_LMEDS for the LMedS algorithm. \(N \ge 8\)</a>
<span class="sourceLineNo">8194</span><a id="line.8194">     * @param ransacReprojThreshold Parameter used only for RANSAC. It is the maximum distance from a point to an epipolar</a>
<span class="sourceLineNo">8195</span><a id="line.8195">     * line in pixels, beyond which the point is considered an outlier and is not used for computing the</a>
<span class="sourceLineNo">8196</span><a id="line.8196">     * final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the</a>
<span class="sourceLineNo">8197</span><a id="line.8197">     * point localization, image resolution, and the image noise.</a>
<span class="sourceLineNo">8198</span><a id="line.8198">     * @param confidence Parameter used for the RANSAC and LMedS methods only. It specifies a desirable level</a>
<span class="sourceLineNo">8199</span><a id="line.8199">     * of confidence (probability) that the estimated matrix is correct.</a>
<span class="sourceLineNo">8200</span><a id="line.8200">     * @param maxIters The maximum number of robust method iterations.</a>
<span class="sourceLineNo">8201</span><a id="line.8201">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8202</span><a id="line.8202">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">8203</span><a id="line.8203">     *</a>
<span class="sourceLineNo">8204</span><a id="line.8204">     * The epipolar geometry is described by the following equation:</a>
<span class="sourceLineNo">8205</span><a id="line.8205">     *</a>
<span class="sourceLineNo">8206</span><a id="line.8206">     * \([p_2; 1]^T F [p_1; 1] = 0\)</a>
<span class="sourceLineNo">8207</span><a id="line.8207">     *</a>
<span class="sourceLineNo">8208</span><a id="line.8208">     * where \(F\) is a fundamental matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the</a>
<span class="sourceLineNo">8209</span><a id="line.8209">     * second images, respectively.</a>
<span class="sourceLineNo">8210</span><a id="line.8210">     *</a>
<span class="sourceLineNo">8211</span><a id="line.8211">     * The function calculates the fundamental matrix using one of four methods listed above and returns</a>
<span class="sourceLineNo">8212</span><a id="line.8212">     * the found fundamental matrix. Normally just one matrix is found. But in case of the 7-point</a>
<span class="sourceLineNo">8213</span><a id="line.8213">     * algorithm, the function may return up to 3 solutions ( \(9 \times 3\) matrix that stores all 3</a>
<span class="sourceLineNo">8214</span><a id="line.8214">     * matrices sequentially).</a>
<span class="sourceLineNo">8215</span><a id="line.8215">     *</a>
<span class="sourceLineNo">8216</span><a id="line.8216">     * The calculated fundamental matrix may be passed further to computeCorrespondEpilines that finds the</a>
<span class="sourceLineNo">8217</span><a id="line.8217">     * epipolar lines corresponding to the specified points. It can also be passed to</a>
<span class="sourceLineNo">8218</span><a id="line.8218">     * stereoRectifyUncalibrated to compute the rectification transformation. :</a>
<span class="sourceLineNo">8219</span><a id="line.8219">     * &lt;code&gt;</a>
<span class="sourceLineNo">8220</span><a id="line.8220">     *     // Example. Estimation of fundamental matrix using the RANSAC algorithm</a>
<span class="sourceLineNo">8221</span><a id="line.8221">     *     int point_count = 100;</a>
<span class="sourceLineNo">8222</span><a id="line.8222">     *     vector&amp;lt;Point2f&amp;gt; points1(point_count);</a>
<span class="sourceLineNo">8223</span><a id="line.8223">     *     vector&amp;lt;Point2f&amp;gt; points2(point_count);</a>
<span class="sourceLineNo">8224</span><a id="line.8224">     *</a>
<span class="sourceLineNo">8225</span><a id="line.8225">     *     // initialize the points here ...</a>
<span class="sourceLineNo">8226</span><a id="line.8226">     *     for( int i = 0; i &amp;lt; point_count; i++ )</a>
<span class="sourceLineNo">8227</span><a id="line.8227">     *     {</a>
<span class="sourceLineNo">8228</span><a id="line.8228">     *         points1[i] = ...;</a>
<span class="sourceLineNo">8229</span><a id="line.8229">     *         points2[i] = ...;</a>
<span class="sourceLineNo">8230</span><a id="line.8230">     *     }</a>
<span class="sourceLineNo">8231</span><a id="line.8231">     *</a>
<span class="sourceLineNo">8232</span><a id="line.8232">     *     Mat fundamental_matrix =</a>
<span class="sourceLineNo">8233</span><a id="line.8233">     *      findFundamentalMat(points1, points2, FM_RANSAC, 3, 0.99);</a>
<span class="sourceLineNo">8234</span><a id="line.8234">     * &lt;/code&gt;</a>
<span class="sourceLineNo">8235</span><a id="line.8235">     * @return automatically generated</a>
<span class="sourceLineNo">8236</span><a id="line.8236">     */</a>
<span class="sourceLineNo">8237</span><a id="line.8237">    public static Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, int method, double ransacReprojThreshold, double confidence, int maxIters) {</a>
<span class="sourceLineNo">8238</span><a id="line.8238">        Mat points1_mat = points1;</a>
<span class="sourceLineNo">8239</span><a id="line.8239">        Mat points2_mat = points2;</a>
<span class="sourceLineNo">8240</span><a id="line.8240">        return new Mat(findFundamentalMat_1(points1_mat.nativeObj, points2_mat.nativeObj, method, ransacReprojThreshold, confidence, maxIters));</a>
<span class="sourceLineNo">8241</span><a id="line.8241">    }</a>
<span class="sourceLineNo">8242</span><a id="line.8242"></a>
<span class="sourceLineNo">8243</span><a id="line.8243"></a>
<span class="sourceLineNo">8244</span><a id="line.8244">    //</a>
<span class="sourceLineNo">8245</span><a id="line.8245">    // C++:  Mat cv::findFundamentalMat(vector_Point2f points1, vector_Point2f points2, int method = FM_RANSAC, double ransacReprojThreshold = 3., double confidence = 0.99, Mat&amp; mask = Mat())</a>
<span class="sourceLineNo">8246</span><a id="line.8246">    //</a>
<span class="sourceLineNo">8247</span><a id="line.8247"></a>
<span class="sourceLineNo">8248</span><a id="line.8248">    public static Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, int method, double ransacReprojThreshold, double confidence, Mat mask) {</a>
<span class="sourceLineNo">8249</span><a id="line.8249">        Mat points1_mat = points1;</a>
<span class="sourceLineNo">8250</span><a id="line.8250">        Mat points2_mat = points2;</a>
<span class="sourceLineNo">8251</span><a id="line.8251">        return new Mat(findFundamentalMat_2(points1_mat.nativeObj, points2_mat.nativeObj, method, ransacReprojThreshold, confidence, mask.nativeObj));</a>
<span class="sourceLineNo">8252</span><a id="line.8252">    }</a>
<span class="sourceLineNo">8253</span><a id="line.8253"></a>
<span class="sourceLineNo">8254</span><a id="line.8254">    public static Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, int method, double ransacReprojThreshold, double confidence) {</a>
<span class="sourceLineNo">8255</span><a id="line.8255">        Mat points1_mat = points1;</a>
<span class="sourceLineNo">8256</span><a id="line.8256">        Mat points2_mat = points2;</a>
<span class="sourceLineNo">8257</span><a id="line.8257">        return new Mat(findFundamentalMat_3(points1_mat.nativeObj, points2_mat.nativeObj, method, ransacReprojThreshold, confidence));</a>
<span class="sourceLineNo">8258</span><a id="line.8258">    }</a>
<span class="sourceLineNo">8259</span><a id="line.8259"></a>
<span class="sourceLineNo">8260</span><a id="line.8260">    public static Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, int method, double ransacReprojThreshold) {</a>
<span class="sourceLineNo">8261</span><a id="line.8261">        Mat points1_mat = points1;</a>
<span class="sourceLineNo">8262</span><a id="line.8262">        Mat points2_mat = points2;</a>
<span class="sourceLineNo">8263</span><a id="line.8263">        return new Mat(findFundamentalMat_4(points1_mat.nativeObj, points2_mat.nativeObj, method, ransacReprojThreshold));</a>
<span class="sourceLineNo">8264</span><a id="line.8264">    }</a>
<span class="sourceLineNo">8265</span><a id="line.8265"></a>
<span class="sourceLineNo">8266</span><a id="line.8266">    public static Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, int method) {</a>
<span class="sourceLineNo">8267</span><a id="line.8267">        Mat points1_mat = points1;</a>
<span class="sourceLineNo">8268</span><a id="line.8268">        Mat points2_mat = points2;</a>
<span class="sourceLineNo">8269</span><a id="line.8269">        return new Mat(findFundamentalMat_5(points1_mat.nativeObj, points2_mat.nativeObj, method));</a>
<span class="sourceLineNo">8270</span><a id="line.8270">    }</a>
<span class="sourceLineNo">8271</span><a id="line.8271"></a>
<span class="sourceLineNo">8272</span><a id="line.8272">    public static Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2) {</a>
<span class="sourceLineNo">8273</span><a id="line.8273">        Mat points1_mat = points1;</a>
<span class="sourceLineNo">8274</span><a id="line.8274">        Mat points2_mat = points2;</a>
<span class="sourceLineNo">8275</span><a id="line.8275">        return new Mat(findFundamentalMat_6(points1_mat.nativeObj, points2_mat.nativeObj));</a>
<span class="sourceLineNo">8276</span><a id="line.8276">    }</a>
<span class="sourceLineNo">8277</span><a id="line.8277"></a>
<span class="sourceLineNo">8278</span><a id="line.8278"></a>
<span class="sourceLineNo">8279</span><a id="line.8279">    //</a>
<span class="sourceLineNo">8280</span><a id="line.8280">    // C++:  Mat cv::findFundamentalMat(vector_Point2f points1, vector_Point2f points2, Mat&amp; mask, UsacParams params)</a>
<span class="sourceLineNo">8281</span><a id="line.8281">    //</a>
<span class="sourceLineNo">8282</span><a id="line.8282"></a>
<span class="sourceLineNo">8283</span><a id="line.8283">    public static Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, Mat mask, UsacParams params) {</a>
<span class="sourceLineNo">8284</span><a id="line.8284">        Mat points1_mat = points1;</a>
<span class="sourceLineNo">8285</span><a id="line.8285">        Mat points2_mat = points2;</a>
<span class="sourceLineNo">8286</span><a id="line.8286">        return new Mat(findFundamentalMat_7(points1_mat.nativeObj, points2_mat.nativeObj, mask.nativeObj, params.nativeObj));</a>
<span class="sourceLineNo">8287</span><a id="line.8287">    }</a>
<span class="sourceLineNo">8288</span><a id="line.8288"></a>
<span class="sourceLineNo">8289</span><a id="line.8289"></a>
<span class="sourceLineNo">8290</span><a id="line.8290">    //</a>
<span class="sourceLineNo">8291</span><a id="line.8291">    // C++:  Mat cv::findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix, int method = RANSAC, double prob = 0.999, double threshold = 1.0, Mat&amp; mask = Mat())</a>
<span class="sourceLineNo">8292</span><a id="line.8292">    //</a>
<span class="sourceLineNo">8293</span><a id="line.8293"></a>
<span class="sourceLineNo">8294</span><a id="line.8294">    /**</a>
<span class="sourceLineNo">8295</span><a id="line.8295">     * Calculates an essential matrix from the corresponding points in two images.</a>
<span class="sourceLineNo">8296</span><a id="line.8296">     *</a>
<span class="sourceLineNo">8297</span><a id="line.8297">     * @param points1 Array of N (N &amp;gt;= 5) 2D points from the first image. The point coordinates should</a>
<span class="sourceLineNo">8298</span><a id="line.8298">     * be floating-point (single or double precision).</a>
<span class="sourceLineNo">8299</span><a id="line.8299">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">8300</span><a id="line.8300">     * @param cameraMatrix Camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">8301</span><a id="line.8301">     * Note that this function assumes that points1 and points2 are feature points from cameras with the</a>
<span class="sourceLineNo">8302</span><a id="line.8302">     * same camera intrinsic matrix. If this assumption does not hold for your use case, use</a>
<span class="sourceLineNo">8303</span><a id="line.8303">     * {@code undistortPoints()} with {@code P = cv::NoArray()} for both cameras to transform image points</a>
<span class="sourceLineNo">8304</span><a id="line.8304">     * to normalized image coordinates, which are valid for the identity camera intrinsic matrix. When</a>
<span class="sourceLineNo">8305</span><a id="line.8305">     * passing these coordinates, pass the identity matrix for this parameter.</a>
<span class="sourceLineNo">8306</span><a id="line.8306">     * @param method Method for computing an essential matrix.</a>
<span class="sourceLineNo">8307</span><a id="line.8307">     * &lt;ul&gt;</a>
<span class="sourceLineNo">8308</span><a id="line.8308">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8309</span><a id="line.8309">     *    REF: RANSAC for the RANSAC algorithm.</a>
<span class="sourceLineNo">8310</span><a id="line.8310">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8311</span><a id="line.8311">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8312</span><a id="line.8312">     *    REF: LMEDS for the LMedS algorithm.</a>
<span class="sourceLineNo">8313</span><a id="line.8313">     * @param prob Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of</a>
<span class="sourceLineNo">8314</span><a id="line.8314">     * confidence (probability) that the estimated matrix is correct.</a>
<span class="sourceLineNo">8315</span><a id="line.8315">     * @param threshold Parameter used for RANSAC. It is the maximum distance from a point to an epipolar</a>
<span class="sourceLineNo">8316</span><a id="line.8316">     * line in pixels, beyond which the point is considered an outlier and is not used for computing the</a>
<span class="sourceLineNo">8317</span><a id="line.8317">     * final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the</a>
<span class="sourceLineNo">8318</span><a id="line.8318">     * point localization, image resolution, and the image noise.</a>
<span class="sourceLineNo">8319</span><a id="line.8319">     * @param mask Output array of N elements, every element of which is set to 0 for outliers and to 1</a>
<span class="sourceLineNo">8320</span><a id="line.8320">     * for the other points. The array is computed only in the RANSAC and LMedS methods.</a>
<span class="sourceLineNo">8321</span><a id="line.8321">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8322</span><a id="line.8322">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">8323</span><a id="line.8323">     *</a>
<span class="sourceLineNo">8324</span><a id="line.8324">     * This function estimates essential matrix based on the five-point algorithm solver in CITE: Nister03 .</a>
<span class="sourceLineNo">8325</span><a id="line.8325">     * CITE: SteweniusCFS is also a related. The epipolar geometry is described by the following equation:</a>
<span class="sourceLineNo">8326</span><a id="line.8326">     *</a>
<span class="sourceLineNo">8327</span><a id="line.8327">     * \([p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\)</a>
<span class="sourceLineNo">8328</span><a id="line.8328">     *</a>
<span class="sourceLineNo">8329</span><a id="line.8329">     * where \(E\) is an essential matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the</a>
<span class="sourceLineNo">8330</span><a id="line.8330">     * second images, respectively. The result of this function may be passed further to</a>
<span class="sourceLineNo">8331</span><a id="line.8331">     * decomposeEssentialMat or recoverPose to recover the relative pose between cameras.</a>
<span class="sourceLineNo">8332</span><a id="line.8332">     * @return automatically generated</a>
<span class="sourceLineNo">8333</span><a id="line.8333">     */</a>
<span class="sourceLineNo">8334</span><a id="line.8334">    public static Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix, int method, double prob, double threshold, Mat mask) {</a>
<span class="sourceLineNo">8335</span><a id="line.8335">        return new Mat(findEssentialMat_0(points1.nativeObj, points2.nativeObj, cameraMatrix.nativeObj, method, prob, threshold, mask.nativeObj));</a>
<span class="sourceLineNo">8336</span><a id="line.8336">    }</a>
<span class="sourceLineNo">8337</span><a id="line.8337"></a>
<span class="sourceLineNo">8338</span><a id="line.8338">    /**</a>
<span class="sourceLineNo">8339</span><a id="line.8339">     * Calculates an essential matrix from the corresponding points in two images.</a>
<span class="sourceLineNo">8340</span><a id="line.8340">     *</a>
<span class="sourceLineNo">8341</span><a id="line.8341">     * @param points1 Array of N (N &amp;gt;= 5) 2D points from the first image. The point coordinates should</a>
<span class="sourceLineNo">8342</span><a id="line.8342">     * be floating-point (single or double precision).</a>
<span class="sourceLineNo">8343</span><a id="line.8343">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">8344</span><a id="line.8344">     * @param cameraMatrix Camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">8345</span><a id="line.8345">     * Note that this function assumes that points1 and points2 are feature points from cameras with the</a>
<span class="sourceLineNo">8346</span><a id="line.8346">     * same camera intrinsic matrix. If this assumption does not hold for your use case, use</a>
<span class="sourceLineNo">8347</span><a id="line.8347">     * {@code undistortPoints()} with {@code P = cv::NoArray()} for both cameras to transform image points</a>
<span class="sourceLineNo">8348</span><a id="line.8348">     * to normalized image coordinates, which are valid for the identity camera intrinsic matrix. When</a>
<span class="sourceLineNo">8349</span><a id="line.8349">     * passing these coordinates, pass the identity matrix for this parameter.</a>
<span class="sourceLineNo">8350</span><a id="line.8350">     * @param method Method for computing an essential matrix.</a>
<span class="sourceLineNo">8351</span><a id="line.8351">     * &lt;ul&gt;</a>
<span class="sourceLineNo">8352</span><a id="line.8352">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8353</span><a id="line.8353">     *    REF: RANSAC for the RANSAC algorithm.</a>
<span class="sourceLineNo">8354</span><a id="line.8354">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8355</span><a id="line.8355">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8356</span><a id="line.8356">     *    REF: LMEDS for the LMedS algorithm.</a>
<span class="sourceLineNo">8357</span><a id="line.8357">     * @param prob Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of</a>
<span class="sourceLineNo">8358</span><a id="line.8358">     * confidence (probability) that the estimated matrix is correct.</a>
<span class="sourceLineNo">8359</span><a id="line.8359">     * @param threshold Parameter used for RANSAC. It is the maximum distance from a point to an epipolar</a>
<span class="sourceLineNo">8360</span><a id="line.8360">     * line in pixels, beyond which the point is considered an outlier and is not used for computing the</a>
<span class="sourceLineNo">8361</span><a id="line.8361">     * final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the</a>
<span class="sourceLineNo">8362</span><a id="line.8362">     * point localization, image resolution, and the image noise.</a>
<span class="sourceLineNo">8363</span><a id="line.8363">     * for the other points. The array is computed only in the RANSAC and LMedS methods.</a>
<span class="sourceLineNo">8364</span><a id="line.8364">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8365</span><a id="line.8365">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">8366</span><a id="line.8366">     *</a>
<span class="sourceLineNo">8367</span><a id="line.8367">     * This function estimates essential matrix based on the five-point algorithm solver in CITE: Nister03 .</a>
<span class="sourceLineNo">8368</span><a id="line.8368">     * CITE: SteweniusCFS is also a related. The epipolar geometry is described by the following equation:</a>
<span class="sourceLineNo">8369</span><a id="line.8369">     *</a>
<span class="sourceLineNo">8370</span><a id="line.8370">     * \([p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\)</a>
<span class="sourceLineNo">8371</span><a id="line.8371">     *</a>
<span class="sourceLineNo">8372</span><a id="line.8372">     * where \(E\) is an essential matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the</a>
<span class="sourceLineNo">8373</span><a id="line.8373">     * second images, respectively. The result of this function may be passed further to</a>
<span class="sourceLineNo">8374</span><a id="line.8374">     * decomposeEssentialMat or recoverPose to recover the relative pose between cameras.</a>
<span class="sourceLineNo">8375</span><a id="line.8375">     * @return automatically generated</a>
<span class="sourceLineNo">8376</span><a id="line.8376">     */</a>
<span class="sourceLineNo">8377</span><a id="line.8377">    public static Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix, int method, double prob, double threshold) {</a>
<span class="sourceLineNo">8378</span><a id="line.8378">        return new Mat(findEssentialMat_1(points1.nativeObj, points2.nativeObj, cameraMatrix.nativeObj, method, prob, threshold));</a>
<span class="sourceLineNo">8379</span><a id="line.8379">    }</a>
<span class="sourceLineNo">8380</span><a id="line.8380"></a>
<span class="sourceLineNo">8381</span><a id="line.8381">    /**</a>
<span class="sourceLineNo">8382</span><a id="line.8382">     * Calculates an essential matrix from the corresponding points in two images.</a>
<span class="sourceLineNo">8383</span><a id="line.8383">     *</a>
<span class="sourceLineNo">8384</span><a id="line.8384">     * @param points1 Array of N (N &amp;gt;= 5) 2D points from the first image. The point coordinates should</a>
<span class="sourceLineNo">8385</span><a id="line.8385">     * be floating-point (single or double precision).</a>
<span class="sourceLineNo">8386</span><a id="line.8386">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">8387</span><a id="line.8387">     * @param cameraMatrix Camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">8388</span><a id="line.8388">     * Note that this function assumes that points1 and points2 are feature points from cameras with the</a>
<span class="sourceLineNo">8389</span><a id="line.8389">     * same camera intrinsic matrix. If this assumption does not hold for your use case, use</a>
<span class="sourceLineNo">8390</span><a id="line.8390">     * {@code undistortPoints()} with {@code P = cv::NoArray()} for both cameras to transform image points</a>
<span class="sourceLineNo">8391</span><a id="line.8391">     * to normalized image coordinates, which are valid for the identity camera intrinsic matrix. When</a>
<span class="sourceLineNo">8392</span><a id="line.8392">     * passing these coordinates, pass the identity matrix for this parameter.</a>
<span class="sourceLineNo">8393</span><a id="line.8393">     * @param method Method for computing an essential matrix.</a>
<span class="sourceLineNo">8394</span><a id="line.8394">     * &lt;ul&gt;</a>
<span class="sourceLineNo">8395</span><a id="line.8395">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8396</span><a id="line.8396">     *    REF: RANSAC for the RANSAC algorithm.</a>
<span class="sourceLineNo">8397</span><a id="line.8397">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8398</span><a id="line.8398">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8399</span><a id="line.8399">     *    REF: LMEDS for the LMedS algorithm.</a>
<span class="sourceLineNo">8400</span><a id="line.8400">     * @param prob Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of</a>
<span class="sourceLineNo">8401</span><a id="line.8401">     * confidence (probability) that the estimated matrix is correct.</a>
<span class="sourceLineNo">8402</span><a id="line.8402">     * line in pixels, beyond which the point is considered an outlier and is not used for computing the</a>
<span class="sourceLineNo">8403</span><a id="line.8403">     * final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the</a>
<span class="sourceLineNo">8404</span><a id="line.8404">     * point localization, image resolution, and the image noise.</a>
<span class="sourceLineNo">8405</span><a id="line.8405">     * for the other points. The array is computed only in the RANSAC and LMedS methods.</a>
<span class="sourceLineNo">8406</span><a id="line.8406">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8407</span><a id="line.8407">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">8408</span><a id="line.8408">     *</a>
<span class="sourceLineNo">8409</span><a id="line.8409">     * This function estimates essential matrix based on the five-point algorithm solver in CITE: Nister03 .</a>
<span class="sourceLineNo">8410</span><a id="line.8410">     * CITE: SteweniusCFS is also a related. The epipolar geometry is described by the following equation:</a>
<span class="sourceLineNo">8411</span><a id="line.8411">     *</a>
<span class="sourceLineNo">8412</span><a id="line.8412">     * \([p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\)</a>
<span class="sourceLineNo">8413</span><a id="line.8413">     *</a>
<span class="sourceLineNo">8414</span><a id="line.8414">     * where \(E\) is an essential matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the</a>
<span class="sourceLineNo">8415</span><a id="line.8415">     * second images, respectively. The result of this function may be passed further to</a>
<span class="sourceLineNo">8416</span><a id="line.8416">     * decomposeEssentialMat or recoverPose to recover the relative pose between cameras.</a>
<span class="sourceLineNo">8417</span><a id="line.8417">     * @return automatically generated</a>
<span class="sourceLineNo">8418</span><a id="line.8418">     */</a>
<span class="sourceLineNo">8419</span><a id="line.8419">    public static Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix, int method, double prob) {</a>
<span class="sourceLineNo">8420</span><a id="line.8420">        return new Mat(findEssentialMat_2(points1.nativeObj, points2.nativeObj, cameraMatrix.nativeObj, method, prob));</a>
<span class="sourceLineNo">8421</span><a id="line.8421">    }</a>
<span class="sourceLineNo">8422</span><a id="line.8422"></a>
<span class="sourceLineNo">8423</span><a id="line.8423">    /**</a>
<span class="sourceLineNo">8424</span><a id="line.8424">     * Calculates an essential matrix from the corresponding points in two images.</a>
<span class="sourceLineNo">8425</span><a id="line.8425">     *</a>
<span class="sourceLineNo">8426</span><a id="line.8426">     * @param points1 Array of N (N &amp;gt;= 5) 2D points from the first image. The point coordinates should</a>
<span class="sourceLineNo">8427</span><a id="line.8427">     * be floating-point (single or double precision).</a>
<span class="sourceLineNo">8428</span><a id="line.8428">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">8429</span><a id="line.8429">     * @param cameraMatrix Camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">8430</span><a id="line.8430">     * Note that this function assumes that points1 and points2 are feature points from cameras with the</a>
<span class="sourceLineNo">8431</span><a id="line.8431">     * same camera intrinsic matrix. If this assumption does not hold for your use case, use</a>
<span class="sourceLineNo">8432</span><a id="line.8432">     * {@code undistortPoints()} with {@code P = cv::NoArray()} for both cameras to transform image points</a>
<span class="sourceLineNo">8433</span><a id="line.8433">     * to normalized image coordinates, which are valid for the identity camera intrinsic matrix. When</a>
<span class="sourceLineNo">8434</span><a id="line.8434">     * passing these coordinates, pass the identity matrix for this parameter.</a>
<span class="sourceLineNo">8435</span><a id="line.8435">     * @param method Method for computing an essential matrix.</a>
<span class="sourceLineNo">8436</span><a id="line.8436">     * &lt;ul&gt;</a>
<span class="sourceLineNo">8437</span><a id="line.8437">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8438</span><a id="line.8438">     *    REF: RANSAC for the RANSAC algorithm.</a>
<span class="sourceLineNo">8439</span><a id="line.8439">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8440</span><a id="line.8440">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8441</span><a id="line.8441">     *    REF: LMEDS for the LMedS algorithm.</a>
<span class="sourceLineNo">8442</span><a id="line.8442">     * confidence (probability) that the estimated matrix is correct.</a>
<span class="sourceLineNo">8443</span><a id="line.8443">     * line in pixels, beyond which the point is considered an outlier and is not used for computing the</a>
<span class="sourceLineNo">8444</span><a id="line.8444">     * final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the</a>
<span class="sourceLineNo">8445</span><a id="line.8445">     * point localization, image resolution, and the image noise.</a>
<span class="sourceLineNo">8446</span><a id="line.8446">     * for the other points. The array is computed only in the RANSAC and LMedS methods.</a>
<span class="sourceLineNo">8447</span><a id="line.8447">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8448</span><a id="line.8448">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">8449</span><a id="line.8449">     *</a>
<span class="sourceLineNo">8450</span><a id="line.8450">     * This function estimates essential matrix based on the five-point algorithm solver in CITE: Nister03 .</a>
<span class="sourceLineNo">8451</span><a id="line.8451">     * CITE: SteweniusCFS is also a related. The epipolar geometry is described by the following equation:</a>
<span class="sourceLineNo">8452</span><a id="line.8452">     *</a>
<span class="sourceLineNo">8453</span><a id="line.8453">     * \([p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\)</a>
<span class="sourceLineNo">8454</span><a id="line.8454">     *</a>
<span class="sourceLineNo">8455</span><a id="line.8455">     * where \(E\) is an essential matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the</a>
<span class="sourceLineNo">8456</span><a id="line.8456">     * second images, respectively. The result of this function may be passed further to</a>
<span class="sourceLineNo">8457</span><a id="line.8457">     * decomposeEssentialMat or recoverPose to recover the relative pose between cameras.</a>
<span class="sourceLineNo">8458</span><a id="line.8458">     * @return automatically generated</a>
<span class="sourceLineNo">8459</span><a id="line.8459">     */</a>
<span class="sourceLineNo">8460</span><a id="line.8460">    public static Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix, int method) {</a>
<span class="sourceLineNo">8461</span><a id="line.8461">        return new Mat(findEssentialMat_3(points1.nativeObj, points2.nativeObj, cameraMatrix.nativeObj, method));</a>
<span class="sourceLineNo">8462</span><a id="line.8462">    }</a>
<span class="sourceLineNo">8463</span><a id="line.8463"></a>
<span class="sourceLineNo">8464</span><a id="line.8464">    /**</a>
<span class="sourceLineNo">8465</span><a id="line.8465">     * Calculates an essential matrix from the corresponding points in two images.</a>
<span class="sourceLineNo">8466</span><a id="line.8466">     *</a>
<span class="sourceLineNo">8467</span><a id="line.8467">     * @param points1 Array of N (N &amp;gt;= 5) 2D points from the first image. The point coordinates should</a>
<span class="sourceLineNo">8468</span><a id="line.8468">     * be floating-point (single or double precision).</a>
<span class="sourceLineNo">8469</span><a id="line.8469">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">8470</span><a id="line.8470">     * @param cameraMatrix Camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">8471</span><a id="line.8471">     * Note that this function assumes that points1 and points2 are feature points from cameras with the</a>
<span class="sourceLineNo">8472</span><a id="line.8472">     * same camera intrinsic matrix. If this assumption does not hold for your use case, use</a>
<span class="sourceLineNo">8473</span><a id="line.8473">     * {@code undistortPoints()} with {@code P = cv::NoArray()} for both cameras to transform image points</a>
<span class="sourceLineNo">8474</span><a id="line.8474">     * to normalized image coordinates, which are valid for the identity camera intrinsic matrix. When</a>
<span class="sourceLineNo">8475</span><a id="line.8475">     * passing these coordinates, pass the identity matrix for this parameter.</a>
<span class="sourceLineNo">8476</span><a id="line.8476">     * &lt;ul&gt;</a>
<span class="sourceLineNo">8477</span><a id="line.8477">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8478</span><a id="line.8478">     *    REF: RANSAC for the RANSAC algorithm.</a>
<span class="sourceLineNo">8479</span><a id="line.8479">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8480</span><a id="line.8480">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8481</span><a id="line.8481">     *    REF: LMEDS for the LMedS algorithm.</a>
<span class="sourceLineNo">8482</span><a id="line.8482">     * confidence (probability) that the estimated matrix is correct.</a>
<span class="sourceLineNo">8483</span><a id="line.8483">     * line in pixels, beyond which the point is considered an outlier and is not used for computing the</a>
<span class="sourceLineNo">8484</span><a id="line.8484">     * final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the</a>
<span class="sourceLineNo">8485</span><a id="line.8485">     * point localization, image resolution, and the image noise.</a>
<span class="sourceLineNo">8486</span><a id="line.8486">     * for the other points. The array is computed only in the RANSAC and LMedS methods.</a>
<span class="sourceLineNo">8487</span><a id="line.8487">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8488</span><a id="line.8488">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">8489</span><a id="line.8489">     *</a>
<span class="sourceLineNo">8490</span><a id="line.8490">     * This function estimates essential matrix based on the five-point algorithm solver in CITE: Nister03 .</a>
<span class="sourceLineNo">8491</span><a id="line.8491">     * CITE: SteweniusCFS is also a related. The epipolar geometry is described by the following equation:</a>
<span class="sourceLineNo">8492</span><a id="line.8492">     *</a>
<span class="sourceLineNo">8493</span><a id="line.8493">     * \([p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\)</a>
<span class="sourceLineNo">8494</span><a id="line.8494">     *</a>
<span class="sourceLineNo">8495</span><a id="line.8495">     * where \(E\) is an essential matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the</a>
<span class="sourceLineNo">8496</span><a id="line.8496">     * second images, respectively. The result of this function may be passed further to</a>
<span class="sourceLineNo">8497</span><a id="line.8497">     * decomposeEssentialMat or recoverPose to recover the relative pose between cameras.</a>
<span class="sourceLineNo">8498</span><a id="line.8498">     * @return automatically generated</a>
<span class="sourceLineNo">8499</span><a id="line.8499">     */</a>
<span class="sourceLineNo">8500</span><a id="line.8500">    public static Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix) {</a>
<span class="sourceLineNo">8501</span><a id="line.8501">        return new Mat(findEssentialMat_4(points1.nativeObj, points2.nativeObj, cameraMatrix.nativeObj));</a>
<span class="sourceLineNo">8502</span><a id="line.8502">    }</a>
<span class="sourceLineNo">8503</span><a id="line.8503"></a>
<span class="sourceLineNo">8504</span><a id="line.8504"></a>
<span class="sourceLineNo">8505</span><a id="line.8505">    //</a>
<span class="sourceLineNo">8506</span><a id="line.8506">    // C++:  Mat cv::findEssentialMat(Mat points1, Mat points2, double focal = 1.0, Point2d pp = Point2d(0, 0), int method = RANSAC, double prob = 0.999, double threshold = 1.0, Mat&amp; mask = Mat())</a>
<span class="sourceLineNo">8507</span><a id="line.8507">    //</a>
<span class="sourceLineNo">8508</span><a id="line.8508"></a>
<span class="sourceLineNo">8509</span><a id="line.8509">    /**</a>
<span class="sourceLineNo">8510</span><a id="line.8510">     *</a>
<span class="sourceLineNo">8511</span><a id="line.8511">     * @param points1 Array of N (N &amp;gt;= 5) 2D points from the first image. The point coordinates should</a>
<span class="sourceLineNo">8512</span><a id="line.8512">     * be floating-point (single or double precision).</a>
<span class="sourceLineNo">8513</span><a id="line.8513">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">8514</span><a id="line.8514">     * @param focal focal length of the camera. Note that this function assumes that points1 and points2</a>
<span class="sourceLineNo">8515</span><a id="line.8515">     * are feature points from cameras with same focal length and principal point.</a>
<span class="sourceLineNo">8516</span><a id="line.8516">     * @param pp principal point of the camera.</a>
<span class="sourceLineNo">8517</span><a id="line.8517">     * @param method Method for computing a fundamental matrix.</a>
<span class="sourceLineNo">8518</span><a id="line.8518">     * &lt;ul&gt;</a>
<span class="sourceLineNo">8519</span><a id="line.8519">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8520</span><a id="line.8520">     *    REF: RANSAC for the RANSAC algorithm.</a>
<span class="sourceLineNo">8521</span><a id="line.8521">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8522</span><a id="line.8522">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8523</span><a id="line.8523">     *    REF: LMEDS for the LMedS algorithm.</a>
<span class="sourceLineNo">8524</span><a id="line.8524">     * @param threshold Parameter used for RANSAC. It is the maximum distance from a point to an epipolar</a>
<span class="sourceLineNo">8525</span><a id="line.8525">     * line in pixels, beyond which the point is considered an outlier and is not used for computing the</a>
<span class="sourceLineNo">8526</span><a id="line.8526">     * final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the</a>
<span class="sourceLineNo">8527</span><a id="line.8527">     * point localization, image resolution, and the image noise.</a>
<span class="sourceLineNo">8528</span><a id="line.8528">     * @param prob Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of</a>
<span class="sourceLineNo">8529</span><a id="line.8529">     * confidence (probability) that the estimated matrix is correct.</a>
<span class="sourceLineNo">8530</span><a id="line.8530">     * @param mask Output array of N elements, every element of which is set to 0 for outliers and to 1</a>
<span class="sourceLineNo">8531</span><a id="line.8531">     * for the other points. The array is computed only in the RANSAC and LMedS methods.</a>
<span class="sourceLineNo">8532</span><a id="line.8532">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8533</span><a id="line.8533">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">8534</span><a id="line.8534">     *</a>
<span class="sourceLineNo">8535</span><a id="line.8535">     * This function differs from the one above that it computes camera intrinsic matrix from focal length and</a>
<span class="sourceLineNo">8536</span><a id="line.8536">     * principal point:</a>
<span class="sourceLineNo">8537</span><a id="line.8537">     *</a>
<span class="sourceLineNo">8538</span><a id="line.8538">     * \(A =</a>
<span class="sourceLineNo">8539</span><a id="line.8539">     * \begin{bmatrix}</a>
<span class="sourceLineNo">8540</span><a id="line.8540">     * f &amp;amp; 0 &amp;amp; x_{pp}  \\</a>
<span class="sourceLineNo">8541</span><a id="line.8541">     * 0 &amp;amp; f &amp;amp; y_{pp}  \\</a>
<span class="sourceLineNo">8542</span><a id="line.8542">     * 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">8543</span><a id="line.8543">     * \end{bmatrix}\)</a>
<span class="sourceLineNo">8544</span><a id="line.8544">     * @return automatically generated</a>
<span class="sourceLineNo">8545</span><a id="line.8545">     */</a>
<span class="sourceLineNo">8546</span><a id="line.8546">    public static Mat findEssentialMat(Mat points1, Mat points2, double focal, Point pp, int method, double prob, double threshold, Mat mask) {</a>
<span class="sourceLineNo">8547</span><a id="line.8547">        return new Mat(findEssentialMat_5(points1.nativeObj, points2.nativeObj, focal, pp.x, pp.y, method, prob, threshold, mask.nativeObj));</a>
<span class="sourceLineNo">8548</span><a id="line.8548">    }</a>
<span class="sourceLineNo">8549</span><a id="line.8549"></a>
<span class="sourceLineNo">8550</span><a id="line.8550">    /**</a>
<span class="sourceLineNo">8551</span><a id="line.8551">     *</a>
<span class="sourceLineNo">8552</span><a id="line.8552">     * @param points1 Array of N (N &amp;gt;= 5) 2D points from the first image. The point coordinates should</a>
<span class="sourceLineNo">8553</span><a id="line.8553">     * be floating-point (single or double precision).</a>
<span class="sourceLineNo">8554</span><a id="line.8554">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">8555</span><a id="line.8555">     * @param focal focal length of the camera. Note that this function assumes that points1 and points2</a>
<span class="sourceLineNo">8556</span><a id="line.8556">     * are feature points from cameras with same focal length and principal point.</a>
<span class="sourceLineNo">8557</span><a id="line.8557">     * @param pp principal point of the camera.</a>
<span class="sourceLineNo">8558</span><a id="line.8558">     * @param method Method for computing a fundamental matrix.</a>
<span class="sourceLineNo">8559</span><a id="line.8559">     * &lt;ul&gt;</a>
<span class="sourceLineNo">8560</span><a id="line.8560">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8561</span><a id="line.8561">     *    REF: RANSAC for the RANSAC algorithm.</a>
<span class="sourceLineNo">8562</span><a id="line.8562">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8563</span><a id="line.8563">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8564</span><a id="line.8564">     *    REF: LMEDS for the LMedS algorithm.</a>
<span class="sourceLineNo">8565</span><a id="line.8565">     * @param threshold Parameter used for RANSAC. It is the maximum distance from a point to an epipolar</a>
<span class="sourceLineNo">8566</span><a id="line.8566">     * line in pixels, beyond which the point is considered an outlier and is not used for computing the</a>
<span class="sourceLineNo">8567</span><a id="line.8567">     * final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the</a>
<span class="sourceLineNo">8568</span><a id="line.8568">     * point localization, image resolution, and the image noise.</a>
<span class="sourceLineNo">8569</span><a id="line.8569">     * @param prob Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of</a>
<span class="sourceLineNo">8570</span><a id="line.8570">     * confidence (probability) that the estimated matrix is correct.</a>
<span class="sourceLineNo">8571</span><a id="line.8571">     * for the other points. The array is computed only in the RANSAC and LMedS methods.</a>
<span class="sourceLineNo">8572</span><a id="line.8572">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8573</span><a id="line.8573">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">8574</span><a id="line.8574">     *</a>
<span class="sourceLineNo">8575</span><a id="line.8575">     * This function differs from the one above that it computes camera intrinsic matrix from focal length and</a>
<span class="sourceLineNo">8576</span><a id="line.8576">     * principal point:</a>
<span class="sourceLineNo">8577</span><a id="line.8577">     *</a>
<span class="sourceLineNo">8578</span><a id="line.8578">     * \(A =</a>
<span class="sourceLineNo">8579</span><a id="line.8579">     * \begin{bmatrix}</a>
<span class="sourceLineNo">8580</span><a id="line.8580">     * f &amp;amp; 0 &amp;amp; x_{pp}  \\</a>
<span class="sourceLineNo">8581</span><a id="line.8581">     * 0 &amp;amp; f &amp;amp; y_{pp}  \\</a>
<span class="sourceLineNo">8582</span><a id="line.8582">     * 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">8583</span><a id="line.8583">     * \end{bmatrix}\)</a>
<span class="sourceLineNo">8584</span><a id="line.8584">     * @return automatically generated</a>
<span class="sourceLineNo">8585</span><a id="line.8585">     */</a>
<span class="sourceLineNo">8586</span><a id="line.8586">    public static Mat findEssentialMat(Mat points1, Mat points2, double focal, Point pp, int method, double prob, double threshold) {</a>
<span class="sourceLineNo">8587</span><a id="line.8587">        return new Mat(findEssentialMat_6(points1.nativeObj, points2.nativeObj, focal, pp.x, pp.y, method, prob, threshold));</a>
<span class="sourceLineNo">8588</span><a id="line.8588">    }</a>
<span class="sourceLineNo">8589</span><a id="line.8589"></a>
<span class="sourceLineNo">8590</span><a id="line.8590">    /**</a>
<span class="sourceLineNo">8591</span><a id="line.8591">     *</a>
<span class="sourceLineNo">8592</span><a id="line.8592">     * @param points1 Array of N (N &amp;gt;= 5) 2D points from the first image. The point coordinates should</a>
<span class="sourceLineNo">8593</span><a id="line.8593">     * be floating-point (single or double precision).</a>
<span class="sourceLineNo">8594</span><a id="line.8594">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">8595</span><a id="line.8595">     * @param focal focal length of the camera. Note that this function assumes that points1 and points2</a>
<span class="sourceLineNo">8596</span><a id="line.8596">     * are feature points from cameras with same focal length and principal point.</a>
<span class="sourceLineNo">8597</span><a id="line.8597">     * @param pp principal point of the camera.</a>
<span class="sourceLineNo">8598</span><a id="line.8598">     * @param method Method for computing a fundamental matrix.</a>
<span class="sourceLineNo">8599</span><a id="line.8599">     * &lt;ul&gt;</a>
<span class="sourceLineNo">8600</span><a id="line.8600">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8601</span><a id="line.8601">     *    REF: RANSAC for the RANSAC algorithm.</a>
<span class="sourceLineNo">8602</span><a id="line.8602">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8603</span><a id="line.8603">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8604</span><a id="line.8604">     *    REF: LMEDS for the LMedS algorithm.</a>
<span class="sourceLineNo">8605</span><a id="line.8605">     * line in pixels, beyond which the point is considered an outlier and is not used for computing the</a>
<span class="sourceLineNo">8606</span><a id="line.8606">     * final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the</a>
<span class="sourceLineNo">8607</span><a id="line.8607">     * point localization, image resolution, and the image noise.</a>
<span class="sourceLineNo">8608</span><a id="line.8608">     * @param prob Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of</a>
<span class="sourceLineNo">8609</span><a id="line.8609">     * confidence (probability) that the estimated matrix is correct.</a>
<span class="sourceLineNo">8610</span><a id="line.8610">     * for the other points. The array is computed only in the RANSAC and LMedS methods.</a>
<span class="sourceLineNo">8611</span><a id="line.8611">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8612</span><a id="line.8612">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">8613</span><a id="line.8613">     *</a>
<span class="sourceLineNo">8614</span><a id="line.8614">     * This function differs from the one above that it computes camera intrinsic matrix from focal length and</a>
<span class="sourceLineNo">8615</span><a id="line.8615">     * principal point:</a>
<span class="sourceLineNo">8616</span><a id="line.8616">     *</a>
<span class="sourceLineNo">8617</span><a id="line.8617">     * \(A =</a>
<span class="sourceLineNo">8618</span><a id="line.8618">     * \begin{bmatrix}</a>
<span class="sourceLineNo">8619</span><a id="line.8619">     * f &amp;amp; 0 &amp;amp; x_{pp}  \\</a>
<span class="sourceLineNo">8620</span><a id="line.8620">     * 0 &amp;amp; f &amp;amp; y_{pp}  \\</a>
<span class="sourceLineNo">8621</span><a id="line.8621">     * 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">8622</span><a id="line.8622">     * \end{bmatrix}\)</a>
<span class="sourceLineNo">8623</span><a id="line.8623">     * @return automatically generated</a>
<span class="sourceLineNo">8624</span><a id="line.8624">     */</a>
<span class="sourceLineNo">8625</span><a id="line.8625">    public static Mat findEssentialMat(Mat points1, Mat points2, double focal, Point pp, int method, double prob) {</a>
<span class="sourceLineNo">8626</span><a id="line.8626">        return new Mat(findEssentialMat_7(points1.nativeObj, points2.nativeObj, focal, pp.x, pp.y, method, prob));</a>
<span class="sourceLineNo">8627</span><a id="line.8627">    }</a>
<span class="sourceLineNo">8628</span><a id="line.8628"></a>
<span class="sourceLineNo">8629</span><a id="line.8629">    /**</a>
<span class="sourceLineNo">8630</span><a id="line.8630">     *</a>
<span class="sourceLineNo">8631</span><a id="line.8631">     * @param points1 Array of N (N &amp;gt;= 5) 2D points from the first image. The point coordinates should</a>
<span class="sourceLineNo">8632</span><a id="line.8632">     * be floating-point (single or double precision).</a>
<span class="sourceLineNo">8633</span><a id="line.8633">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">8634</span><a id="line.8634">     * @param focal focal length of the camera. Note that this function assumes that points1 and points2</a>
<span class="sourceLineNo">8635</span><a id="line.8635">     * are feature points from cameras with same focal length and principal point.</a>
<span class="sourceLineNo">8636</span><a id="line.8636">     * @param pp principal point of the camera.</a>
<span class="sourceLineNo">8637</span><a id="line.8637">     * @param method Method for computing a fundamental matrix.</a>
<span class="sourceLineNo">8638</span><a id="line.8638">     * &lt;ul&gt;</a>
<span class="sourceLineNo">8639</span><a id="line.8639">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8640</span><a id="line.8640">     *    REF: RANSAC for the RANSAC algorithm.</a>
<span class="sourceLineNo">8641</span><a id="line.8641">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8642</span><a id="line.8642">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8643</span><a id="line.8643">     *    REF: LMEDS for the LMedS algorithm.</a>
<span class="sourceLineNo">8644</span><a id="line.8644">     * line in pixels, beyond which the point is considered an outlier and is not used for computing the</a>
<span class="sourceLineNo">8645</span><a id="line.8645">     * final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the</a>
<span class="sourceLineNo">8646</span><a id="line.8646">     * point localization, image resolution, and the image noise.</a>
<span class="sourceLineNo">8647</span><a id="line.8647">     * confidence (probability) that the estimated matrix is correct.</a>
<span class="sourceLineNo">8648</span><a id="line.8648">     * for the other points. The array is computed only in the RANSAC and LMedS methods.</a>
<span class="sourceLineNo">8649</span><a id="line.8649">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8650</span><a id="line.8650">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">8651</span><a id="line.8651">     *</a>
<span class="sourceLineNo">8652</span><a id="line.8652">     * This function differs from the one above that it computes camera intrinsic matrix from focal length and</a>
<span class="sourceLineNo">8653</span><a id="line.8653">     * principal point:</a>
<span class="sourceLineNo">8654</span><a id="line.8654">     *</a>
<span class="sourceLineNo">8655</span><a id="line.8655">     * \(A =</a>
<span class="sourceLineNo">8656</span><a id="line.8656">     * \begin{bmatrix}</a>
<span class="sourceLineNo">8657</span><a id="line.8657">     * f &amp;amp; 0 &amp;amp; x_{pp}  \\</a>
<span class="sourceLineNo">8658</span><a id="line.8658">     * 0 &amp;amp; f &amp;amp; y_{pp}  \\</a>
<span class="sourceLineNo">8659</span><a id="line.8659">     * 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">8660</span><a id="line.8660">     * \end{bmatrix}\)</a>
<span class="sourceLineNo">8661</span><a id="line.8661">     * @return automatically generated</a>
<span class="sourceLineNo">8662</span><a id="line.8662">     */</a>
<span class="sourceLineNo">8663</span><a id="line.8663">    public static Mat findEssentialMat(Mat points1, Mat points2, double focal, Point pp, int method) {</a>
<span class="sourceLineNo">8664</span><a id="line.8664">        return new Mat(findEssentialMat_8(points1.nativeObj, points2.nativeObj, focal, pp.x, pp.y, method));</a>
<span class="sourceLineNo">8665</span><a id="line.8665">    }</a>
<span class="sourceLineNo">8666</span><a id="line.8666"></a>
<span class="sourceLineNo">8667</span><a id="line.8667">    /**</a>
<span class="sourceLineNo">8668</span><a id="line.8668">     *</a>
<span class="sourceLineNo">8669</span><a id="line.8669">     * @param points1 Array of N (N &amp;gt;= 5) 2D points from the first image. The point coordinates should</a>
<span class="sourceLineNo">8670</span><a id="line.8670">     * be floating-point (single or double precision).</a>
<span class="sourceLineNo">8671</span><a id="line.8671">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">8672</span><a id="line.8672">     * @param focal focal length of the camera. Note that this function assumes that points1 and points2</a>
<span class="sourceLineNo">8673</span><a id="line.8673">     * are feature points from cameras with same focal length and principal point.</a>
<span class="sourceLineNo">8674</span><a id="line.8674">     * @param pp principal point of the camera.</a>
<span class="sourceLineNo">8675</span><a id="line.8675">     * &lt;ul&gt;</a>
<span class="sourceLineNo">8676</span><a id="line.8676">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8677</span><a id="line.8677">     *    REF: RANSAC for the RANSAC algorithm.</a>
<span class="sourceLineNo">8678</span><a id="line.8678">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8679</span><a id="line.8679">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8680</span><a id="line.8680">     *    REF: LMEDS for the LMedS algorithm.</a>
<span class="sourceLineNo">8681</span><a id="line.8681">     * line in pixels, beyond which the point is considered an outlier and is not used for computing the</a>
<span class="sourceLineNo">8682</span><a id="line.8682">     * final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the</a>
<span class="sourceLineNo">8683</span><a id="line.8683">     * point localization, image resolution, and the image noise.</a>
<span class="sourceLineNo">8684</span><a id="line.8684">     * confidence (probability) that the estimated matrix is correct.</a>
<span class="sourceLineNo">8685</span><a id="line.8685">     * for the other points. The array is computed only in the RANSAC and LMedS methods.</a>
<span class="sourceLineNo">8686</span><a id="line.8686">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8687</span><a id="line.8687">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">8688</span><a id="line.8688">     *</a>
<span class="sourceLineNo">8689</span><a id="line.8689">     * This function differs from the one above that it computes camera intrinsic matrix from focal length and</a>
<span class="sourceLineNo">8690</span><a id="line.8690">     * principal point:</a>
<span class="sourceLineNo">8691</span><a id="line.8691">     *</a>
<span class="sourceLineNo">8692</span><a id="line.8692">     * \(A =</a>
<span class="sourceLineNo">8693</span><a id="line.8693">     * \begin{bmatrix}</a>
<span class="sourceLineNo">8694</span><a id="line.8694">     * f &amp;amp; 0 &amp;amp; x_{pp}  \\</a>
<span class="sourceLineNo">8695</span><a id="line.8695">     * 0 &amp;amp; f &amp;amp; y_{pp}  \\</a>
<span class="sourceLineNo">8696</span><a id="line.8696">     * 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">8697</span><a id="line.8697">     * \end{bmatrix}\)</a>
<span class="sourceLineNo">8698</span><a id="line.8698">     * @return automatically generated</a>
<span class="sourceLineNo">8699</span><a id="line.8699">     */</a>
<span class="sourceLineNo">8700</span><a id="line.8700">    public static Mat findEssentialMat(Mat points1, Mat points2, double focal, Point pp) {</a>
<span class="sourceLineNo">8701</span><a id="line.8701">        return new Mat(findEssentialMat_9(points1.nativeObj, points2.nativeObj, focal, pp.x, pp.y));</a>
<span class="sourceLineNo">8702</span><a id="line.8702">    }</a>
<span class="sourceLineNo">8703</span><a id="line.8703"></a>
<span class="sourceLineNo">8704</span><a id="line.8704">    /**</a>
<span class="sourceLineNo">8705</span><a id="line.8705">     *</a>
<span class="sourceLineNo">8706</span><a id="line.8706">     * @param points1 Array of N (N &amp;gt;= 5) 2D points from the first image. The point coordinates should</a>
<span class="sourceLineNo">8707</span><a id="line.8707">     * be floating-point (single or double precision).</a>
<span class="sourceLineNo">8708</span><a id="line.8708">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">8709</span><a id="line.8709">     * @param focal focal length of the camera. Note that this function assumes that points1 and points2</a>
<span class="sourceLineNo">8710</span><a id="line.8710">     * are feature points from cameras with same focal length and principal point.</a>
<span class="sourceLineNo">8711</span><a id="line.8711">     * &lt;ul&gt;</a>
<span class="sourceLineNo">8712</span><a id="line.8712">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8713</span><a id="line.8713">     *    REF: RANSAC for the RANSAC algorithm.</a>
<span class="sourceLineNo">8714</span><a id="line.8714">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8715</span><a id="line.8715">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8716</span><a id="line.8716">     *    REF: LMEDS for the LMedS algorithm.</a>
<span class="sourceLineNo">8717</span><a id="line.8717">     * line in pixels, beyond which the point is considered an outlier and is not used for computing the</a>
<span class="sourceLineNo">8718</span><a id="line.8718">     * final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the</a>
<span class="sourceLineNo">8719</span><a id="line.8719">     * point localization, image resolution, and the image noise.</a>
<span class="sourceLineNo">8720</span><a id="line.8720">     * confidence (probability) that the estimated matrix is correct.</a>
<span class="sourceLineNo">8721</span><a id="line.8721">     * for the other points. The array is computed only in the RANSAC and LMedS methods.</a>
<span class="sourceLineNo">8722</span><a id="line.8722">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8723</span><a id="line.8723">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">8724</span><a id="line.8724">     *</a>
<span class="sourceLineNo">8725</span><a id="line.8725">     * This function differs from the one above that it computes camera intrinsic matrix from focal length and</a>
<span class="sourceLineNo">8726</span><a id="line.8726">     * principal point:</a>
<span class="sourceLineNo">8727</span><a id="line.8727">     *</a>
<span class="sourceLineNo">8728</span><a id="line.8728">     * \(A =</a>
<span class="sourceLineNo">8729</span><a id="line.8729">     * \begin{bmatrix}</a>
<span class="sourceLineNo">8730</span><a id="line.8730">     * f &amp;amp; 0 &amp;amp; x_{pp}  \\</a>
<span class="sourceLineNo">8731</span><a id="line.8731">     * 0 &amp;amp; f &amp;amp; y_{pp}  \\</a>
<span class="sourceLineNo">8732</span><a id="line.8732">     * 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">8733</span><a id="line.8733">     * \end{bmatrix}\)</a>
<span class="sourceLineNo">8734</span><a id="line.8734">     * @return automatically generated</a>
<span class="sourceLineNo">8735</span><a id="line.8735">     */</a>
<span class="sourceLineNo">8736</span><a id="line.8736">    public static Mat findEssentialMat(Mat points1, Mat points2, double focal) {</a>
<span class="sourceLineNo">8737</span><a id="line.8737">        return new Mat(findEssentialMat_10(points1.nativeObj, points2.nativeObj, focal));</a>
<span class="sourceLineNo">8738</span><a id="line.8738">    }</a>
<span class="sourceLineNo">8739</span><a id="line.8739"></a>
<span class="sourceLineNo">8740</span><a id="line.8740">    /**</a>
<span class="sourceLineNo">8741</span><a id="line.8741">     *</a>
<span class="sourceLineNo">8742</span><a id="line.8742">     * @param points1 Array of N (N &amp;gt;= 5) 2D points from the first image. The point coordinates should</a>
<span class="sourceLineNo">8743</span><a id="line.8743">     * be floating-point (single or double precision).</a>
<span class="sourceLineNo">8744</span><a id="line.8744">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">8745</span><a id="line.8745">     * are feature points from cameras with same focal length and principal point.</a>
<span class="sourceLineNo">8746</span><a id="line.8746">     * &lt;ul&gt;</a>
<span class="sourceLineNo">8747</span><a id="line.8747">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8748</span><a id="line.8748">     *    REF: RANSAC for the RANSAC algorithm.</a>
<span class="sourceLineNo">8749</span><a id="line.8749">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8750</span><a id="line.8750">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8751</span><a id="line.8751">     *    REF: LMEDS for the LMedS algorithm.</a>
<span class="sourceLineNo">8752</span><a id="line.8752">     * line in pixels, beyond which the point is considered an outlier and is not used for computing the</a>
<span class="sourceLineNo">8753</span><a id="line.8753">     * final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the</a>
<span class="sourceLineNo">8754</span><a id="line.8754">     * point localization, image resolution, and the image noise.</a>
<span class="sourceLineNo">8755</span><a id="line.8755">     * confidence (probability) that the estimated matrix is correct.</a>
<span class="sourceLineNo">8756</span><a id="line.8756">     * for the other points. The array is computed only in the RANSAC and LMedS methods.</a>
<span class="sourceLineNo">8757</span><a id="line.8757">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8758</span><a id="line.8758">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">8759</span><a id="line.8759">     *</a>
<span class="sourceLineNo">8760</span><a id="line.8760">     * This function differs from the one above that it computes camera intrinsic matrix from focal length and</a>
<span class="sourceLineNo">8761</span><a id="line.8761">     * principal point:</a>
<span class="sourceLineNo">8762</span><a id="line.8762">     *</a>
<span class="sourceLineNo">8763</span><a id="line.8763">     * \(A =</a>
<span class="sourceLineNo">8764</span><a id="line.8764">     * \begin{bmatrix}</a>
<span class="sourceLineNo">8765</span><a id="line.8765">     * f &amp;amp; 0 &amp;amp; x_{pp}  \\</a>
<span class="sourceLineNo">8766</span><a id="line.8766">     * 0 &amp;amp; f &amp;amp; y_{pp}  \\</a>
<span class="sourceLineNo">8767</span><a id="line.8767">     * 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">8768</span><a id="line.8768">     * \end{bmatrix}\)</a>
<span class="sourceLineNo">8769</span><a id="line.8769">     * @return automatically generated</a>
<span class="sourceLineNo">8770</span><a id="line.8770">     */</a>
<span class="sourceLineNo">8771</span><a id="line.8771">    public static Mat findEssentialMat(Mat points1, Mat points2) {</a>
<span class="sourceLineNo">8772</span><a id="line.8772">        return new Mat(findEssentialMat_11(points1.nativeObj, points2.nativeObj));</a>
<span class="sourceLineNo">8773</span><a id="line.8773">    }</a>
<span class="sourceLineNo">8774</span><a id="line.8774"></a>
<span class="sourceLineNo">8775</span><a id="line.8775"></a>
<span class="sourceLineNo">8776</span><a id="line.8776">    //</a>
<span class="sourceLineNo">8777</span><a id="line.8777">    // C++:  Mat cv::findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, int method = RANSAC, double prob = 0.999, double threshold = 1.0, Mat&amp; mask = Mat())</a>
<span class="sourceLineNo">8778</span><a id="line.8778">    //</a>
<span class="sourceLineNo">8779</span><a id="line.8779"></a>
<span class="sourceLineNo">8780</span><a id="line.8780">    /**</a>
<span class="sourceLineNo">8781</span><a id="line.8781">     * Calculates an essential matrix from the corresponding points in two images from potentially two different cameras.</a>
<span class="sourceLineNo">8782</span><a id="line.8782">     *</a>
<span class="sourceLineNo">8783</span><a id="line.8783">     * @param points1 Array of N (N &amp;gt;= 5) 2D points from the first image. The point coordinates should</a>
<span class="sourceLineNo">8784</span><a id="line.8784">     * be floating-point (single or double precision).</a>
<span class="sourceLineNo">8785</span><a id="line.8785">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">8786</span><a id="line.8786">     * @param cameraMatrix1 Camera matrix \(K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</a>
<span class="sourceLineNo">8787</span><a id="line.8787">     * Note that this function assumes that points1 and points2 are feature points from cameras with the</a>
<span class="sourceLineNo">8788</span><a id="line.8788">     * same camera matrix. If this assumption does not hold for your use case, use</a>
<span class="sourceLineNo">8789</span><a id="line.8789">     * {@code undistortPoints()} with {@code P = cv::NoArray()} for both cameras to transform image points</a>
<span class="sourceLineNo">8790</span><a id="line.8790">     * to normalized image coordinates, which are valid for the identity camera matrix. When</a>
<span class="sourceLineNo">8791</span><a id="line.8791">     * passing these coordinates, pass the identity matrix for this parameter.</a>
<span class="sourceLineNo">8792</span><a id="line.8792">     * @param cameraMatrix2 Camera matrix \(K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</a>
<span class="sourceLineNo">8793</span><a id="line.8793">     * Note that this function assumes that points1 and points2 are feature points from cameras with the</a>
<span class="sourceLineNo">8794</span><a id="line.8794">     * same camera matrix. If this assumption does not hold for your use case, use</a>
<span class="sourceLineNo">8795</span><a id="line.8795">     * {@code undistortPoints()} with {@code P = cv::NoArray()} for both cameras to transform image points</a>
<span class="sourceLineNo">8796</span><a id="line.8796">     * to normalized image coordinates, which are valid for the identity camera matrix. When</a>
<span class="sourceLineNo">8797</span><a id="line.8797">     * passing these coordinates, pass the identity matrix for this parameter.</a>
<span class="sourceLineNo">8798</span><a id="line.8798">     * @param distCoeffs1 Input vector of distortion coefficients</a>
<span class="sourceLineNo">8799</span><a id="line.8799">     * \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)</a>
<span class="sourceLineNo">8800</span><a id="line.8800">     * of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</a>
<span class="sourceLineNo">8801</span><a id="line.8801">     * @param distCoeffs2 Input vector of distortion coefficients</a>
<span class="sourceLineNo">8802</span><a id="line.8802">     * \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)</a>
<span class="sourceLineNo">8803</span><a id="line.8803">     * of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</a>
<span class="sourceLineNo">8804</span><a id="line.8804">     * @param method Method for computing an essential matrix.</a>
<span class="sourceLineNo">8805</span><a id="line.8805">     * &lt;ul&gt;</a>
<span class="sourceLineNo">8806</span><a id="line.8806">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8807</span><a id="line.8807">     *    REF: RANSAC for the RANSAC algorithm.</a>
<span class="sourceLineNo">8808</span><a id="line.8808">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8809</span><a id="line.8809">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8810</span><a id="line.8810">     *    REF: LMEDS for the LMedS algorithm.</a>
<span class="sourceLineNo">8811</span><a id="line.8811">     * @param prob Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of</a>
<span class="sourceLineNo">8812</span><a id="line.8812">     * confidence (probability) that the estimated matrix is correct.</a>
<span class="sourceLineNo">8813</span><a id="line.8813">     * @param threshold Parameter used for RANSAC. It is the maximum distance from a point to an epipolar</a>
<span class="sourceLineNo">8814</span><a id="line.8814">     * line in pixels, beyond which the point is considered an outlier and is not used for computing the</a>
<span class="sourceLineNo">8815</span><a id="line.8815">     * final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the</a>
<span class="sourceLineNo">8816</span><a id="line.8816">     * point localization, image resolution, and the image noise.</a>
<span class="sourceLineNo">8817</span><a id="line.8817">     * @param mask Output array of N elements, every element of which is set to 0 for outliers and to 1</a>
<span class="sourceLineNo">8818</span><a id="line.8818">     * for the other points. The array is computed only in the RANSAC and LMedS methods.</a>
<span class="sourceLineNo">8819</span><a id="line.8819">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8820</span><a id="line.8820">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">8821</span><a id="line.8821">     *</a>
<span class="sourceLineNo">8822</span><a id="line.8822">     * This function estimates essential matrix based on the five-point algorithm solver in CITE: Nister03 .</a>
<span class="sourceLineNo">8823</span><a id="line.8823">     * CITE: SteweniusCFS is also a related. The epipolar geometry is described by the following equation:</a>
<span class="sourceLineNo">8824</span><a id="line.8824">     *</a>
<span class="sourceLineNo">8825</span><a id="line.8825">     * \([p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\)</a>
<span class="sourceLineNo">8826</span><a id="line.8826">     *</a>
<span class="sourceLineNo">8827</span><a id="line.8827">     * where \(E\) is an essential matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the</a>
<span class="sourceLineNo">8828</span><a id="line.8828">     * second images, respectively. The result of this function may be passed further to</a>
<span class="sourceLineNo">8829</span><a id="line.8829">     * decomposeEssentialMat or recoverPose to recover the relative pose between cameras.</a>
<span class="sourceLineNo">8830</span><a id="line.8830">     * @return automatically generated</a>
<span class="sourceLineNo">8831</span><a id="line.8831">     */</a>
<span class="sourceLineNo">8832</span><a id="line.8832">    public static Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, int method, double prob, double threshold, Mat mask) {</a>
<span class="sourceLineNo">8833</span><a id="line.8833">        return new Mat(findEssentialMat_12(points1.nativeObj, points2.nativeObj, cameraMatrix1.nativeObj, distCoeffs1.nativeObj, cameraMatrix2.nativeObj, distCoeffs2.nativeObj, method, prob, threshold, mask.nativeObj));</a>
<span class="sourceLineNo">8834</span><a id="line.8834">    }</a>
<span class="sourceLineNo">8835</span><a id="line.8835"></a>
<span class="sourceLineNo">8836</span><a id="line.8836">    /**</a>
<span class="sourceLineNo">8837</span><a id="line.8837">     * Calculates an essential matrix from the corresponding points in two images from potentially two different cameras.</a>
<span class="sourceLineNo">8838</span><a id="line.8838">     *</a>
<span class="sourceLineNo">8839</span><a id="line.8839">     * @param points1 Array of N (N &amp;gt;= 5) 2D points from the first image. The point coordinates should</a>
<span class="sourceLineNo">8840</span><a id="line.8840">     * be floating-point (single or double precision).</a>
<span class="sourceLineNo">8841</span><a id="line.8841">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">8842</span><a id="line.8842">     * @param cameraMatrix1 Camera matrix \(K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</a>
<span class="sourceLineNo">8843</span><a id="line.8843">     * Note that this function assumes that points1 and points2 are feature points from cameras with the</a>
<span class="sourceLineNo">8844</span><a id="line.8844">     * same camera matrix. If this assumption does not hold for your use case, use</a>
<span class="sourceLineNo">8845</span><a id="line.8845">     * {@code undistortPoints()} with {@code P = cv::NoArray()} for both cameras to transform image points</a>
<span class="sourceLineNo">8846</span><a id="line.8846">     * to normalized image coordinates, which are valid for the identity camera matrix. When</a>
<span class="sourceLineNo">8847</span><a id="line.8847">     * passing these coordinates, pass the identity matrix for this parameter.</a>
<span class="sourceLineNo">8848</span><a id="line.8848">     * @param cameraMatrix2 Camera matrix \(K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</a>
<span class="sourceLineNo">8849</span><a id="line.8849">     * Note that this function assumes that points1 and points2 are feature points from cameras with the</a>
<span class="sourceLineNo">8850</span><a id="line.8850">     * same camera matrix. If this assumption does not hold for your use case, use</a>
<span class="sourceLineNo">8851</span><a id="line.8851">     * {@code undistortPoints()} with {@code P = cv::NoArray()} for both cameras to transform image points</a>
<span class="sourceLineNo">8852</span><a id="line.8852">     * to normalized image coordinates, which are valid for the identity camera matrix. When</a>
<span class="sourceLineNo">8853</span><a id="line.8853">     * passing these coordinates, pass the identity matrix for this parameter.</a>
<span class="sourceLineNo">8854</span><a id="line.8854">     * @param distCoeffs1 Input vector of distortion coefficients</a>
<span class="sourceLineNo">8855</span><a id="line.8855">     * \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)</a>
<span class="sourceLineNo">8856</span><a id="line.8856">     * of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</a>
<span class="sourceLineNo">8857</span><a id="line.8857">     * @param distCoeffs2 Input vector of distortion coefficients</a>
<span class="sourceLineNo">8858</span><a id="line.8858">     * \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)</a>
<span class="sourceLineNo">8859</span><a id="line.8859">     * of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</a>
<span class="sourceLineNo">8860</span><a id="line.8860">     * @param method Method for computing an essential matrix.</a>
<span class="sourceLineNo">8861</span><a id="line.8861">     * &lt;ul&gt;</a>
<span class="sourceLineNo">8862</span><a id="line.8862">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8863</span><a id="line.8863">     *    REF: RANSAC for the RANSAC algorithm.</a>
<span class="sourceLineNo">8864</span><a id="line.8864">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8865</span><a id="line.8865">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8866</span><a id="line.8866">     *    REF: LMEDS for the LMedS algorithm.</a>
<span class="sourceLineNo">8867</span><a id="line.8867">     * @param prob Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of</a>
<span class="sourceLineNo">8868</span><a id="line.8868">     * confidence (probability) that the estimated matrix is correct.</a>
<span class="sourceLineNo">8869</span><a id="line.8869">     * @param threshold Parameter used for RANSAC. It is the maximum distance from a point to an epipolar</a>
<span class="sourceLineNo">8870</span><a id="line.8870">     * line in pixels, beyond which the point is considered an outlier and is not used for computing the</a>
<span class="sourceLineNo">8871</span><a id="line.8871">     * final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the</a>
<span class="sourceLineNo">8872</span><a id="line.8872">     * point localization, image resolution, and the image noise.</a>
<span class="sourceLineNo">8873</span><a id="line.8873">     * for the other points. The array is computed only in the RANSAC and LMedS methods.</a>
<span class="sourceLineNo">8874</span><a id="line.8874">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8875</span><a id="line.8875">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">8876</span><a id="line.8876">     *</a>
<span class="sourceLineNo">8877</span><a id="line.8877">     * This function estimates essential matrix based on the five-point algorithm solver in CITE: Nister03 .</a>
<span class="sourceLineNo">8878</span><a id="line.8878">     * CITE: SteweniusCFS is also a related. The epipolar geometry is described by the following equation:</a>
<span class="sourceLineNo">8879</span><a id="line.8879">     *</a>
<span class="sourceLineNo">8880</span><a id="line.8880">     * \([p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\)</a>
<span class="sourceLineNo">8881</span><a id="line.8881">     *</a>
<span class="sourceLineNo">8882</span><a id="line.8882">     * where \(E\) is an essential matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the</a>
<span class="sourceLineNo">8883</span><a id="line.8883">     * second images, respectively. The result of this function may be passed further to</a>
<span class="sourceLineNo">8884</span><a id="line.8884">     * decomposeEssentialMat or recoverPose to recover the relative pose between cameras.</a>
<span class="sourceLineNo">8885</span><a id="line.8885">     * @return automatically generated</a>
<span class="sourceLineNo">8886</span><a id="line.8886">     */</a>
<span class="sourceLineNo">8887</span><a id="line.8887">    public static Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, int method, double prob, double threshold) {</a>
<span class="sourceLineNo">8888</span><a id="line.8888">        return new Mat(findEssentialMat_13(points1.nativeObj, points2.nativeObj, cameraMatrix1.nativeObj, distCoeffs1.nativeObj, cameraMatrix2.nativeObj, distCoeffs2.nativeObj, method, prob, threshold));</a>
<span class="sourceLineNo">8889</span><a id="line.8889">    }</a>
<span class="sourceLineNo">8890</span><a id="line.8890"></a>
<span class="sourceLineNo">8891</span><a id="line.8891">    /**</a>
<span class="sourceLineNo">8892</span><a id="line.8892">     * Calculates an essential matrix from the corresponding points in two images from potentially two different cameras.</a>
<span class="sourceLineNo">8893</span><a id="line.8893">     *</a>
<span class="sourceLineNo">8894</span><a id="line.8894">     * @param points1 Array of N (N &amp;gt;= 5) 2D points from the first image. The point coordinates should</a>
<span class="sourceLineNo">8895</span><a id="line.8895">     * be floating-point (single or double precision).</a>
<span class="sourceLineNo">8896</span><a id="line.8896">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">8897</span><a id="line.8897">     * @param cameraMatrix1 Camera matrix \(K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</a>
<span class="sourceLineNo">8898</span><a id="line.8898">     * Note that this function assumes that points1 and points2 are feature points from cameras with the</a>
<span class="sourceLineNo">8899</span><a id="line.8899">     * same camera matrix. If this assumption does not hold for your use case, use</a>
<span class="sourceLineNo">8900</span><a id="line.8900">     * {@code undistortPoints()} with {@code P = cv::NoArray()} for both cameras to transform image points</a>
<span class="sourceLineNo">8901</span><a id="line.8901">     * to normalized image coordinates, which are valid for the identity camera matrix. When</a>
<span class="sourceLineNo">8902</span><a id="line.8902">     * passing these coordinates, pass the identity matrix for this parameter.</a>
<span class="sourceLineNo">8903</span><a id="line.8903">     * @param cameraMatrix2 Camera matrix \(K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</a>
<span class="sourceLineNo">8904</span><a id="line.8904">     * Note that this function assumes that points1 and points2 are feature points from cameras with the</a>
<span class="sourceLineNo">8905</span><a id="line.8905">     * same camera matrix. If this assumption does not hold for your use case, use</a>
<span class="sourceLineNo">8906</span><a id="line.8906">     * {@code undistortPoints()} with {@code P = cv::NoArray()} for both cameras to transform image points</a>
<span class="sourceLineNo">8907</span><a id="line.8907">     * to normalized image coordinates, which are valid for the identity camera matrix. When</a>
<span class="sourceLineNo">8908</span><a id="line.8908">     * passing these coordinates, pass the identity matrix for this parameter.</a>
<span class="sourceLineNo">8909</span><a id="line.8909">     * @param distCoeffs1 Input vector of distortion coefficients</a>
<span class="sourceLineNo">8910</span><a id="line.8910">     * \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)</a>
<span class="sourceLineNo">8911</span><a id="line.8911">     * of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</a>
<span class="sourceLineNo">8912</span><a id="line.8912">     * @param distCoeffs2 Input vector of distortion coefficients</a>
<span class="sourceLineNo">8913</span><a id="line.8913">     * \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)</a>
<span class="sourceLineNo">8914</span><a id="line.8914">     * of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</a>
<span class="sourceLineNo">8915</span><a id="line.8915">     * @param method Method for computing an essential matrix.</a>
<span class="sourceLineNo">8916</span><a id="line.8916">     * &lt;ul&gt;</a>
<span class="sourceLineNo">8917</span><a id="line.8917">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8918</span><a id="line.8918">     *    REF: RANSAC for the RANSAC algorithm.</a>
<span class="sourceLineNo">8919</span><a id="line.8919">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8920</span><a id="line.8920">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8921</span><a id="line.8921">     *    REF: LMEDS for the LMedS algorithm.</a>
<span class="sourceLineNo">8922</span><a id="line.8922">     * @param prob Parameter used for the RANSAC or LMedS methods only. It specifies a desirable level of</a>
<span class="sourceLineNo">8923</span><a id="line.8923">     * confidence (probability) that the estimated matrix is correct.</a>
<span class="sourceLineNo">8924</span><a id="line.8924">     * line in pixels, beyond which the point is considered an outlier and is not used for computing the</a>
<span class="sourceLineNo">8925</span><a id="line.8925">     * final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the</a>
<span class="sourceLineNo">8926</span><a id="line.8926">     * point localization, image resolution, and the image noise.</a>
<span class="sourceLineNo">8927</span><a id="line.8927">     * for the other points. The array is computed only in the RANSAC and LMedS methods.</a>
<span class="sourceLineNo">8928</span><a id="line.8928">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8929</span><a id="line.8929">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">8930</span><a id="line.8930">     *</a>
<span class="sourceLineNo">8931</span><a id="line.8931">     * This function estimates essential matrix based on the five-point algorithm solver in CITE: Nister03 .</a>
<span class="sourceLineNo">8932</span><a id="line.8932">     * CITE: SteweniusCFS is also a related. The epipolar geometry is described by the following equation:</a>
<span class="sourceLineNo">8933</span><a id="line.8933">     *</a>
<span class="sourceLineNo">8934</span><a id="line.8934">     * \([p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\)</a>
<span class="sourceLineNo">8935</span><a id="line.8935">     *</a>
<span class="sourceLineNo">8936</span><a id="line.8936">     * where \(E\) is an essential matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the</a>
<span class="sourceLineNo">8937</span><a id="line.8937">     * second images, respectively. The result of this function may be passed further to</a>
<span class="sourceLineNo">8938</span><a id="line.8938">     * decomposeEssentialMat or recoverPose to recover the relative pose between cameras.</a>
<span class="sourceLineNo">8939</span><a id="line.8939">     * @return automatically generated</a>
<span class="sourceLineNo">8940</span><a id="line.8940">     */</a>
<span class="sourceLineNo">8941</span><a id="line.8941">    public static Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, int method, double prob) {</a>
<span class="sourceLineNo">8942</span><a id="line.8942">        return new Mat(findEssentialMat_14(points1.nativeObj, points2.nativeObj, cameraMatrix1.nativeObj, distCoeffs1.nativeObj, cameraMatrix2.nativeObj, distCoeffs2.nativeObj, method, prob));</a>
<span class="sourceLineNo">8943</span><a id="line.8943">    }</a>
<span class="sourceLineNo">8944</span><a id="line.8944"></a>
<span class="sourceLineNo">8945</span><a id="line.8945">    /**</a>
<span class="sourceLineNo">8946</span><a id="line.8946">     * Calculates an essential matrix from the corresponding points in two images from potentially two different cameras.</a>
<span class="sourceLineNo">8947</span><a id="line.8947">     *</a>
<span class="sourceLineNo">8948</span><a id="line.8948">     * @param points1 Array of N (N &amp;gt;= 5) 2D points from the first image. The point coordinates should</a>
<span class="sourceLineNo">8949</span><a id="line.8949">     * be floating-point (single or double precision).</a>
<span class="sourceLineNo">8950</span><a id="line.8950">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">8951</span><a id="line.8951">     * @param cameraMatrix1 Camera matrix \(K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</a>
<span class="sourceLineNo">8952</span><a id="line.8952">     * Note that this function assumes that points1 and points2 are feature points from cameras with the</a>
<span class="sourceLineNo">8953</span><a id="line.8953">     * same camera matrix. If this assumption does not hold for your use case, use</a>
<span class="sourceLineNo">8954</span><a id="line.8954">     * {@code undistortPoints()} with {@code P = cv::NoArray()} for both cameras to transform image points</a>
<span class="sourceLineNo">8955</span><a id="line.8955">     * to normalized image coordinates, which are valid for the identity camera matrix. When</a>
<span class="sourceLineNo">8956</span><a id="line.8956">     * passing these coordinates, pass the identity matrix for this parameter.</a>
<span class="sourceLineNo">8957</span><a id="line.8957">     * @param cameraMatrix2 Camera matrix \(K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</a>
<span class="sourceLineNo">8958</span><a id="line.8958">     * Note that this function assumes that points1 and points2 are feature points from cameras with the</a>
<span class="sourceLineNo">8959</span><a id="line.8959">     * same camera matrix. If this assumption does not hold for your use case, use</a>
<span class="sourceLineNo">8960</span><a id="line.8960">     * {@code undistortPoints()} with {@code P = cv::NoArray()} for both cameras to transform image points</a>
<span class="sourceLineNo">8961</span><a id="line.8961">     * to normalized image coordinates, which are valid for the identity camera matrix. When</a>
<span class="sourceLineNo">8962</span><a id="line.8962">     * passing these coordinates, pass the identity matrix for this parameter.</a>
<span class="sourceLineNo">8963</span><a id="line.8963">     * @param distCoeffs1 Input vector of distortion coefficients</a>
<span class="sourceLineNo">8964</span><a id="line.8964">     * \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)</a>
<span class="sourceLineNo">8965</span><a id="line.8965">     * of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</a>
<span class="sourceLineNo">8966</span><a id="line.8966">     * @param distCoeffs2 Input vector of distortion coefficients</a>
<span class="sourceLineNo">8967</span><a id="line.8967">     * \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)</a>
<span class="sourceLineNo">8968</span><a id="line.8968">     * of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</a>
<span class="sourceLineNo">8969</span><a id="line.8969">     * @param method Method for computing an essential matrix.</a>
<span class="sourceLineNo">8970</span><a id="line.8970">     * &lt;ul&gt;</a>
<span class="sourceLineNo">8971</span><a id="line.8971">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8972</span><a id="line.8972">     *    REF: RANSAC for the RANSAC algorithm.</a>
<span class="sourceLineNo">8973</span><a id="line.8973">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8974</span><a id="line.8974">     *   &lt;li&gt;</a>
<span class="sourceLineNo">8975</span><a id="line.8975">     *    REF: LMEDS for the LMedS algorithm.</a>
<span class="sourceLineNo">8976</span><a id="line.8976">     * confidence (probability) that the estimated matrix is correct.</a>
<span class="sourceLineNo">8977</span><a id="line.8977">     * line in pixels, beyond which the point is considered an outlier and is not used for computing the</a>
<span class="sourceLineNo">8978</span><a id="line.8978">     * final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the</a>
<span class="sourceLineNo">8979</span><a id="line.8979">     * point localization, image resolution, and the image noise.</a>
<span class="sourceLineNo">8980</span><a id="line.8980">     * for the other points. The array is computed only in the RANSAC and LMedS methods.</a>
<span class="sourceLineNo">8981</span><a id="line.8981">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">8982</span><a id="line.8982">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">8983</span><a id="line.8983">     *</a>
<span class="sourceLineNo">8984</span><a id="line.8984">     * This function estimates essential matrix based on the five-point algorithm solver in CITE: Nister03 .</a>
<span class="sourceLineNo">8985</span><a id="line.8985">     * CITE: SteweniusCFS is also a related. The epipolar geometry is described by the following equation:</a>
<span class="sourceLineNo">8986</span><a id="line.8986">     *</a>
<span class="sourceLineNo">8987</span><a id="line.8987">     * \([p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\)</a>
<span class="sourceLineNo">8988</span><a id="line.8988">     *</a>
<span class="sourceLineNo">8989</span><a id="line.8989">     * where \(E\) is an essential matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the</a>
<span class="sourceLineNo">8990</span><a id="line.8990">     * second images, respectively. The result of this function may be passed further to</a>
<span class="sourceLineNo">8991</span><a id="line.8991">     * decomposeEssentialMat or recoverPose to recover the relative pose between cameras.</a>
<span class="sourceLineNo">8992</span><a id="line.8992">     * @return automatically generated</a>
<span class="sourceLineNo">8993</span><a id="line.8993">     */</a>
<span class="sourceLineNo">8994</span><a id="line.8994">    public static Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, int method) {</a>
<span class="sourceLineNo">8995</span><a id="line.8995">        return new Mat(findEssentialMat_15(points1.nativeObj, points2.nativeObj, cameraMatrix1.nativeObj, distCoeffs1.nativeObj, cameraMatrix2.nativeObj, distCoeffs2.nativeObj, method));</a>
<span class="sourceLineNo">8996</span><a id="line.8996">    }</a>
<span class="sourceLineNo">8997</span><a id="line.8997"></a>
<span class="sourceLineNo">8998</span><a id="line.8998">    /**</a>
<span class="sourceLineNo">8999</span><a id="line.8999">     * Calculates an essential matrix from the corresponding points in two images from potentially two different cameras.</a>
<span class="sourceLineNo">9000</span><a id="line.9000">     *</a>
<span class="sourceLineNo">9001</span><a id="line.9001">     * @param points1 Array of N (N &amp;gt;= 5) 2D points from the first image. The point coordinates should</a>
<span class="sourceLineNo">9002</span><a id="line.9002">     * be floating-point (single or double precision).</a>
<span class="sourceLineNo">9003</span><a id="line.9003">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">9004</span><a id="line.9004">     * @param cameraMatrix1 Camera matrix \(K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</a>
<span class="sourceLineNo">9005</span><a id="line.9005">     * Note that this function assumes that points1 and points2 are feature points from cameras with the</a>
<span class="sourceLineNo">9006</span><a id="line.9006">     * same camera matrix. If this assumption does not hold for your use case, use</a>
<span class="sourceLineNo">9007</span><a id="line.9007">     * {@code undistortPoints()} with {@code P = cv::NoArray()} for both cameras to transform image points</a>
<span class="sourceLineNo">9008</span><a id="line.9008">     * to normalized image coordinates, which are valid for the identity camera matrix. When</a>
<span class="sourceLineNo">9009</span><a id="line.9009">     * passing these coordinates, pass the identity matrix for this parameter.</a>
<span class="sourceLineNo">9010</span><a id="line.9010">     * @param cameraMatrix2 Camera matrix \(K = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</a>
<span class="sourceLineNo">9011</span><a id="line.9011">     * Note that this function assumes that points1 and points2 are feature points from cameras with the</a>
<span class="sourceLineNo">9012</span><a id="line.9012">     * same camera matrix. If this assumption does not hold for your use case, use</a>
<span class="sourceLineNo">9013</span><a id="line.9013">     * {@code undistortPoints()} with {@code P = cv::NoArray()} for both cameras to transform image points</a>
<span class="sourceLineNo">9014</span><a id="line.9014">     * to normalized image coordinates, which are valid for the identity camera matrix. When</a>
<span class="sourceLineNo">9015</span><a id="line.9015">     * passing these coordinates, pass the identity matrix for this parameter.</a>
<span class="sourceLineNo">9016</span><a id="line.9016">     * @param distCoeffs1 Input vector of distortion coefficients</a>
<span class="sourceLineNo">9017</span><a id="line.9017">     * \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)</a>
<span class="sourceLineNo">9018</span><a id="line.9018">     * of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</a>
<span class="sourceLineNo">9019</span><a id="line.9019">     * @param distCoeffs2 Input vector of distortion coefficients</a>
<span class="sourceLineNo">9020</span><a id="line.9020">     * \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)</a>
<span class="sourceLineNo">9021</span><a id="line.9021">     * of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</a>
<span class="sourceLineNo">9022</span><a id="line.9022">     * &lt;ul&gt;</a>
<span class="sourceLineNo">9023</span><a id="line.9023">     *   &lt;li&gt;</a>
<span class="sourceLineNo">9024</span><a id="line.9024">     *    REF: RANSAC for the RANSAC algorithm.</a>
<span class="sourceLineNo">9025</span><a id="line.9025">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">9026</span><a id="line.9026">     *   &lt;li&gt;</a>
<span class="sourceLineNo">9027</span><a id="line.9027">     *    REF: LMEDS for the LMedS algorithm.</a>
<span class="sourceLineNo">9028</span><a id="line.9028">     * confidence (probability) that the estimated matrix is correct.</a>
<span class="sourceLineNo">9029</span><a id="line.9029">     * line in pixels, beyond which the point is considered an outlier and is not used for computing the</a>
<span class="sourceLineNo">9030</span><a id="line.9030">     * final fundamental matrix. It can be set to something like 1-3, depending on the accuracy of the</a>
<span class="sourceLineNo">9031</span><a id="line.9031">     * point localization, image resolution, and the image noise.</a>
<span class="sourceLineNo">9032</span><a id="line.9032">     * for the other points. The array is computed only in the RANSAC and LMedS methods.</a>
<span class="sourceLineNo">9033</span><a id="line.9033">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">9034</span><a id="line.9034">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">9035</span><a id="line.9035">     *</a>
<span class="sourceLineNo">9036</span><a id="line.9036">     * This function estimates essential matrix based on the five-point algorithm solver in CITE: Nister03 .</a>
<span class="sourceLineNo">9037</span><a id="line.9037">     * CITE: SteweniusCFS is also a related. The epipolar geometry is described by the following equation:</a>
<span class="sourceLineNo">9038</span><a id="line.9038">     *</a>
<span class="sourceLineNo">9039</span><a id="line.9039">     * \([p_2; 1]^T K^{-T} E K^{-1} [p_1; 1] = 0\)</a>
<span class="sourceLineNo">9040</span><a id="line.9040">     *</a>
<span class="sourceLineNo">9041</span><a id="line.9041">     * where \(E\) is an essential matrix, \(p_1\) and \(p_2\) are corresponding points in the first and the</a>
<span class="sourceLineNo">9042</span><a id="line.9042">     * second images, respectively. The result of this function may be passed further to</a>
<span class="sourceLineNo">9043</span><a id="line.9043">     * decomposeEssentialMat or recoverPose to recover the relative pose between cameras.</a>
<span class="sourceLineNo">9044</span><a id="line.9044">     * @return automatically generated</a>
<span class="sourceLineNo">9045</span><a id="line.9045">     */</a>
<span class="sourceLineNo">9046</span><a id="line.9046">    public static Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2) {</a>
<span class="sourceLineNo">9047</span><a id="line.9047">        return new Mat(findEssentialMat_16(points1.nativeObj, points2.nativeObj, cameraMatrix1.nativeObj, distCoeffs1.nativeObj, cameraMatrix2.nativeObj, distCoeffs2.nativeObj));</a>
<span class="sourceLineNo">9048</span><a id="line.9048">    }</a>
<span class="sourceLineNo">9049</span><a id="line.9049"></a>
<span class="sourceLineNo">9050</span><a id="line.9050"></a>
<span class="sourceLineNo">9051</span><a id="line.9051">    //</a>
<span class="sourceLineNo">9052</span><a id="line.9052">    // C++:  Mat cv::findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix1, Mat cameraMatrix2, Mat dist_coeff1, Mat dist_coeff2, Mat&amp; mask, UsacParams params)</a>
<span class="sourceLineNo">9053</span><a id="line.9053">    //</a>
<span class="sourceLineNo">9054</span><a id="line.9054"></a>
<span class="sourceLineNo">9055</span><a id="line.9055">    public static Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix1, Mat cameraMatrix2, Mat dist_coeff1, Mat dist_coeff2, Mat mask, UsacParams params) {</a>
<span class="sourceLineNo">9056</span><a id="line.9056">        return new Mat(findEssentialMat_17(points1.nativeObj, points2.nativeObj, cameraMatrix1.nativeObj, cameraMatrix2.nativeObj, dist_coeff1.nativeObj, dist_coeff2.nativeObj, mask.nativeObj, params.nativeObj));</a>
<span class="sourceLineNo">9057</span><a id="line.9057">    }</a>
<span class="sourceLineNo">9058</span><a id="line.9058"></a>
<span class="sourceLineNo">9059</span><a id="line.9059"></a>
<span class="sourceLineNo">9060</span><a id="line.9060">    //</a>
<span class="sourceLineNo">9061</span><a id="line.9061">    // C++:  void cv::decomposeEssentialMat(Mat E, Mat&amp; R1, Mat&amp; R2, Mat&amp; t)</a>
<span class="sourceLineNo">9062</span><a id="line.9062">    //</a>
<span class="sourceLineNo">9063</span><a id="line.9063"></a>
<span class="sourceLineNo">9064</span><a id="line.9064">    /**</a>
<span class="sourceLineNo">9065</span><a id="line.9065">     * Decompose an essential matrix to possible rotations and translation.</a>
<span class="sourceLineNo">9066</span><a id="line.9066">     *</a>
<span class="sourceLineNo">9067</span><a id="line.9067">     * @param E The input essential matrix.</a>
<span class="sourceLineNo">9068</span><a id="line.9068">     * @param R1 One possible rotation matrix.</a>
<span class="sourceLineNo">9069</span><a id="line.9069">     * @param R2 Another possible rotation matrix.</a>
<span class="sourceLineNo">9070</span><a id="line.9070">     * @param t One possible translation.</a>
<span class="sourceLineNo">9071</span><a id="line.9071">     *</a>
<span class="sourceLineNo">9072</span><a id="line.9072">     * This function decomposes the essential matrix E using svd decomposition CITE: HartleyZ00. In</a>
<span class="sourceLineNo">9073</span><a id="line.9073">     * general, four possible poses exist for the decomposition of E. They are \([R_1, t]\),</a>
<span class="sourceLineNo">9074</span><a id="line.9074">     * \([R_1, -t]\), \([R_2, t]\), \([R_2, -t]\).</a>
<span class="sourceLineNo">9075</span><a id="line.9075">     *</a>
<span class="sourceLineNo">9076</span><a id="line.9076">     * If E gives the epipolar constraint \([p_2; 1]^T A^{-T} E A^{-1} [p_1; 1] = 0\) between the image</a>
<span class="sourceLineNo">9077</span><a id="line.9077">     * points \(p_1\) in the first image and \(p_2\) in second image, then any of the tuples</a>
<span class="sourceLineNo">9078</span><a id="line.9078">     * \([R_1, t]\), \([R_1, -t]\), \([R_2, t]\), \([R_2, -t]\) is a change of basis from the first</a>
<span class="sourceLineNo">9079</span><a id="line.9079">     * camera's coordinate system to the second camera's coordinate system. However, by decomposing E, one</a>
<span class="sourceLineNo">9080</span><a id="line.9080">     * can only get the direction of the translation. For this reason, the translation t is returned with</a>
<span class="sourceLineNo">9081</span><a id="line.9081">     * unit length.</a>
<span class="sourceLineNo">9082</span><a id="line.9082">     */</a>
<span class="sourceLineNo">9083</span><a id="line.9083">    public static void decomposeEssentialMat(Mat E, Mat R1, Mat R2, Mat t) {</a>
<span class="sourceLineNo">9084</span><a id="line.9084">        decomposeEssentialMat_0(E.nativeObj, R1.nativeObj, R2.nativeObj, t.nativeObj);</a>
<span class="sourceLineNo">9085</span><a id="line.9085">    }</a>
<span class="sourceLineNo">9086</span><a id="line.9086"></a>
<span class="sourceLineNo">9087</span><a id="line.9087"></a>
<span class="sourceLineNo">9088</span><a id="line.9088">    //</a>
<span class="sourceLineNo">9089</span><a id="line.9089">    // C++:  int cv::recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat&amp; R, Mat&amp; t, Mat&amp; mask = Mat())</a>
<span class="sourceLineNo">9090</span><a id="line.9090">    //</a>
<span class="sourceLineNo">9091</span><a id="line.9091"></a>
<span class="sourceLineNo">9092</span><a id="line.9092">    /**</a>
<span class="sourceLineNo">9093</span><a id="line.9093">     * Recovers the relative camera rotation and the translation from an estimated essential</a>
<span class="sourceLineNo">9094</span><a id="line.9094">     * matrix and the corresponding points in two images, using cheirality check. Returns the number of</a>
<span class="sourceLineNo">9095</span><a id="line.9095">     * inliers that pass the check.</a>
<span class="sourceLineNo">9096</span><a id="line.9096">     *</a>
<span class="sourceLineNo">9097</span><a id="line.9097">     * @param E The input essential matrix.</a>
<span class="sourceLineNo">9098</span><a id="line.9098">     * @param points1 Array of N 2D points from the first image. The point coordinates should be</a>
<span class="sourceLineNo">9099</span><a id="line.9099">     * floating-point (single or double precision).</a>
<span class="sourceLineNo">9100</span><a id="line.9100">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">9101</span><a id="line.9101">     * @param cameraMatrix Camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">9102</span><a id="line.9102">     * Note that this function assumes that points1 and points2 are feature points from cameras with the</a>
<span class="sourceLineNo">9103</span><a id="line.9103">     * same camera intrinsic matrix.</a>
<span class="sourceLineNo">9104</span><a id="line.9104">     * @param R Output rotation matrix. Together with the translation vector, this matrix makes up a tuple</a>
<span class="sourceLineNo">9105</span><a id="line.9105">     * that performs a change of basis from the first camera's coordinate system to the second camera's</a>
<span class="sourceLineNo">9106</span><a id="line.9106">     * coordinate system. Note that, in general, t can not be used for this tuple, see the parameter</a>
<span class="sourceLineNo">9107</span><a id="line.9107">     * described below.</a>
<span class="sourceLineNo">9108</span><a id="line.9108">     * @param t Output translation vector. This vector is obtained by REF: decomposeEssentialMat and</a>
<span class="sourceLineNo">9109</span><a id="line.9109">     * therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit</a>
<span class="sourceLineNo">9110</span><a id="line.9110">     * length.</a>
<span class="sourceLineNo">9111</span><a id="line.9111">     * @param mask Input/output mask for inliers in points1 and points2. If it is not empty, then it marks</a>
<span class="sourceLineNo">9112</span><a id="line.9112">     * inliers in points1 and points2 for then given essential matrix E. Only these inliers will be used to</a>
<span class="sourceLineNo">9113</span><a id="line.9113">     * recover pose. In the output mask only inliers which pass the cheirality check.</a>
<span class="sourceLineNo">9114</span><a id="line.9114">     *</a>
<span class="sourceLineNo">9115</span><a id="line.9115">     * This function decomposes an essential matrix using REF: decomposeEssentialMat and then verifies</a>
<span class="sourceLineNo">9116</span><a id="line.9116">     * possible pose hypotheses by doing cheirality check. The cheirality check means that the</a>
<span class="sourceLineNo">9117</span><a id="line.9117">     * triangulated 3D points should have positive depth. Some details can be found in CITE: Nister03.</a>
<span class="sourceLineNo">9118</span><a id="line.9118">     *</a>
<span class="sourceLineNo">9119</span><a id="line.9119">     * This function can be used to process the output E and mask from REF: findEssentialMat. In this</a>
<span class="sourceLineNo">9120</span><a id="line.9120">     * scenario, points1 and points2 are the same input for findEssentialMat.:</a>
<span class="sourceLineNo">9121</span><a id="line.9121">     * &lt;code&gt;</a>
<span class="sourceLineNo">9122</span><a id="line.9122">     *     // Example. Estimation of fundamental matrix using the RANSAC algorithm</a>
<span class="sourceLineNo">9123</span><a id="line.9123">     *     int point_count = 100;</a>
<span class="sourceLineNo">9124</span><a id="line.9124">     *     vector&amp;lt;Point2f&amp;gt; points1(point_count);</a>
<span class="sourceLineNo">9125</span><a id="line.9125">     *     vector&amp;lt;Point2f&amp;gt; points2(point_count);</a>
<span class="sourceLineNo">9126</span><a id="line.9126">     *</a>
<span class="sourceLineNo">9127</span><a id="line.9127">     *     // initialize the points here ...</a>
<span class="sourceLineNo">9128</span><a id="line.9128">     *     for( int i = 0; i &amp;lt; point_count; i++ )</a>
<span class="sourceLineNo">9129</span><a id="line.9129">     *     {</a>
<span class="sourceLineNo">9130</span><a id="line.9130">     *         points1[i] = ...;</a>
<span class="sourceLineNo">9131</span><a id="line.9131">     *         points2[i] = ...;</a>
<span class="sourceLineNo">9132</span><a id="line.9132">     *     }</a>
<span class="sourceLineNo">9133</span><a id="line.9133">     *</a>
<span class="sourceLineNo">9134</span><a id="line.9134">     *     // cametra matrix with both focal lengths = 1, and principal point = (0, 0)</a>
<span class="sourceLineNo">9135</span><a id="line.9135">     *     Mat cameraMatrix = Mat::eye(3, 3, CV_64F);</a>
<span class="sourceLineNo">9136</span><a id="line.9136">     *</a>
<span class="sourceLineNo">9137</span><a id="line.9137">     *     Mat E, R, t, mask;</a>
<span class="sourceLineNo">9138</span><a id="line.9138">     *</a>
<span class="sourceLineNo">9139</span><a id="line.9139">     *     E = findEssentialMat(points1, points2, cameraMatrix, RANSAC, 0.999, 1.0, mask);</a>
<span class="sourceLineNo">9140</span><a id="line.9140">     *     recoverPose(E, points1, points2, cameraMatrix, R, t, mask);</a>
<span class="sourceLineNo">9141</span><a id="line.9141">     * &lt;/code&gt;</a>
<span class="sourceLineNo">9142</span><a id="line.9142">     * @return automatically generated</a>
<span class="sourceLineNo">9143</span><a id="line.9143">     */</a>
<span class="sourceLineNo">9144</span><a id="line.9144">    public static int recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat R, Mat t, Mat mask) {</a>
<span class="sourceLineNo">9145</span><a id="line.9145">        return recoverPose_0(E.nativeObj, points1.nativeObj, points2.nativeObj, cameraMatrix.nativeObj, R.nativeObj, t.nativeObj, mask.nativeObj);</a>
<span class="sourceLineNo">9146</span><a id="line.9146">    }</a>
<span class="sourceLineNo">9147</span><a id="line.9147"></a>
<span class="sourceLineNo">9148</span><a id="line.9148">    /**</a>
<span class="sourceLineNo">9149</span><a id="line.9149">     * Recovers the relative camera rotation and the translation from an estimated essential</a>
<span class="sourceLineNo">9150</span><a id="line.9150">     * matrix and the corresponding points in two images, using cheirality check. Returns the number of</a>
<span class="sourceLineNo">9151</span><a id="line.9151">     * inliers that pass the check.</a>
<span class="sourceLineNo">9152</span><a id="line.9152">     *</a>
<span class="sourceLineNo">9153</span><a id="line.9153">     * @param E The input essential matrix.</a>
<span class="sourceLineNo">9154</span><a id="line.9154">     * @param points1 Array of N 2D points from the first image. The point coordinates should be</a>
<span class="sourceLineNo">9155</span><a id="line.9155">     * floating-point (single or double precision).</a>
<span class="sourceLineNo">9156</span><a id="line.9156">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">9157</span><a id="line.9157">     * @param cameraMatrix Camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">9158</span><a id="line.9158">     * Note that this function assumes that points1 and points2 are feature points from cameras with the</a>
<span class="sourceLineNo">9159</span><a id="line.9159">     * same camera intrinsic matrix.</a>
<span class="sourceLineNo">9160</span><a id="line.9160">     * @param R Output rotation matrix. Together with the translation vector, this matrix makes up a tuple</a>
<span class="sourceLineNo">9161</span><a id="line.9161">     * that performs a change of basis from the first camera's coordinate system to the second camera's</a>
<span class="sourceLineNo">9162</span><a id="line.9162">     * coordinate system. Note that, in general, t can not be used for this tuple, see the parameter</a>
<span class="sourceLineNo">9163</span><a id="line.9163">     * described below.</a>
<span class="sourceLineNo">9164</span><a id="line.9164">     * @param t Output translation vector. This vector is obtained by REF: decomposeEssentialMat and</a>
<span class="sourceLineNo">9165</span><a id="line.9165">     * therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit</a>
<span class="sourceLineNo">9166</span><a id="line.9166">     * length.</a>
<span class="sourceLineNo">9167</span><a id="line.9167">     * inliers in points1 and points2 for then given essential matrix E. Only these inliers will be used to</a>
<span class="sourceLineNo">9168</span><a id="line.9168">     * recover pose. In the output mask only inliers which pass the cheirality check.</a>
<span class="sourceLineNo">9169</span><a id="line.9169">     *</a>
<span class="sourceLineNo">9170</span><a id="line.9170">     * This function decomposes an essential matrix using REF: decomposeEssentialMat and then verifies</a>
<span class="sourceLineNo">9171</span><a id="line.9171">     * possible pose hypotheses by doing cheirality check. The cheirality check means that the</a>
<span class="sourceLineNo">9172</span><a id="line.9172">     * triangulated 3D points should have positive depth. Some details can be found in CITE: Nister03.</a>
<span class="sourceLineNo">9173</span><a id="line.9173">     *</a>
<span class="sourceLineNo">9174</span><a id="line.9174">     * This function can be used to process the output E and mask from REF: findEssentialMat. In this</a>
<span class="sourceLineNo">9175</span><a id="line.9175">     * scenario, points1 and points2 are the same input for findEssentialMat.:</a>
<span class="sourceLineNo">9176</span><a id="line.9176">     * &lt;code&gt;</a>
<span class="sourceLineNo">9177</span><a id="line.9177">     *     // Example. Estimation of fundamental matrix using the RANSAC algorithm</a>
<span class="sourceLineNo">9178</span><a id="line.9178">     *     int point_count = 100;</a>
<span class="sourceLineNo">9179</span><a id="line.9179">     *     vector&amp;lt;Point2f&amp;gt; points1(point_count);</a>
<span class="sourceLineNo">9180</span><a id="line.9180">     *     vector&amp;lt;Point2f&amp;gt; points2(point_count);</a>
<span class="sourceLineNo">9181</span><a id="line.9181">     *</a>
<span class="sourceLineNo">9182</span><a id="line.9182">     *     // initialize the points here ...</a>
<span class="sourceLineNo">9183</span><a id="line.9183">     *     for( int i = 0; i &amp;lt; point_count; i++ )</a>
<span class="sourceLineNo">9184</span><a id="line.9184">     *     {</a>
<span class="sourceLineNo">9185</span><a id="line.9185">     *         points1[i] = ...;</a>
<span class="sourceLineNo">9186</span><a id="line.9186">     *         points2[i] = ...;</a>
<span class="sourceLineNo">9187</span><a id="line.9187">     *     }</a>
<span class="sourceLineNo">9188</span><a id="line.9188">     *</a>
<span class="sourceLineNo">9189</span><a id="line.9189">     *     // cametra matrix with both focal lengths = 1, and principal point = (0, 0)</a>
<span class="sourceLineNo">9190</span><a id="line.9190">     *     Mat cameraMatrix = Mat::eye(3, 3, CV_64F);</a>
<span class="sourceLineNo">9191</span><a id="line.9191">     *</a>
<span class="sourceLineNo">9192</span><a id="line.9192">     *     Mat E, R, t, mask;</a>
<span class="sourceLineNo">9193</span><a id="line.9193">     *</a>
<span class="sourceLineNo">9194</span><a id="line.9194">     *     E = findEssentialMat(points1, points2, cameraMatrix, RANSAC, 0.999, 1.0, mask);</a>
<span class="sourceLineNo">9195</span><a id="line.9195">     *     recoverPose(E, points1, points2, cameraMatrix, R, t, mask);</a>
<span class="sourceLineNo">9196</span><a id="line.9196">     * &lt;/code&gt;</a>
<span class="sourceLineNo">9197</span><a id="line.9197">     * @return automatically generated</a>
<span class="sourceLineNo">9198</span><a id="line.9198">     */</a>
<span class="sourceLineNo">9199</span><a id="line.9199">    public static int recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat R, Mat t) {</a>
<span class="sourceLineNo">9200</span><a id="line.9200">        return recoverPose_1(E.nativeObj, points1.nativeObj, points2.nativeObj, cameraMatrix.nativeObj, R.nativeObj, t.nativeObj);</a>
<span class="sourceLineNo">9201</span><a id="line.9201">    }</a>
<span class="sourceLineNo">9202</span><a id="line.9202"></a>
<span class="sourceLineNo">9203</span><a id="line.9203"></a>
<span class="sourceLineNo">9204</span><a id="line.9204">    //</a>
<span class="sourceLineNo">9205</span><a id="line.9205">    // C++:  int cv::recoverPose(Mat E, Mat points1, Mat points2, Mat&amp; R, Mat&amp; t, double focal = 1.0, Point2d pp = Point2d(0, 0), Mat&amp; mask = Mat())</a>
<span class="sourceLineNo">9206</span><a id="line.9206">    //</a>
<span class="sourceLineNo">9207</span><a id="line.9207"></a>
<span class="sourceLineNo">9208</span><a id="line.9208">    /**</a>
<span class="sourceLineNo">9209</span><a id="line.9209">     *</a>
<span class="sourceLineNo">9210</span><a id="line.9210">     * @param E The input essential matrix.</a>
<span class="sourceLineNo">9211</span><a id="line.9211">     * @param points1 Array of N 2D points from the first image. The point coordinates should be</a>
<span class="sourceLineNo">9212</span><a id="line.9212">     * floating-point (single or double precision).</a>
<span class="sourceLineNo">9213</span><a id="line.9213">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">9214</span><a id="line.9214">     * @param R Output rotation matrix. Together with the translation vector, this matrix makes up a tuple</a>
<span class="sourceLineNo">9215</span><a id="line.9215">     * that performs a change of basis from the first camera's coordinate system to the second camera's</a>
<span class="sourceLineNo">9216</span><a id="line.9216">     * coordinate system. Note that, in general, t can not be used for this tuple, see the parameter</a>
<span class="sourceLineNo">9217</span><a id="line.9217">     * description below.</a>
<span class="sourceLineNo">9218</span><a id="line.9218">     * @param t Output translation vector. This vector is obtained by REF: decomposeEssentialMat and</a>
<span class="sourceLineNo">9219</span><a id="line.9219">     * therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit</a>
<span class="sourceLineNo">9220</span><a id="line.9220">     * length.</a>
<span class="sourceLineNo">9221</span><a id="line.9221">     * @param focal Focal length of the camera. Note that this function assumes that points1 and points2</a>
<span class="sourceLineNo">9222</span><a id="line.9222">     * are feature points from cameras with same focal length and principal point.</a>
<span class="sourceLineNo">9223</span><a id="line.9223">     * @param pp principal point of the camera.</a>
<span class="sourceLineNo">9224</span><a id="line.9224">     * @param mask Input/output mask for inliers in points1 and points2. If it is not empty, then it marks</a>
<span class="sourceLineNo">9225</span><a id="line.9225">     * inliers in points1 and points2 for then given essential matrix E. Only these inliers will be used to</a>
<span class="sourceLineNo">9226</span><a id="line.9226">     * recover pose. In the output mask only inliers which pass the cheirality check.</a>
<span class="sourceLineNo">9227</span><a id="line.9227">     *</a>
<span class="sourceLineNo">9228</span><a id="line.9228">     * This function differs from the one above that it computes camera intrinsic matrix from focal length and</a>
<span class="sourceLineNo">9229</span><a id="line.9229">     * principal point:</a>
<span class="sourceLineNo">9230</span><a id="line.9230">     *</a>
<span class="sourceLineNo">9231</span><a id="line.9231">     * \(A =</a>
<span class="sourceLineNo">9232</span><a id="line.9232">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9233</span><a id="line.9233">     * f &amp;amp; 0 &amp;amp; x_{pp}  \\</a>
<span class="sourceLineNo">9234</span><a id="line.9234">     * 0 &amp;amp; f &amp;amp; y_{pp}  \\</a>
<span class="sourceLineNo">9235</span><a id="line.9235">     * 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">9236</span><a id="line.9236">     * \end{bmatrix}\)</a>
<span class="sourceLineNo">9237</span><a id="line.9237">     * @return automatically generated</a>
<span class="sourceLineNo">9238</span><a id="line.9238">     */</a>
<span class="sourceLineNo">9239</span><a id="line.9239">    public static int recoverPose(Mat E, Mat points1, Mat points2, Mat R, Mat t, double focal, Point pp, Mat mask) {</a>
<span class="sourceLineNo">9240</span><a id="line.9240">        return recoverPose_2(E.nativeObj, points1.nativeObj, points2.nativeObj, R.nativeObj, t.nativeObj, focal, pp.x, pp.y, mask.nativeObj);</a>
<span class="sourceLineNo">9241</span><a id="line.9241">    }</a>
<span class="sourceLineNo">9242</span><a id="line.9242"></a>
<span class="sourceLineNo">9243</span><a id="line.9243">    /**</a>
<span class="sourceLineNo">9244</span><a id="line.9244">     *</a>
<span class="sourceLineNo">9245</span><a id="line.9245">     * @param E The input essential matrix.</a>
<span class="sourceLineNo">9246</span><a id="line.9246">     * @param points1 Array of N 2D points from the first image. The point coordinates should be</a>
<span class="sourceLineNo">9247</span><a id="line.9247">     * floating-point (single or double precision).</a>
<span class="sourceLineNo">9248</span><a id="line.9248">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">9249</span><a id="line.9249">     * @param R Output rotation matrix. Together with the translation vector, this matrix makes up a tuple</a>
<span class="sourceLineNo">9250</span><a id="line.9250">     * that performs a change of basis from the first camera's coordinate system to the second camera's</a>
<span class="sourceLineNo">9251</span><a id="line.9251">     * coordinate system. Note that, in general, t can not be used for this tuple, see the parameter</a>
<span class="sourceLineNo">9252</span><a id="line.9252">     * description below.</a>
<span class="sourceLineNo">9253</span><a id="line.9253">     * @param t Output translation vector. This vector is obtained by REF: decomposeEssentialMat and</a>
<span class="sourceLineNo">9254</span><a id="line.9254">     * therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit</a>
<span class="sourceLineNo">9255</span><a id="line.9255">     * length.</a>
<span class="sourceLineNo">9256</span><a id="line.9256">     * @param focal Focal length of the camera. Note that this function assumes that points1 and points2</a>
<span class="sourceLineNo">9257</span><a id="line.9257">     * are feature points from cameras with same focal length and principal point.</a>
<span class="sourceLineNo">9258</span><a id="line.9258">     * @param pp principal point of the camera.</a>
<span class="sourceLineNo">9259</span><a id="line.9259">     * inliers in points1 and points2 for then given essential matrix E. Only these inliers will be used to</a>
<span class="sourceLineNo">9260</span><a id="line.9260">     * recover pose. In the output mask only inliers which pass the cheirality check.</a>
<span class="sourceLineNo">9261</span><a id="line.9261">     *</a>
<span class="sourceLineNo">9262</span><a id="line.9262">     * This function differs from the one above that it computes camera intrinsic matrix from focal length and</a>
<span class="sourceLineNo">9263</span><a id="line.9263">     * principal point:</a>
<span class="sourceLineNo">9264</span><a id="line.9264">     *</a>
<span class="sourceLineNo">9265</span><a id="line.9265">     * \(A =</a>
<span class="sourceLineNo">9266</span><a id="line.9266">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9267</span><a id="line.9267">     * f &amp;amp; 0 &amp;amp; x_{pp}  \\</a>
<span class="sourceLineNo">9268</span><a id="line.9268">     * 0 &amp;amp; f &amp;amp; y_{pp}  \\</a>
<span class="sourceLineNo">9269</span><a id="line.9269">     * 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">9270</span><a id="line.9270">     * \end{bmatrix}\)</a>
<span class="sourceLineNo">9271</span><a id="line.9271">     * @return automatically generated</a>
<span class="sourceLineNo">9272</span><a id="line.9272">     */</a>
<span class="sourceLineNo">9273</span><a id="line.9273">    public static int recoverPose(Mat E, Mat points1, Mat points2, Mat R, Mat t, double focal, Point pp) {</a>
<span class="sourceLineNo">9274</span><a id="line.9274">        return recoverPose_3(E.nativeObj, points1.nativeObj, points2.nativeObj, R.nativeObj, t.nativeObj, focal, pp.x, pp.y);</a>
<span class="sourceLineNo">9275</span><a id="line.9275">    }</a>
<span class="sourceLineNo">9276</span><a id="line.9276"></a>
<span class="sourceLineNo">9277</span><a id="line.9277">    /**</a>
<span class="sourceLineNo">9278</span><a id="line.9278">     *</a>
<span class="sourceLineNo">9279</span><a id="line.9279">     * @param E The input essential matrix.</a>
<span class="sourceLineNo">9280</span><a id="line.9280">     * @param points1 Array of N 2D points from the first image. The point coordinates should be</a>
<span class="sourceLineNo">9281</span><a id="line.9281">     * floating-point (single or double precision).</a>
<span class="sourceLineNo">9282</span><a id="line.9282">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">9283</span><a id="line.9283">     * @param R Output rotation matrix. Together with the translation vector, this matrix makes up a tuple</a>
<span class="sourceLineNo">9284</span><a id="line.9284">     * that performs a change of basis from the first camera's coordinate system to the second camera's</a>
<span class="sourceLineNo">9285</span><a id="line.9285">     * coordinate system. Note that, in general, t can not be used for this tuple, see the parameter</a>
<span class="sourceLineNo">9286</span><a id="line.9286">     * description below.</a>
<span class="sourceLineNo">9287</span><a id="line.9287">     * @param t Output translation vector. This vector is obtained by REF: decomposeEssentialMat and</a>
<span class="sourceLineNo">9288</span><a id="line.9288">     * therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit</a>
<span class="sourceLineNo">9289</span><a id="line.9289">     * length.</a>
<span class="sourceLineNo">9290</span><a id="line.9290">     * @param focal Focal length of the camera. Note that this function assumes that points1 and points2</a>
<span class="sourceLineNo">9291</span><a id="line.9291">     * are feature points from cameras with same focal length and principal point.</a>
<span class="sourceLineNo">9292</span><a id="line.9292">     * inliers in points1 and points2 for then given essential matrix E. Only these inliers will be used to</a>
<span class="sourceLineNo">9293</span><a id="line.9293">     * recover pose. In the output mask only inliers which pass the cheirality check.</a>
<span class="sourceLineNo">9294</span><a id="line.9294">     *</a>
<span class="sourceLineNo">9295</span><a id="line.9295">     * This function differs from the one above that it computes camera intrinsic matrix from focal length and</a>
<span class="sourceLineNo">9296</span><a id="line.9296">     * principal point:</a>
<span class="sourceLineNo">9297</span><a id="line.9297">     *</a>
<span class="sourceLineNo">9298</span><a id="line.9298">     * \(A =</a>
<span class="sourceLineNo">9299</span><a id="line.9299">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9300</span><a id="line.9300">     * f &amp;amp; 0 &amp;amp; x_{pp}  \\</a>
<span class="sourceLineNo">9301</span><a id="line.9301">     * 0 &amp;amp; f &amp;amp; y_{pp}  \\</a>
<span class="sourceLineNo">9302</span><a id="line.9302">     * 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">9303</span><a id="line.9303">     * \end{bmatrix}\)</a>
<span class="sourceLineNo">9304</span><a id="line.9304">     * @return automatically generated</a>
<span class="sourceLineNo">9305</span><a id="line.9305">     */</a>
<span class="sourceLineNo">9306</span><a id="line.9306">    public static int recoverPose(Mat E, Mat points1, Mat points2, Mat R, Mat t, double focal) {</a>
<span class="sourceLineNo">9307</span><a id="line.9307">        return recoverPose_4(E.nativeObj, points1.nativeObj, points2.nativeObj, R.nativeObj, t.nativeObj, focal);</a>
<span class="sourceLineNo">9308</span><a id="line.9308">    }</a>
<span class="sourceLineNo">9309</span><a id="line.9309"></a>
<span class="sourceLineNo">9310</span><a id="line.9310">    /**</a>
<span class="sourceLineNo">9311</span><a id="line.9311">     *</a>
<span class="sourceLineNo">9312</span><a id="line.9312">     * @param E The input essential matrix.</a>
<span class="sourceLineNo">9313</span><a id="line.9313">     * @param points1 Array of N 2D points from the first image. The point coordinates should be</a>
<span class="sourceLineNo">9314</span><a id="line.9314">     * floating-point (single or double precision).</a>
<span class="sourceLineNo">9315</span><a id="line.9315">     * @param points2 Array of the second image points of the same size and format as points1 .</a>
<span class="sourceLineNo">9316</span><a id="line.9316">     * @param R Output rotation matrix. Together with the translation vector, this matrix makes up a tuple</a>
<span class="sourceLineNo">9317</span><a id="line.9317">     * that performs a change of basis from the first camera's coordinate system to the second camera's</a>
<span class="sourceLineNo">9318</span><a id="line.9318">     * coordinate system. Note that, in general, t can not be used for this tuple, see the parameter</a>
<span class="sourceLineNo">9319</span><a id="line.9319">     * description below.</a>
<span class="sourceLineNo">9320</span><a id="line.9320">     * @param t Output translation vector. This vector is obtained by REF: decomposeEssentialMat and</a>
<span class="sourceLineNo">9321</span><a id="line.9321">     * therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit</a>
<span class="sourceLineNo">9322</span><a id="line.9322">     * length.</a>
<span class="sourceLineNo">9323</span><a id="line.9323">     * are feature points from cameras with same focal length and principal point.</a>
<span class="sourceLineNo">9324</span><a id="line.9324">     * inliers in points1 and points2 for then given essential matrix E. Only these inliers will be used to</a>
<span class="sourceLineNo">9325</span><a id="line.9325">     * recover pose. In the output mask only inliers which pass the cheirality check.</a>
<span class="sourceLineNo">9326</span><a id="line.9326">     *</a>
<span class="sourceLineNo">9327</span><a id="line.9327">     * This function differs from the one above that it computes camera intrinsic matrix from focal length and</a>
<span class="sourceLineNo">9328</span><a id="line.9328">     * principal point:</a>
<span class="sourceLineNo">9329</span><a id="line.9329">     *</a>
<span class="sourceLineNo">9330</span><a id="line.9330">     * \(A =</a>
<span class="sourceLineNo">9331</span><a id="line.9331">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9332</span><a id="line.9332">     * f &amp;amp; 0 &amp;amp; x_{pp}  \\</a>
<span class="sourceLineNo">9333</span><a id="line.9333">     * 0 &amp;amp; f &amp;amp; y_{pp}  \\</a>
<span class="sourceLineNo">9334</span><a id="line.9334">     * 0 &amp;amp; 0 &amp;amp; 1</a>
<span class="sourceLineNo">9335</span><a id="line.9335">     * \end{bmatrix}\)</a>
<span class="sourceLineNo">9336</span><a id="line.9336">     * @return automatically generated</a>
<span class="sourceLineNo">9337</span><a id="line.9337">     */</a>
<span class="sourceLineNo">9338</span><a id="line.9338">    public static int recoverPose(Mat E, Mat points1, Mat points2, Mat R, Mat t) {</a>
<span class="sourceLineNo">9339</span><a id="line.9339">        return recoverPose_5(E.nativeObj, points1.nativeObj, points2.nativeObj, R.nativeObj, t.nativeObj);</a>
<span class="sourceLineNo">9340</span><a id="line.9340">    }</a>
<span class="sourceLineNo">9341</span><a id="line.9341"></a>
<span class="sourceLineNo">9342</span><a id="line.9342"></a>
<span class="sourceLineNo">9343</span><a id="line.9343">    //</a>
<span class="sourceLineNo">9344</span><a id="line.9344">    // C++:  int cv::recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat&amp; R, Mat&amp; t, double distanceThresh, Mat&amp; mask = Mat(), Mat&amp; triangulatedPoints = Mat())</a>
<span class="sourceLineNo">9345</span><a id="line.9345">    //</a>
<span class="sourceLineNo">9346</span><a id="line.9346"></a>
<span class="sourceLineNo">9347</span><a id="line.9347">    /**</a>
<span class="sourceLineNo">9348</span><a id="line.9348">     *</a>
<span class="sourceLineNo">9349</span><a id="line.9349">     * @param E The input essential matrix.</a>
<span class="sourceLineNo">9350</span><a id="line.9350">     * @param points1 Array of N 2D points from the first image. The point coordinates should be</a>
<span class="sourceLineNo">9351</span><a id="line.9351">     * floating-point (single or double precision).</a>
<span class="sourceLineNo">9352</span><a id="line.9352">     * @param points2 Array of the second image points of the same size and format as points1.</a>
<span class="sourceLineNo">9353</span><a id="line.9353">     * @param cameraMatrix Camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">9354</span><a id="line.9354">     * Note that this function assumes that points1 and points2 are feature points from cameras with the</a>
<span class="sourceLineNo">9355</span><a id="line.9355">     * same camera intrinsic matrix.</a>
<span class="sourceLineNo">9356</span><a id="line.9356">     * @param R Output rotation matrix. Together with the translation vector, this matrix makes up a tuple</a>
<span class="sourceLineNo">9357</span><a id="line.9357">     * that performs a change of basis from the first camera's coordinate system to the second camera's</a>
<span class="sourceLineNo">9358</span><a id="line.9358">     * coordinate system. Note that, in general, t can not be used for this tuple, see the parameter</a>
<span class="sourceLineNo">9359</span><a id="line.9359">     * description below.</a>
<span class="sourceLineNo">9360</span><a id="line.9360">     * @param t Output translation vector. This vector is obtained by REF: decomposeEssentialMat and</a>
<span class="sourceLineNo">9361</span><a id="line.9361">     * therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit</a>
<span class="sourceLineNo">9362</span><a id="line.9362">     * length.</a>
<span class="sourceLineNo">9363</span><a id="line.9363">     * @param distanceThresh threshold distance which is used to filter out far away points (i.e. infinite</a>
<span class="sourceLineNo">9364</span><a id="line.9364">     * points).</a>
<span class="sourceLineNo">9365</span><a id="line.9365">     * @param mask Input/output mask for inliers in points1 and points2. If it is not empty, then it marks</a>
<span class="sourceLineNo">9366</span><a id="line.9366">     * inliers in points1 and points2 for then given essential matrix E. Only these inliers will be used to</a>
<span class="sourceLineNo">9367</span><a id="line.9367">     * recover pose. In the output mask only inliers which pass the cheirality check.</a>
<span class="sourceLineNo">9368</span><a id="line.9368">     * @param triangulatedPoints 3D points which were reconstructed by triangulation.</a>
<span class="sourceLineNo">9369</span><a id="line.9369">     *</a>
<span class="sourceLineNo">9370</span><a id="line.9370">     * This function differs from the one above that it outputs the triangulated 3D point that are used for</a>
<span class="sourceLineNo">9371</span><a id="line.9371">     * the cheirality check.</a>
<span class="sourceLineNo">9372</span><a id="line.9372">     * @return automatically generated</a>
<span class="sourceLineNo">9373</span><a id="line.9373">     */</a>
<span class="sourceLineNo">9374</span><a id="line.9374">    public static int recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat R, Mat t, double distanceThresh, Mat mask, Mat triangulatedPoints) {</a>
<span class="sourceLineNo">9375</span><a id="line.9375">        return recoverPose_6(E.nativeObj, points1.nativeObj, points2.nativeObj, cameraMatrix.nativeObj, R.nativeObj, t.nativeObj, distanceThresh, mask.nativeObj, triangulatedPoints.nativeObj);</a>
<span class="sourceLineNo">9376</span><a id="line.9376">    }</a>
<span class="sourceLineNo">9377</span><a id="line.9377"></a>
<span class="sourceLineNo">9378</span><a id="line.9378">    /**</a>
<span class="sourceLineNo">9379</span><a id="line.9379">     *</a>
<span class="sourceLineNo">9380</span><a id="line.9380">     * @param E The input essential matrix.</a>
<span class="sourceLineNo">9381</span><a id="line.9381">     * @param points1 Array of N 2D points from the first image. The point coordinates should be</a>
<span class="sourceLineNo">9382</span><a id="line.9382">     * floating-point (single or double precision).</a>
<span class="sourceLineNo">9383</span><a id="line.9383">     * @param points2 Array of the second image points of the same size and format as points1.</a>
<span class="sourceLineNo">9384</span><a id="line.9384">     * @param cameraMatrix Camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">9385</span><a id="line.9385">     * Note that this function assumes that points1 and points2 are feature points from cameras with the</a>
<span class="sourceLineNo">9386</span><a id="line.9386">     * same camera intrinsic matrix.</a>
<span class="sourceLineNo">9387</span><a id="line.9387">     * @param R Output rotation matrix. Together with the translation vector, this matrix makes up a tuple</a>
<span class="sourceLineNo">9388</span><a id="line.9388">     * that performs a change of basis from the first camera's coordinate system to the second camera's</a>
<span class="sourceLineNo">9389</span><a id="line.9389">     * coordinate system. Note that, in general, t can not be used for this tuple, see the parameter</a>
<span class="sourceLineNo">9390</span><a id="line.9390">     * description below.</a>
<span class="sourceLineNo">9391</span><a id="line.9391">     * @param t Output translation vector. This vector is obtained by REF: decomposeEssentialMat and</a>
<span class="sourceLineNo">9392</span><a id="line.9392">     * therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit</a>
<span class="sourceLineNo">9393</span><a id="line.9393">     * length.</a>
<span class="sourceLineNo">9394</span><a id="line.9394">     * @param distanceThresh threshold distance which is used to filter out far away points (i.e. infinite</a>
<span class="sourceLineNo">9395</span><a id="line.9395">     * points).</a>
<span class="sourceLineNo">9396</span><a id="line.9396">     * @param mask Input/output mask for inliers in points1 and points2. If it is not empty, then it marks</a>
<span class="sourceLineNo">9397</span><a id="line.9397">     * inliers in points1 and points2 for then given essential matrix E. Only these inliers will be used to</a>
<span class="sourceLineNo">9398</span><a id="line.9398">     * recover pose. In the output mask only inliers which pass the cheirality check.</a>
<span class="sourceLineNo">9399</span><a id="line.9399">     *</a>
<span class="sourceLineNo">9400</span><a id="line.9400">     * This function differs from the one above that it outputs the triangulated 3D point that are used for</a>
<span class="sourceLineNo">9401</span><a id="line.9401">     * the cheirality check.</a>
<span class="sourceLineNo">9402</span><a id="line.9402">     * @return automatically generated</a>
<span class="sourceLineNo">9403</span><a id="line.9403">     */</a>
<span class="sourceLineNo">9404</span><a id="line.9404">    public static int recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat R, Mat t, double distanceThresh, Mat mask) {</a>
<span class="sourceLineNo">9405</span><a id="line.9405">        return recoverPose_7(E.nativeObj, points1.nativeObj, points2.nativeObj, cameraMatrix.nativeObj, R.nativeObj, t.nativeObj, distanceThresh, mask.nativeObj);</a>
<span class="sourceLineNo">9406</span><a id="line.9406">    }</a>
<span class="sourceLineNo">9407</span><a id="line.9407"></a>
<span class="sourceLineNo">9408</span><a id="line.9408">    /**</a>
<span class="sourceLineNo">9409</span><a id="line.9409">     *</a>
<span class="sourceLineNo">9410</span><a id="line.9410">     * @param E The input essential matrix.</a>
<span class="sourceLineNo">9411</span><a id="line.9411">     * @param points1 Array of N 2D points from the first image. The point coordinates should be</a>
<span class="sourceLineNo">9412</span><a id="line.9412">     * floating-point (single or double precision).</a>
<span class="sourceLineNo">9413</span><a id="line.9413">     * @param points2 Array of the second image points of the same size and format as points1.</a>
<span class="sourceLineNo">9414</span><a id="line.9414">     * @param cameraMatrix Camera intrinsic matrix \(\cameramatrix{A}\) .</a>
<span class="sourceLineNo">9415</span><a id="line.9415">     * Note that this function assumes that points1 and points2 are feature points from cameras with the</a>
<span class="sourceLineNo">9416</span><a id="line.9416">     * same camera intrinsic matrix.</a>
<span class="sourceLineNo">9417</span><a id="line.9417">     * @param R Output rotation matrix. Together with the translation vector, this matrix makes up a tuple</a>
<span class="sourceLineNo">9418</span><a id="line.9418">     * that performs a change of basis from the first camera's coordinate system to the second camera's</a>
<span class="sourceLineNo">9419</span><a id="line.9419">     * coordinate system. Note that, in general, t can not be used for this tuple, see the parameter</a>
<span class="sourceLineNo">9420</span><a id="line.9420">     * description below.</a>
<span class="sourceLineNo">9421</span><a id="line.9421">     * @param t Output translation vector. This vector is obtained by REF: decomposeEssentialMat and</a>
<span class="sourceLineNo">9422</span><a id="line.9422">     * therefore is only known up to scale, i.e. t is the direction of the translation vector and has unit</a>
<span class="sourceLineNo">9423</span><a id="line.9423">     * length.</a>
<span class="sourceLineNo">9424</span><a id="line.9424">     * @param distanceThresh threshold distance which is used to filter out far away points (i.e. infinite</a>
<span class="sourceLineNo">9425</span><a id="line.9425">     * points).</a>
<span class="sourceLineNo">9426</span><a id="line.9426">     * inliers in points1 and points2 for then given essential matrix E. Only these inliers will be used to</a>
<span class="sourceLineNo">9427</span><a id="line.9427">     * recover pose. In the output mask only inliers which pass the cheirality check.</a>
<span class="sourceLineNo">9428</span><a id="line.9428">     *</a>
<span class="sourceLineNo">9429</span><a id="line.9429">     * This function differs from the one above that it outputs the triangulated 3D point that are used for</a>
<span class="sourceLineNo">9430</span><a id="line.9430">     * the cheirality check.</a>
<span class="sourceLineNo">9431</span><a id="line.9431">     * @return automatically generated</a>
<span class="sourceLineNo">9432</span><a id="line.9432">     */</a>
<span class="sourceLineNo">9433</span><a id="line.9433">    public static int recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat R, Mat t, double distanceThresh) {</a>
<span class="sourceLineNo">9434</span><a id="line.9434">        return recoverPose_8(E.nativeObj, points1.nativeObj, points2.nativeObj, cameraMatrix.nativeObj, R.nativeObj, t.nativeObj, distanceThresh);</a>
<span class="sourceLineNo">9435</span><a id="line.9435">    }</a>
<span class="sourceLineNo">9436</span><a id="line.9436"></a>
<span class="sourceLineNo">9437</span><a id="line.9437"></a>
<span class="sourceLineNo">9438</span><a id="line.9438">    //</a>
<span class="sourceLineNo">9439</span><a id="line.9439">    // C++:  void cv::computeCorrespondEpilines(Mat points, int whichImage, Mat F, Mat&amp; lines)</a>
<span class="sourceLineNo">9440</span><a id="line.9440">    //</a>
<span class="sourceLineNo">9441</span><a id="line.9441"></a>
<span class="sourceLineNo">9442</span><a id="line.9442">    /**</a>
<span class="sourceLineNo">9443</span><a id="line.9443">     * For points in an image of a stereo pair, computes the corresponding epilines in the other image.</a>
<span class="sourceLineNo">9444</span><a id="line.9444">     *</a>
<span class="sourceLineNo">9445</span><a id="line.9445">     * @param points Input points. \(N \times 1\) or \(1 \times N\) matrix of type CV_32FC2 or</a>
<span class="sourceLineNo">9446</span><a id="line.9446">     * vector&amp;lt;Point2f&amp;gt; .</a>
<span class="sourceLineNo">9447</span><a id="line.9447">     * @param whichImage Index of the image (1 or 2) that contains the points .</a>
<span class="sourceLineNo">9448</span><a id="line.9448">     * @param F Fundamental matrix that can be estimated using findFundamentalMat or stereoRectify .</a>
<span class="sourceLineNo">9449</span><a id="line.9449">     * @param lines Output vector of the epipolar lines corresponding to the points in the other image.</a>
<span class="sourceLineNo">9450</span><a id="line.9450">     * Each line \(ax + by + c=0\) is encoded by 3 numbers \((a, b, c)\) .</a>
<span class="sourceLineNo">9451</span><a id="line.9451">     *</a>
<span class="sourceLineNo">9452</span><a id="line.9452">     * For every point in one of the two images of a stereo pair, the function finds the equation of the</a>
<span class="sourceLineNo">9453</span><a id="line.9453">     * corresponding epipolar line in the other image.</a>
<span class="sourceLineNo">9454</span><a id="line.9454">     *</a>
<span class="sourceLineNo">9455</span><a id="line.9455">     * From the fundamental matrix definition (see findFundamentalMat ), line \(l^{(2)}_i\) in the second</a>
<span class="sourceLineNo">9456</span><a id="line.9456">     * image for the point \(p^{(1)}_i\) in the first image (when whichImage=1 ) is computed as:</a>
<span class="sourceLineNo">9457</span><a id="line.9457">     *</a>
<span class="sourceLineNo">9458</span><a id="line.9458">     * \(l^{(2)}_i = F p^{(1)}_i\)</a>
<span class="sourceLineNo">9459</span><a id="line.9459">     *</a>
<span class="sourceLineNo">9460</span><a id="line.9460">     * And vice versa, when whichImage=2, \(l^{(1)}_i\) is computed from \(p^{(2)}_i\) as:</a>
<span class="sourceLineNo">9461</span><a id="line.9461">     *</a>
<span class="sourceLineNo">9462</span><a id="line.9462">     * \(l^{(1)}_i = F^T p^{(2)}_i\)</a>
<span class="sourceLineNo">9463</span><a id="line.9463">     *</a>
<span class="sourceLineNo">9464</span><a id="line.9464">     * Line coefficients are defined up to a scale. They are normalized so that \(a_i^2+b_i^2=1\) .</a>
<span class="sourceLineNo">9465</span><a id="line.9465">     */</a>
<span class="sourceLineNo">9466</span><a id="line.9466">    public static void computeCorrespondEpilines(Mat points, int whichImage, Mat F, Mat lines) {</a>
<span class="sourceLineNo">9467</span><a id="line.9467">        computeCorrespondEpilines_0(points.nativeObj, whichImage, F.nativeObj, lines.nativeObj);</a>
<span class="sourceLineNo">9468</span><a id="line.9468">    }</a>
<span class="sourceLineNo">9469</span><a id="line.9469"></a>
<span class="sourceLineNo">9470</span><a id="line.9470"></a>
<span class="sourceLineNo">9471</span><a id="line.9471">    //</a>
<span class="sourceLineNo">9472</span><a id="line.9472">    // C++:  void cv::triangulatePoints(Mat projMatr1, Mat projMatr2, Mat projPoints1, Mat projPoints2, Mat&amp; points4D)</a>
<span class="sourceLineNo">9473</span><a id="line.9473">    //</a>
<span class="sourceLineNo">9474</span><a id="line.9474"></a>
<span class="sourceLineNo">9475</span><a id="line.9475">    /**</a>
<span class="sourceLineNo">9476</span><a id="line.9476">     * This function reconstructs 3-dimensional points (in homogeneous coordinates) by using</a>
<span class="sourceLineNo">9477</span><a id="line.9477">     * their observations with a stereo camera.</a>
<span class="sourceLineNo">9478</span><a id="line.9478">     *</a>
<span class="sourceLineNo">9479</span><a id="line.9479">     * @param projMatr1 3x4 projection matrix of the first camera, i.e. this matrix projects 3D points</a>
<span class="sourceLineNo">9480</span><a id="line.9480">     * given in the world's coordinate system into the first image.</a>
<span class="sourceLineNo">9481</span><a id="line.9481">     * @param projMatr2 3x4 projection matrix of the second camera, i.e. this matrix projects 3D points</a>
<span class="sourceLineNo">9482</span><a id="line.9482">     * given in the world's coordinate system into the second image.</a>
<span class="sourceLineNo">9483</span><a id="line.9483">     * @param projPoints1 2xN array of feature points in the first image. In the case of the c++ version,</a>
<span class="sourceLineNo">9484</span><a id="line.9484">     * it can be also a vector of feature points or two-channel matrix of size 1xN or Nx1.</a>
<span class="sourceLineNo">9485</span><a id="line.9485">     * @param projPoints2 2xN array of corresponding points in the second image. In the case of the c++</a>
<span class="sourceLineNo">9486</span><a id="line.9486">     * version, it can be also a vector of feature points or two-channel matrix of size 1xN or Nx1.</a>
<span class="sourceLineNo">9487</span><a id="line.9487">     * @param points4D 4xN array of reconstructed points in homogeneous coordinates. These points are</a>
<span class="sourceLineNo">9488</span><a id="line.9488">     * returned in the world's coordinate system.</a>
<span class="sourceLineNo">9489</span><a id="line.9489">     *</a>
<span class="sourceLineNo">9490</span><a id="line.9490">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">9491</span><a id="line.9491">     *    Keep in mind that all input data should be of float type in order for this function to work.</a>
<span class="sourceLineNo">9492</span><a id="line.9492">     *</a>
<span class="sourceLineNo">9493</span><a id="line.9493">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">9494</span><a id="line.9494">     *    If the projection matrices from REF: stereoRectify are used, then the returned points are</a>
<span class="sourceLineNo">9495</span><a id="line.9495">     *    represented in the first camera's rectified coordinate system.</a>
<span class="sourceLineNo">9496</span><a id="line.9496">     *</a>
<span class="sourceLineNo">9497</span><a id="line.9497">     * SEE:</a>
<span class="sourceLineNo">9498</span><a id="line.9498">     *    reprojectImageTo3D</a>
<span class="sourceLineNo">9499</span><a id="line.9499">     */</a>
<span class="sourceLineNo">9500</span><a id="line.9500">    public static void triangulatePoints(Mat projMatr1, Mat projMatr2, Mat projPoints1, Mat projPoints2, Mat points4D) {</a>
<span class="sourceLineNo">9501</span><a id="line.9501">        triangulatePoints_0(projMatr1.nativeObj, projMatr2.nativeObj, projPoints1.nativeObj, projPoints2.nativeObj, points4D.nativeObj);</a>
<span class="sourceLineNo">9502</span><a id="line.9502">    }</a>
<span class="sourceLineNo">9503</span><a id="line.9503"></a>
<span class="sourceLineNo">9504</span><a id="line.9504"></a>
<span class="sourceLineNo">9505</span><a id="line.9505">    //</a>
<span class="sourceLineNo">9506</span><a id="line.9506">    // C++:  void cv::correctMatches(Mat F, Mat points1, Mat points2, Mat&amp; newPoints1, Mat&amp; newPoints2)</a>
<span class="sourceLineNo">9507</span><a id="line.9507">    //</a>
<span class="sourceLineNo">9508</span><a id="line.9508"></a>
<span class="sourceLineNo">9509</span><a id="line.9509">    /**</a>
<span class="sourceLineNo">9510</span><a id="line.9510">     * Refines coordinates of corresponding points.</a>
<span class="sourceLineNo">9511</span><a id="line.9511">     *</a>
<span class="sourceLineNo">9512</span><a id="line.9512">     * @param F 3x3 fundamental matrix.</a>
<span class="sourceLineNo">9513</span><a id="line.9513">     * @param points1 1xN array containing the first set of points.</a>
<span class="sourceLineNo">9514</span><a id="line.9514">     * @param points2 1xN array containing the second set of points.</a>
<span class="sourceLineNo">9515</span><a id="line.9515">     * @param newPoints1 The optimized points1.</a>
<span class="sourceLineNo">9516</span><a id="line.9516">     * @param newPoints2 The optimized points2.</a>
<span class="sourceLineNo">9517</span><a id="line.9517">     *</a>
<span class="sourceLineNo">9518</span><a id="line.9518">     * The function implements the Optimal Triangulation Method (see Multiple View Geometry for details).</a>
<span class="sourceLineNo">9519</span><a id="line.9519">     * For each given point correspondence points1[i] &amp;lt;-&amp;gt; points2[i], and a fundamental matrix F, it</a>
<span class="sourceLineNo">9520</span><a id="line.9520">     * computes the corrected correspondences newPoints1[i] &amp;lt;-&amp;gt; newPoints2[i] that minimize the geometric</a>
<span class="sourceLineNo">9521</span><a id="line.9521">     * error \(d(points1[i], newPoints1[i])^2 + d(points2[i],newPoints2[i])^2\) (where \(d(a,b)\) is the</a>
<span class="sourceLineNo">9522</span><a id="line.9522">     * geometric distance between points \(a\) and \(b\) ) subject to the epipolar constraint</a>
<span class="sourceLineNo">9523</span><a id="line.9523">     * \(newPoints2^T * F * newPoints1 = 0\) .</a>
<span class="sourceLineNo">9524</span><a id="line.9524">     */</a>
<span class="sourceLineNo">9525</span><a id="line.9525">    public static void correctMatches(Mat F, Mat points1, Mat points2, Mat newPoints1, Mat newPoints2) {</a>
<span class="sourceLineNo">9526</span><a id="line.9526">        correctMatches_0(F.nativeObj, points1.nativeObj, points2.nativeObj, newPoints1.nativeObj, newPoints2.nativeObj);</a>
<span class="sourceLineNo">9527</span><a id="line.9527">    }</a>
<span class="sourceLineNo">9528</span><a id="line.9528"></a>
<span class="sourceLineNo">9529</span><a id="line.9529"></a>
<span class="sourceLineNo">9530</span><a id="line.9530">    //</a>
<span class="sourceLineNo">9531</span><a id="line.9531">    // C++:  void cv::filterSpeckles(Mat&amp; img, double newVal, int maxSpeckleSize, double maxDiff, Mat&amp; buf = Mat())</a>
<span class="sourceLineNo">9532</span><a id="line.9532">    //</a>
<span class="sourceLineNo">9533</span><a id="line.9533"></a>
<span class="sourceLineNo">9534</span><a id="line.9534">    /**</a>
<span class="sourceLineNo">9535</span><a id="line.9535">     * Filters off small noise blobs (speckles) in the disparity map</a>
<span class="sourceLineNo">9536</span><a id="line.9536">     *</a>
<span class="sourceLineNo">9537</span><a id="line.9537">     * @param img The input 16-bit signed disparity image</a>
<span class="sourceLineNo">9538</span><a id="line.9538">     * @param newVal The disparity value used to paint-off the speckles</a>
<span class="sourceLineNo">9539</span><a id="line.9539">     * @param maxSpeckleSize The maximum speckle size to consider it a speckle. Larger blobs are not</a>
<span class="sourceLineNo">9540</span><a id="line.9540">     * affected by the algorithm</a>
<span class="sourceLineNo">9541</span><a id="line.9541">     * @param maxDiff Maximum difference between neighbor disparity pixels to put them into the same</a>
<span class="sourceLineNo">9542</span><a id="line.9542">     * blob. Note that since StereoBM, StereoSGBM and may be other algorithms return a fixed-point</a>
<span class="sourceLineNo">9543</span><a id="line.9543">     * disparity map, where disparity values are multiplied by 16, this scale factor should be taken into</a>
<span class="sourceLineNo">9544</span><a id="line.9544">     * account when specifying this parameter value.</a>
<span class="sourceLineNo">9545</span><a id="line.9545">     * @param buf The optional temporary buffer to avoid memory allocation within the function.</a>
<span class="sourceLineNo">9546</span><a id="line.9546">     */</a>
<span class="sourceLineNo">9547</span><a id="line.9547">    public static void filterSpeckles(Mat img, double newVal, int maxSpeckleSize, double maxDiff, Mat buf) {</a>
<span class="sourceLineNo">9548</span><a id="line.9548">        filterSpeckles_0(img.nativeObj, newVal, maxSpeckleSize, maxDiff, buf.nativeObj);</a>
<span class="sourceLineNo">9549</span><a id="line.9549">    }</a>
<span class="sourceLineNo">9550</span><a id="line.9550"></a>
<span class="sourceLineNo">9551</span><a id="line.9551">    /**</a>
<span class="sourceLineNo">9552</span><a id="line.9552">     * Filters off small noise blobs (speckles) in the disparity map</a>
<span class="sourceLineNo">9553</span><a id="line.9553">     *</a>
<span class="sourceLineNo">9554</span><a id="line.9554">     * @param img The input 16-bit signed disparity image</a>
<span class="sourceLineNo">9555</span><a id="line.9555">     * @param newVal The disparity value used to paint-off the speckles</a>
<span class="sourceLineNo">9556</span><a id="line.9556">     * @param maxSpeckleSize The maximum speckle size to consider it a speckle. Larger blobs are not</a>
<span class="sourceLineNo">9557</span><a id="line.9557">     * affected by the algorithm</a>
<span class="sourceLineNo">9558</span><a id="line.9558">     * @param maxDiff Maximum difference between neighbor disparity pixels to put them into the same</a>
<span class="sourceLineNo">9559</span><a id="line.9559">     * blob. Note that since StereoBM, StereoSGBM and may be other algorithms return a fixed-point</a>
<span class="sourceLineNo">9560</span><a id="line.9560">     * disparity map, where disparity values are multiplied by 16, this scale factor should be taken into</a>
<span class="sourceLineNo">9561</span><a id="line.9561">     * account when specifying this parameter value.</a>
<span class="sourceLineNo">9562</span><a id="line.9562">     */</a>
<span class="sourceLineNo">9563</span><a id="line.9563">    public static void filterSpeckles(Mat img, double newVal, int maxSpeckleSize, double maxDiff) {</a>
<span class="sourceLineNo">9564</span><a id="line.9564">        filterSpeckles_1(img.nativeObj, newVal, maxSpeckleSize, maxDiff);</a>
<span class="sourceLineNo">9565</span><a id="line.9565">    }</a>
<span class="sourceLineNo">9566</span><a id="line.9566"></a>
<span class="sourceLineNo">9567</span><a id="line.9567"></a>
<span class="sourceLineNo">9568</span><a id="line.9568">    //</a>
<span class="sourceLineNo">9569</span><a id="line.9569">    // C++:  Rect cv::getValidDisparityROI(Rect roi1, Rect roi2, int minDisparity, int numberOfDisparities, int blockSize)</a>
<span class="sourceLineNo">9570</span><a id="line.9570">    //</a>
<span class="sourceLineNo">9571</span><a id="line.9571"></a>
<span class="sourceLineNo">9572</span><a id="line.9572">    public static Rect getValidDisparityROI(Rect roi1, Rect roi2, int minDisparity, int numberOfDisparities, int blockSize) {</a>
<span class="sourceLineNo">9573</span><a id="line.9573">        return new Rect(getValidDisparityROI_0(roi1.x, roi1.y, roi1.width, roi1.height, roi2.x, roi2.y, roi2.width, roi2.height, minDisparity, numberOfDisparities, blockSize));</a>
<span class="sourceLineNo">9574</span><a id="line.9574">    }</a>
<span class="sourceLineNo">9575</span><a id="line.9575"></a>
<span class="sourceLineNo">9576</span><a id="line.9576"></a>
<span class="sourceLineNo">9577</span><a id="line.9577">    //</a>
<span class="sourceLineNo">9578</span><a id="line.9578">    // C++:  void cv::validateDisparity(Mat&amp; disparity, Mat cost, int minDisparity, int numberOfDisparities, int disp12MaxDisp = 1)</a>
<span class="sourceLineNo">9579</span><a id="line.9579">    //</a>
<span class="sourceLineNo">9580</span><a id="line.9580"></a>
<span class="sourceLineNo">9581</span><a id="line.9581">    public static void validateDisparity(Mat disparity, Mat cost, int minDisparity, int numberOfDisparities, int disp12MaxDisp) {</a>
<span class="sourceLineNo">9582</span><a id="line.9582">        validateDisparity_0(disparity.nativeObj, cost.nativeObj, minDisparity, numberOfDisparities, disp12MaxDisp);</a>
<span class="sourceLineNo">9583</span><a id="line.9583">    }</a>
<span class="sourceLineNo">9584</span><a id="line.9584"></a>
<span class="sourceLineNo">9585</span><a id="line.9585">    public static void validateDisparity(Mat disparity, Mat cost, int minDisparity, int numberOfDisparities) {</a>
<span class="sourceLineNo">9586</span><a id="line.9586">        validateDisparity_1(disparity.nativeObj, cost.nativeObj, minDisparity, numberOfDisparities);</a>
<span class="sourceLineNo">9587</span><a id="line.9587">    }</a>
<span class="sourceLineNo">9588</span><a id="line.9588"></a>
<span class="sourceLineNo">9589</span><a id="line.9589"></a>
<span class="sourceLineNo">9590</span><a id="line.9590">    //</a>
<span class="sourceLineNo">9591</span><a id="line.9591">    // C++:  void cv::reprojectImageTo3D(Mat disparity, Mat&amp; _3dImage, Mat Q, bool handleMissingValues = false, int ddepth = -1)</a>
<span class="sourceLineNo">9592</span><a id="line.9592">    //</a>
<span class="sourceLineNo">9593</span><a id="line.9593"></a>
<span class="sourceLineNo">9594</span><a id="line.9594">    /**</a>
<span class="sourceLineNo">9595</span><a id="line.9595">     * Reprojects a disparity image to 3D space.</a>
<span class="sourceLineNo">9596</span><a id="line.9596">     *</a>
<span class="sourceLineNo">9597</span><a id="line.9597">     * @param disparity Input single-channel 8-bit unsigned, 16-bit signed, 32-bit signed or 32-bit</a>
<span class="sourceLineNo">9598</span><a id="line.9598">     * floating-point disparity image. The values of 8-bit / 16-bit signed formats are assumed to have no</a>
<span class="sourceLineNo">9599</span><a id="line.9599">     * fractional bits. If the disparity is 16-bit signed format, as computed by REF: StereoBM or</a>
<span class="sourceLineNo">9600</span><a id="line.9600">     * REF: StereoSGBM and maybe other algorithms, it should be divided by 16 (and scaled to float) before</a>
<span class="sourceLineNo">9601</span><a id="line.9601">     * being used here.</a>
<span class="sourceLineNo">9602</span><a id="line.9602">     * @param _3dImage Output 3-channel floating-point image of the same size as disparity. Each element of</a>
<span class="sourceLineNo">9603</span><a id="line.9603">     * _3dImage(x,y) contains 3D coordinates of the point (x,y) computed from the disparity map. If one</a>
<span class="sourceLineNo">9604</span><a id="line.9604">     * uses Q obtained by REF: stereoRectify, then the returned points are represented in the first</a>
<span class="sourceLineNo">9605</span><a id="line.9605">     * camera's rectified coordinate system.</a>
<span class="sourceLineNo">9606</span><a id="line.9606">     * @param Q \(4 \times 4\) perspective transformation matrix that can be obtained with</a>
<span class="sourceLineNo">9607</span><a id="line.9607">     * REF: stereoRectify.</a>
<span class="sourceLineNo">9608</span><a id="line.9608">     * @param handleMissingValues Indicates, whether the function should handle missing values (i.e.</a>
<span class="sourceLineNo">9609</span><a id="line.9609">     * points where the disparity was not computed). If handleMissingValues=true, then pixels with the</a>
<span class="sourceLineNo">9610</span><a id="line.9610">     * minimal disparity that corresponds to the outliers (see StereoMatcher::compute ) are transformed</a>
<span class="sourceLineNo">9611</span><a id="line.9611">     * to 3D points with a very large Z value (currently set to 10000).</a>
<span class="sourceLineNo">9612</span><a id="line.9612">     * @param ddepth The optional output array depth. If it is -1, the output image will have CV_32F</a>
<span class="sourceLineNo">9613</span><a id="line.9613">     * depth. ddepth can also be set to CV_16S, CV_32S or CV_32F.</a>
<span class="sourceLineNo">9614</span><a id="line.9614">     *</a>
<span class="sourceLineNo">9615</span><a id="line.9615">     * The function transforms a single-channel disparity map to a 3-channel image representing a 3D</a>
<span class="sourceLineNo">9616</span><a id="line.9616">     * surface. That is, for each pixel (x,y) and the corresponding disparity d=disparity(x,y) , it</a>
<span class="sourceLineNo">9617</span><a id="line.9617">     * computes:</a>
<span class="sourceLineNo">9618</span><a id="line.9618">     *</a>
<span class="sourceLineNo">9619</span><a id="line.9619">     * \(\begin{bmatrix}</a>
<span class="sourceLineNo">9620</span><a id="line.9620">     * X \\</a>
<span class="sourceLineNo">9621</span><a id="line.9621">     * Y \\</a>
<span class="sourceLineNo">9622</span><a id="line.9622">     * Z \\</a>
<span class="sourceLineNo">9623</span><a id="line.9623">     * W</a>
<span class="sourceLineNo">9624</span><a id="line.9624">     * \end{bmatrix} = Q \begin{bmatrix}</a>
<span class="sourceLineNo">9625</span><a id="line.9625">     * x \\</a>
<span class="sourceLineNo">9626</span><a id="line.9626">     * y \\</a>
<span class="sourceLineNo">9627</span><a id="line.9627">     * \texttt{disparity} (x,y) \\</a>
<span class="sourceLineNo">9628</span><a id="line.9628">     * z</a>
<span class="sourceLineNo">9629</span><a id="line.9629">     * \end{bmatrix}.\)</a>
<span class="sourceLineNo">9630</span><a id="line.9630">     *</a>
<span class="sourceLineNo">9631</span><a id="line.9631">     * SEE:</a>
<span class="sourceLineNo">9632</span><a id="line.9632">     *    To reproject a sparse set of points {(x,y,d),...} to 3D space, use perspectiveTransform.</a>
<span class="sourceLineNo">9633</span><a id="line.9633">     */</a>
<span class="sourceLineNo">9634</span><a id="line.9634">    public static void reprojectImageTo3D(Mat disparity, Mat _3dImage, Mat Q, boolean handleMissingValues, int ddepth) {</a>
<span class="sourceLineNo">9635</span><a id="line.9635">        reprojectImageTo3D_0(disparity.nativeObj, _3dImage.nativeObj, Q.nativeObj, handleMissingValues, ddepth);</a>
<span class="sourceLineNo">9636</span><a id="line.9636">    }</a>
<span class="sourceLineNo">9637</span><a id="line.9637"></a>
<span class="sourceLineNo">9638</span><a id="line.9638">    /**</a>
<span class="sourceLineNo">9639</span><a id="line.9639">     * Reprojects a disparity image to 3D space.</a>
<span class="sourceLineNo">9640</span><a id="line.9640">     *</a>
<span class="sourceLineNo">9641</span><a id="line.9641">     * @param disparity Input single-channel 8-bit unsigned, 16-bit signed, 32-bit signed or 32-bit</a>
<span class="sourceLineNo">9642</span><a id="line.9642">     * floating-point disparity image. The values of 8-bit / 16-bit signed formats are assumed to have no</a>
<span class="sourceLineNo">9643</span><a id="line.9643">     * fractional bits. If the disparity is 16-bit signed format, as computed by REF: StereoBM or</a>
<span class="sourceLineNo">9644</span><a id="line.9644">     * REF: StereoSGBM and maybe other algorithms, it should be divided by 16 (and scaled to float) before</a>
<span class="sourceLineNo">9645</span><a id="line.9645">     * being used here.</a>
<span class="sourceLineNo">9646</span><a id="line.9646">     * @param _3dImage Output 3-channel floating-point image of the same size as disparity. Each element of</a>
<span class="sourceLineNo">9647</span><a id="line.9647">     * _3dImage(x,y) contains 3D coordinates of the point (x,y) computed from the disparity map. If one</a>
<span class="sourceLineNo">9648</span><a id="line.9648">     * uses Q obtained by REF: stereoRectify, then the returned points are represented in the first</a>
<span class="sourceLineNo">9649</span><a id="line.9649">     * camera's rectified coordinate system.</a>
<span class="sourceLineNo">9650</span><a id="line.9650">     * @param Q \(4 \times 4\) perspective transformation matrix that can be obtained with</a>
<span class="sourceLineNo">9651</span><a id="line.9651">     * REF: stereoRectify.</a>
<span class="sourceLineNo">9652</span><a id="line.9652">     * @param handleMissingValues Indicates, whether the function should handle missing values (i.e.</a>
<span class="sourceLineNo">9653</span><a id="line.9653">     * points where the disparity was not computed). If handleMissingValues=true, then pixels with the</a>
<span class="sourceLineNo">9654</span><a id="line.9654">     * minimal disparity that corresponds to the outliers (see StereoMatcher::compute ) are transformed</a>
<span class="sourceLineNo">9655</span><a id="line.9655">     * to 3D points with a very large Z value (currently set to 10000).</a>
<span class="sourceLineNo">9656</span><a id="line.9656">     * depth. ddepth can also be set to CV_16S, CV_32S or CV_32F.</a>
<span class="sourceLineNo">9657</span><a id="line.9657">     *</a>
<span class="sourceLineNo">9658</span><a id="line.9658">     * The function transforms a single-channel disparity map to a 3-channel image representing a 3D</a>
<span class="sourceLineNo">9659</span><a id="line.9659">     * surface. That is, for each pixel (x,y) and the corresponding disparity d=disparity(x,y) , it</a>
<span class="sourceLineNo">9660</span><a id="line.9660">     * computes:</a>
<span class="sourceLineNo">9661</span><a id="line.9661">     *</a>
<span class="sourceLineNo">9662</span><a id="line.9662">     * \(\begin{bmatrix}</a>
<span class="sourceLineNo">9663</span><a id="line.9663">     * X \\</a>
<span class="sourceLineNo">9664</span><a id="line.9664">     * Y \\</a>
<span class="sourceLineNo">9665</span><a id="line.9665">     * Z \\</a>
<span class="sourceLineNo">9666</span><a id="line.9666">     * W</a>
<span class="sourceLineNo">9667</span><a id="line.9667">     * \end{bmatrix} = Q \begin{bmatrix}</a>
<span class="sourceLineNo">9668</span><a id="line.9668">     * x \\</a>
<span class="sourceLineNo">9669</span><a id="line.9669">     * y \\</a>
<span class="sourceLineNo">9670</span><a id="line.9670">     * \texttt{disparity} (x,y) \\</a>
<span class="sourceLineNo">9671</span><a id="line.9671">     * z</a>
<span class="sourceLineNo">9672</span><a id="line.9672">     * \end{bmatrix}.\)</a>
<span class="sourceLineNo">9673</span><a id="line.9673">     *</a>
<span class="sourceLineNo">9674</span><a id="line.9674">     * SEE:</a>
<span class="sourceLineNo">9675</span><a id="line.9675">     *    To reproject a sparse set of points {(x,y,d),...} to 3D space, use perspectiveTransform.</a>
<span class="sourceLineNo">9676</span><a id="line.9676">     */</a>
<span class="sourceLineNo">9677</span><a id="line.9677">    public static void reprojectImageTo3D(Mat disparity, Mat _3dImage, Mat Q, boolean handleMissingValues) {</a>
<span class="sourceLineNo">9678</span><a id="line.9678">        reprojectImageTo3D_1(disparity.nativeObj, _3dImage.nativeObj, Q.nativeObj, handleMissingValues);</a>
<span class="sourceLineNo">9679</span><a id="line.9679">    }</a>
<span class="sourceLineNo">9680</span><a id="line.9680"></a>
<span class="sourceLineNo">9681</span><a id="line.9681">    /**</a>
<span class="sourceLineNo">9682</span><a id="line.9682">     * Reprojects a disparity image to 3D space.</a>
<span class="sourceLineNo">9683</span><a id="line.9683">     *</a>
<span class="sourceLineNo">9684</span><a id="line.9684">     * @param disparity Input single-channel 8-bit unsigned, 16-bit signed, 32-bit signed or 32-bit</a>
<span class="sourceLineNo">9685</span><a id="line.9685">     * floating-point disparity image. The values of 8-bit / 16-bit signed formats are assumed to have no</a>
<span class="sourceLineNo">9686</span><a id="line.9686">     * fractional bits. If the disparity is 16-bit signed format, as computed by REF: StereoBM or</a>
<span class="sourceLineNo">9687</span><a id="line.9687">     * REF: StereoSGBM and maybe other algorithms, it should be divided by 16 (and scaled to float) before</a>
<span class="sourceLineNo">9688</span><a id="line.9688">     * being used here.</a>
<span class="sourceLineNo">9689</span><a id="line.9689">     * @param _3dImage Output 3-channel floating-point image of the same size as disparity. Each element of</a>
<span class="sourceLineNo">9690</span><a id="line.9690">     * _3dImage(x,y) contains 3D coordinates of the point (x,y) computed from the disparity map. If one</a>
<span class="sourceLineNo">9691</span><a id="line.9691">     * uses Q obtained by REF: stereoRectify, then the returned points are represented in the first</a>
<span class="sourceLineNo">9692</span><a id="line.9692">     * camera's rectified coordinate system.</a>
<span class="sourceLineNo">9693</span><a id="line.9693">     * @param Q \(4 \times 4\) perspective transformation matrix that can be obtained with</a>
<span class="sourceLineNo">9694</span><a id="line.9694">     * REF: stereoRectify.</a>
<span class="sourceLineNo">9695</span><a id="line.9695">     * points where the disparity was not computed). If handleMissingValues=true, then pixels with the</a>
<span class="sourceLineNo">9696</span><a id="line.9696">     * minimal disparity that corresponds to the outliers (see StereoMatcher::compute ) are transformed</a>
<span class="sourceLineNo">9697</span><a id="line.9697">     * to 3D points with a very large Z value (currently set to 10000).</a>
<span class="sourceLineNo">9698</span><a id="line.9698">     * depth. ddepth can also be set to CV_16S, CV_32S or CV_32F.</a>
<span class="sourceLineNo">9699</span><a id="line.9699">     *</a>
<span class="sourceLineNo">9700</span><a id="line.9700">     * The function transforms a single-channel disparity map to a 3-channel image representing a 3D</a>
<span class="sourceLineNo">9701</span><a id="line.9701">     * surface. That is, for each pixel (x,y) and the corresponding disparity d=disparity(x,y) , it</a>
<span class="sourceLineNo">9702</span><a id="line.9702">     * computes:</a>
<span class="sourceLineNo">9703</span><a id="line.9703">     *</a>
<span class="sourceLineNo">9704</span><a id="line.9704">     * \(\begin{bmatrix}</a>
<span class="sourceLineNo">9705</span><a id="line.9705">     * X \\</a>
<span class="sourceLineNo">9706</span><a id="line.9706">     * Y \\</a>
<span class="sourceLineNo">9707</span><a id="line.9707">     * Z \\</a>
<span class="sourceLineNo">9708</span><a id="line.9708">     * W</a>
<span class="sourceLineNo">9709</span><a id="line.9709">     * \end{bmatrix} = Q \begin{bmatrix}</a>
<span class="sourceLineNo">9710</span><a id="line.9710">     * x \\</a>
<span class="sourceLineNo">9711</span><a id="line.9711">     * y \\</a>
<span class="sourceLineNo">9712</span><a id="line.9712">     * \texttt{disparity} (x,y) \\</a>
<span class="sourceLineNo">9713</span><a id="line.9713">     * z</a>
<span class="sourceLineNo">9714</span><a id="line.9714">     * \end{bmatrix}.\)</a>
<span class="sourceLineNo">9715</span><a id="line.9715">     *</a>
<span class="sourceLineNo">9716</span><a id="line.9716">     * SEE:</a>
<span class="sourceLineNo">9717</span><a id="line.9717">     *    To reproject a sparse set of points {(x,y,d),...} to 3D space, use perspectiveTransform.</a>
<span class="sourceLineNo">9718</span><a id="line.9718">     */</a>
<span class="sourceLineNo">9719</span><a id="line.9719">    public static void reprojectImageTo3D(Mat disparity, Mat _3dImage, Mat Q) {</a>
<span class="sourceLineNo">9720</span><a id="line.9720">        reprojectImageTo3D_2(disparity.nativeObj, _3dImage.nativeObj, Q.nativeObj);</a>
<span class="sourceLineNo">9721</span><a id="line.9721">    }</a>
<span class="sourceLineNo">9722</span><a id="line.9722"></a>
<span class="sourceLineNo">9723</span><a id="line.9723"></a>
<span class="sourceLineNo">9724</span><a id="line.9724">    //</a>
<span class="sourceLineNo">9725</span><a id="line.9725">    // C++:  double cv::sampsonDistance(Mat pt1, Mat pt2, Mat F)</a>
<span class="sourceLineNo">9726</span><a id="line.9726">    //</a>
<span class="sourceLineNo">9727</span><a id="line.9727"></a>
<span class="sourceLineNo">9728</span><a id="line.9728">    /**</a>
<span class="sourceLineNo">9729</span><a id="line.9729">     * Calculates the Sampson Distance between two points.</a>
<span class="sourceLineNo">9730</span><a id="line.9730">     *</a>
<span class="sourceLineNo">9731</span><a id="line.9731">     * The function cv::sampsonDistance calculates and returns the first order approximation of the geometric error as:</a>
<span class="sourceLineNo">9732</span><a id="line.9732">     * \(</a>
<span class="sourceLineNo">9733</span><a id="line.9733">     * sd( \texttt{pt1} , \texttt{pt2} )=</a>
<span class="sourceLineNo">9734</span><a id="line.9734">     * \frac{(\texttt{pt2}^t \cdot \texttt{F} \cdot \texttt{pt1})^2}</a>
<span class="sourceLineNo">9735</span><a id="line.9735">     * {((\texttt{F} \cdot \texttt{pt1})(0))^2 +</a>
<span class="sourceLineNo">9736</span><a id="line.9736">     * ((\texttt{F} \cdot \texttt{pt1})(1))^2 +</a>
<span class="sourceLineNo">9737</span><a id="line.9737">     * ((\texttt{F}^t \cdot \texttt{pt2})(0))^2 +</a>
<span class="sourceLineNo">9738</span><a id="line.9738">     * ((\texttt{F}^t \cdot \texttt{pt2})(1))^2}</a>
<span class="sourceLineNo">9739</span><a id="line.9739">     * \)</a>
<span class="sourceLineNo">9740</span><a id="line.9740">     * The fundamental matrix may be calculated using the cv::findFundamentalMat function. See CITE: HartleyZ00 11.4.3 for details.</a>
<span class="sourceLineNo">9741</span><a id="line.9741">     * @param pt1 first homogeneous 2d point</a>
<span class="sourceLineNo">9742</span><a id="line.9742">     * @param pt2 second homogeneous 2d point</a>
<span class="sourceLineNo">9743</span><a id="line.9743">     * @param F fundamental matrix</a>
<span class="sourceLineNo">9744</span><a id="line.9744">     * @return The computed Sampson distance.</a>
<span class="sourceLineNo">9745</span><a id="line.9745">     */</a>
<span class="sourceLineNo">9746</span><a id="line.9746">    public static double sampsonDistance(Mat pt1, Mat pt2, Mat F) {</a>
<span class="sourceLineNo">9747</span><a id="line.9747">        return sampsonDistance_0(pt1.nativeObj, pt2.nativeObj, F.nativeObj);</a>
<span class="sourceLineNo">9748</span><a id="line.9748">    }</a>
<span class="sourceLineNo">9749</span><a id="line.9749"></a>
<span class="sourceLineNo">9750</span><a id="line.9750"></a>
<span class="sourceLineNo">9751</span><a id="line.9751">    //</a>
<span class="sourceLineNo">9752</span><a id="line.9752">    // C++:  int cv::estimateAffine3D(Mat src, Mat dst, Mat&amp; out, Mat&amp; inliers, double ransacThreshold = 3, double confidence = 0.99)</a>
<span class="sourceLineNo">9753</span><a id="line.9753">    //</a>
<span class="sourceLineNo">9754</span><a id="line.9754"></a>
<span class="sourceLineNo">9755</span><a id="line.9755">    /**</a>
<span class="sourceLineNo">9756</span><a id="line.9756">     * Computes an optimal affine transformation between two 3D point sets.</a>
<span class="sourceLineNo">9757</span><a id="line.9757">     *</a>
<span class="sourceLineNo">9758</span><a id="line.9758">     * It computes</a>
<span class="sourceLineNo">9759</span><a id="line.9759">     * \(</a>
<span class="sourceLineNo">9760</span><a id="line.9760">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9761</span><a id="line.9761">     * x\\</a>
<span class="sourceLineNo">9762</span><a id="line.9762">     * y\\</a>
<span class="sourceLineNo">9763</span><a id="line.9763">     * z\\</a>
<span class="sourceLineNo">9764</span><a id="line.9764">     * \end{bmatrix}</a>
<span class="sourceLineNo">9765</span><a id="line.9765">     * =</a>
<span class="sourceLineNo">9766</span><a id="line.9766">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9767</span><a id="line.9767">     * a_{11} &amp;amp; a_{12} &amp;amp; a_{13}\\</a>
<span class="sourceLineNo">9768</span><a id="line.9768">     * a_{21} &amp;amp; a_{22} &amp;amp; a_{23}\\</a>
<span class="sourceLineNo">9769</span><a id="line.9769">     * a_{31} &amp;amp; a_{32} &amp;amp; a_{33}\\</a>
<span class="sourceLineNo">9770</span><a id="line.9770">     * \end{bmatrix}</a>
<span class="sourceLineNo">9771</span><a id="line.9771">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9772</span><a id="line.9772">     * X\\</a>
<span class="sourceLineNo">9773</span><a id="line.9773">     * Y\\</a>
<span class="sourceLineNo">9774</span><a id="line.9774">     * Z\\</a>
<span class="sourceLineNo">9775</span><a id="line.9775">     * \end{bmatrix}</a>
<span class="sourceLineNo">9776</span><a id="line.9776">     * +</a>
<span class="sourceLineNo">9777</span><a id="line.9777">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9778</span><a id="line.9778">     * b_1\\</a>
<span class="sourceLineNo">9779</span><a id="line.9779">     * b_2\\</a>
<span class="sourceLineNo">9780</span><a id="line.9780">     * b_3\\</a>
<span class="sourceLineNo">9781</span><a id="line.9781">     * \end{bmatrix}</a>
<span class="sourceLineNo">9782</span><a id="line.9782">     * \)</a>
<span class="sourceLineNo">9783</span><a id="line.9783">     *</a>
<span class="sourceLineNo">9784</span><a id="line.9784">     * @param src First input 3D point set containing \((X,Y,Z)\).</a>
<span class="sourceLineNo">9785</span><a id="line.9785">     * @param dst Second input 3D point set containing \((x,y,z)\).</a>
<span class="sourceLineNo">9786</span><a id="line.9786">     * @param out Output 3D affine transformation matrix \(3 \times 4\) of the form</a>
<span class="sourceLineNo">9787</span><a id="line.9787">     * \(</a>
<span class="sourceLineNo">9788</span><a id="line.9788">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9789</span><a id="line.9789">     * a_{11} &amp;amp; a_{12} &amp;amp; a_{13} &amp;amp; b_1\\</a>
<span class="sourceLineNo">9790</span><a id="line.9790">     * a_{21} &amp;amp; a_{22} &amp;amp; a_{23} &amp;amp; b_2\\</a>
<span class="sourceLineNo">9791</span><a id="line.9791">     * a_{31} &amp;amp; a_{32} &amp;amp; a_{33} &amp;amp; b_3\\</a>
<span class="sourceLineNo">9792</span><a id="line.9792">     * \end{bmatrix}</a>
<span class="sourceLineNo">9793</span><a id="line.9793">     * \)</a>
<span class="sourceLineNo">9794</span><a id="line.9794">     * @param inliers Output vector indicating which points are inliers (1-inlier, 0-outlier).</a>
<span class="sourceLineNo">9795</span><a id="line.9795">     * @param ransacThreshold Maximum reprojection error in the RANSAC algorithm to consider a point as</a>
<span class="sourceLineNo">9796</span><a id="line.9796">     * an inlier.</a>
<span class="sourceLineNo">9797</span><a id="line.9797">     * @param confidence Confidence level, between 0 and 1, for the estimated transformation. Anything</a>
<span class="sourceLineNo">9798</span><a id="line.9798">     * between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation</a>
<span class="sourceLineNo">9799</span><a id="line.9799">     * significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</a>
<span class="sourceLineNo">9800</span><a id="line.9800">     *</a>
<span class="sourceLineNo">9801</span><a id="line.9801">     * The function estimates an optimal 3D affine transformation between two 3D point sets using the</a>
<span class="sourceLineNo">9802</span><a id="line.9802">     * RANSAC algorithm.</a>
<span class="sourceLineNo">9803</span><a id="line.9803">     * @return automatically generated</a>
<span class="sourceLineNo">9804</span><a id="line.9804">     */</a>
<span class="sourceLineNo">9805</span><a id="line.9805">    public static int estimateAffine3D(Mat src, Mat dst, Mat out, Mat inliers, double ransacThreshold, double confidence) {</a>
<span class="sourceLineNo">9806</span><a id="line.9806">        return estimateAffine3D_0(src.nativeObj, dst.nativeObj, out.nativeObj, inliers.nativeObj, ransacThreshold, confidence);</a>
<span class="sourceLineNo">9807</span><a id="line.9807">    }</a>
<span class="sourceLineNo">9808</span><a id="line.9808"></a>
<span class="sourceLineNo">9809</span><a id="line.9809">    /**</a>
<span class="sourceLineNo">9810</span><a id="line.9810">     * Computes an optimal affine transformation between two 3D point sets.</a>
<span class="sourceLineNo">9811</span><a id="line.9811">     *</a>
<span class="sourceLineNo">9812</span><a id="line.9812">     * It computes</a>
<span class="sourceLineNo">9813</span><a id="line.9813">     * \(</a>
<span class="sourceLineNo">9814</span><a id="line.9814">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9815</span><a id="line.9815">     * x\\</a>
<span class="sourceLineNo">9816</span><a id="line.9816">     * y\\</a>
<span class="sourceLineNo">9817</span><a id="line.9817">     * z\\</a>
<span class="sourceLineNo">9818</span><a id="line.9818">     * \end{bmatrix}</a>
<span class="sourceLineNo">9819</span><a id="line.9819">     * =</a>
<span class="sourceLineNo">9820</span><a id="line.9820">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9821</span><a id="line.9821">     * a_{11} &amp;amp; a_{12} &amp;amp; a_{13}\\</a>
<span class="sourceLineNo">9822</span><a id="line.9822">     * a_{21} &amp;amp; a_{22} &amp;amp; a_{23}\\</a>
<span class="sourceLineNo">9823</span><a id="line.9823">     * a_{31} &amp;amp; a_{32} &amp;amp; a_{33}\\</a>
<span class="sourceLineNo">9824</span><a id="line.9824">     * \end{bmatrix}</a>
<span class="sourceLineNo">9825</span><a id="line.9825">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9826</span><a id="line.9826">     * X\\</a>
<span class="sourceLineNo">9827</span><a id="line.9827">     * Y\\</a>
<span class="sourceLineNo">9828</span><a id="line.9828">     * Z\\</a>
<span class="sourceLineNo">9829</span><a id="line.9829">     * \end{bmatrix}</a>
<span class="sourceLineNo">9830</span><a id="line.9830">     * +</a>
<span class="sourceLineNo">9831</span><a id="line.9831">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9832</span><a id="line.9832">     * b_1\\</a>
<span class="sourceLineNo">9833</span><a id="line.9833">     * b_2\\</a>
<span class="sourceLineNo">9834</span><a id="line.9834">     * b_3\\</a>
<span class="sourceLineNo">9835</span><a id="line.9835">     * \end{bmatrix}</a>
<span class="sourceLineNo">9836</span><a id="line.9836">     * \)</a>
<span class="sourceLineNo">9837</span><a id="line.9837">     *</a>
<span class="sourceLineNo">9838</span><a id="line.9838">     * @param src First input 3D point set containing \((X,Y,Z)\).</a>
<span class="sourceLineNo">9839</span><a id="line.9839">     * @param dst Second input 3D point set containing \((x,y,z)\).</a>
<span class="sourceLineNo">9840</span><a id="line.9840">     * @param out Output 3D affine transformation matrix \(3 \times 4\) of the form</a>
<span class="sourceLineNo">9841</span><a id="line.9841">     * \(</a>
<span class="sourceLineNo">9842</span><a id="line.9842">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9843</span><a id="line.9843">     * a_{11} &amp;amp; a_{12} &amp;amp; a_{13} &amp;amp; b_1\\</a>
<span class="sourceLineNo">9844</span><a id="line.9844">     * a_{21} &amp;amp; a_{22} &amp;amp; a_{23} &amp;amp; b_2\\</a>
<span class="sourceLineNo">9845</span><a id="line.9845">     * a_{31} &amp;amp; a_{32} &amp;amp; a_{33} &amp;amp; b_3\\</a>
<span class="sourceLineNo">9846</span><a id="line.9846">     * \end{bmatrix}</a>
<span class="sourceLineNo">9847</span><a id="line.9847">     * \)</a>
<span class="sourceLineNo">9848</span><a id="line.9848">     * @param inliers Output vector indicating which points are inliers (1-inlier, 0-outlier).</a>
<span class="sourceLineNo">9849</span><a id="line.9849">     * @param ransacThreshold Maximum reprojection error in the RANSAC algorithm to consider a point as</a>
<span class="sourceLineNo">9850</span><a id="line.9850">     * an inlier.</a>
<span class="sourceLineNo">9851</span><a id="line.9851">     * between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation</a>
<span class="sourceLineNo">9852</span><a id="line.9852">     * significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</a>
<span class="sourceLineNo">9853</span><a id="line.9853">     *</a>
<span class="sourceLineNo">9854</span><a id="line.9854">     * The function estimates an optimal 3D affine transformation between two 3D point sets using the</a>
<span class="sourceLineNo">9855</span><a id="line.9855">     * RANSAC algorithm.</a>
<span class="sourceLineNo">9856</span><a id="line.9856">     * @return automatically generated</a>
<span class="sourceLineNo">9857</span><a id="line.9857">     */</a>
<span class="sourceLineNo">9858</span><a id="line.9858">    public static int estimateAffine3D(Mat src, Mat dst, Mat out, Mat inliers, double ransacThreshold) {</a>
<span class="sourceLineNo">9859</span><a id="line.9859">        return estimateAffine3D_1(src.nativeObj, dst.nativeObj, out.nativeObj, inliers.nativeObj, ransacThreshold);</a>
<span class="sourceLineNo">9860</span><a id="line.9860">    }</a>
<span class="sourceLineNo">9861</span><a id="line.9861"></a>
<span class="sourceLineNo">9862</span><a id="line.9862">    /**</a>
<span class="sourceLineNo">9863</span><a id="line.9863">     * Computes an optimal affine transformation between two 3D point sets.</a>
<span class="sourceLineNo">9864</span><a id="line.9864">     *</a>
<span class="sourceLineNo">9865</span><a id="line.9865">     * It computes</a>
<span class="sourceLineNo">9866</span><a id="line.9866">     * \(</a>
<span class="sourceLineNo">9867</span><a id="line.9867">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9868</span><a id="line.9868">     * x\\</a>
<span class="sourceLineNo">9869</span><a id="line.9869">     * y\\</a>
<span class="sourceLineNo">9870</span><a id="line.9870">     * z\\</a>
<span class="sourceLineNo">9871</span><a id="line.9871">     * \end{bmatrix}</a>
<span class="sourceLineNo">9872</span><a id="line.9872">     * =</a>
<span class="sourceLineNo">9873</span><a id="line.9873">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9874</span><a id="line.9874">     * a_{11} &amp;amp; a_{12} &amp;amp; a_{13}\\</a>
<span class="sourceLineNo">9875</span><a id="line.9875">     * a_{21} &amp;amp; a_{22} &amp;amp; a_{23}\\</a>
<span class="sourceLineNo">9876</span><a id="line.9876">     * a_{31} &amp;amp; a_{32} &amp;amp; a_{33}\\</a>
<span class="sourceLineNo">9877</span><a id="line.9877">     * \end{bmatrix}</a>
<span class="sourceLineNo">9878</span><a id="line.9878">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9879</span><a id="line.9879">     * X\\</a>
<span class="sourceLineNo">9880</span><a id="line.9880">     * Y\\</a>
<span class="sourceLineNo">9881</span><a id="line.9881">     * Z\\</a>
<span class="sourceLineNo">9882</span><a id="line.9882">     * \end{bmatrix}</a>
<span class="sourceLineNo">9883</span><a id="line.9883">     * +</a>
<span class="sourceLineNo">9884</span><a id="line.9884">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9885</span><a id="line.9885">     * b_1\\</a>
<span class="sourceLineNo">9886</span><a id="line.9886">     * b_2\\</a>
<span class="sourceLineNo">9887</span><a id="line.9887">     * b_3\\</a>
<span class="sourceLineNo">9888</span><a id="line.9888">     * \end{bmatrix}</a>
<span class="sourceLineNo">9889</span><a id="line.9889">     * \)</a>
<span class="sourceLineNo">9890</span><a id="line.9890">     *</a>
<span class="sourceLineNo">9891</span><a id="line.9891">     * @param src First input 3D point set containing \((X,Y,Z)\).</a>
<span class="sourceLineNo">9892</span><a id="line.9892">     * @param dst Second input 3D point set containing \((x,y,z)\).</a>
<span class="sourceLineNo">9893</span><a id="line.9893">     * @param out Output 3D affine transformation matrix \(3 \times 4\) of the form</a>
<span class="sourceLineNo">9894</span><a id="line.9894">     * \(</a>
<span class="sourceLineNo">9895</span><a id="line.9895">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9896</span><a id="line.9896">     * a_{11} &amp;amp; a_{12} &amp;amp; a_{13} &amp;amp; b_1\\</a>
<span class="sourceLineNo">9897</span><a id="line.9897">     * a_{21} &amp;amp; a_{22} &amp;amp; a_{23} &amp;amp; b_2\\</a>
<span class="sourceLineNo">9898</span><a id="line.9898">     * a_{31} &amp;amp; a_{32} &amp;amp; a_{33} &amp;amp; b_3\\</a>
<span class="sourceLineNo">9899</span><a id="line.9899">     * \end{bmatrix}</a>
<span class="sourceLineNo">9900</span><a id="line.9900">     * \)</a>
<span class="sourceLineNo">9901</span><a id="line.9901">     * @param inliers Output vector indicating which points are inliers (1-inlier, 0-outlier).</a>
<span class="sourceLineNo">9902</span><a id="line.9902">     * an inlier.</a>
<span class="sourceLineNo">9903</span><a id="line.9903">     * between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation</a>
<span class="sourceLineNo">9904</span><a id="line.9904">     * significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</a>
<span class="sourceLineNo">9905</span><a id="line.9905">     *</a>
<span class="sourceLineNo">9906</span><a id="line.9906">     * The function estimates an optimal 3D affine transformation between two 3D point sets using the</a>
<span class="sourceLineNo">9907</span><a id="line.9907">     * RANSAC algorithm.</a>
<span class="sourceLineNo">9908</span><a id="line.9908">     * @return automatically generated</a>
<span class="sourceLineNo">9909</span><a id="line.9909">     */</a>
<span class="sourceLineNo">9910</span><a id="line.9910">    public static int estimateAffine3D(Mat src, Mat dst, Mat out, Mat inliers) {</a>
<span class="sourceLineNo">9911</span><a id="line.9911">        return estimateAffine3D_2(src.nativeObj, dst.nativeObj, out.nativeObj, inliers.nativeObj);</a>
<span class="sourceLineNo">9912</span><a id="line.9912">    }</a>
<span class="sourceLineNo">9913</span><a id="line.9913"></a>
<span class="sourceLineNo">9914</span><a id="line.9914"></a>
<span class="sourceLineNo">9915</span><a id="line.9915">    //</a>
<span class="sourceLineNo">9916</span><a id="line.9916">    // C++:  int cv::estimateTranslation3D(Mat src, Mat dst, Mat&amp; out, Mat&amp; inliers, double ransacThreshold = 3, double confidence = 0.99)</a>
<span class="sourceLineNo">9917</span><a id="line.9917">    //</a>
<span class="sourceLineNo">9918</span><a id="line.9918"></a>
<span class="sourceLineNo">9919</span><a id="line.9919">    /**</a>
<span class="sourceLineNo">9920</span><a id="line.9920">     * Computes an optimal translation between two 3D point sets.</a>
<span class="sourceLineNo">9921</span><a id="line.9921">     *</a>
<span class="sourceLineNo">9922</span><a id="line.9922">     * It computes</a>
<span class="sourceLineNo">9923</span><a id="line.9923">     * \(</a>
<span class="sourceLineNo">9924</span><a id="line.9924">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9925</span><a id="line.9925">     * x\\</a>
<span class="sourceLineNo">9926</span><a id="line.9926">     * y\\</a>
<span class="sourceLineNo">9927</span><a id="line.9927">     * z\\</a>
<span class="sourceLineNo">9928</span><a id="line.9928">     * \end{bmatrix}</a>
<span class="sourceLineNo">9929</span><a id="line.9929">     * =</a>
<span class="sourceLineNo">9930</span><a id="line.9930">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9931</span><a id="line.9931">     * X\\</a>
<span class="sourceLineNo">9932</span><a id="line.9932">     * Y\\</a>
<span class="sourceLineNo">9933</span><a id="line.9933">     * Z\\</a>
<span class="sourceLineNo">9934</span><a id="line.9934">     * \end{bmatrix}</a>
<span class="sourceLineNo">9935</span><a id="line.9935">     * +</a>
<span class="sourceLineNo">9936</span><a id="line.9936">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9937</span><a id="line.9937">     * b_1\\</a>
<span class="sourceLineNo">9938</span><a id="line.9938">     * b_2\\</a>
<span class="sourceLineNo">9939</span><a id="line.9939">     * b_3\\</a>
<span class="sourceLineNo">9940</span><a id="line.9940">     * \end{bmatrix}</a>
<span class="sourceLineNo">9941</span><a id="line.9941">     * \)</a>
<span class="sourceLineNo">9942</span><a id="line.9942">     *</a>
<span class="sourceLineNo">9943</span><a id="line.9943">     * @param src First input 3D point set containing \((X,Y,Z)\).</a>
<span class="sourceLineNo">9944</span><a id="line.9944">     * @param dst Second input 3D point set containing \((x,y,z)\).</a>
<span class="sourceLineNo">9945</span><a id="line.9945">     * @param out Output 3D translation vector \(3 \times 1\) of the form</a>
<span class="sourceLineNo">9946</span><a id="line.9946">     * \(</a>
<span class="sourceLineNo">9947</span><a id="line.9947">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9948</span><a id="line.9948">     * b_1 \\</a>
<span class="sourceLineNo">9949</span><a id="line.9949">     * b_2 \\</a>
<span class="sourceLineNo">9950</span><a id="line.9950">     * b_3 \\</a>
<span class="sourceLineNo">9951</span><a id="line.9951">     * \end{bmatrix}</a>
<span class="sourceLineNo">9952</span><a id="line.9952">     * \)</a>
<span class="sourceLineNo">9953</span><a id="line.9953">     * @param inliers Output vector indicating which points are inliers (1-inlier, 0-outlier).</a>
<span class="sourceLineNo">9954</span><a id="line.9954">     * @param ransacThreshold Maximum reprojection error in the RANSAC algorithm to consider a point as</a>
<span class="sourceLineNo">9955</span><a id="line.9955">     * an inlier.</a>
<span class="sourceLineNo">9956</span><a id="line.9956">     * @param confidence Confidence level, between 0 and 1, for the estimated transformation. Anything</a>
<span class="sourceLineNo">9957</span><a id="line.9957">     * between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation</a>
<span class="sourceLineNo">9958</span><a id="line.9958">     * significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</a>
<span class="sourceLineNo">9959</span><a id="line.9959">     *</a>
<span class="sourceLineNo">9960</span><a id="line.9960">     * The function estimates an optimal 3D translation between two 3D point sets using the</a>
<span class="sourceLineNo">9961</span><a id="line.9961">     * RANSAC algorithm.</a>
<span class="sourceLineNo">9962</span><a id="line.9962">     *</a>
<span class="sourceLineNo">9963</span><a id="line.9963">     * @return automatically generated</a>
<span class="sourceLineNo">9964</span><a id="line.9964">     */</a>
<span class="sourceLineNo">9965</span><a id="line.9965">    public static int estimateTranslation3D(Mat src, Mat dst, Mat out, Mat inliers, double ransacThreshold, double confidence) {</a>
<span class="sourceLineNo">9966</span><a id="line.9966">        return estimateTranslation3D_0(src.nativeObj, dst.nativeObj, out.nativeObj, inliers.nativeObj, ransacThreshold, confidence);</a>
<span class="sourceLineNo">9967</span><a id="line.9967">    }</a>
<span class="sourceLineNo">9968</span><a id="line.9968"></a>
<span class="sourceLineNo">9969</span><a id="line.9969">    /**</a>
<span class="sourceLineNo">9970</span><a id="line.9970">     * Computes an optimal translation between two 3D point sets.</a>
<span class="sourceLineNo">9971</span><a id="line.9971">     *</a>
<span class="sourceLineNo">9972</span><a id="line.9972">     * It computes</a>
<span class="sourceLineNo">9973</span><a id="line.9973">     * \(</a>
<span class="sourceLineNo">9974</span><a id="line.9974">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9975</span><a id="line.9975">     * x\\</a>
<span class="sourceLineNo">9976</span><a id="line.9976">     * y\\</a>
<span class="sourceLineNo">9977</span><a id="line.9977">     * z\\</a>
<span class="sourceLineNo">9978</span><a id="line.9978">     * \end{bmatrix}</a>
<span class="sourceLineNo">9979</span><a id="line.9979">     * =</a>
<span class="sourceLineNo">9980</span><a id="line.9980">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9981</span><a id="line.9981">     * X\\</a>
<span class="sourceLineNo">9982</span><a id="line.9982">     * Y\\</a>
<span class="sourceLineNo">9983</span><a id="line.9983">     * Z\\</a>
<span class="sourceLineNo">9984</span><a id="line.9984">     * \end{bmatrix}</a>
<span class="sourceLineNo">9985</span><a id="line.9985">     * +</a>
<span class="sourceLineNo">9986</span><a id="line.9986">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9987</span><a id="line.9987">     * b_1\\</a>
<span class="sourceLineNo">9988</span><a id="line.9988">     * b_2\\</a>
<span class="sourceLineNo">9989</span><a id="line.9989">     * b_3\\</a>
<span class="sourceLineNo">9990</span><a id="line.9990">     * \end{bmatrix}</a>
<span class="sourceLineNo">9991</span><a id="line.9991">     * \)</a>
<span class="sourceLineNo">9992</span><a id="line.9992">     *</a>
<span class="sourceLineNo">9993</span><a id="line.9993">     * @param src First input 3D point set containing \((X,Y,Z)\).</a>
<span class="sourceLineNo">9994</span><a id="line.9994">     * @param dst Second input 3D point set containing \((x,y,z)\).</a>
<span class="sourceLineNo">9995</span><a id="line.9995">     * @param out Output 3D translation vector \(3 \times 1\) of the form</a>
<span class="sourceLineNo">9996</span><a id="line.9996">     * \(</a>
<span class="sourceLineNo">9997</span><a id="line.9997">     * \begin{bmatrix}</a>
<span class="sourceLineNo">9998</span><a id="line.9998">     * b_1 \\</a>
<span class="sourceLineNo">9999</span><a id="line.9999">     * b_2 \\</a>
<span class="sourceLineNo">10000</span><a id="line.10000">     * b_3 \\</a>
<span class="sourceLineNo">10001</span><a id="line.10001">     * \end{bmatrix}</a>
<span class="sourceLineNo">10002</span><a id="line.10002">     * \)</a>
<span class="sourceLineNo">10003</span><a id="line.10003">     * @param inliers Output vector indicating which points are inliers (1-inlier, 0-outlier).</a>
<span class="sourceLineNo">10004</span><a id="line.10004">     * @param ransacThreshold Maximum reprojection error in the RANSAC algorithm to consider a point as</a>
<span class="sourceLineNo">10005</span><a id="line.10005">     * an inlier.</a>
<span class="sourceLineNo">10006</span><a id="line.10006">     * between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation</a>
<span class="sourceLineNo">10007</span><a id="line.10007">     * significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</a>
<span class="sourceLineNo">10008</span><a id="line.10008">     *</a>
<span class="sourceLineNo">10009</span><a id="line.10009">     * The function estimates an optimal 3D translation between two 3D point sets using the</a>
<span class="sourceLineNo">10010</span><a id="line.10010">     * RANSAC algorithm.</a>
<span class="sourceLineNo">10011</span><a id="line.10011">     *</a>
<span class="sourceLineNo">10012</span><a id="line.10012">     * @return automatically generated</a>
<span class="sourceLineNo">10013</span><a id="line.10013">     */</a>
<span class="sourceLineNo">10014</span><a id="line.10014">    public static int estimateTranslation3D(Mat src, Mat dst, Mat out, Mat inliers, double ransacThreshold) {</a>
<span class="sourceLineNo">10015</span><a id="line.10015">        return estimateTranslation3D_1(src.nativeObj, dst.nativeObj, out.nativeObj, inliers.nativeObj, ransacThreshold);</a>
<span class="sourceLineNo">10016</span><a id="line.10016">    }</a>
<span class="sourceLineNo">10017</span><a id="line.10017"></a>
<span class="sourceLineNo">10018</span><a id="line.10018">    /**</a>
<span class="sourceLineNo">10019</span><a id="line.10019">     * Computes an optimal translation between two 3D point sets.</a>
<span class="sourceLineNo">10020</span><a id="line.10020">     *</a>
<span class="sourceLineNo">10021</span><a id="line.10021">     * It computes</a>
<span class="sourceLineNo">10022</span><a id="line.10022">     * \(</a>
<span class="sourceLineNo">10023</span><a id="line.10023">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10024</span><a id="line.10024">     * x\\</a>
<span class="sourceLineNo">10025</span><a id="line.10025">     * y\\</a>
<span class="sourceLineNo">10026</span><a id="line.10026">     * z\\</a>
<span class="sourceLineNo">10027</span><a id="line.10027">     * \end{bmatrix}</a>
<span class="sourceLineNo">10028</span><a id="line.10028">     * =</a>
<span class="sourceLineNo">10029</span><a id="line.10029">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10030</span><a id="line.10030">     * X\\</a>
<span class="sourceLineNo">10031</span><a id="line.10031">     * Y\\</a>
<span class="sourceLineNo">10032</span><a id="line.10032">     * Z\\</a>
<span class="sourceLineNo">10033</span><a id="line.10033">     * \end{bmatrix}</a>
<span class="sourceLineNo">10034</span><a id="line.10034">     * +</a>
<span class="sourceLineNo">10035</span><a id="line.10035">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10036</span><a id="line.10036">     * b_1\\</a>
<span class="sourceLineNo">10037</span><a id="line.10037">     * b_2\\</a>
<span class="sourceLineNo">10038</span><a id="line.10038">     * b_3\\</a>
<span class="sourceLineNo">10039</span><a id="line.10039">     * \end{bmatrix}</a>
<span class="sourceLineNo">10040</span><a id="line.10040">     * \)</a>
<span class="sourceLineNo">10041</span><a id="line.10041">     *</a>
<span class="sourceLineNo">10042</span><a id="line.10042">     * @param src First input 3D point set containing \((X,Y,Z)\).</a>
<span class="sourceLineNo">10043</span><a id="line.10043">     * @param dst Second input 3D point set containing \((x,y,z)\).</a>
<span class="sourceLineNo">10044</span><a id="line.10044">     * @param out Output 3D translation vector \(3 \times 1\) of the form</a>
<span class="sourceLineNo">10045</span><a id="line.10045">     * \(</a>
<span class="sourceLineNo">10046</span><a id="line.10046">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10047</span><a id="line.10047">     * b_1 \\</a>
<span class="sourceLineNo">10048</span><a id="line.10048">     * b_2 \\</a>
<span class="sourceLineNo">10049</span><a id="line.10049">     * b_3 \\</a>
<span class="sourceLineNo">10050</span><a id="line.10050">     * \end{bmatrix}</a>
<span class="sourceLineNo">10051</span><a id="line.10051">     * \)</a>
<span class="sourceLineNo">10052</span><a id="line.10052">     * @param inliers Output vector indicating which points are inliers (1-inlier, 0-outlier).</a>
<span class="sourceLineNo">10053</span><a id="line.10053">     * an inlier.</a>
<span class="sourceLineNo">10054</span><a id="line.10054">     * between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation</a>
<span class="sourceLineNo">10055</span><a id="line.10055">     * significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</a>
<span class="sourceLineNo">10056</span><a id="line.10056">     *</a>
<span class="sourceLineNo">10057</span><a id="line.10057">     * The function estimates an optimal 3D translation between two 3D point sets using the</a>
<span class="sourceLineNo">10058</span><a id="line.10058">     * RANSAC algorithm.</a>
<span class="sourceLineNo">10059</span><a id="line.10059">     *</a>
<span class="sourceLineNo">10060</span><a id="line.10060">     * @return automatically generated</a>
<span class="sourceLineNo">10061</span><a id="line.10061">     */</a>
<span class="sourceLineNo">10062</span><a id="line.10062">    public static int estimateTranslation3D(Mat src, Mat dst, Mat out, Mat inliers) {</a>
<span class="sourceLineNo">10063</span><a id="line.10063">        return estimateTranslation3D_2(src.nativeObj, dst.nativeObj, out.nativeObj, inliers.nativeObj);</a>
<span class="sourceLineNo">10064</span><a id="line.10064">    }</a>
<span class="sourceLineNo">10065</span><a id="line.10065"></a>
<span class="sourceLineNo">10066</span><a id="line.10066"></a>
<span class="sourceLineNo">10067</span><a id="line.10067">    //</a>
<span class="sourceLineNo">10068</span><a id="line.10068">    // C++:  Mat cv::estimateAffine2D(Mat from, Mat to, Mat&amp; inliers = Mat(), int method = RANSAC, double ransacReprojThreshold = 3, size_t maxIters = 2000, double confidence = 0.99, size_t refineIters = 10)</a>
<span class="sourceLineNo">10069</span><a id="line.10069">    //</a>
<span class="sourceLineNo">10070</span><a id="line.10070"></a>
<span class="sourceLineNo">10071</span><a id="line.10071">    /**</a>
<span class="sourceLineNo">10072</span><a id="line.10072">     * Computes an optimal affine transformation between two 2D point sets.</a>
<span class="sourceLineNo">10073</span><a id="line.10073">     *</a>
<span class="sourceLineNo">10074</span><a id="line.10074">     * It computes</a>
<span class="sourceLineNo">10075</span><a id="line.10075">     * \(</a>
<span class="sourceLineNo">10076</span><a id="line.10076">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10077</span><a id="line.10077">     * x\\</a>
<span class="sourceLineNo">10078</span><a id="line.10078">     * y\\</a>
<span class="sourceLineNo">10079</span><a id="line.10079">     * \end{bmatrix}</a>
<span class="sourceLineNo">10080</span><a id="line.10080">     * =</a>
<span class="sourceLineNo">10081</span><a id="line.10081">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10082</span><a id="line.10082">     * a_{11} &amp;amp; a_{12}\\</a>
<span class="sourceLineNo">10083</span><a id="line.10083">     * a_{21} &amp;amp; a_{22}\\</a>
<span class="sourceLineNo">10084</span><a id="line.10084">     * \end{bmatrix}</a>
<span class="sourceLineNo">10085</span><a id="line.10085">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10086</span><a id="line.10086">     * X\\</a>
<span class="sourceLineNo">10087</span><a id="line.10087">     * Y\\</a>
<span class="sourceLineNo">10088</span><a id="line.10088">     * \end{bmatrix}</a>
<span class="sourceLineNo">10089</span><a id="line.10089">     * +</a>
<span class="sourceLineNo">10090</span><a id="line.10090">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10091</span><a id="line.10091">     * b_1\\</a>
<span class="sourceLineNo">10092</span><a id="line.10092">     * b_2\\</a>
<span class="sourceLineNo">10093</span><a id="line.10093">     * \end{bmatrix}</a>
<span class="sourceLineNo">10094</span><a id="line.10094">     * \)</a>
<span class="sourceLineNo">10095</span><a id="line.10095">     *</a>
<span class="sourceLineNo">10096</span><a id="line.10096">     * @param from First input 2D point set containing \((X,Y)\).</a>
<span class="sourceLineNo">10097</span><a id="line.10097">     * @param to Second input 2D point set containing \((x,y)\).</a>
<span class="sourceLineNo">10098</span><a id="line.10098">     * @param inliers Output vector indicating which points are inliers (1-inlier, 0-outlier).</a>
<span class="sourceLineNo">10099</span><a id="line.10099">     * @param method Robust method used to compute transformation. The following methods are possible:</a>
<span class="sourceLineNo">10100</span><a id="line.10100">     * &lt;ul&gt;</a>
<span class="sourceLineNo">10101</span><a id="line.10101">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10102</span><a id="line.10102">     *    REF: RANSAC - RANSAC-based robust method</a>
<span class="sourceLineNo">10103</span><a id="line.10103">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10104</span><a id="line.10104">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10105</span><a id="line.10105">     *    REF: LMEDS - Least-Median robust method</a>
<span class="sourceLineNo">10106</span><a id="line.10106">     * RANSAC is the default method.</a>
<span class="sourceLineNo">10107</span><a id="line.10107">     * @param ransacReprojThreshold Maximum reprojection error in the RANSAC algorithm to consider</a>
<span class="sourceLineNo">10108</span><a id="line.10108">     * a point as an inlier. Applies only to RANSAC.</a>
<span class="sourceLineNo">10109</span><a id="line.10109">     * @param maxIters The maximum number of robust method iterations.</a>
<span class="sourceLineNo">10110</span><a id="line.10110">     * @param confidence Confidence level, between 0 and 1, for the estimated transformation. Anything</a>
<span class="sourceLineNo">10111</span><a id="line.10111">     * between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation</a>
<span class="sourceLineNo">10112</span><a id="line.10112">     * significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</a>
<span class="sourceLineNo">10113</span><a id="line.10113">     * @param refineIters Maximum number of iterations of refining algorithm (Levenberg-Marquardt).</a>
<span class="sourceLineNo">10114</span><a id="line.10114">     * Passing 0 will disable refining, so the output matrix will be output of robust method.</a>
<span class="sourceLineNo">10115</span><a id="line.10115">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10116</span><a id="line.10116">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">10117</span><a id="line.10117">     *</a>
<span class="sourceLineNo">10118</span><a id="line.10118">     * @return Output 2D affine transformation matrix \(2 \times 3\) or empty matrix if transformation</a>
<span class="sourceLineNo">10119</span><a id="line.10119">     * could not be estimated. The returned matrix has the following form:</a>
<span class="sourceLineNo">10120</span><a id="line.10120">     * \(</a>
<span class="sourceLineNo">10121</span><a id="line.10121">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10122</span><a id="line.10122">     * a_{11} &amp;amp; a_{12} &amp;amp; b_1\\</a>
<span class="sourceLineNo">10123</span><a id="line.10123">     * a_{21} &amp;amp; a_{22} &amp;amp; b_2\\</a>
<span class="sourceLineNo">10124</span><a id="line.10124">     * \end{bmatrix}</a>
<span class="sourceLineNo">10125</span><a id="line.10125">     * \)</a>
<span class="sourceLineNo">10126</span><a id="line.10126">     *</a>
<span class="sourceLineNo">10127</span><a id="line.10127">     * The function estimates an optimal 2D affine transformation between two 2D point sets using the</a>
<span class="sourceLineNo">10128</span><a id="line.10128">     * selected robust algorithm.</a>
<span class="sourceLineNo">10129</span><a id="line.10129">     *</a>
<span class="sourceLineNo">10130</span><a id="line.10130">     * The computed transformation is then refined further (using only inliers) with the</a>
<span class="sourceLineNo">10131</span><a id="line.10131">     * Levenberg-Marquardt method to reduce the re-projection error even more.</a>
<span class="sourceLineNo">10132</span><a id="line.10132">     *</a>
<span class="sourceLineNo">10133</span><a id="line.10133">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">10134</span><a id="line.10134">     * The RANSAC method can handle practically any ratio of outliers but needs a threshold to</a>
<span class="sourceLineNo">10135</span><a id="line.10135">     * distinguish inliers from outliers. The method LMeDS does not need any threshold but it works</a>
<span class="sourceLineNo">10136</span><a id="line.10136">     * correctly only when there are more than 50% of inliers.</a>
<span class="sourceLineNo">10137</span><a id="line.10137">     *</a>
<span class="sourceLineNo">10138</span><a id="line.10138">     * SEE: estimateAffinePartial2D, getAffineTransform</a>
<span class="sourceLineNo">10139</span><a id="line.10139">     */</a>
<span class="sourceLineNo">10140</span><a id="line.10140">    public static Mat estimateAffine2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters, double confidence, long refineIters) {</a>
<span class="sourceLineNo">10141</span><a id="line.10141">        return new Mat(estimateAffine2D_0(from.nativeObj, to.nativeObj, inliers.nativeObj, method, ransacReprojThreshold, maxIters, confidence, refineIters));</a>
<span class="sourceLineNo">10142</span><a id="line.10142">    }</a>
<span class="sourceLineNo">10143</span><a id="line.10143"></a>
<span class="sourceLineNo">10144</span><a id="line.10144">    /**</a>
<span class="sourceLineNo">10145</span><a id="line.10145">     * Computes an optimal affine transformation between two 2D point sets.</a>
<span class="sourceLineNo">10146</span><a id="line.10146">     *</a>
<span class="sourceLineNo">10147</span><a id="line.10147">     * It computes</a>
<span class="sourceLineNo">10148</span><a id="line.10148">     * \(</a>
<span class="sourceLineNo">10149</span><a id="line.10149">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10150</span><a id="line.10150">     * x\\</a>
<span class="sourceLineNo">10151</span><a id="line.10151">     * y\\</a>
<span class="sourceLineNo">10152</span><a id="line.10152">     * \end{bmatrix}</a>
<span class="sourceLineNo">10153</span><a id="line.10153">     * =</a>
<span class="sourceLineNo">10154</span><a id="line.10154">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10155</span><a id="line.10155">     * a_{11} &amp;amp; a_{12}\\</a>
<span class="sourceLineNo">10156</span><a id="line.10156">     * a_{21} &amp;amp; a_{22}\\</a>
<span class="sourceLineNo">10157</span><a id="line.10157">     * \end{bmatrix}</a>
<span class="sourceLineNo">10158</span><a id="line.10158">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10159</span><a id="line.10159">     * X\\</a>
<span class="sourceLineNo">10160</span><a id="line.10160">     * Y\\</a>
<span class="sourceLineNo">10161</span><a id="line.10161">     * \end{bmatrix}</a>
<span class="sourceLineNo">10162</span><a id="line.10162">     * +</a>
<span class="sourceLineNo">10163</span><a id="line.10163">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10164</span><a id="line.10164">     * b_1\\</a>
<span class="sourceLineNo">10165</span><a id="line.10165">     * b_2\\</a>
<span class="sourceLineNo">10166</span><a id="line.10166">     * \end{bmatrix}</a>
<span class="sourceLineNo">10167</span><a id="line.10167">     * \)</a>
<span class="sourceLineNo">10168</span><a id="line.10168">     *</a>
<span class="sourceLineNo">10169</span><a id="line.10169">     * @param from First input 2D point set containing \((X,Y)\).</a>
<span class="sourceLineNo">10170</span><a id="line.10170">     * @param to Second input 2D point set containing \((x,y)\).</a>
<span class="sourceLineNo">10171</span><a id="line.10171">     * @param inliers Output vector indicating which points are inliers (1-inlier, 0-outlier).</a>
<span class="sourceLineNo">10172</span><a id="line.10172">     * @param method Robust method used to compute transformation. The following methods are possible:</a>
<span class="sourceLineNo">10173</span><a id="line.10173">     * &lt;ul&gt;</a>
<span class="sourceLineNo">10174</span><a id="line.10174">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10175</span><a id="line.10175">     *    REF: RANSAC - RANSAC-based robust method</a>
<span class="sourceLineNo">10176</span><a id="line.10176">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10177</span><a id="line.10177">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10178</span><a id="line.10178">     *    REF: LMEDS - Least-Median robust method</a>
<span class="sourceLineNo">10179</span><a id="line.10179">     * RANSAC is the default method.</a>
<span class="sourceLineNo">10180</span><a id="line.10180">     * @param ransacReprojThreshold Maximum reprojection error in the RANSAC algorithm to consider</a>
<span class="sourceLineNo">10181</span><a id="line.10181">     * a point as an inlier. Applies only to RANSAC.</a>
<span class="sourceLineNo">10182</span><a id="line.10182">     * @param maxIters The maximum number of robust method iterations.</a>
<span class="sourceLineNo">10183</span><a id="line.10183">     * @param confidence Confidence level, between 0 and 1, for the estimated transformation. Anything</a>
<span class="sourceLineNo">10184</span><a id="line.10184">     * between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation</a>
<span class="sourceLineNo">10185</span><a id="line.10185">     * significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</a>
<span class="sourceLineNo">10186</span><a id="line.10186">     * Passing 0 will disable refining, so the output matrix will be output of robust method.</a>
<span class="sourceLineNo">10187</span><a id="line.10187">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10188</span><a id="line.10188">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">10189</span><a id="line.10189">     *</a>
<span class="sourceLineNo">10190</span><a id="line.10190">     * @return Output 2D affine transformation matrix \(2 \times 3\) or empty matrix if transformation</a>
<span class="sourceLineNo">10191</span><a id="line.10191">     * could not be estimated. The returned matrix has the following form:</a>
<span class="sourceLineNo">10192</span><a id="line.10192">     * \(</a>
<span class="sourceLineNo">10193</span><a id="line.10193">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10194</span><a id="line.10194">     * a_{11} &amp;amp; a_{12} &amp;amp; b_1\\</a>
<span class="sourceLineNo">10195</span><a id="line.10195">     * a_{21} &amp;amp; a_{22} &amp;amp; b_2\\</a>
<span class="sourceLineNo">10196</span><a id="line.10196">     * \end{bmatrix}</a>
<span class="sourceLineNo">10197</span><a id="line.10197">     * \)</a>
<span class="sourceLineNo">10198</span><a id="line.10198">     *</a>
<span class="sourceLineNo">10199</span><a id="line.10199">     * The function estimates an optimal 2D affine transformation between two 2D point sets using the</a>
<span class="sourceLineNo">10200</span><a id="line.10200">     * selected robust algorithm.</a>
<span class="sourceLineNo">10201</span><a id="line.10201">     *</a>
<span class="sourceLineNo">10202</span><a id="line.10202">     * The computed transformation is then refined further (using only inliers) with the</a>
<span class="sourceLineNo">10203</span><a id="line.10203">     * Levenberg-Marquardt method to reduce the re-projection error even more.</a>
<span class="sourceLineNo">10204</span><a id="line.10204">     *</a>
<span class="sourceLineNo">10205</span><a id="line.10205">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">10206</span><a id="line.10206">     * The RANSAC method can handle practically any ratio of outliers but needs a threshold to</a>
<span class="sourceLineNo">10207</span><a id="line.10207">     * distinguish inliers from outliers. The method LMeDS does not need any threshold but it works</a>
<span class="sourceLineNo">10208</span><a id="line.10208">     * correctly only when there are more than 50% of inliers.</a>
<span class="sourceLineNo">10209</span><a id="line.10209">     *</a>
<span class="sourceLineNo">10210</span><a id="line.10210">     * SEE: estimateAffinePartial2D, getAffineTransform</a>
<span class="sourceLineNo">10211</span><a id="line.10211">     */</a>
<span class="sourceLineNo">10212</span><a id="line.10212">    public static Mat estimateAffine2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters, double confidence) {</a>
<span class="sourceLineNo">10213</span><a id="line.10213">        return new Mat(estimateAffine2D_1(from.nativeObj, to.nativeObj, inliers.nativeObj, method, ransacReprojThreshold, maxIters, confidence));</a>
<span class="sourceLineNo">10214</span><a id="line.10214">    }</a>
<span class="sourceLineNo">10215</span><a id="line.10215"></a>
<span class="sourceLineNo">10216</span><a id="line.10216">    /**</a>
<span class="sourceLineNo">10217</span><a id="line.10217">     * Computes an optimal affine transformation between two 2D point sets.</a>
<span class="sourceLineNo">10218</span><a id="line.10218">     *</a>
<span class="sourceLineNo">10219</span><a id="line.10219">     * It computes</a>
<span class="sourceLineNo">10220</span><a id="line.10220">     * \(</a>
<span class="sourceLineNo">10221</span><a id="line.10221">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10222</span><a id="line.10222">     * x\\</a>
<span class="sourceLineNo">10223</span><a id="line.10223">     * y\\</a>
<span class="sourceLineNo">10224</span><a id="line.10224">     * \end{bmatrix}</a>
<span class="sourceLineNo">10225</span><a id="line.10225">     * =</a>
<span class="sourceLineNo">10226</span><a id="line.10226">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10227</span><a id="line.10227">     * a_{11} &amp;amp; a_{12}\\</a>
<span class="sourceLineNo">10228</span><a id="line.10228">     * a_{21} &amp;amp; a_{22}\\</a>
<span class="sourceLineNo">10229</span><a id="line.10229">     * \end{bmatrix}</a>
<span class="sourceLineNo">10230</span><a id="line.10230">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10231</span><a id="line.10231">     * X\\</a>
<span class="sourceLineNo">10232</span><a id="line.10232">     * Y\\</a>
<span class="sourceLineNo">10233</span><a id="line.10233">     * \end{bmatrix}</a>
<span class="sourceLineNo">10234</span><a id="line.10234">     * +</a>
<span class="sourceLineNo">10235</span><a id="line.10235">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10236</span><a id="line.10236">     * b_1\\</a>
<span class="sourceLineNo">10237</span><a id="line.10237">     * b_2\\</a>
<span class="sourceLineNo">10238</span><a id="line.10238">     * \end{bmatrix}</a>
<span class="sourceLineNo">10239</span><a id="line.10239">     * \)</a>
<span class="sourceLineNo">10240</span><a id="line.10240">     *</a>
<span class="sourceLineNo">10241</span><a id="line.10241">     * @param from First input 2D point set containing \((X,Y)\).</a>
<span class="sourceLineNo">10242</span><a id="line.10242">     * @param to Second input 2D point set containing \((x,y)\).</a>
<span class="sourceLineNo">10243</span><a id="line.10243">     * @param inliers Output vector indicating which points are inliers (1-inlier, 0-outlier).</a>
<span class="sourceLineNo">10244</span><a id="line.10244">     * @param method Robust method used to compute transformation. The following methods are possible:</a>
<span class="sourceLineNo">10245</span><a id="line.10245">     * &lt;ul&gt;</a>
<span class="sourceLineNo">10246</span><a id="line.10246">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10247</span><a id="line.10247">     *    REF: RANSAC - RANSAC-based robust method</a>
<span class="sourceLineNo">10248</span><a id="line.10248">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10249</span><a id="line.10249">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10250</span><a id="line.10250">     *    REF: LMEDS - Least-Median robust method</a>
<span class="sourceLineNo">10251</span><a id="line.10251">     * RANSAC is the default method.</a>
<span class="sourceLineNo">10252</span><a id="line.10252">     * @param ransacReprojThreshold Maximum reprojection error in the RANSAC algorithm to consider</a>
<span class="sourceLineNo">10253</span><a id="line.10253">     * a point as an inlier. Applies only to RANSAC.</a>
<span class="sourceLineNo">10254</span><a id="line.10254">     * @param maxIters The maximum number of robust method iterations.</a>
<span class="sourceLineNo">10255</span><a id="line.10255">     * between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation</a>
<span class="sourceLineNo">10256</span><a id="line.10256">     * significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</a>
<span class="sourceLineNo">10257</span><a id="line.10257">     * Passing 0 will disable refining, so the output matrix will be output of robust method.</a>
<span class="sourceLineNo">10258</span><a id="line.10258">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10259</span><a id="line.10259">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">10260</span><a id="line.10260">     *</a>
<span class="sourceLineNo">10261</span><a id="line.10261">     * @return Output 2D affine transformation matrix \(2 \times 3\) or empty matrix if transformation</a>
<span class="sourceLineNo">10262</span><a id="line.10262">     * could not be estimated. The returned matrix has the following form:</a>
<span class="sourceLineNo">10263</span><a id="line.10263">     * \(</a>
<span class="sourceLineNo">10264</span><a id="line.10264">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10265</span><a id="line.10265">     * a_{11} &amp;amp; a_{12} &amp;amp; b_1\\</a>
<span class="sourceLineNo">10266</span><a id="line.10266">     * a_{21} &amp;amp; a_{22} &amp;amp; b_2\\</a>
<span class="sourceLineNo">10267</span><a id="line.10267">     * \end{bmatrix}</a>
<span class="sourceLineNo">10268</span><a id="line.10268">     * \)</a>
<span class="sourceLineNo">10269</span><a id="line.10269">     *</a>
<span class="sourceLineNo">10270</span><a id="line.10270">     * The function estimates an optimal 2D affine transformation between two 2D point sets using the</a>
<span class="sourceLineNo">10271</span><a id="line.10271">     * selected robust algorithm.</a>
<span class="sourceLineNo">10272</span><a id="line.10272">     *</a>
<span class="sourceLineNo">10273</span><a id="line.10273">     * The computed transformation is then refined further (using only inliers) with the</a>
<span class="sourceLineNo">10274</span><a id="line.10274">     * Levenberg-Marquardt method to reduce the re-projection error even more.</a>
<span class="sourceLineNo">10275</span><a id="line.10275">     *</a>
<span class="sourceLineNo">10276</span><a id="line.10276">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">10277</span><a id="line.10277">     * The RANSAC method can handle practically any ratio of outliers but needs a threshold to</a>
<span class="sourceLineNo">10278</span><a id="line.10278">     * distinguish inliers from outliers. The method LMeDS does not need any threshold but it works</a>
<span class="sourceLineNo">10279</span><a id="line.10279">     * correctly only when there are more than 50% of inliers.</a>
<span class="sourceLineNo">10280</span><a id="line.10280">     *</a>
<span class="sourceLineNo">10281</span><a id="line.10281">     * SEE: estimateAffinePartial2D, getAffineTransform</a>
<span class="sourceLineNo">10282</span><a id="line.10282">     */</a>
<span class="sourceLineNo">10283</span><a id="line.10283">    public static Mat estimateAffine2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters) {</a>
<span class="sourceLineNo">10284</span><a id="line.10284">        return new Mat(estimateAffine2D_2(from.nativeObj, to.nativeObj, inliers.nativeObj, method, ransacReprojThreshold, maxIters));</a>
<span class="sourceLineNo">10285</span><a id="line.10285">    }</a>
<span class="sourceLineNo">10286</span><a id="line.10286"></a>
<span class="sourceLineNo">10287</span><a id="line.10287">    /**</a>
<span class="sourceLineNo">10288</span><a id="line.10288">     * Computes an optimal affine transformation between two 2D point sets.</a>
<span class="sourceLineNo">10289</span><a id="line.10289">     *</a>
<span class="sourceLineNo">10290</span><a id="line.10290">     * It computes</a>
<span class="sourceLineNo">10291</span><a id="line.10291">     * \(</a>
<span class="sourceLineNo">10292</span><a id="line.10292">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10293</span><a id="line.10293">     * x\\</a>
<span class="sourceLineNo">10294</span><a id="line.10294">     * y\\</a>
<span class="sourceLineNo">10295</span><a id="line.10295">     * \end{bmatrix}</a>
<span class="sourceLineNo">10296</span><a id="line.10296">     * =</a>
<span class="sourceLineNo">10297</span><a id="line.10297">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10298</span><a id="line.10298">     * a_{11} &amp;amp; a_{12}\\</a>
<span class="sourceLineNo">10299</span><a id="line.10299">     * a_{21} &amp;amp; a_{22}\\</a>
<span class="sourceLineNo">10300</span><a id="line.10300">     * \end{bmatrix}</a>
<span class="sourceLineNo">10301</span><a id="line.10301">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10302</span><a id="line.10302">     * X\\</a>
<span class="sourceLineNo">10303</span><a id="line.10303">     * Y\\</a>
<span class="sourceLineNo">10304</span><a id="line.10304">     * \end{bmatrix}</a>
<span class="sourceLineNo">10305</span><a id="line.10305">     * +</a>
<span class="sourceLineNo">10306</span><a id="line.10306">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10307</span><a id="line.10307">     * b_1\\</a>
<span class="sourceLineNo">10308</span><a id="line.10308">     * b_2\\</a>
<span class="sourceLineNo">10309</span><a id="line.10309">     * \end{bmatrix}</a>
<span class="sourceLineNo">10310</span><a id="line.10310">     * \)</a>
<span class="sourceLineNo">10311</span><a id="line.10311">     *</a>
<span class="sourceLineNo">10312</span><a id="line.10312">     * @param from First input 2D point set containing \((X,Y)\).</a>
<span class="sourceLineNo">10313</span><a id="line.10313">     * @param to Second input 2D point set containing \((x,y)\).</a>
<span class="sourceLineNo">10314</span><a id="line.10314">     * @param inliers Output vector indicating which points are inliers (1-inlier, 0-outlier).</a>
<span class="sourceLineNo">10315</span><a id="line.10315">     * @param method Robust method used to compute transformation. The following methods are possible:</a>
<span class="sourceLineNo">10316</span><a id="line.10316">     * &lt;ul&gt;</a>
<span class="sourceLineNo">10317</span><a id="line.10317">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10318</span><a id="line.10318">     *    REF: RANSAC - RANSAC-based robust method</a>
<span class="sourceLineNo">10319</span><a id="line.10319">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10320</span><a id="line.10320">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10321</span><a id="line.10321">     *    REF: LMEDS - Least-Median robust method</a>
<span class="sourceLineNo">10322</span><a id="line.10322">     * RANSAC is the default method.</a>
<span class="sourceLineNo">10323</span><a id="line.10323">     * @param ransacReprojThreshold Maximum reprojection error in the RANSAC algorithm to consider</a>
<span class="sourceLineNo">10324</span><a id="line.10324">     * a point as an inlier. Applies only to RANSAC.</a>
<span class="sourceLineNo">10325</span><a id="line.10325">     * between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation</a>
<span class="sourceLineNo">10326</span><a id="line.10326">     * significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</a>
<span class="sourceLineNo">10327</span><a id="line.10327">     * Passing 0 will disable refining, so the output matrix will be output of robust method.</a>
<span class="sourceLineNo">10328</span><a id="line.10328">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10329</span><a id="line.10329">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">10330</span><a id="line.10330">     *</a>
<span class="sourceLineNo">10331</span><a id="line.10331">     * @return Output 2D affine transformation matrix \(2 \times 3\) or empty matrix if transformation</a>
<span class="sourceLineNo">10332</span><a id="line.10332">     * could not be estimated. The returned matrix has the following form:</a>
<span class="sourceLineNo">10333</span><a id="line.10333">     * \(</a>
<span class="sourceLineNo">10334</span><a id="line.10334">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10335</span><a id="line.10335">     * a_{11} &amp;amp; a_{12} &amp;amp; b_1\\</a>
<span class="sourceLineNo">10336</span><a id="line.10336">     * a_{21} &amp;amp; a_{22} &amp;amp; b_2\\</a>
<span class="sourceLineNo">10337</span><a id="line.10337">     * \end{bmatrix}</a>
<span class="sourceLineNo">10338</span><a id="line.10338">     * \)</a>
<span class="sourceLineNo">10339</span><a id="line.10339">     *</a>
<span class="sourceLineNo">10340</span><a id="line.10340">     * The function estimates an optimal 2D affine transformation between two 2D point sets using the</a>
<span class="sourceLineNo">10341</span><a id="line.10341">     * selected robust algorithm.</a>
<span class="sourceLineNo">10342</span><a id="line.10342">     *</a>
<span class="sourceLineNo">10343</span><a id="line.10343">     * The computed transformation is then refined further (using only inliers) with the</a>
<span class="sourceLineNo">10344</span><a id="line.10344">     * Levenberg-Marquardt method to reduce the re-projection error even more.</a>
<span class="sourceLineNo">10345</span><a id="line.10345">     *</a>
<span class="sourceLineNo">10346</span><a id="line.10346">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">10347</span><a id="line.10347">     * The RANSAC method can handle practically any ratio of outliers but needs a threshold to</a>
<span class="sourceLineNo">10348</span><a id="line.10348">     * distinguish inliers from outliers. The method LMeDS does not need any threshold but it works</a>
<span class="sourceLineNo">10349</span><a id="line.10349">     * correctly only when there are more than 50% of inliers.</a>
<span class="sourceLineNo">10350</span><a id="line.10350">     *</a>
<span class="sourceLineNo">10351</span><a id="line.10351">     * SEE: estimateAffinePartial2D, getAffineTransform</a>
<span class="sourceLineNo">10352</span><a id="line.10352">     */</a>
<span class="sourceLineNo">10353</span><a id="line.10353">    public static Mat estimateAffine2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold) {</a>
<span class="sourceLineNo">10354</span><a id="line.10354">        return new Mat(estimateAffine2D_3(from.nativeObj, to.nativeObj, inliers.nativeObj, method, ransacReprojThreshold));</a>
<span class="sourceLineNo">10355</span><a id="line.10355">    }</a>
<span class="sourceLineNo">10356</span><a id="line.10356"></a>
<span class="sourceLineNo">10357</span><a id="line.10357">    /**</a>
<span class="sourceLineNo">10358</span><a id="line.10358">     * Computes an optimal affine transformation between two 2D point sets.</a>
<span class="sourceLineNo">10359</span><a id="line.10359">     *</a>
<span class="sourceLineNo">10360</span><a id="line.10360">     * It computes</a>
<span class="sourceLineNo">10361</span><a id="line.10361">     * \(</a>
<span class="sourceLineNo">10362</span><a id="line.10362">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10363</span><a id="line.10363">     * x\\</a>
<span class="sourceLineNo">10364</span><a id="line.10364">     * y\\</a>
<span class="sourceLineNo">10365</span><a id="line.10365">     * \end{bmatrix}</a>
<span class="sourceLineNo">10366</span><a id="line.10366">     * =</a>
<span class="sourceLineNo">10367</span><a id="line.10367">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10368</span><a id="line.10368">     * a_{11} &amp;amp; a_{12}\\</a>
<span class="sourceLineNo">10369</span><a id="line.10369">     * a_{21} &amp;amp; a_{22}\\</a>
<span class="sourceLineNo">10370</span><a id="line.10370">     * \end{bmatrix}</a>
<span class="sourceLineNo">10371</span><a id="line.10371">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10372</span><a id="line.10372">     * X\\</a>
<span class="sourceLineNo">10373</span><a id="line.10373">     * Y\\</a>
<span class="sourceLineNo">10374</span><a id="line.10374">     * \end{bmatrix}</a>
<span class="sourceLineNo">10375</span><a id="line.10375">     * +</a>
<span class="sourceLineNo">10376</span><a id="line.10376">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10377</span><a id="line.10377">     * b_1\\</a>
<span class="sourceLineNo">10378</span><a id="line.10378">     * b_2\\</a>
<span class="sourceLineNo">10379</span><a id="line.10379">     * \end{bmatrix}</a>
<span class="sourceLineNo">10380</span><a id="line.10380">     * \)</a>
<span class="sourceLineNo">10381</span><a id="line.10381">     *</a>
<span class="sourceLineNo">10382</span><a id="line.10382">     * @param from First input 2D point set containing \((X,Y)\).</a>
<span class="sourceLineNo">10383</span><a id="line.10383">     * @param to Second input 2D point set containing \((x,y)\).</a>
<span class="sourceLineNo">10384</span><a id="line.10384">     * @param inliers Output vector indicating which points are inliers (1-inlier, 0-outlier).</a>
<span class="sourceLineNo">10385</span><a id="line.10385">     * @param method Robust method used to compute transformation. The following methods are possible:</a>
<span class="sourceLineNo">10386</span><a id="line.10386">     * &lt;ul&gt;</a>
<span class="sourceLineNo">10387</span><a id="line.10387">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10388</span><a id="line.10388">     *    REF: RANSAC - RANSAC-based robust method</a>
<span class="sourceLineNo">10389</span><a id="line.10389">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10390</span><a id="line.10390">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10391</span><a id="line.10391">     *    REF: LMEDS - Least-Median robust method</a>
<span class="sourceLineNo">10392</span><a id="line.10392">     * RANSAC is the default method.</a>
<span class="sourceLineNo">10393</span><a id="line.10393">     * a point as an inlier. Applies only to RANSAC.</a>
<span class="sourceLineNo">10394</span><a id="line.10394">     * between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation</a>
<span class="sourceLineNo">10395</span><a id="line.10395">     * significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</a>
<span class="sourceLineNo">10396</span><a id="line.10396">     * Passing 0 will disable refining, so the output matrix will be output of robust method.</a>
<span class="sourceLineNo">10397</span><a id="line.10397">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10398</span><a id="line.10398">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">10399</span><a id="line.10399">     *</a>
<span class="sourceLineNo">10400</span><a id="line.10400">     * @return Output 2D affine transformation matrix \(2 \times 3\) or empty matrix if transformation</a>
<span class="sourceLineNo">10401</span><a id="line.10401">     * could not be estimated. The returned matrix has the following form:</a>
<span class="sourceLineNo">10402</span><a id="line.10402">     * \(</a>
<span class="sourceLineNo">10403</span><a id="line.10403">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10404</span><a id="line.10404">     * a_{11} &amp;amp; a_{12} &amp;amp; b_1\\</a>
<span class="sourceLineNo">10405</span><a id="line.10405">     * a_{21} &amp;amp; a_{22} &amp;amp; b_2\\</a>
<span class="sourceLineNo">10406</span><a id="line.10406">     * \end{bmatrix}</a>
<span class="sourceLineNo">10407</span><a id="line.10407">     * \)</a>
<span class="sourceLineNo">10408</span><a id="line.10408">     *</a>
<span class="sourceLineNo">10409</span><a id="line.10409">     * The function estimates an optimal 2D affine transformation between two 2D point sets using the</a>
<span class="sourceLineNo">10410</span><a id="line.10410">     * selected robust algorithm.</a>
<span class="sourceLineNo">10411</span><a id="line.10411">     *</a>
<span class="sourceLineNo">10412</span><a id="line.10412">     * The computed transformation is then refined further (using only inliers) with the</a>
<span class="sourceLineNo">10413</span><a id="line.10413">     * Levenberg-Marquardt method to reduce the re-projection error even more.</a>
<span class="sourceLineNo">10414</span><a id="line.10414">     *</a>
<span class="sourceLineNo">10415</span><a id="line.10415">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">10416</span><a id="line.10416">     * The RANSAC method can handle practically any ratio of outliers but needs a threshold to</a>
<span class="sourceLineNo">10417</span><a id="line.10417">     * distinguish inliers from outliers. The method LMeDS does not need any threshold but it works</a>
<span class="sourceLineNo">10418</span><a id="line.10418">     * correctly only when there are more than 50% of inliers.</a>
<span class="sourceLineNo">10419</span><a id="line.10419">     *</a>
<span class="sourceLineNo">10420</span><a id="line.10420">     * SEE: estimateAffinePartial2D, getAffineTransform</a>
<span class="sourceLineNo">10421</span><a id="line.10421">     */</a>
<span class="sourceLineNo">10422</span><a id="line.10422">    public static Mat estimateAffine2D(Mat from, Mat to, Mat inliers, int method) {</a>
<span class="sourceLineNo">10423</span><a id="line.10423">        return new Mat(estimateAffine2D_4(from.nativeObj, to.nativeObj, inliers.nativeObj, method));</a>
<span class="sourceLineNo">10424</span><a id="line.10424">    }</a>
<span class="sourceLineNo">10425</span><a id="line.10425"></a>
<span class="sourceLineNo">10426</span><a id="line.10426">    /**</a>
<span class="sourceLineNo">10427</span><a id="line.10427">     * Computes an optimal affine transformation between two 2D point sets.</a>
<span class="sourceLineNo">10428</span><a id="line.10428">     *</a>
<span class="sourceLineNo">10429</span><a id="line.10429">     * It computes</a>
<span class="sourceLineNo">10430</span><a id="line.10430">     * \(</a>
<span class="sourceLineNo">10431</span><a id="line.10431">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10432</span><a id="line.10432">     * x\\</a>
<span class="sourceLineNo">10433</span><a id="line.10433">     * y\\</a>
<span class="sourceLineNo">10434</span><a id="line.10434">     * \end{bmatrix}</a>
<span class="sourceLineNo">10435</span><a id="line.10435">     * =</a>
<span class="sourceLineNo">10436</span><a id="line.10436">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10437</span><a id="line.10437">     * a_{11} &amp;amp; a_{12}\\</a>
<span class="sourceLineNo">10438</span><a id="line.10438">     * a_{21} &amp;amp; a_{22}\\</a>
<span class="sourceLineNo">10439</span><a id="line.10439">     * \end{bmatrix}</a>
<span class="sourceLineNo">10440</span><a id="line.10440">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10441</span><a id="line.10441">     * X\\</a>
<span class="sourceLineNo">10442</span><a id="line.10442">     * Y\\</a>
<span class="sourceLineNo">10443</span><a id="line.10443">     * \end{bmatrix}</a>
<span class="sourceLineNo">10444</span><a id="line.10444">     * +</a>
<span class="sourceLineNo">10445</span><a id="line.10445">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10446</span><a id="line.10446">     * b_1\\</a>
<span class="sourceLineNo">10447</span><a id="line.10447">     * b_2\\</a>
<span class="sourceLineNo">10448</span><a id="line.10448">     * \end{bmatrix}</a>
<span class="sourceLineNo">10449</span><a id="line.10449">     * \)</a>
<span class="sourceLineNo">10450</span><a id="line.10450">     *</a>
<span class="sourceLineNo">10451</span><a id="line.10451">     * @param from First input 2D point set containing \((X,Y)\).</a>
<span class="sourceLineNo">10452</span><a id="line.10452">     * @param to Second input 2D point set containing \((x,y)\).</a>
<span class="sourceLineNo">10453</span><a id="line.10453">     * @param inliers Output vector indicating which points are inliers (1-inlier, 0-outlier).</a>
<span class="sourceLineNo">10454</span><a id="line.10454">     * &lt;ul&gt;</a>
<span class="sourceLineNo">10455</span><a id="line.10455">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10456</span><a id="line.10456">     *    REF: RANSAC - RANSAC-based robust method</a>
<span class="sourceLineNo">10457</span><a id="line.10457">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10458</span><a id="line.10458">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10459</span><a id="line.10459">     *    REF: LMEDS - Least-Median robust method</a>
<span class="sourceLineNo">10460</span><a id="line.10460">     * RANSAC is the default method.</a>
<span class="sourceLineNo">10461</span><a id="line.10461">     * a point as an inlier. Applies only to RANSAC.</a>
<span class="sourceLineNo">10462</span><a id="line.10462">     * between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation</a>
<span class="sourceLineNo">10463</span><a id="line.10463">     * significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</a>
<span class="sourceLineNo">10464</span><a id="line.10464">     * Passing 0 will disable refining, so the output matrix will be output of robust method.</a>
<span class="sourceLineNo">10465</span><a id="line.10465">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10466</span><a id="line.10466">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">10467</span><a id="line.10467">     *</a>
<span class="sourceLineNo">10468</span><a id="line.10468">     * @return Output 2D affine transformation matrix \(2 \times 3\) or empty matrix if transformation</a>
<span class="sourceLineNo">10469</span><a id="line.10469">     * could not be estimated. The returned matrix has the following form:</a>
<span class="sourceLineNo">10470</span><a id="line.10470">     * \(</a>
<span class="sourceLineNo">10471</span><a id="line.10471">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10472</span><a id="line.10472">     * a_{11} &amp;amp; a_{12} &amp;amp; b_1\\</a>
<span class="sourceLineNo">10473</span><a id="line.10473">     * a_{21} &amp;amp; a_{22} &amp;amp; b_2\\</a>
<span class="sourceLineNo">10474</span><a id="line.10474">     * \end{bmatrix}</a>
<span class="sourceLineNo">10475</span><a id="line.10475">     * \)</a>
<span class="sourceLineNo">10476</span><a id="line.10476">     *</a>
<span class="sourceLineNo">10477</span><a id="line.10477">     * The function estimates an optimal 2D affine transformation between two 2D point sets using the</a>
<span class="sourceLineNo">10478</span><a id="line.10478">     * selected robust algorithm.</a>
<span class="sourceLineNo">10479</span><a id="line.10479">     *</a>
<span class="sourceLineNo">10480</span><a id="line.10480">     * The computed transformation is then refined further (using only inliers) with the</a>
<span class="sourceLineNo">10481</span><a id="line.10481">     * Levenberg-Marquardt method to reduce the re-projection error even more.</a>
<span class="sourceLineNo">10482</span><a id="line.10482">     *</a>
<span class="sourceLineNo">10483</span><a id="line.10483">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">10484</span><a id="line.10484">     * The RANSAC method can handle practically any ratio of outliers but needs a threshold to</a>
<span class="sourceLineNo">10485</span><a id="line.10485">     * distinguish inliers from outliers. The method LMeDS does not need any threshold but it works</a>
<span class="sourceLineNo">10486</span><a id="line.10486">     * correctly only when there are more than 50% of inliers.</a>
<span class="sourceLineNo">10487</span><a id="line.10487">     *</a>
<span class="sourceLineNo">10488</span><a id="line.10488">     * SEE: estimateAffinePartial2D, getAffineTransform</a>
<span class="sourceLineNo">10489</span><a id="line.10489">     */</a>
<span class="sourceLineNo">10490</span><a id="line.10490">    public static Mat estimateAffine2D(Mat from, Mat to, Mat inliers) {</a>
<span class="sourceLineNo">10491</span><a id="line.10491">        return new Mat(estimateAffine2D_5(from.nativeObj, to.nativeObj, inliers.nativeObj));</a>
<span class="sourceLineNo">10492</span><a id="line.10492">    }</a>
<span class="sourceLineNo">10493</span><a id="line.10493"></a>
<span class="sourceLineNo">10494</span><a id="line.10494">    /**</a>
<span class="sourceLineNo">10495</span><a id="line.10495">     * Computes an optimal affine transformation between two 2D point sets.</a>
<span class="sourceLineNo">10496</span><a id="line.10496">     *</a>
<span class="sourceLineNo">10497</span><a id="line.10497">     * It computes</a>
<span class="sourceLineNo">10498</span><a id="line.10498">     * \(</a>
<span class="sourceLineNo">10499</span><a id="line.10499">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10500</span><a id="line.10500">     * x\\</a>
<span class="sourceLineNo">10501</span><a id="line.10501">     * y\\</a>
<span class="sourceLineNo">10502</span><a id="line.10502">     * \end{bmatrix}</a>
<span class="sourceLineNo">10503</span><a id="line.10503">     * =</a>
<span class="sourceLineNo">10504</span><a id="line.10504">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10505</span><a id="line.10505">     * a_{11} &amp;amp; a_{12}\\</a>
<span class="sourceLineNo">10506</span><a id="line.10506">     * a_{21} &amp;amp; a_{22}\\</a>
<span class="sourceLineNo">10507</span><a id="line.10507">     * \end{bmatrix}</a>
<span class="sourceLineNo">10508</span><a id="line.10508">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10509</span><a id="line.10509">     * X\\</a>
<span class="sourceLineNo">10510</span><a id="line.10510">     * Y\\</a>
<span class="sourceLineNo">10511</span><a id="line.10511">     * \end{bmatrix}</a>
<span class="sourceLineNo">10512</span><a id="line.10512">     * +</a>
<span class="sourceLineNo">10513</span><a id="line.10513">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10514</span><a id="line.10514">     * b_1\\</a>
<span class="sourceLineNo">10515</span><a id="line.10515">     * b_2\\</a>
<span class="sourceLineNo">10516</span><a id="line.10516">     * \end{bmatrix}</a>
<span class="sourceLineNo">10517</span><a id="line.10517">     * \)</a>
<span class="sourceLineNo">10518</span><a id="line.10518">     *</a>
<span class="sourceLineNo">10519</span><a id="line.10519">     * @param from First input 2D point set containing \((X,Y)\).</a>
<span class="sourceLineNo">10520</span><a id="line.10520">     * @param to Second input 2D point set containing \((x,y)\).</a>
<span class="sourceLineNo">10521</span><a id="line.10521">     * &lt;ul&gt;</a>
<span class="sourceLineNo">10522</span><a id="line.10522">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10523</span><a id="line.10523">     *    REF: RANSAC - RANSAC-based robust method</a>
<span class="sourceLineNo">10524</span><a id="line.10524">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10525</span><a id="line.10525">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10526</span><a id="line.10526">     *    REF: LMEDS - Least-Median robust method</a>
<span class="sourceLineNo">10527</span><a id="line.10527">     * RANSAC is the default method.</a>
<span class="sourceLineNo">10528</span><a id="line.10528">     * a point as an inlier. Applies only to RANSAC.</a>
<span class="sourceLineNo">10529</span><a id="line.10529">     * between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation</a>
<span class="sourceLineNo">10530</span><a id="line.10530">     * significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</a>
<span class="sourceLineNo">10531</span><a id="line.10531">     * Passing 0 will disable refining, so the output matrix will be output of robust method.</a>
<span class="sourceLineNo">10532</span><a id="line.10532">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10533</span><a id="line.10533">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">10534</span><a id="line.10534">     *</a>
<span class="sourceLineNo">10535</span><a id="line.10535">     * @return Output 2D affine transformation matrix \(2 \times 3\) or empty matrix if transformation</a>
<span class="sourceLineNo">10536</span><a id="line.10536">     * could not be estimated. The returned matrix has the following form:</a>
<span class="sourceLineNo">10537</span><a id="line.10537">     * \(</a>
<span class="sourceLineNo">10538</span><a id="line.10538">     * \begin{bmatrix}</a>
<span class="sourceLineNo">10539</span><a id="line.10539">     * a_{11} &amp;amp; a_{12} &amp;amp; b_1\\</a>
<span class="sourceLineNo">10540</span><a id="line.10540">     * a_{21} &amp;amp; a_{22} &amp;amp; b_2\\</a>
<span class="sourceLineNo">10541</span><a id="line.10541">     * \end{bmatrix}</a>
<span class="sourceLineNo">10542</span><a id="line.10542">     * \)</a>
<span class="sourceLineNo">10543</span><a id="line.10543">     *</a>
<span class="sourceLineNo">10544</span><a id="line.10544">     * The function estimates an optimal 2D affine transformation between two 2D point sets using the</a>
<span class="sourceLineNo">10545</span><a id="line.10545">     * selected robust algorithm.</a>
<span class="sourceLineNo">10546</span><a id="line.10546">     *</a>
<span class="sourceLineNo">10547</span><a id="line.10547">     * The computed transformation is then refined further (using only inliers) with the</a>
<span class="sourceLineNo">10548</span><a id="line.10548">     * Levenberg-Marquardt method to reduce the re-projection error even more.</a>
<span class="sourceLineNo">10549</span><a id="line.10549">     *</a>
<span class="sourceLineNo">10550</span><a id="line.10550">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">10551</span><a id="line.10551">     * The RANSAC method can handle practically any ratio of outliers but needs a threshold to</a>
<span class="sourceLineNo">10552</span><a id="line.10552">     * distinguish inliers from outliers. The method LMeDS does not need any threshold but it works</a>
<span class="sourceLineNo">10553</span><a id="line.10553">     * correctly only when there are more than 50% of inliers.</a>
<span class="sourceLineNo">10554</span><a id="line.10554">     *</a>
<span class="sourceLineNo">10555</span><a id="line.10555">     * SEE: estimateAffinePartial2D, getAffineTransform</a>
<span class="sourceLineNo">10556</span><a id="line.10556">     */</a>
<span class="sourceLineNo">10557</span><a id="line.10557">    public static Mat estimateAffine2D(Mat from, Mat to) {</a>
<span class="sourceLineNo">10558</span><a id="line.10558">        return new Mat(estimateAffine2D_6(from.nativeObj, to.nativeObj));</a>
<span class="sourceLineNo">10559</span><a id="line.10559">    }</a>
<span class="sourceLineNo">10560</span><a id="line.10560"></a>
<span class="sourceLineNo">10561</span><a id="line.10561"></a>
<span class="sourceLineNo">10562</span><a id="line.10562">    //</a>
<span class="sourceLineNo">10563</span><a id="line.10563">    // C++:  Mat cv::estimateAffine2D(Mat pts1, Mat pts2, Mat&amp; inliers, UsacParams params)</a>
<span class="sourceLineNo">10564</span><a id="line.10564">    //</a>
<span class="sourceLineNo">10565</span><a id="line.10565"></a>
<span class="sourceLineNo">10566</span><a id="line.10566">    public static Mat estimateAffine2D(Mat pts1, Mat pts2, Mat inliers, UsacParams params) {</a>
<span class="sourceLineNo">10567</span><a id="line.10567">        return new Mat(estimateAffine2D_7(pts1.nativeObj, pts2.nativeObj, inliers.nativeObj, params.nativeObj));</a>
<span class="sourceLineNo">10568</span><a id="line.10568">    }</a>
<span class="sourceLineNo">10569</span><a id="line.10569"></a>
<span class="sourceLineNo">10570</span><a id="line.10570"></a>
<span class="sourceLineNo">10571</span><a id="line.10571">    //</a>
<span class="sourceLineNo">10572</span><a id="line.10572">    // C++:  Mat cv::estimateAffinePartial2D(Mat from, Mat to, Mat&amp; inliers = Mat(), int method = RANSAC, double ransacReprojThreshold = 3, size_t maxIters = 2000, double confidence = 0.99, size_t refineIters = 10)</a>
<span class="sourceLineNo">10573</span><a id="line.10573">    //</a>
<span class="sourceLineNo">10574</span><a id="line.10574"></a>
<span class="sourceLineNo">10575</span><a id="line.10575">    /**</a>
<span class="sourceLineNo">10576</span><a id="line.10576">     * Computes an optimal limited affine transformation with 4 degrees of freedom between</a>
<span class="sourceLineNo">10577</span><a id="line.10577">     * two 2D point sets.</a>
<span class="sourceLineNo">10578</span><a id="line.10578">     *</a>
<span class="sourceLineNo">10579</span><a id="line.10579">     * @param from First input 2D point set.</a>
<span class="sourceLineNo">10580</span><a id="line.10580">     * @param to Second input 2D point set.</a>
<span class="sourceLineNo">10581</span><a id="line.10581">     * @param inliers Output vector indicating which points are inliers.</a>
<span class="sourceLineNo">10582</span><a id="line.10582">     * @param method Robust method used to compute transformation. The following methods are possible:</a>
<span class="sourceLineNo">10583</span><a id="line.10583">     * &lt;ul&gt;</a>
<span class="sourceLineNo">10584</span><a id="line.10584">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10585</span><a id="line.10585">     *    REF: RANSAC - RANSAC-based robust method</a>
<span class="sourceLineNo">10586</span><a id="line.10586">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10587</span><a id="line.10587">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10588</span><a id="line.10588">     *    REF: LMEDS - Least-Median robust method</a>
<span class="sourceLineNo">10589</span><a id="line.10589">     * RANSAC is the default method.</a>
<span class="sourceLineNo">10590</span><a id="line.10590">     * @param ransacReprojThreshold Maximum reprojection error in the RANSAC algorithm to consider</a>
<span class="sourceLineNo">10591</span><a id="line.10591">     * a point as an inlier. Applies only to RANSAC.</a>
<span class="sourceLineNo">10592</span><a id="line.10592">     * @param maxIters The maximum number of robust method iterations.</a>
<span class="sourceLineNo">10593</span><a id="line.10593">     * @param confidence Confidence level, between 0 and 1, for the estimated transformation. Anything</a>
<span class="sourceLineNo">10594</span><a id="line.10594">     * between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation</a>
<span class="sourceLineNo">10595</span><a id="line.10595">     * significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</a>
<span class="sourceLineNo">10596</span><a id="line.10596">     * @param refineIters Maximum number of iterations of refining algorithm (Levenberg-Marquardt).</a>
<span class="sourceLineNo">10597</span><a id="line.10597">     * Passing 0 will disable refining, so the output matrix will be output of robust method.</a>
<span class="sourceLineNo">10598</span><a id="line.10598">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10599</span><a id="line.10599">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">10600</span><a id="line.10600">     *</a>
<span class="sourceLineNo">10601</span><a id="line.10601">     * @return Output 2D affine transformation (4 degrees of freedom) matrix \(2 \times 3\) or</a>
<span class="sourceLineNo">10602</span><a id="line.10602">     * empty matrix if transformation could not be estimated.</a>
<span class="sourceLineNo">10603</span><a id="line.10603">     *</a>
<span class="sourceLineNo">10604</span><a id="line.10604">     * The function estimates an optimal 2D affine transformation with 4 degrees of freedom limited to</a>
<span class="sourceLineNo">10605</span><a id="line.10605">     * combinations of translation, rotation, and uniform scaling. Uses the selected algorithm for robust</a>
<span class="sourceLineNo">10606</span><a id="line.10606">     * estimation.</a>
<span class="sourceLineNo">10607</span><a id="line.10607">     *</a>
<span class="sourceLineNo">10608</span><a id="line.10608">     * The computed transformation is then refined further (using only inliers) with the</a>
<span class="sourceLineNo">10609</span><a id="line.10609">     * Levenberg-Marquardt method to reduce the re-projection error even more.</a>
<span class="sourceLineNo">10610</span><a id="line.10610">     *</a>
<span class="sourceLineNo">10611</span><a id="line.10611">     * Estimated transformation matrix is:</a>
<span class="sourceLineNo">10612</span><a id="line.10612">     * \( \begin{bmatrix} \cos(\theta) \cdot s &amp;amp; -\sin(\theta) \cdot s &amp;amp; t_x \\</a>
<span class="sourceLineNo">10613</span><a id="line.10613">     *                 \sin(\theta) \cdot s &amp;amp; \cos(\theta) \cdot s &amp;amp; t_y</a>
<span class="sourceLineNo">10614</span><a id="line.10614">     * \end{bmatrix} \)</a>
<span class="sourceLineNo">10615</span><a id="line.10615">     * Where \( \theta \) is the rotation angle, \( s \) the scaling factor and \( t_x, t_y \) are</a>
<span class="sourceLineNo">10616</span><a id="line.10616">     * translations in \( x, y \) axes respectively.</a>
<span class="sourceLineNo">10617</span><a id="line.10617">     *</a>
<span class="sourceLineNo">10618</span><a id="line.10618">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">10619</span><a id="line.10619">     * The RANSAC method can handle practically any ratio of outliers but need a threshold to</a>
<span class="sourceLineNo">10620</span><a id="line.10620">     * distinguish inliers from outliers. The method LMeDS does not need any threshold but it works</a>
<span class="sourceLineNo">10621</span><a id="line.10621">     * correctly only when there are more than 50% of inliers.</a>
<span class="sourceLineNo">10622</span><a id="line.10622">     *</a>
<span class="sourceLineNo">10623</span><a id="line.10623">     * SEE: estimateAffine2D, getAffineTransform</a>
<span class="sourceLineNo">10624</span><a id="line.10624">     */</a>
<span class="sourceLineNo">10625</span><a id="line.10625">    public static Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters, double confidence, long refineIters) {</a>
<span class="sourceLineNo">10626</span><a id="line.10626">        return new Mat(estimateAffinePartial2D_0(from.nativeObj, to.nativeObj, inliers.nativeObj, method, ransacReprojThreshold, maxIters, confidence, refineIters));</a>
<span class="sourceLineNo">10627</span><a id="line.10627">    }</a>
<span class="sourceLineNo">10628</span><a id="line.10628"></a>
<span class="sourceLineNo">10629</span><a id="line.10629">    /**</a>
<span class="sourceLineNo">10630</span><a id="line.10630">     * Computes an optimal limited affine transformation with 4 degrees of freedom between</a>
<span class="sourceLineNo">10631</span><a id="line.10631">     * two 2D point sets.</a>
<span class="sourceLineNo">10632</span><a id="line.10632">     *</a>
<span class="sourceLineNo">10633</span><a id="line.10633">     * @param from First input 2D point set.</a>
<span class="sourceLineNo">10634</span><a id="line.10634">     * @param to Second input 2D point set.</a>
<span class="sourceLineNo">10635</span><a id="line.10635">     * @param inliers Output vector indicating which points are inliers.</a>
<span class="sourceLineNo">10636</span><a id="line.10636">     * @param method Robust method used to compute transformation. The following methods are possible:</a>
<span class="sourceLineNo">10637</span><a id="line.10637">     * &lt;ul&gt;</a>
<span class="sourceLineNo">10638</span><a id="line.10638">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10639</span><a id="line.10639">     *    REF: RANSAC - RANSAC-based robust method</a>
<span class="sourceLineNo">10640</span><a id="line.10640">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10641</span><a id="line.10641">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10642</span><a id="line.10642">     *    REF: LMEDS - Least-Median robust method</a>
<span class="sourceLineNo">10643</span><a id="line.10643">     * RANSAC is the default method.</a>
<span class="sourceLineNo">10644</span><a id="line.10644">     * @param ransacReprojThreshold Maximum reprojection error in the RANSAC algorithm to consider</a>
<span class="sourceLineNo">10645</span><a id="line.10645">     * a point as an inlier. Applies only to RANSAC.</a>
<span class="sourceLineNo">10646</span><a id="line.10646">     * @param maxIters The maximum number of robust method iterations.</a>
<span class="sourceLineNo">10647</span><a id="line.10647">     * @param confidence Confidence level, between 0 and 1, for the estimated transformation. Anything</a>
<span class="sourceLineNo">10648</span><a id="line.10648">     * between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation</a>
<span class="sourceLineNo">10649</span><a id="line.10649">     * significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</a>
<span class="sourceLineNo">10650</span><a id="line.10650">     * Passing 0 will disable refining, so the output matrix will be output of robust method.</a>
<span class="sourceLineNo">10651</span><a id="line.10651">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10652</span><a id="line.10652">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">10653</span><a id="line.10653">     *</a>
<span class="sourceLineNo">10654</span><a id="line.10654">     * @return Output 2D affine transformation (4 degrees of freedom) matrix \(2 \times 3\) or</a>
<span class="sourceLineNo">10655</span><a id="line.10655">     * empty matrix if transformation could not be estimated.</a>
<span class="sourceLineNo">10656</span><a id="line.10656">     *</a>
<span class="sourceLineNo">10657</span><a id="line.10657">     * The function estimates an optimal 2D affine transformation with 4 degrees of freedom limited to</a>
<span class="sourceLineNo">10658</span><a id="line.10658">     * combinations of translation, rotation, and uniform scaling. Uses the selected algorithm for robust</a>
<span class="sourceLineNo">10659</span><a id="line.10659">     * estimation.</a>
<span class="sourceLineNo">10660</span><a id="line.10660">     *</a>
<span class="sourceLineNo">10661</span><a id="line.10661">     * The computed transformation is then refined further (using only inliers) with the</a>
<span class="sourceLineNo">10662</span><a id="line.10662">     * Levenberg-Marquardt method to reduce the re-projection error even more.</a>
<span class="sourceLineNo">10663</span><a id="line.10663">     *</a>
<span class="sourceLineNo">10664</span><a id="line.10664">     * Estimated transformation matrix is:</a>
<span class="sourceLineNo">10665</span><a id="line.10665">     * \( \begin{bmatrix} \cos(\theta) \cdot s &amp;amp; -\sin(\theta) \cdot s &amp;amp; t_x \\</a>
<span class="sourceLineNo">10666</span><a id="line.10666">     *                 \sin(\theta) \cdot s &amp;amp; \cos(\theta) \cdot s &amp;amp; t_y</a>
<span class="sourceLineNo">10667</span><a id="line.10667">     * \end{bmatrix} \)</a>
<span class="sourceLineNo">10668</span><a id="line.10668">     * Where \( \theta \) is the rotation angle, \( s \) the scaling factor and \( t_x, t_y \) are</a>
<span class="sourceLineNo">10669</span><a id="line.10669">     * translations in \( x, y \) axes respectively.</a>
<span class="sourceLineNo">10670</span><a id="line.10670">     *</a>
<span class="sourceLineNo">10671</span><a id="line.10671">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">10672</span><a id="line.10672">     * The RANSAC method can handle practically any ratio of outliers but need a threshold to</a>
<span class="sourceLineNo">10673</span><a id="line.10673">     * distinguish inliers from outliers. The method LMeDS does not need any threshold but it works</a>
<span class="sourceLineNo">10674</span><a id="line.10674">     * correctly only when there are more than 50% of inliers.</a>
<span class="sourceLineNo">10675</span><a id="line.10675">     *</a>
<span class="sourceLineNo">10676</span><a id="line.10676">     * SEE: estimateAffine2D, getAffineTransform</a>
<span class="sourceLineNo">10677</span><a id="line.10677">     */</a>
<span class="sourceLineNo">10678</span><a id="line.10678">    public static Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters, double confidence) {</a>
<span class="sourceLineNo">10679</span><a id="line.10679">        return new Mat(estimateAffinePartial2D_1(from.nativeObj, to.nativeObj, inliers.nativeObj, method, ransacReprojThreshold, maxIters, confidence));</a>
<span class="sourceLineNo">10680</span><a id="line.10680">    }</a>
<span class="sourceLineNo">10681</span><a id="line.10681"></a>
<span class="sourceLineNo">10682</span><a id="line.10682">    /**</a>
<span class="sourceLineNo">10683</span><a id="line.10683">     * Computes an optimal limited affine transformation with 4 degrees of freedom between</a>
<span class="sourceLineNo">10684</span><a id="line.10684">     * two 2D point sets.</a>
<span class="sourceLineNo">10685</span><a id="line.10685">     *</a>
<span class="sourceLineNo">10686</span><a id="line.10686">     * @param from First input 2D point set.</a>
<span class="sourceLineNo">10687</span><a id="line.10687">     * @param to Second input 2D point set.</a>
<span class="sourceLineNo">10688</span><a id="line.10688">     * @param inliers Output vector indicating which points are inliers.</a>
<span class="sourceLineNo">10689</span><a id="line.10689">     * @param method Robust method used to compute transformation. The following methods are possible:</a>
<span class="sourceLineNo">10690</span><a id="line.10690">     * &lt;ul&gt;</a>
<span class="sourceLineNo">10691</span><a id="line.10691">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10692</span><a id="line.10692">     *    REF: RANSAC - RANSAC-based robust method</a>
<span class="sourceLineNo">10693</span><a id="line.10693">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10694</span><a id="line.10694">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10695</span><a id="line.10695">     *    REF: LMEDS - Least-Median robust method</a>
<span class="sourceLineNo">10696</span><a id="line.10696">     * RANSAC is the default method.</a>
<span class="sourceLineNo">10697</span><a id="line.10697">     * @param ransacReprojThreshold Maximum reprojection error in the RANSAC algorithm to consider</a>
<span class="sourceLineNo">10698</span><a id="line.10698">     * a point as an inlier. Applies only to RANSAC.</a>
<span class="sourceLineNo">10699</span><a id="line.10699">     * @param maxIters The maximum number of robust method iterations.</a>
<span class="sourceLineNo">10700</span><a id="line.10700">     * between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation</a>
<span class="sourceLineNo">10701</span><a id="line.10701">     * significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</a>
<span class="sourceLineNo">10702</span><a id="line.10702">     * Passing 0 will disable refining, so the output matrix will be output of robust method.</a>
<span class="sourceLineNo">10703</span><a id="line.10703">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10704</span><a id="line.10704">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">10705</span><a id="line.10705">     *</a>
<span class="sourceLineNo">10706</span><a id="line.10706">     * @return Output 2D affine transformation (4 degrees of freedom) matrix \(2 \times 3\) or</a>
<span class="sourceLineNo">10707</span><a id="line.10707">     * empty matrix if transformation could not be estimated.</a>
<span class="sourceLineNo">10708</span><a id="line.10708">     *</a>
<span class="sourceLineNo">10709</span><a id="line.10709">     * The function estimates an optimal 2D affine transformation with 4 degrees of freedom limited to</a>
<span class="sourceLineNo">10710</span><a id="line.10710">     * combinations of translation, rotation, and uniform scaling. Uses the selected algorithm for robust</a>
<span class="sourceLineNo">10711</span><a id="line.10711">     * estimation.</a>
<span class="sourceLineNo">10712</span><a id="line.10712">     *</a>
<span class="sourceLineNo">10713</span><a id="line.10713">     * The computed transformation is then refined further (using only inliers) with the</a>
<span class="sourceLineNo">10714</span><a id="line.10714">     * Levenberg-Marquardt method to reduce the re-projection error even more.</a>
<span class="sourceLineNo">10715</span><a id="line.10715">     *</a>
<span class="sourceLineNo">10716</span><a id="line.10716">     * Estimated transformation matrix is:</a>
<span class="sourceLineNo">10717</span><a id="line.10717">     * \( \begin{bmatrix} \cos(\theta) \cdot s &amp;amp; -\sin(\theta) \cdot s &amp;amp; t_x \\</a>
<span class="sourceLineNo">10718</span><a id="line.10718">     *                 \sin(\theta) \cdot s &amp;amp; \cos(\theta) \cdot s &amp;amp; t_y</a>
<span class="sourceLineNo">10719</span><a id="line.10719">     * \end{bmatrix} \)</a>
<span class="sourceLineNo">10720</span><a id="line.10720">     * Where \( \theta \) is the rotation angle, \( s \) the scaling factor and \( t_x, t_y \) are</a>
<span class="sourceLineNo">10721</span><a id="line.10721">     * translations in \( x, y \) axes respectively.</a>
<span class="sourceLineNo">10722</span><a id="line.10722">     *</a>
<span class="sourceLineNo">10723</span><a id="line.10723">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">10724</span><a id="line.10724">     * The RANSAC method can handle practically any ratio of outliers but need a threshold to</a>
<span class="sourceLineNo">10725</span><a id="line.10725">     * distinguish inliers from outliers. The method LMeDS does not need any threshold but it works</a>
<span class="sourceLineNo">10726</span><a id="line.10726">     * correctly only when there are more than 50% of inliers.</a>
<span class="sourceLineNo">10727</span><a id="line.10727">     *</a>
<span class="sourceLineNo">10728</span><a id="line.10728">     * SEE: estimateAffine2D, getAffineTransform</a>
<span class="sourceLineNo">10729</span><a id="line.10729">     */</a>
<span class="sourceLineNo">10730</span><a id="line.10730">    public static Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters) {</a>
<span class="sourceLineNo">10731</span><a id="line.10731">        return new Mat(estimateAffinePartial2D_2(from.nativeObj, to.nativeObj, inliers.nativeObj, method, ransacReprojThreshold, maxIters));</a>
<span class="sourceLineNo">10732</span><a id="line.10732">    }</a>
<span class="sourceLineNo">10733</span><a id="line.10733"></a>
<span class="sourceLineNo">10734</span><a id="line.10734">    /**</a>
<span class="sourceLineNo">10735</span><a id="line.10735">     * Computes an optimal limited affine transformation with 4 degrees of freedom between</a>
<span class="sourceLineNo">10736</span><a id="line.10736">     * two 2D point sets.</a>
<span class="sourceLineNo">10737</span><a id="line.10737">     *</a>
<span class="sourceLineNo">10738</span><a id="line.10738">     * @param from First input 2D point set.</a>
<span class="sourceLineNo">10739</span><a id="line.10739">     * @param to Second input 2D point set.</a>
<span class="sourceLineNo">10740</span><a id="line.10740">     * @param inliers Output vector indicating which points are inliers.</a>
<span class="sourceLineNo">10741</span><a id="line.10741">     * @param method Robust method used to compute transformation. The following methods are possible:</a>
<span class="sourceLineNo">10742</span><a id="line.10742">     * &lt;ul&gt;</a>
<span class="sourceLineNo">10743</span><a id="line.10743">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10744</span><a id="line.10744">     *    REF: RANSAC - RANSAC-based robust method</a>
<span class="sourceLineNo">10745</span><a id="line.10745">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10746</span><a id="line.10746">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10747</span><a id="line.10747">     *    REF: LMEDS - Least-Median robust method</a>
<span class="sourceLineNo">10748</span><a id="line.10748">     * RANSAC is the default method.</a>
<span class="sourceLineNo">10749</span><a id="line.10749">     * @param ransacReprojThreshold Maximum reprojection error in the RANSAC algorithm to consider</a>
<span class="sourceLineNo">10750</span><a id="line.10750">     * a point as an inlier. Applies only to RANSAC.</a>
<span class="sourceLineNo">10751</span><a id="line.10751">     * between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation</a>
<span class="sourceLineNo">10752</span><a id="line.10752">     * significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</a>
<span class="sourceLineNo">10753</span><a id="line.10753">     * Passing 0 will disable refining, so the output matrix will be output of robust method.</a>
<span class="sourceLineNo">10754</span><a id="line.10754">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10755</span><a id="line.10755">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">10756</span><a id="line.10756">     *</a>
<span class="sourceLineNo">10757</span><a id="line.10757">     * @return Output 2D affine transformation (4 degrees of freedom) matrix \(2 \times 3\) or</a>
<span class="sourceLineNo">10758</span><a id="line.10758">     * empty matrix if transformation could not be estimated.</a>
<span class="sourceLineNo">10759</span><a id="line.10759">     *</a>
<span class="sourceLineNo">10760</span><a id="line.10760">     * The function estimates an optimal 2D affine transformation with 4 degrees of freedom limited to</a>
<span class="sourceLineNo">10761</span><a id="line.10761">     * combinations of translation, rotation, and uniform scaling. Uses the selected algorithm for robust</a>
<span class="sourceLineNo">10762</span><a id="line.10762">     * estimation.</a>
<span class="sourceLineNo">10763</span><a id="line.10763">     *</a>
<span class="sourceLineNo">10764</span><a id="line.10764">     * The computed transformation is then refined further (using only inliers) with the</a>
<span class="sourceLineNo">10765</span><a id="line.10765">     * Levenberg-Marquardt method to reduce the re-projection error even more.</a>
<span class="sourceLineNo">10766</span><a id="line.10766">     *</a>
<span class="sourceLineNo">10767</span><a id="line.10767">     * Estimated transformation matrix is:</a>
<span class="sourceLineNo">10768</span><a id="line.10768">     * \( \begin{bmatrix} \cos(\theta) \cdot s &amp;amp; -\sin(\theta) \cdot s &amp;amp; t_x \\</a>
<span class="sourceLineNo">10769</span><a id="line.10769">     *                 \sin(\theta) \cdot s &amp;amp; \cos(\theta) \cdot s &amp;amp; t_y</a>
<span class="sourceLineNo">10770</span><a id="line.10770">     * \end{bmatrix} \)</a>
<span class="sourceLineNo">10771</span><a id="line.10771">     * Where \( \theta \) is the rotation angle, \( s \) the scaling factor and \( t_x, t_y \) are</a>
<span class="sourceLineNo">10772</span><a id="line.10772">     * translations in \( x, y \) axes respectively.</a>
<span class="sourceLineNo">10773</span><a id="line.10773">     *</a>
<span class="sourceLineNo">10774</span><a id="line.10774">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">10775</span><a id="line.10775">     * The RANSAC method can handle practically any ratio of outliers but need a threshold to</a>
<span class="sourceLineNo">10776</span><a id="line.10776">     * distinguish inliers from outliers. The method LMeDS does not need any threshold but it works</a>
<span class="sourceLineNo">10777</span><a id="line.10777">     * correctly only when there are more than 50% of inliers.</a>
<span class="sourceLineNo">10778</span><a id="line.10778">     *</a>
<span class="sourceLineNo">10779</span><a id="line.10779">     * SEE: estimateAffine2D, getAffineTransform</a>
<span class="sourceLineNo">10780</span><a id="line.10780">     */</a>
<span class="sourceLineNo">10781</span><a id="line.10781">    public static Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold) {</a>
<span class="sourceLineNo">10782</span><a id="line.10782">        return new Mat(estimateAffinePartial2D_3(from.nativeObj, to.nativeObj, inliers.nativeObj, method, ransacReprojThreshold));</a>
<span class="sourceLineNo">10783</span><a id="line.10783">    }</a>
<span class="sourceLineNo">10784</span><a id="line.10784"></a>
<span class="sourceLineNo">10785</span><a id="line.10785">    /**</a>
<span class="sourceLineNo">10786</span><a id="line.10786">     * Computes an optimal limited affine transformation with 4 degrees of freedom between</a>
<span class="sourceLineNo">10787</span><a id="line.10787">     * two 2D point sets.</a>
<span class="sourceLineNo">10788</span><a id="line.10788">     *</a>
<span class="sourceLineNo">10789</span><a id="line.10789">     * @param from First input 2D point set.</a>
<span class="sourceLineNo">10790</span><a id="line.10790">     * @param to Second input 2D point set.</a>
<span class="sourceLineNo">10791</span><a id="line.10791">     * @param inliers Output vector indicating which points are inliers.</a>
<span class="sourceLineNo">10792</span><a id="line.10792">     * @param method Robust method used to compute transformation. The following methods are possible:</a>
<span class="sourceLineNo">10793</span><a id="line.10793">     * &lt;ul&gt;</a>
<span class="sourceLineNo">10794</span><a id="line.10794">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10795</span><a id="line.10795">     *    REF: RANSAC - RANSAC-based robust method</a>
<span class="sourceLineNo">10796</span><a id="line.10796">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10797</span><a id="line.10797">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10798</span><a id="line.10798">     *    REF: LMEDS - Least-Median robust method</a>
<span class="sourceLineNo">10799</span><a id="line.10799">     * RANSAC is the default method.</a>
<span class="sourceLineNo">10800</span><a id="line.10800">     * a point as an inlier. Applies only to RANSAC.</a>
<span class="sourceLineNo">10801</span><a id="line.10801">     * between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation</a>
<span class="sourceLineNo">10802</span><a id="line.10802">     * significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</a>
<span class="sourceLineNo">10803</span><a id="line.10803">     * Passing 0 will disable refining, so the output matrix will be output of robust method.</a>
<span class="sourceLineNo">10804</span><a id="line.10804">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10805</span><a id="line.10805">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">10806</span><a id="line.10806">     *</a>
<span class="sourceLineNo">10807</span><a id="line.10807">     * @return Output 2D affine transformation (4 degrees of freedom) matrix \(2 \times 3\) or</a>
<span class="sourceLineNo">10808</span><a id="line.10808">     * empty matrix if transformation could not be estimated.</a>
<span class="sourceLineNo">10809</span><a id="line.10809">     *</a>
<span class="sourceLineNo">10810</span><a id="line.10810">     * The function estimates an optimal 2D affine transformation with 4 degrees of freedom limited to</a>
<span class="sourceLineNo">10811</span><a id="line.10811">     * combinations of translation, rotation, and uniform scaling. Uses the selected algorithm for robust</a>
<span class="sourceLineNo">10812</span><a id="line.10812">     * estimation.</a>
<span class="sourceLineNo">10813</span><a id="line.10813">     *</a>
<span class="sourceLineNo">10814</span><a id="line.10814">     * The computed transformation is then refined further (using only inliers) with the</a>
<span class="sourceLineNo">10815</span><a id="line.10815">     * Levenberg-Marquardt method to reduce the re-projection error even more.</a>
<span class="sourceLineNo">10816</span><a id="line.10816">     *</a>
<span class="sourceLineNo">10817</span><a id="line.10817">     * Estimated transformation matrix is:</a>
<span class="sourceLineNo">10818</span><a id="line.10818">     * \( \begin{bmatrix} \cos(\theta) \cdot s &amp;amp; -\sin(\theta) \cdot s &amp;amp; t_x \\</a>
<span class="sourceLineNo">10819</span><a id="line.10819">     *                 \sin(\theta) \cdot s &amp;amp; \cos(\theta) \cdot s &amp;amp; t_y</a>
<span class="sourceLineNo">10820</span><a id="line.10820">     * \end{bmatrix} \)</a>
<span class="sourceLineNo">10821</span><a id="line.10821">     * Where \( \theta \) is the rotation angle, \( s \) the scaling factor and \( t_x, t_y \) are</a>
<span class="sourceLineNo">10822</span><a id="line.10822">     * translations in \( x, y \) axes respectively.</a>
<span class="sourceLineNo">10823</span><a id="line.10823">     *</a>
<span class="sourceLineNo">10824</span><a id="line.10824">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">10825</span><a id="line.10825">     * The RANSAC method can handle practically any ratio of outliers but need a threshold to</a>
<span class="sourceLineNo">10826</span><a id="line.10826">     * distinguish inliers from outliers. The method LMeDS does not need any threshold but it works</a>
<span class="sourceLineNo">10827</span><a id="line.10827">     * correctly only when there are more than 50% of inliers.</a>
<span class="sourceLineNo">10828</span><a id="line.10828">     *</a>
<span class="sourceLineNo">10829</span><a id="line.10829">     * SEE: estimateAffine2D, getAffineTransform</a>
<span class="sourceLineNo">10830</span><a id="line.10830">     */</a>
<span class="sourceLineNo">10831</span><a id="line.10831">    public static Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers, int method) {</a>
<span class="sourceLineNo">10832</span><a id="line.10832">        return new Mat(estimateAffinePartial2D_4(from.nativeObj, to.nativeObj, inliers.nativeObj, method));</a>
<span class="sourceLineNo">10833</span><a id="line.10833">    }</a>
<span class="sourceLineNo">10834</span><a id="line.10834"></a>
<span class="sourceLineNo">10835</span><a id="line.10835">    /**</a>
<span class="sourceLineNo">10836</span><a id="line.10836">     * Computes an optimal limited affine transformation with 4 degrees of freedom between</a>
<span class="sourceLineNo">10837</span><a id="line.10837">     * two 2D point sets.</a>
<span class="sourceLineNo">10838</span><a id="line.10838">     *</a>
<span class="sourceLineNo">10839</span><a id="line.10839">     * @param from First input 2D point set.</a>
<span class="sourceLineNo">10840</span><a id="line.10840">     * @param to Second input 2D point set.</a>
<span class="sourceLineNo">10841</span><a id="line.10841">     * @param inliers Output vector indicating which points are inliers.</a>
<span class="sourceLineNo">10842</span><a id="line.10842">     * &lt;ul&gt;</a>
<span class="sourceLineNo">10843</span><a id="line.10843">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10844</span><a id="line.10844">     *    REF: RANSAC - RANSAC-based robust method</a>
<span class="sourceLineNo">10845</span><a id="line.10845">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10846</span><a id="line.10846">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10847</span><a id="line.10847">     *    REF: LMEDS - Least-Median robust method</a>
<span class="sourceLineNo">10848</span><a id="line.10848">     * RANSAC is the default method.</a>
<span class="sourceLineNo">10849</span><a id="line.10849">     * a point as an inlier. Applies only to RANSAC.</a>
<span class="sourceLineNo">10850</span><a id="line.10850">     * between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation</a>
<span class="sourceLineNo">10851</span><a id="line.10851">     * significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</a>
<span class="sourceLineNo">10852</span><a id="line.10852">     * Passing 0 will disable refining, so the output matrix will be output of robust method.</a>
<span class="sourceLineNo">10853</span><a id="line.10853">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10854</span><a id="line.10854">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">10855</span><a id="line.10855">     *</a>
<span class="sourceLineNo">10856</span><a id="line.10856">     * @return Output 2D affine transformation (4 degrees of freedom) matrix \(2 \times 3\) or</a>
<span class="sourceLineNo">10857</span><a id="line.10857">     * empty matrix if transformation could not be estimated.</a>
<span class="sourceLineNo">10858</span><a id="line.10858">     *</a>
<span class="sourceLineNo">10859</span><a id="line.10859">     * The function estimates an optimal 2D affine transformation with 4 degrees of freedom limited to</a>
<span class="sourceLineNo">10860</span><a id="line.10860">     * combinations of translation, rotation, and uniform scaling. Uses the selected algorithm for robust</a>
<span class="sourceLineNo">10861</span><a id="line.10861">     * estimation.</a>
<span class="sourceLineNo">10862</span><a id="line.10862">     *</a>
<span class="sourceLineNo">10863</span><a id="line.10863">     * The computed transformation is then refined further (using only inliers) with the</a>
<span class="sourceLineNo">10864</span><a id="line.10864">     * Levenberg-Marquardt method to reduce the re-projection error even more.</a>
<span class="sourceLineNo">10865</span><a id="line.10865">     *</a>
<span class="sourceLineNo">10866</span><a id="line.10866">     * Estimated transformation matrix is:</a>
<span class="sourceLineNo">10867</span><a id="line.10867">     * \( \begin{bmatrix} \cos(\theta) \cdot s &amp;amp; -\sin(\theta) \cdot s &amp;amp; t_x \\</a>
<span class="sourceLineNo">10868</span><a id="line.10868">     *                 \sin(\theta) \cdot s &amp;amp; \cos(\theta) \cdot s &amp;amp; t_y</a>
<span class="sourceLineNo">10869</span><a id="line.10869">     * \end{bmatrix} \)</a>
<span class="sourceLineNo">10870</span><a id="line.10870">     * Where \( \theta \) is the rotation angle, \( s \) the scaling factor and \( t_x, t_y \) are</a>
<span class="sourceLineNo">10871</span><a id="line.10871">     * translations in \( x, y \) axes respectively.</a>
<span class="sourceLineNo">10872</span><a id="line.10872">     *</a>
<span class="sourceLineNo">10873</span><a id="line.10873">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">10874</span><a id="line.10874">     * The RANSAC method can handle practically any ratio of outliers but need a threshold to</a>
<span class="sourceLineNo">10875</span><a id="line.10875">     * distinguish inliers from outliers. The method LMeDS does not need any threshold but it works</a>
<span class="sourceLineNo">10876</span><a id="line.10876">     * correctly only when there are more than 50% of inliers.</a>
<span class="sourceLineNo">10877</span><a id="line.10877">     *</a>
<span class="sourceLineNo">10878</span><a id="line.10878">     * SEE: estimateAffine2D, getAffineTransform</a>
<span class="sourceLineNo">10879</span><a id="line.10879">     */</a>
<span class="sourceLineNo">10880</span><a id="line.10880">    public static Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers) {</a>
<span class="sourceLineNo">10881</span><a id="line.10881">        return new Mat(estimateAffinePartial2D_5(from.nativeObj, to.nativeObj, inliers.nativeObj));</a>
<span class="sourceLineNo">10882</span><a id="line.10882">    }</a>
<span class="sourceLineNo">10883</span><a id="line.10883"></a>
<span class="sourceLineNo">10884</span><a id="line.10884">    /**</a>
<span class="sourceLineNo">10885</span><a id="line.10885">     * Computes an optimal limited affine transformation with 4 degrees of freedom between</a>
<span class="sourceLineNo">10886</span><a id="line.10886">     * two 2D point sets.</a>
<span class="sourceLineNo">10887</span><a id="line.10887">     *</a>
<span class="sourceLineNo">10888</span><a id="line.10888">     * @param from First input 2D point set.</a>
<span class="sourceLineNo">10889</span><a id="line.10889">     * @param to Second input 2D point set.</a>
<span class="sourceLineNo">10890</span><a id="line.10890">     * &lt;ul&gt;</a>
<span class="sourceLineNo">10891</span><a id="line.10891">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10892</span><a id="line.10892">     *    REF: RANSAC - RANSAC-based robust method</a>
<span class="sourceLineNo">10893</span><a id="line.10893">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10894</span><a id="line.10894">     *   &lt;li&gt;</a>
<span class="sourceLineNo">10895</span><a id="line.10895">     *    REF: LMEDS - Least-Median robust method</a>
<span class="sourceLineNo">10896</span><a id="line.10896">     * RANSAC is the default method.</a>
<span class="sourceLineNo">10897</span><a id="line.10897">     * a point as an inlier. Applies only to RANSAC.</a>
<span class="sourceLineNo">10898</span><a id="line.10898">     * between 0.95 and 0.99 is usually good enough. Values too close to 1 can slow down the estimation</a>
<span class="sourceLineNo">10899</span><a id="line.10899">     * significantly. Values lower than 0.8-0.9 can result in an incorrectly estimated transformation.</a>
<span class="sourceLineNo">10900</span><a id="line.10900">     * Passing 0 will disable refining, so the output matrix will be output of robust method.</a>
<span class="sourceLineNo">10901</span><a id="line.10901">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">10902</span><a id="line.10902">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">10903</span><a id="line.10903">     *</a>
<span class="sourceLineNo">10904</span><a id="line.10904">     * @return Output 2D affine transformation (4 degrees of freedom) matrix \(2 \times 3\) or</a>
<span class="sourceLineNo">10905</span><a id="line.10905">     * empty matrix if transformation could not be estimated.</a>
<span class="sourceLineNo">10906</span><a id="line.10906">     *</a>
<span class="sourceLineNo">10907</span><a id="line.10907">     * The function estimates an optimal 2D affine transformation with 4 degrees of freedom limited to</a>
<span class="sourceLineNo">10908</span><a id="line.10908">     * combinations of translation, rotation, and uniform scaling. Uses the selected algorithm for robust</a>
<span class="sourceLineNo">10909</span><a id="line.10909">     * estimation.</a>
<span class="sourceLineNo">10910</span><a id="line.10910">     *</a>
<span class="sourceLineNo">10911</span><a id="line.10911">     * The computed transformation is then refined further (using only inliers) with the</a>
<span class="sourceLineNo">10912</span><a id="line.10912">     * Levenberg-Marquardt method to reduce the re-projection error even more.</a>
<span class="sourceLineNo">10913</span><a id="line.10913">     *</a>
<span class="sourceLineNo">10914</span><a id="line.10914">     * Estimated transformation matrix is:</a>
<span class="sourceLineNo">10915</span><a id="line.10915">     * \( \begin{bmatrix} \cos(\theta) \cdot s &amp;amp; -\sin(\theta) \cdot s &amp;amp; t_x \\</a>
<span class="sourceLineNo">10916</span><a id="line.10916">     *                 \sin(\theta) \cdot s &amp;amp; \cos(\theta) \cdot s &amp;amp; t_y</a>
<span class="sourceLineNo">10917</span><a id="line.10917">     * \end{bmatrix} \)</a>
<span class="sourceLineNo">10918</span><a id="line.10918">     * Where \( \theta \) is the rotation angle, \( s \) the scaling factor and \( t_x, t_y \) are</a>
<span class="sourceLineNo">10919</span><a id="line.10919">     * translations in \( x, y \) axes respectively.</a>
<span class="sourceLineNo">10920</span><a id="line.10920">     *</a>
<span class="sourceLineNo">10921</span><a id="line.10921">     * &lt;b&gt;Note:&lt;/b&gt;</a>
<span class="sourceLineNo">10922</span><a id="line.10922">     * The RANSAC method can handle practically any ratio of outliers but need a threshold to</a>
<span class="sourceLineNo">10923</span><a id="line.10923">     * distinguish inliers from outliers. The method LMeDS does not need any threshold but it works</a>
<span class="sourceLineNo">10924</span><a id="line.10924">     * correctly only when there are more than 50% of inliers.</a>
<span class="sourceLineNo">10925</span><a id="line.10925">     *</a>
<span class="sourceLineNo">10926</span><a id="line.10926">     * SEE: estimateAffine2D, getAffineTransform</a>
<span class="sourceLineNo">10927</span><a id="line.10927">     */</a>
<span class="sourceLineNo">10928</span><a id="line.10928">    public static Mat estimateAffinePartial2D(Mat from, Mat to) {</a>
<span class="sourceLineNo">10929</span><a id="line.10929">        return new Mat(estimateAffinePartial2D_6(from.nativeObj, to.nativeObj));</a>
<span class="sourceLineNo">10930</span><a id="line.10930">    }</a>
<span class="sourceLineNo">10931</span><a id="line.10931"></a>
<span class="sourceLineNo">10932</span><a id="line.10932"></a>
<span class="sourceLineNo">10933</span><a id="line.10933">    //</a>
<span class="sourceLineNo">10934</span><a id="line.10934">    // C++:  int cv::decomposeHomographyMat(Mat H, Mat K, vector_Mat&amp; rotations, vector_Mat&amp; translations, vector_Mat&amp; normals)</a>
<span class="sourceLineNo">10935</span><a id="line.10935">    //</a>
<span class="sourceLineNo">10936</span><a id="line.10936"></a>
<span class="sourceLineNo">10937</span><a id="line.10937">    /**</a>
<span class="sourceLineNo">10938</span><a id="line.10938">     * Decompose a homography matrix to rotation(s), translation(s) and plane normal(s).</a>
<span class="sourceLineNo">10939</span><a id="line.10939">     *</a>
<span class="sourceLineNo">10940</span><a id="line.10940">     * @param H The input homography matrix between two images.</a>
<span class="sourceLineNo">10941</span><a id="line.10941">     * @param K The input camera intrinsic matrix.</a>
<span class="sourceLineNo">10942</span><a id="line.10942">     * @param rotations Array of rotation matrices.</a>
<span class="sourceLineNo">10943</span><a id="line.10943">     * @param translations Array of translation matrices.</a>
<span class="sourceLineNo">10944</span><a id="line.10944">     * @param normals Array of plane normal matrices.</a>
<span class="sourceLineNo">10945</span><a id="line.10945">     *</a>
<span class="sourceLineNo">10946</span><a id="line.10946">     * This function extracts relative camera motion between two views of a planar object and returns up to</a>
<span class="sourceLineNo">10947</span><a id="line.10947">     * four mathematical solution tuples of rotation, translation, and plane normal. The decomposition of</a>
<span class="sourceLineNo">10948</span><a id="line.10948">     * the homography matrix H is described in detail in CITE: Malis.</a>
<span class="sourceLineNo">10949</span><a id="line.10949">     *</a>
<span class="sourceLineNo">10950</span><a id="line.10950">     * If the homography H, induced by the plane, gives the constraint</a>
<span class="sourceLineNo">10951</span><a id="line.10951">     * \(s_i \vecthree{x'_i}{y'_i}{1} \sim H \vecthree{x_i}{y_i}{1}\) on the source image points</a>
<span class="sourceLineNo">10952</span><a id="line.10952">     * \(p_i\) and the destination image points \(p'_i\), then the tuple of rotations[k] and</a>
<span class="sourceLineNo">10953</span><a id="line.10953">     * translations[k] is a change of basis from the source camera's coordinate system to the destination</a>
<span class="sourceLineNo">10954</span><a id="line.10954">     * camera's coordinate system. However, by decomposing H, one can only get the translation normalized</a>
<span class="sourceLineNo">10955</span><a id="line.10955">     * by the (typically unknown) depth of the scene, i.e. its direction but with normalized length.</a>
<span class="sourceLineNo">10956</span><a id="line.10956">     *</a>
<span class="sourceLineNo">10957</span><a id="line.10957">     * If point correspondences are available, at least two solutions may further be invalidated, by</a>
<span class="sourceLineNo">10958</span><a id="line.10958">     * applying positive depth constraint, i.e. all points must be in front of the camera.</a>
<span class="sourceLineNo">10959</span><a id="line.10959">     * @return automatically generated</a>
<span class="sourceLineNo">10960</span><a id="line.10960">     */</a>
<span class="sourceLineNo">10961</span><a id="line.10961">    public static int decomposeHomographyMat(Mat H, Mat K, List&lt;Mat&gt; rotations, List&lt;Mat&gt; translations, List&lt;Mat&gt; normals) {</a>
<span class="sourceLineNo">10962</span><a id="line.10962">        Mat rotations_mat = new Mat();</a>
<span class="sourceLineNo">10963</span><a id="line.10963">        Mat translations_mat = new Mat();</a>
<span class="sourceLineNo">10964</span><a id="line.10964">        Mat normals_mat = new Mat();</a>
<span class="sourceLineNo">10965</span><a id="line.10965">        int retVal = decomposeHomographyMat_0(H.nativeObj, K.nativeObj, rotations_mat.nativeObj, translations_mat.nativeObj, normals_mat.nativeObj);</a>
<span class="sourceLineNo">10966</span><a id="line.10966">        Converters.Mat_to_vector_Mat(rotations_mat, rotations);</a>
<span class="sourceLineNo">10967</span><a id="line.10967">        rotations_mat.release();</a>
<span class="sourceLineNo">10968</span><a id="line.10968">        Converters.Mat_to_vector_Mat(translations_mat, translations);</a>
<span class="sourceLineNo">10969</span><a id="line.10969">        translations_mat.release();</a>
<span class="sourceLineNo">10970</span><a id="line.10970">        Converters.Mat_to_vector_Mat(normals_mat, normals);</a>
<span class="sourceLineNo">10971</span><a id="line.10971">        normals_mat.release();</a>
<span class="sourceLineNo">10972</span><a id="line.10972">        return retVal;</a>
<span class="sourceLineNo">10973</span><a id="line.10973">    }</a>
<span class="sourceLineNo">10974</span><a id="line.10974"></a>
<span class="sourceLineNo">10975</span><a id="line.10975"></a>
<span class="sourceLineNo">10976</span><a id="line.10976">    //</a>
<span class="sourceLineNo">10977</span><a id="line.10977">    // C++:  void cv::filterHomographyDecompByVisibleRefpoints(vector_Mat rotations, vector_Mat normals, Mat beforePoints, Mat afterPoints, Mat&amp; possibleSolutions, Mat pointsMask = Mat())</a>
<span class="sourceLineNo">10978</span><a id="line.10978">    //</a>
<span class="sourceLineNo">10979</span><a id="line.10979"></a>
<span class="sourceLineNo">10980</span><a id="line.10980">    /**</a>
<span class="sourceLineNo">10981</span><a id="line.10981">     * Filters homography decompositions based on additional information.</a>
<span class="sourceLineNo">10982</span><a id="line.10982">     *</a>
<span class="sourceLineNo">10983</span><a id="line.10983">     * @param rotations Vector of rotation matrices.</a>
<span class="sourceLineNo">10984</span><a id="line.10984">     * @param normals Vector of plane normal matrices.</a>
<span class="sourceLineNo">10985</span><a id="line.10985">     * @param beforePoints Vector of (rectified) visible reference points before the homography is applied</a>
<span class="sourceLineNo">10986</span><a id="line.10986">     * @param afterPoints Vector of (rectified) visible reference points after the homography is applied</a>
<span class="sourceLineNo">10987</span><a id="line.10987">     * @param possibleSolutions Vector of int indices representing the viable solution set after filtering</a>
<span class="sourceLineNo">10988</span><a id="line.10988">     * @param pointsMask optional Mat/Vector of 8u type representing the mask for the inliers as given by the findHomography function</a>
<span class="sourceLineNo">10989</span><a id="line.10989">     *</a>
<span class="sourceLineNo">10990</span><a id="line.10990">     * This function is intended to filter the output of the decomposeHomographyMat based on additional</a>
<span class="sourceLineNo">10991</span><a id="line.10991">     * information as described in CITE: Malis . The summary of the method: the decomposeHomographyMat function</a>
<span class="sourceLineNo">10992</span><a id="line.10992">     * returns 2 unique solutions and their "opposites" for a total of 4 solutions. If we have access to the</a>
<span class="sourceLineNo">10993</span><a id="line.10993">     * sets of points visible in the camera frame before and after the homography transformation is applied,</a>
<span class="sourceLineNo">10994</span><a id="line.10994">     * we can determine which are the true potential solutions and which are the opposites by verifying which</a>
<span class="sourceLineNo">10995</span><a id="line.10995">     * homographies are consistent with all visible reference points being in front of the camera. The inputs</a>
<span class="sourceLineNo">10996</span><a id="line.10996">     * are left unchanged; the filtered solution set is returned as indices into the existing one.</a>
<span class="sourceLineNo">10997</span><a id="line.10997">     */</a>
<span class="sourceLineNo">10998</span><a id="line.10998">    public static void filterHomographyDecompByVisibleRefpoints(List&lt;Mat&gt; rotations, List&lt;Mat&gt; normals, Mat beforePoints, Mat afterPoints, Mat possibleSolutions, Mat pointsMask) {</a>
<span class="sourceLineNo">10999</span><a id="line.10999">        Mat rotations_mat = Converters.vector_Mat_to_Mat(rotations);</a>
<span class="sourceLineNo">11000</span><a id="line.11000">        Mat normals_mat = Converters.vector_Mat_to_Mat(normals);</a>
<span class="sourceLineNo">11001</span><a id="line.11001">        filterHomographyDecompByVisibleRefpoints_0(rotations_mat.nativeObj, normals_mat.nativeObj, beforePoints.nativeObj, afterPoints.nativeObj, possibleSolutions.nativeObj, pointsMask.nativeObj);</a>
<span class="sourceLineNo">11002</span><a id="line.11002">    }</a>
<span class="sourceLineNo">11003</span><a id="line.11003"></a>
<span class="sourceLineNo">11004</span><a id="line.11004">    /**</a>
<span class="sourceLineNo">11005</span><a id="line.11005">     * Filters homography decompositions based on additional information.</a>
<span class="sourceLineNo">11006</span><a id="line.11006">     *</a>
<span class="sourceLineNo">11007</span><a id="line.11007">     * @param rotations Vector of rotation matrices.</a>
<span class="sourceLineNo">11008</span><a id="line.11008">     * @param normals Vector of plane normal matrices.</a>
<span class="sourceLineNo">11009</span><a id="line.11009">     * @param beforePoints Vector of (rectified) visible reference points before the homography is applied</a>
<span class="sourceLineNo">11010</span><a id="line.11010">     * @param afterPoints Vector of (rectified) visible reference points after the homography is applied</a>
<span class="sourceLineNo">11011</span><a id="line.11011">     * @param possibleSolutions Vector of int indices representing the viable solution set after filtering</a>
<span class="sourceLineNo">11012</span><a id="line.11012">     *</a>
<span class="sourceLineNo">11013</span><a id="line.11013">     * This function is intended to filter the output of the decomposeHomographyMat based on additional</a>
<span class="sourceLineNo">11014</span><a id="line.11014">     * information as described in CITE: Malis . The summary of the method: the decomposeHomographyMat function</a>
<span class="sourceLineNo">11015</span><a id="line.11015">     * returns 2 unique solutions and their "opposites" for a total of 4 solutions. If we have access to the</a>
<span class="sourceLineNo">11016</span><a id="line.11016">     * sets of points visible in the camera frame before and after the homography transformation is applied,</a>
<span class="sourceLineNo">11017</span><a id="line.11017">     * we can determine which are the true potential solutions and which are the opposites by verifying which</a>
<span class="sourceLineNo">11018</span><a id="line.11018">     * homographies are consistent with all visible reference points being in front of the camera. The inputs</a>
<span class="sourceLineNo">11019</span><a id="line.11019">     * are left unchanged; the filtered solution set is returned as indices into the existing one.</a>
<span class="sourceLineNo">11020</span><a id="line.11020">     */</a>
<span class="sourceLineNo">11021</span><a id="line.11021">    public static void filterHomographyDecompByVisibleRefpoints(List&lt;Mat&gt; rotations, List&lt;Mat&gt; normals, Mat beforePoints, Mat afterPoints, Mat possibleSolutions) {</a>
<span class="sourceLineNo">11022</span><a id="line.11022">        Mat rotations_mat = Converters.vector_Mat_to_Mat(rotations);</a>
<span class="sourceLineNo">11023</span><a id="line.11023">        Mat normals_mat = Converters.vector_Mat_to_Mat(normals);</a>
<span class="sourceLineNo">11024</span><a id="line.11024">        filterHomographyDecompByVisibleRefpoints_1(rotations_mat.nativeObj, normals_mat.nativeObj, beforePoints.nativeObj, afterPoints.nativeObj, possibleSolutions.nativeObj);</a>
<span class="sourceLineNo">11025</span><a id="line.11025">    }</a>
<span class="sourceLineNo">11026</span><a id="line.11026"></a>
<span class="sourceLineNo">11027</span><a id="line.11027"></a>
<span class="sourceLineNo">11028</span><a id="line.11028">    //</a>
<span class="sourceLineNo">11029</span><a id="line.11029">    // C++:  void cv::undistort(Mat src, Mat&amp; dst, Mat cameraMatrix, Mat distCoeffs, Mat newCameraMatrix = Mat())</a>
<span class="sourceLineNo">11030</span><a id="line.11030">    //</a>
<span class="sourceLineNo">11031</span><a id="line.11031"></a>
<span class="sourceLineNo">11032</span><a id="line.11032">    /**</a>
<span class="sourceLineNo">11033</span><a id="line.11033">     * Transforms an image to compensate for lens distortion.</a>
<span class="sourceLineNo">11034</span><a id="line.11034">     *</a>
<span class="sourceLineNo">11035</span><a id="line.11035">     * The function transforms an image to compensate radial and tangential lens distortion.</a>
<span class="sourceLineNo">11036</span><a id="line.11036">     *</a>
<span class="sourceLineNo">11037</span><a id="line.11037">     * The function is simply a combination of #initUndistortRectifyMap (with unity R ) and #remap</a>
<span class="sourceLineNo">11038</span><a id="line.11038">     * (with bilinear interpolation). See the former function for details of the transformation being</a>
<span class="sourceLineNo">11039</span><a id="line.11039">     * performed.</a>
<span class="sourceLineNo">11040</span><a id="line.11040">     *</a>
<span class="sourceLineNo">11041</span><a id="line.11041">     * Those pixels in the destination image, for which there is no correspondent pixels in the source</a>
<span class="sourceLineNo">11042</span><a id="line.11042">     * image, are filled with zeros (black color).</a>
<span class="sourceLineNo">11043</span><a id="line.11043">     *</a>
<span class="sourceLineNo">11044</span><a id="line.11044">     * A particular subset of the source image that will be visible in the corrected image can be regulated</a>
<span class="sourceLineNo">11045</span><a id="line.11045">     * by newCameraMatrix. You can use #getOptimalNewCameraMatrix to compute the appropriate</a>
<span class="sourceLineNo">11046</span><a id="line.11046">     * newCameraMatrix depending on your requirements.</a>
<span class="sourceLineNo">11047</span><a id="line.11047">     *</a>
<span class="sourceLineNo">11048</span><a id="line.11048">     * The camera matrix and the distortion parameters can be determined using #calibrateCamera. If</a>
<span class="sourceLineNo">11049</span><a id="line.11049">     * the resolution of images is different from the resolution used at the calibration stage, \(f_x,</a>
<span class="sourceLineNo">11050</span><a id="line.11050">     * f_y, c_x\) and \(c_y\) need to be scaled accordingly, while the distortion coefficients remain</a>
<span class="sourceLineNo">11051</span><a id="line.11051">     * the same.</a>
<span class="sourceLineNo">11052</span><a id="line.11052">     *</a>
<span class="sourceLineNo">11053</span><a id="line.11053">     * @param src Input (distorted) image.</a>
<span class="sourceLineNo">11054</span><a id="line.11054">     * @param dst Output (corrected) image that has the same size and type as src .</a>
<span class="sourceLineNo">11055</span><a id="line.11055">     * @param cameraMatrix Input camera matrix \(A = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</a>
<span class="sourceLineNo">11056</span><a id="line.11056">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">11057</span><a id="line.11057">     * \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)</a>
<span class="sourceLineNo">11058</span><a id="line.11058">     * of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</a>
<span class="sourceLineNo">11059</span><a id="line.11059">     * @param newCameraMatrix Camera matrix of the distorted image. By default, it is the same as</a>
<span class="sourceLineNo">11060</span><a id="line.11060">     * cameraMatrix but you may additionally scale and shift the result by using a different matrix.</a>
<span class="sourceLineNo">11061</span><a id="line.11061">     */</a>
<span class="sourceLineNo">11062</span><a id="line.11062">    public static void undistort(Mat src, Mat dst, Mat cameraMatrix, Mat distCoeffs, Mat newCameraMatrix) {</a>
<span class="sourceLineNo">11063</span><a id="line.11063">        undistort_0(src.nativeObj, dst.nativeObj, cameraMatrix.nativeObj, distCoeffs.nativeObj, newCameraMatrix.nativeObj);</a>
<span class="sourceLineNo">11064</span><a id="line.11064">    }</a>
<span class="sourceLineNo">11065</span><a id="line.11065"></a>
<span class="sourceLineNo">11066</span><a id="line.11066">    /**</a>
<span class="sourceLineNo">11067</span><a id="line.11067">     * Transforms an image to compensate for lens distortion.</a>
<span class="sourceLineNo">11068</span><a id="line.11068">     *</a>
<span class="sourceLineNo">11069</span><a id="line.11069">     * The function transforms an image to compensate radial and tangential lens distortion.</a>
<span class="sourceLineNo">11070</span><a id="line.11070">     *</a>
<span class="sourceLineNo">11071</span><a id="line.11071">     * The function is simply a combination of #initUndistortRectifyMap (with unity R ) and #remap</a>
<span class="sourceLineNo">11072</span><a id="line.11072">     * (with bilinear interpolation). See the former function for details of the transformation being</a>
<span class="sourceLineNo">11073</span><a id="line.11073">     * performed.</a>
<span class="sourceLineNo">11074</span><a id="line.11074">     *</a>
<span class="sourceLineNo">11075</span><a id="line.11075">     * Those pixels in the destination image, for which there is no correspondent pixels in the source</a>
<span class="sourceLineNo">11076</span><a id="line.11076">     * image, are filled with zeros (black color).</a>
<span class="sourceLineNo">11077</span><a id="line.11077">     *</a>
<span class="sourceLineNo">11078</span><a id="line.11078">     * A particular subset of the source image that will be visible in the corrected image can be regulated</a>
<span class="sourceLineNo">11079</span><a id="line.11079">     * by newCameraMatrix. You can use #getOptimalNewCameraMatrix to compute the appropriate</a>
<span class="sourceLineNo">11080</span><a id="line.11080">     * newCameraMatrix depending on your requirements.</a>
<span class="sourceLineNo">11081</span><a id="line.11081">     *</a>
<span class="sourceLineNo">11082</span><a id="line.11082">     * The camera matrix and the distortion parameters can be determined using #calibrateCamera. If</a>
<span class="sourceLineNo">11083</span><a id="line.11083">     * the resolution of images is different from the resolution used at the calibration stage, \(f_x,</a>
<span class="sourceLineNo">11084</span><a id="line.11084">     * f_y, c_x\) and \(c_y\) need to be scaled accordingly, while the distortion coefficients remain</a>
<span class="sourceLineNo">11085</span><a id="line.11085">     * the same.</a>
<span class="sourceLineNo">11086</span><a id="line.11086">     *</a>
<span class="sourceLineNo">11087</span><a id="line.11087">     * @param src Input (distorted) image.</a>
<span class="sourceLineNo">11088</span><a id="line.11088">     * @param dst Output (corrected) image that has the same size and type as src .</a>
<span class="sourceLineNo">11089</span><a id="line.11089">     * @param cameraMatrix Input camera matrix \(A = \vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</a>
<span class="sourceLineNo">11090</span><a id="line.11090">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">11091</span><a id="line.11091">     * \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)</a>
<span class="sourceLineNo">11092</span><a id="line.11092">     * of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</a>
<span class="sourceLineNo">11093</span><a id="line.11093">     * cameraMatrix but you may additionally scale and shift the result by using a different matrix.</a>
<span class="sourceLineNo">11094</span><a id="line.11094">     */</a>
<span class="sourceLineNo">11095</span><a id="line.11095">    public static void undistort(Mat src, Mat dst, Mat cameraMatrix, Mat distCoeffs) {</a>
<span class="sourceLineNo">11096</span><a id="line.11096">        undistort_1(src.nativeObj, dst.nativeObj, cameraMatrix.nativeObj, distCoeffs.nativeObj);</a>
<span class="sourceLineNo">11097</span><a id="line.11097">    }</a>
<span class="sourceLineNo">11098</span><a id="line.11098"></a>
<span class="sourceLineNo">11099</span><a id="line.11099"></a>
<span class="sourceLineNo">11100</span><a id="line.11100">    //</a>
<span class="sourceLineNo">11101</span><a id="line.11101">    // C++:  void cv::initUndistortRectifyMap(Mat cameraMatrix, Mat distCoeffs, Mat R, Mat newCameraMatrix, Size size, int m1type, Mat&amp; map1, Mat&amp; map2)</a>
<span class="sourceLineNo">11102</span><a id="line.11102">    //</a>
<span class="sourceLineNo">11103</span><a id="line.11103"></a>
<span class="sourceLineNo">11104</span><a id="line.11104">    /**</a>
<span class="sourceLineNo">11105</span><a id="line.11105">     * Computes the undistortion and rectification transformation map.</a>
<span class="sourceLineNo">11106</span><a id="line.11106">     *</a>
<span class="sourceLineNo">11107</span><a id="line.11107">     * The function computes the joint undistortion and rectification transformation and represents the</a>
<span class="sourceLineNo">11108</span><a id="line.11108">     * result in the form of maps for remap. The undistorted image looks like original, as if it is</a>
<span class="sourceLineNo">11109</span><a id="line.11109">     * captured with a camera using the camera matrix =newCameraMatrix and zero distortion. In case of a</a>
<span class="sourceLineNo">11110</span><a id="line.11110">     * monocular camera, newCameraMatrix is usually equal to cameraMatrix, or it can be computed by</a>
<span class="sourceLineNo">11111</span><a id="line.11111">     * #getOptimalNewCameraMatrix for a better control over scaling. In case of a stereo camera,</a>
<span class="sourceLineNo">11112</span><a id="line.11112">     * newCameraMatrix is normally set to P1 or P2 computed by #stereoRectify .</a>
<span class="sourceLineNo">11113</span><a id="line.11113">     *</a>
<span class="sourceLineNo">11114</span><a id="line.11114">     * Also, this new camera is oriented differently in the coordinate space, according to R. That, for</a>
<span class="sourceLineNo">11115</span><a id="line.11115">     * example, helps to align two heads of a stereo camera so that the epipolar lines on both images</a>
<span class="sourceLineNo">11116</span><a id="line.11116">     * become horizontal and have the same y- coordinate (in case of a horizontally aligned stereo camera).</a>
<span class="sourceLineNo">11117</span><a id="line.11117">     *</a>
<span class="sourceLineNo">11118</span><a id="line.11118">     * The function actually builds the maps for the inverse mapping algorithm that is used by remap. That</a>
<span class="sourceLineNo">11119</span><a id="line.11119">     * is, for each pixel \((u, v)\) in the destination (corrected and rectified) image, the function</a>
<span class="sourceLineNo">11120</span><a id="line.11120">     * computes the corresponding coordinates in the source image (that is, in the original image from</a>
<span class="sourceLineNo">11121</span><a id="line.11121">     * camera). The following process is applied:</a>
<span class="sourceLineNo">11122</span><a id="line.11122">     * \(</a>
<span class="sourceLineNo">11123</span><a id="line.11123">     * \begin{array}{l}</a>
<span class="sourceLineNo">11124</span><a id="line.11124">     * x  \leftarrow (u - {c'}_x)/{f'}_x  \\</a>
<span class="sourceLineNo">11125</span><a id="line.11125">     * y  \leftarrow (v - {c'}_y)/{f'}_y  \\</a>
<span class="sourceLineNo">11126</span><a id="line.11126">     * {[X\,Y\,W]} ^T  \leftarrow R^{-1}*[x \, y \, 1]^T  \\</a>
<span class="sourceLineNo">11127</span><a id="line.11127">     * x'  \leftarrow X/W  \\</a>
<span class="sourceLineNo">11128</span><a id="line.11128">     * y'  \leftarrow Y/W  \\</a>
<span class="sourceLineNo">11129</span><a id="line.11129">     * r^2  \leftarrow x'^2 + y'^2 \\</a>
<span class="sourceLineNo">11130</span><a id="line.11130">     * x''  \leftarrow x' \frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6}</a>
<span class="sourceLineNo">11131</span><a id="line.11131">     * + 2p_1 x' y' + p_2(r^2 + 2 x'^2)  + s_1 r^2 + s_2 r^4\\</a>
<span class="sourceLineNo">11132</span><a id="line.11132">     * y''  \leftarrow y' \frac{1 + k_1 r^2 + k_2 r^4 + k_3 r^6}{1 + k_4 r^2 + k_5 r^4 + k_6 r^6}</a>
<span class="sourceLineNo">11133</span><a id="line.11133">     * + p_1 (r^2 + 2 y'^2) + 2 p_2 x' y' + s_3 r^2 + s_4 r^4 \\</a>
<span class="sourceLineNo">11134</span><a id="line.11134">     * s\vecthree{x'''}{y'''}{1} =</a>
<span class="sourceLineNo">11135</span><a id="line.11135">     * \vecthreethree{R_{33}(\tau_x, \tau_y)}{0}{-R_{13}((\tau_x, \tau_y)}</a>
<span class="sourceLineNo">11136</span><a id="line.11136">     * {0}{R_{33}(\tau_x, \tau_y)}{-R_{23}(\tau_x, \tau_y)}</a>
<span class="sourceLineNo">11137</span><a id="line.11137">     * {0}{0}{1} R(\tau_x, \tau_y) \vecthree{x''}{y''}{1}\\</a>
<span class="sourceLineNo">11138</span><a id="line.11138">     * map_x(u,v)  \leftarrow x''' f_x + c_x  \\</a>
<span class="sourceLineNo">11139</span><a id="line.11139">     * map_y(u,v)  \leftarrow y''' f_y + c_y</a>
<span class="sourceLineNo">11140</span><a id="line.11140">     * \end{array}</a>
<span class="sourceLineNo">11141</span><a id="line.11141">     * \)</a>
<span class="sourceLineNo">11142</span><a id="line.11142">     * where \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)</a>
<span class="sourceLineNo">11143</span><a id="line.11143">     * are the distortion coefficients.</a>
<span class="sourceLineNo">11144</span><a id="line.11144">     *</a>
<span class="sourceLineNo">11145</span><a id="line.11145">     * In case of a stereo camera, this function is called twice: once for each camera head, after</a>
<span class="sourceLineNo">11146</span><a id="line.11146">     * stereoRectify, which in its turn is called after #stereoCalibrate. But if the stereo camera</a>
<span class="sourceLineNo">11147</span><a id="line.11147">     * was not calibrated, it is still possible to compute the rectification transformations directly from</a>
<span class="sourceLineNo">11148</span><a id="line.11148">     * the fundamental matrix using #stereoRectifyUncalibrated. For each camera, the function computes</a>
<span class="sourceLineNo">11149</span><a id="line.11149">     * homography H as the rectification transformation in a pixel domain, not a rotation matrix R in 3D</a>
<span class="sourceLineNo">11150</span><a id="line.11150">     * space. R can be computed from H as</a>
<span class="sourceLineNo">11151</span><a id="line.11151">     * \(\texttt{R} = \texttt{cameraMatrix} ^{-1} \cdot \texttt{H} \cdot \texttt{cameraMatrix}\)</a>
<span class="sourceLineNo">11152</span><a id="line.11152">     * where cameraMatrix can be chosen arbitrarily.</a>
<span class="sourceLineNo">11153</span><a id="line.11153">     *</a>
<span class="sourceLineNo">11154</span><a id="line.11154">     * @param cameraMatrix Input camera matrix \(A=\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</a>
<span class="sourceLineNo">11155</span><a id="line.11155">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">11156</span><a id="line.11156">     * \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)</a>
<span class="sourceLineNo">11157</span><a id="line.11157">     * of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</a>
<span class="sourceLineNo">11158</span><a id="line.11158">     * @param R Optional rectification transformation in the object space (3x3 matrix). R1 or R2 ,</a>
<span class="sourceLineNo">11159</span><a id="line.11159">     * computed by #stereoRectify can be passed here. If the matrix is empty, the identity transformation</a>
<span class="sourceLineNo">11160</span><a id="line.11160">     * is assumed. In cvInitUndistortMap R assumed to be an identity matrix.</a>
<span class="sourceLineNo">11161</span><a id="line.11161">     * @param newCameraMatrix New camera matrix \(A'=\vecthreethree{f_x'}{0}{c_x'}{0}{f_y'}{c_y'}{0}{0}{1}\).</a>
<span class="sourceLineNo">11162</span><a id="line.11162">     * @param size Undistorted image size.</a>
<span class="sourceLineNo">11163</span><a id="line.11163">     * @param m1type Type of the first output map that can be CV_32FC1, CV_32FC2 or CV_16SC2, see #convertMaps</a>
<span class="sourceLineNo">11164</span><a id="line.11164">     * @param map1 The first output map.</a>
<span class="sourceLineNo">11165</span><a id="line.11165">     * @param map2 The second output map.</a>
<span class="sourceLineNo">11166</span><a id="line.11166">     */</a>
<span class="sourceLineNo">11167</span><a id="line.11167">    public static void initUndistortRectifyMap(Mat cameraMatrix, Mat distCoeffs, Mat R, Mat newCameraMatrix, Size size, int m1type, Mat map1, Mat map2) {</a>
<span class="sourceLineNo">11168</span><a id="line.11168">        initUndistortRectifyMap_0(cameraMatrix.nativeObj, distCoeffs.nativeObj, R.nativeObj, newCameraMatrix.nativeObj, size.width, size.height, m1type, map1.nativeObj, map2.nativeObj);</a>
<span class="sourceLineNo">11169</span><a id="line.11169">    }</a>
<span class="sourceLineNo">11170</span><a id="line.11170"></a>
<span class="sourceLineNo">11171</span><a id="line.11171"></a>
<span class="sourceLineNo">11172</span><a id="line.11172">    //</a>
<span class="sourceLineNo">11173</span><a id="line.11173">    // C++:  Mat cv::getDefaultNewCameraMatrix(Mat cameraMatrix, Size imgsize = Size(), bool centerPrincipalPoint = false)</a>
<span class="sourceLineNo">11174</span><a id="line.11174">    //</a>
<span class="sourceLineNo">11175</span><a id="line.11175"></a>
<span class="sourceLineNo">11176</span><a id="line.11176">    /**</a>
<span class="sourceLineNo">11177</span><a id="line.11177">     * Returns the default new camera matrix.</a>
<span class="sourceLineNo">11178</span><a id="line.11178">     *</a>
<span class="sourceLineNo">11179</span><a id="line.11179">     * The function returns the camera matrix that is either an exact copy of the input cameraMatrix (when</a>
<span class="sourceLineNo">11180</span><a id="line.11180">     * centerPrinicipalPoint=false ), or the modified one (when centerPrincipalPoint=true).</a>
<span class="sourceLineNo">11181</span><a id="line.11181">     *</a>
<span class="sourceLineNo">11182</span><a id="line.11182">     * In the latter case, the new camera matrix will be:</a>
<span class="sourceLineNo">11183</span><a id="line.11183">     *</a>
<span class="sourceLineNo">11184</span><a id="line.11184">     * \(\begin{bmatrix} f_x &amp;amp;&amp;amp; 0 &amp;amp;&amp;amp; ( \texttt{imgSize.width} -1)*0.5  \\ 0 &amp;amp;&amp;amp; f_y &amp;amp;&amp;amp; ( \texttt{imgSize.height} -1)*0.5  \\ 0 &amp;amp;&amp;amp; 0 &amp;amp;&amp;amp; 1 \end{bmatrix} ,\)</a>
<span class="sourceLineNo">11185</span><a id="line.11185">     *</a>
<span class="sourceLineNo">11186</span><a id="line.11186">     * where \(f_x\) and \(f_y\) are \((0,0)\) and \((1,1)\) elements of cameraMatrix, respectively.</a>
<span class="sourceLineNo">11187</span><a id="line.11187">     *</a>
<span class="sourceLineNo">11188</span><a id="line.11188">     * By default, the undistortion functions in OpenCV (see #initUndistortRectifyMap, #undistort) do not</a>
<span class="sourceLineNo">11189</span><a id="line.11189">     * move the principal point. However, when you work with stereo, it is important to move the principal</a>
<span class="sourceLineNo">11190</span><a id="line.11190">     * points in both views to the same y-coordinate (which is required by most of stereo correspondence</a>
<span class="sourceLineNo">11191</span><a id="line.11191">     * algorithms), and may be to the same x-coordinate too. So, you can form the new camera matrix for</a>
<span class="sourceLineNo">11192</span><a id="line.11192">     * each view where the principal points are located at the center.</a>
<span class="sourceLineNo">11193</span><a id="line.11193">     *</a>
<span class="sourceLineNo">11194</span><a id="line.11194">     * @param cameraMatrix Input camera matrix.</a>
<span class="sourceLineNo">11195</span><a id="line.11195">     * @param imgsize Camera view image size in pixels.</a>
<span class="sourceLineNo">11196</span><a id="line.11196">     * @param centerPrincipalPoint Location of the principal point in the new camera matrix. The</a>
<span class="sourceLineNo">11197</span><a id="line.11197">     * parameter indicates whether this location should be at the image center or not.</a>
<span class="sourceLineNo">11198</span><a id="line.11198">     * @return automatically generated</a>
<span class="sourceLineNo">11199</span><a id="line.11199">     */</a>
<span class="sourceLineNo">11200</span><a id="line.11200">    public static Mat getDefaultNewCameraMatrix(Mat cameraMatrix, Size imgsize, boolean centerPrincipalPoint) {</a>
<span class="sourceLineNo">11201</span><a id="line.11201">        return new Mat(getDefaultNewCameraMatrix_0(cameraMatrix.nativeObj, imgsize.width, imgsize.height, centerPrincipalPoint));</a>
<span class="sourceLineNo">11202</span><a id="line.11202">    }</a>
<span class="sourceLineNo">11203</span><a id="line.11203"></a>
<span class="sourceLineNo">11204</span><a id="line.11204">    /**</a>
<span class="sourceLineNo">11205</span><a id="line.11205">     * Returns the default new camera matrix.</a>
<span class="sourceLineNo">11206</span><a id="line.11206">     *</a>
<span class="sourceLineNo">11207</span><a id="line.11207">     * The function returns the camera matrix that is either an exact copy of the input cameraMatrix (when</a>
<span class="sourceLineNo">11208</span><a id="line.11208">     * centerPrinicipalPoint=false ), or the modified one (when centerPrincipalPoint=true).</a>
<span class="sourceLineNo">11209</span><a id="line.11209">     *</a>
<span class="sourceLineNo">11210</span><a id="line.11210">     * In the latter case, the new camera matrix will be:</a>
<span class="sourceLineNo">11211</span><a id="line.11211">     *</a>
<span class="sourceLineNo">11212</span><a id="line.11212">     * \(\begin{bmatrix} f_x &amp;amp;&amp;amp; 0 &amp;amp;&amp;amp; ( \texttt{imgSize.width} -1)*0.5  \\ 0 &amp;amp;&amp;amp; f_y &amp;amp;&amp;amp; ( \texttt{imgSize.height} -1)*0.5  \\ 0 &amp;amp;&amp;amp; 0 &amp;amp;&amp;amp; 1 \end{bmatrix} ,\)</a>
<span class="sourceLineNo">11213</span><a id="line.11213">     *</a>
<span class="sourceLineNo">11214</span><a id="line.11214">     * where \(f_x\) and \(f_y\) are \((0,0)\) and \((1,1)\) elements of cameraMatrix, respectively.</a>
<span class="sourceLineNo">11215</span><a id="line.11215">     *</a>
<span class="sourceLineNo">11216</span><a id="line.11216">     * By default, the undistortion functions in OpenCV (see #initUndistortRectifyMap, #undistort) do not</a>
<span class="sourceLineNo">11217</span><a id="line.11217">     * move the principal point. However, when you work with stereo, it is important to move the principal</a>
<span class="sourceLineNo">11218</span><a id="line.11218">     * points in both views to the same y-coordinate (which is required by most of stereo correspondence</a>
<span class="sourceLineNo">11219</span><a id="line.11219">     * algorithms), and may be to the same x-coordinate too. So, you can form the new camera matrix for</a>
<span class="sourceLineNo">11220</span><a id="line.11220">     * each view where the principal points are located at the center.</a>
<span class="sourceLineNo">11221</span><a id="line.11221">     *</a>
<span class="sourceLineNo">11222</span><a id="line.11222">     * @param cameraMatrix Input camera matrix.</a>
<span class="sourceLineNo">11223</span><a id="line.11223">     * @param imgsize Camera view image size in pixels.</a>
<span class="sourceLineNo">11224</span><a id="line.11224">     * parameter indicates whether this location should be at the image center or not.</a>
<span class="sourceLineNo">11225</span><a id="line.11225">     * @return automatically generated</a>
<span class="sourceLineNo">11226</span><a id="line.11226">     */</a>
<span class="sourceLineNo">11227</span><a id="line.11227">    public static Mat getDefaultNewCameraMatrix(Mat cameraMatrix, Size imgsize) {</a>
<span class="sourceLineNo">11228</span><a id="line.11228">        return new Mat(getDefaultNewCameraMatrix_1(cameraMatrix.nativeObj, imgsize.width, imgsize.height));</a>
<span class="sourceLineNo">11229</span><a id="line.11229">    }</a>
<span class="sourceLineNo">11230</span><a id="line.11230"></a>
<span class="sourceLineNo">11231</span><a id="line.11231">    /**</a>
<span class="sourceLineNo">11232</span><a id="line.11232">     * Returns the default new camera matrix.</a>
<span class="sourceLineNo">11233</span><a id="line.11233">     *</a>
<span class="sourceLineNo">11234</span><a id="line.11234">     * The function returns the camera matrix that is either an exact copy of the input cameraMatrix (when</a>
<span class="sourceLineNo">11235</span><a id="line.11235">     * centerPrinicipalPoint=false ), or the modified one (when centerPrincipalPoint=true).</a>
<span class="sourceLineNo">11236</span><a id="line.11236">     *</a>
<span class="sourceLineNo">11237</span><a id="line.11237">     * In the latter case, the new camera matrix will be:</a>
<span class="sourceLineNo">11238</span><a id="line.11238">     *</a>
<span class="sourceLineNo">11239</span><a id="line.11239">     * \(\begin{bmatrix} f_x &amp;amp;&amp;amp; 0 &amp;amp;&amp;amp; ( \texttt{imgSize.width} -1)*0.5  \\ 0 &amp;amp;&amp;amp; f_y &amp;amp;&amp;amp; ( \texttt{imgSize.height} -1)*0.5  \\ 0 &amp;amp;&amp;amp; 0 &amp;amp;&amp;amp; 1 \end{bmatrix} ,\)</a>
<span class="sourceLineNo">11240</span><a id="line.11240">     *</a>
<span class="sourceLineNo">11241</span><a id="line.11241">     * where \(f_x\) and \(f_y\) are \((0,0)\) and \((1,1)\) elements of cameraMatrix, respectively.</a>
<span class="sourceLineNo">11242</span><a id="line.11242">     *</a>
<span class="sourceLineNo">11243</span><a id="line.11243">     * By default, the undistortion functions in OpenCV (see #initUndistortRectifyMap, #undistort) do not</a>
<span class="sourceLineNo">11244</span><a id="line.11244">     * move the principal point. However, when you work with stereo, it is important to move the principal</a>
<span class="sourceLineNo">11245</span><a id="line.11245">     * points in both views to the same y-coordinate (which is required by most of stereo correspondence</a>
<span class="sourceLineNo">11246</span><a id="line.11246">     * algorithms), and may be to the same x-coordinate too. So, you can form the new camera matrix for</a>
<span class="sourceLineNo">11247</span><a id="line.11247">     * each view where the principal points are located at the center.</a>
<span class="sourceLineNo">11248</span><a id="line.11248">     *</a>
<span class="sourceLineNo">11249</span><a id="line.11249">     * @param cameraMatrix Input camera matrix.</a>
<span class="sourceLineNo">11250</span><a id="line.11250">     * parameter indicates whether this location should be at the image center or not.</a>
<span class="sourceLineNo">11251</span><a id="line.11251">     * @return automatically generated</a>
<span class="sourceLineNo">11252</span><a id="line.11252">     */</a>
<span class="sourceLineNo">11253</span><a id="line.11253">    public static Mat getDefaultNewCameraMatrix(Mat cameraMatrix) {</a>
<span class="sourceLineNo">11254</span><a id="line.11254">        return new Mat(getDefaultNewCameraMatrix_2(cameraMatrix.nativeObj));</a>
<span class="sourceLineNo">11255</span><a id="line.11255">    }</a>
<span class="sourceLineNo">11256</span><a id="line.11256"></a>
<span class="sourceLineNo">11257</span><a id="line.11257"></a>
<span class="sourceLineNo">11258</span><a id="line.11258">    //</a>
<span class="sourceLineNo">11259</span><a id="line.11259">    // C++:  void cv::undistortPoints(vector_Point2f src, vector_Point2f&amp; dst, Mat cameraMatrix, Mat distCoeffs, Mat R = Mat(), Mat P = Mat())</a>
<span class="sourceLineNo">11260</span><a id="line.11260">    //</a>
<span class="sourceLineNo">11261</span><a id="line.11261"></a>
<span class="sourceLineNo">11262</span><a id="line.11262">    /**</a>
<span class="sourceLineNo">11263</span><a id="line.11263">     * Computes the ideal point coordinates from the observed point coordinates.</a>
<span class="sourceLineNo">11264</span><a id="line.11264">     *</a>
<span class="sourceLineNo">11265</span><a id="line.11265">     * The function is similar to #undistort and #initUndistortRectifyMap but it operates on a</a>
<span class="sourceLineNo">11266</span><a id="line.11266">     * sparse set of points instead of a raster image. Also the function performs a reverse transformation</a>
<span class="sourceLineNo">11267</span><a id="line.11267">     * to projectPoints. In case of a 3D object, it does not reconstruct its 3D coordinates, but for a</a>
<span class="sourceLineNo">11268</span><a id="line.11268">     * planar object, it does, up to a translation vector, if the proper R is specified.</a>
<span class="sourceLineNo">11269</span><a id="line.11269">     *</a>
<span class="sourceLineNo">11270</span><a id="line.11270">     * For each observed point coordinate \((u, v)\) the function computes:</a>
<span class="sourceLineNo">11271</span><a id="line.11271">     * \(</a>
<span class="sourceLineNo">11272</span><a id="line.11272">     * \begin{array}{l}</a>
<span class="sourceLineNo">11273</span><a id="line.11273">     * x^{"}  \leftarrow (u - c_x)/f_x  \\</a>
<span class="sourceLineNo">11274</span><a id="line.11274">     * y^{"}  \leftarrow (v - c_y)/f_y  \\</a>
<span class="sourceLineNo">11275</span><a id="line.11275">     * (x',y') = undistort(x^{"},y^{"}, \texttt{distCoeffs}) \\</a>
<span class="sourceLineNo">11276</span><a id="line.11276">     * {[X\,Y\,W]} ^T  \leftarrow R*[x' \, y' \, 1]^T  \\</a>
<span class="sourceLineNo">11277</span><a id="line.11277">     * x  \leftarrow X/W  \\</a>
<span class="sourceLineNo">11278</span><a id="line.11278">     * y  \leftarrow Y/W  \\</a>
<span class="sourceLineNo">11279</span><a id="line.11279">     * \text{only performed if P is specified:} \\</a>
<span class="sourceLineNo">11280</span><a id="line.11280">     * u'  \leftarrow x {f'}_x + {c'}_x  \\</a>
<span class="sourceLineNo">11281</span><a id="line.11281">     * v'  \leftarrow y {f'}_y + {c'}_y</a>
<span class="sourceLineNo">11282</span><a id="line.11282">     * \end{array}</a>
<span class="sourceLineNo">11283</span><a id="line.11283">     * \)</a>
<span class="sourceLineNo">11284</span><a id="line.11284">     *</a>
<span class="sourceLineNo">11285</span><a id="line.11285">     * where *undistort* is an approximate iterative algorithm that estimates the normalized original</a>
<span class="sourceLineNo">11286</span><a id="line.11286">     * point coordinates out of the normalized distorted point coordinates ("normalized" means that the</a>
<span class="sourceLineNo">11287</span><a id="line.11287">     * coordinates do not depend on the camera matrix).</a>
<span class="sourceLineNo">11288</span><a id="line.11288">     *</a>
<span class="sourceLineNo">11289</span><a id="line.11289">     * The function can be used for both a stereo camera head or a monocular camera (when R is empty).</a>
<span class="sourceLineNo">11290</span><a id="line.11290">     * @param src Observed point coordinates, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel (CV_32FC2 or CV_64FC2) (or</a>
<span class="sourceLineNo">11291</span><a id="line.11291">     * vector&amp;lt;Point2f&amp;gt; ).</a>
<span class="sourceLineNo">11292</span><a id="line.11292">     * @param dst Output ideal point coordinates (1xN/Nx1 2-channel or vector&amp;lt;Point2f&amp;gt; ) after undistortion and reverse perspective</a>
<span class="sourceLineNo">11293</span><a id="line.11293">     * transformation. If matrix P is identity or omitted, dst will contain normalized point coordinates.</a>
<span class="sourceLineNo">11294</span><a id="line.11294">     * @param cameraMatrix Camera matrix \(\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</a>
<span class="sourceLineNo">11295</span><a id="line.11295">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">11296</span><a id="line.11296">     * \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)</a>
<span class="sourceLineNo">11297</span><a id="line.11297">     * of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</a>
<span class="sourceLineNo">11298</span><a id="line.11298">     * @param R Rectification transformation in the object space (3x3 matrix). R1 or R2 computed by</a>
<span class="sourceLineNo">11299</span><a id="line.11299">     * #stereoRectify can be passed here. If the matrix is empty, the identity transformation is used.</a>
<span class="sourceLineNo">11300</span><a id="line.11300">     * @param P New camera matrix (3x3) or new projection matrix (3x4) \(\begin{bmatrix} {f'}_x &amp;amp; 0 &amp;amp; {c'}_x &amp;amp; t_x \\ 0 &amp;amp; {f'}_y &amp;amp; {c'}_y &amp;amp; t_y \\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; t_z \end{bmatrix}\). P1 or P2 computed by</a>
<span class="sourceLineNo">11301</span><a id="line.11301">     * #stereoRectify can be passed here. If the matrix is empty, the identity new camera matrix is used.</a>
<span class="sourceLineNo">11302</span><a id="line.11302">     */</a>
<span class="sourceLineNo">11303</span><a id="line.11303">    public static void undistortPoints(MatOfPoint2f src, MatOfPoint2f dst, Mat cameraMatrix, Mat distCoeffs, Mat R, Mat P) {</a>
<span class="sourceLineNo">11304</span><a id="line.11304">        Mat src_mat = src;</a>
<span class="sourceLineNo">11305</span><a id="line.11305">        Mat dst_mat = dst;</a>
<span class="sourceLineNo">11306</span><a id="line.11306">        undistortPoints_0(src_mat.nativeObj, dst_mat.nativeObj, cameraMatrix.nativeObj, distCoeffs.nativeObj, R.nativeObj, P.nativeObj);</a>
<span class="sourceLineNo">11307</span><a id="line.11307">    }</a>
<span class="sourceLineNo">11308</span><a id="line.11308"></a>
<span class="sourceLineNo">11309</span><a id="line.11309">    /**</a>
<span class="sourceLineNo">11310</span><a id="line.11310">     * Computes the ideal point coordinates from the observed point coordinates.</a>
<span class="sourceLineNo">11311</span><a id="line.11311">     *</a>
<span class="sourceLineNo">11312</span><a id="line.11312">     * The function is similar to #undistort and #initUndistortRectifyMap but it operates on a</a>
<span class="sourceLineNo">11313</span><a id="line.11313">     * sparse set of points instead of a raster image. Also the function performs a reverse transformation</a>
<span class="sourceLineNo">11314</span><a id="line.11314">     * to projectPoints. In case of a 3D object, it does not reconstruct its 3D coordinates, but for a</a>
<span class="sourceLineNo">11315</span><a id="line.11315">     * planar object, it does, up to a translation vector, if the proper R is specified.</a>
<span class="sourceLineNo">11316</span><a id="line.11316">     *</a>
<span class="sourceLineNo">11317</span><a id="line.11317">     * For each observed point coordinate \((u, v)\) the function computes:</a>
<span class="sourceLineNo">11318</span><a id="line.11318">     * \(</a>
<span class="sourceLineNo">11319</span><a id="line.11319">     * \begin{array}{l}</a>
<span class="sourceLineNo">11320</span><a id="line.11320">     * x^{"}  \leftarrow (u - c_x)/f_x  \\</a>
<span class="sourceLineNo">11321</span><a id="line.11321">     * y^{"}  \leftarrow (v - c_y)/f_y  \\</a>
<span class="sourceLineNo">11322</span><a id="line.11322">     * (x',y') = undistort(x^{"},y^{"}, \texttt{distCoeffs}) \\</a>
<span class="sourceLineNo">11323</span><a id="line.11323">     * {[X\,Y\,W]} ^T  \leftarrow R*[x' \, y' \, 1]^T  \\</a>
<span class="sourceLineNo">11324</span><a id="line.11324">     * x  \leftarrow X/W  \\</a>
<span class="sourceLineNo">11325</span><a id="line.11325">     * y  \leftarrow Y/W  \\</a>
<span class="sourceLineNo">11326</span><a id="line.11326">     * \text{only performed if P is specified:} \\</a>
<span class="sourceLineNo">11327</span><a id="line.11327">     * u'  \leftarrow x {f'}_x + {c'}_x  \\</a>
<span class="sourceLineNo">11328</span><a id="line.11328">     * v'  \leftarrow y {f'}_y + {c'}_y</a>
<span class="sourceLineNo">11329</span><a id="line.11329">     * \end{array}</a>
<span class="sourceLineNo">11330</span><a id="line.11330">     * \)</a>
<span class="sourceLineNo">11331</span><a id="line.11331">     *</a>
<span class="sourceLineNo">11332</span><a id="line.11332">     * where *undistort* is an approximate iterative algorithm that estimates the normalized original</a>
<span class="sourceLineNo">11333</span><a id="line.11333">     * point coordinates out of the normalized distorted point coordinates ("normalized" means that the</a>
<span class="sourceLineNo">11334</span><a id="line.11334">     * coordinates do not depend on the camera matrix).</a>
<span class="sourceLineNo">11335</span><a id="line.11335">     *</a>
<span class="sourceLineNo">11336</span><a id="line.11336">     * The function can be used for both a stereo camera head or a monocular camera (when R is empty).</a>
<span class="sourceLineNo">11337</span><a id="line.11337">     * @param src Observed point coordinates, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel (CV_32FC2 or CV_64FC2) (or</a>
<span class="sourceLineNo">11338</span><a id="line.11338">     * vector&amp;lt;Point2f&amp;gt; ).</a>
<span class="sourceLineNo">11339</span><a id="line.11339">     * @param dst Output ideal point coordinates (1xN/Nx1 2-channel or vector&amp;lt;Point2f&amp;gt; ) after undistortion and reverse perspective</a>
<span class="sourceLineNo">11340</span><a id="line.11340">     * transformation. If matrix P is identity or omitted, dst will contain normalized point coordinates.</a>
<span class="sourceLineNo">11341</span><a id="line.11341">     * @param cameraMatrix Camera matrix \(\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</a>
<span class="sourceLineNo">11342</span><a id="line.11342">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">11343</span><a id="line.11343">     * \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)</a>
<span class="sourceLineNo">11344</span><a id="line.11344">     * of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</a>
<span class="sourceLineNo">11345</span><a id="line.11345">     * @param R Rectification transformation in the object space (3x3 matrix). R1 or R2 computed by</a>
<span class="sourceLineNo">11346</span><a id="line.11346">     * #stereoRectify can be passed here. If the matrix is empty, the identity transformation is used.</a>
<span class="sourceLineNo">11347</span><a id="line.11347">     * #stereoRectify can be passed here. If the matrix is empty, the identity new camera matrix is used.</a>
<span class="sourceLineNo">11348</span><a id="line.11348">     */</a>
<span class="sourceLineNo">11349</span><a id="line.11349">    public static void undistortPoints(MatOfPoint2f src, MatOfPoint2f dst, Mat cameraMatrix, Mat distCoeffs, Mat R) {</a>
<span class="sourceLineNo">11350</span><a id="line.11350">        Mat src_mat = src;</a>
<span class="sourceLineNo">11351</span><a id="line.11351">        Mat dst_mat = dst;</a>
<span class="sourceLineNo">11352</span><a id="line.11352">        undistortPoints_1(src_mat.nativeObj, dst_mat.nativeObj, cameraMatrix.nativeObj, distCoeffs.nativeObj, R.nativeObj);</a>
<span class="sourceLineNo">11353</span><a id="line.11353">    }</a>
<span class="sourceLineNo">11354</span><a id="line.11354"></a>
<span class="sourceLineNo">11355</span><a id="line.11355">    /**</a>
<span class="sourceLineNo">11356</span><a id="line.11356">     * Computes the ideal point coordinates from the observed point coordinates.</a>
<span class="sourceLineNo">11357</span><a id="line.11357">     *</a>
<span class="sourceLineNo">11358</span><a id="line.11358">     * The function is similar to #undistort and #initUndistortRectifyMap but it operates on a</a>
<span class="sourceLineNo">11359</span><a id="line.11359">     * sparse set of points instead of a raster image. Also the function performs a reverse transformation</a>
<span class="sourceLineNo">11360</span><a id="line.11360">     * to projectPoints. In case of a 3D object, it does not reconstruct its 3D coordinates, but for a</a>
<span class="sourceLineNo">11361</span><a id="line.11361">     * planar object, it does, up to a translation vector, if the proper R is specified.</a>
<span class="sourceLineNo">11362</span><a id="line.11362">     *</a>
<span class="sourceLineNo">11363</span><a id="line.11363">     * For each observed point coordinate \((u, v)\) the function computes:</a>
<span class="sourceLineNo">11364</span><a id="line.11364">     * \(</a>
<span class="sourceLineNo">11365</span><a id="line.11365">     * \begin{array}{l}</a>
<span class="sourceLineNo">11366</span><a id="line.11366">     * x^{"}  \leftarrow (u - c_x)/f_x  \\</a>
<span class="sourceLineNo">11367</span><a id="line.11367">     * y^{"}  \leftarrow (v - c_y)/f_y  \\</a>
<span class="sourceLineNo">11368</span><a id="line.11368">     * (x',y') = undistort(x^{"},y^{"}, \texttt{distCoeffs}) \\</a>
<span class="sourceLineNo">11369</span><a id="line.11369">     * {[X\,Y\,W]} ^T  \leftarrow R*[x' \, y' \, 1]^T  \\</a>
<span class="sourceLineNo">11370</span><a id="line.11370">     * x  \leftarrow X/W  \\</a>
<span class="sourceLineNo">11371</span><a id="line.11371">     * y  \leftarrow Y/W  \\</a>
<span class="sourceLineNo">11372</span><a id="line.11372">     * \text{only performed if P is specified:} \\</a>
<span class="sourceLineNo">11373</span><a id="line.11373">     * u'  \leftarrow x {f'}_x + {c'}_x  \\</a>
<span class="sourceLineNo">11374</span><a id="line.11374">     * v'  \leftarrow y {f'}_y + {c'}_y</a>
<span class="sourceLineNo">11375</span><a id="line.11375">     * \end{array}</a>
<span class="sourceLineNo">11376</span><a id="line.11376">     * \)</a>
<span class="sourceLineNo">11377</span><a id="line.11377">     *</a>
<span class="sourceLineNo">11378</span><a id="line.11378">     * where *undistort* is an approximate iterative algorithm that estimates the normalized original</a>
<span class="sourceLineNo">11379</span><a id="line.11379">     * point coordinates out of the normalized distorted point coordinates ("normalized" means that the</a>
<span class="sourceLineNo">11380</span><a id="line.11380">     * coordinates do not depend on the camera matrix).</a>
<span class="sourceLineNo">11381</span><a id="line.11381">     *</a>
<span class="sourceLineNo">11382</span><a id="line.11382">     * The function can be used for both a stereo camera head or a monocular camera (when R is empty).</a>
<span class="sourceLineNo">11383</span><a id="line.11383">     * @param src Observed point coordinates, 2xN/Nx2 1-channel or 1xN/Nx1 2-channel (CV_32FC2 or CV_64FC2) (or</a>
<span class="sourceLineNo">11384</span><a id="line.11384">     * vector&amp;lt;Point2f&amp;gt; ).</a>
<span class="sourceLineNo">11385</span><a id="line.11385">     * @param dst Output ideal point coordinates (1xN/Nx1 2-channel or vector&amp;lt;Point2f&amp;gt; ) after undistortion and reverse perspective</a>
<span class="sourceLineNo">11386</span><a id="line.11386">     * transformation. If matrix P is identity or omitted, dst will contain normalized point coordinates.</a>
<span class="sourceLineNo">11387</span><a id="line.11387">     * @param cameraMatrix Camera matrix \(\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\) .</a>
<span class="sourceLineNo">11388</span><a id="line.11388">     * @param distCoeffs Input vector of distortion coefficients</a>
<span class="sourceLineNo">11389</span><a id="line.11389">     * \((k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6[, s_1, s_2, s_3, s_4[, \tau_x, \tau_y]]]])\)</a>
<span class="sourceLineNo">11390</span><a id="line.11390">     * of 4, 5, 8, 12 or 14 elements. If the vector is NULL/empty, the zero distortion coefficients are assumed.</a>
<span class="sourceLineNo">11391</span><a id="line.11391">     * #stereoRectify can be passed here. If the matrix is empty, the identity transformation is used.</a>
<span class="sourceLineNo">11392</span><a id="line.11392">     * #stereoRectify can be passed here. If the matrix is empty, the identity new camera matrix is used.</a>
<span class="sourceLineNo">11393</span><a id="line.11393">     */</a>
<span class="sourceLineNo">11394</span><a id="line.11394">    public static void undistortPoints(MatOfPoint2f src, MatOfPoint2f dst, Mat cameraMatrix, Mat distCoeffs) {</a>
<span class="sourceLineNo">11395</span><a id="line.11395">        Mat src_mat = src;</a>
<span class="sourceLineNo">11396</span><a id="line.11396">        Mat dst_mat = dst;</a>
<span class="sourceLineNo">11397</span><a id="line.11397">        undistortPoints_2(src_mat.nativeObj, dst_mat.nativeObj, cameraMatrix.nativeObj, distCoeffs.nativeObj);</a>
<span class="sourceLineNo">11398</span><a id="line.11398">    }</a>
<span class="sourceLineNo">11399</span><a id="line.11399"></a>
<span class="sourceLineNo">11400</span><a id="line.11400"></a>
<span class="sourceLineNo">11401</span><a id="line.11401">    //</a>
<span class="sourceLineNo">11402</span><a id="line.11402">    // C++:  void cv::undistortPoints(Mat src, Mat&amp; dst, Mat cameraMatrix, Mat distCoeffs, Mat R, Mat P, TermCriteria criteria)</a>
<span class="sourceLineNo">11403</span><a id="line.11403">    //</a>
<span class="sourceLineNo">11404</span><a id="line.11404"></a>
<span class="sourceLineNo">11405</span><a id="line.11405">    /**</a>
<span class="sourceLineNo">11406</span><a id="line.11406">     *</a>
<span class="sourceLineNo">11407</span><a id="line.11407">     *     &lt;b&gt;Note:&lt;/b&gt; Default version of #undistortPoints does 5 iterations to compute undistorted points.</a>
<span class="sourceLineNo">11408</span><a id="line.11408">     * @param src automatically generated</a>
<span class="sourceLineNo">11409</span><a id="line.11409">     * @param dst automatically generated</a>
<span class="sourceLineNo">11410</span><a id="line.11410">     * @param cameraMatrix automatically generated</a>
<span class="sourceLineNo">11411</span><a id="line.11411">     * @param distCoeffs automatically generated</a>
<span class="sourceLineNo">11412</span><a id="line.11412">     * @param R automatically generated</a>
<span class="sourceLineNo">11413</span><a id="line.11413">     * @param P automatically generated</a>
<span class="sourceLineNo">11414</span><a id="line.11414">     * @param criteria automatically generated</a>
<span class="sourceLineNo">11415</span><a id="line.11415">     */</a>
<span class="sourceLineNo">11416</span><a id="line.11416">    public static void undistortPointsIter(Mat src, Mat dst, Mat cameraMatrix, Mat distCoeffs, Mat R, Mat P, TermCriteria criteria) {</a>
<span class="sourceLineNo">11417</span><a id="line.11417">        undistortPointsIter_0(src.nativeObj, dst.nativeObj, cameraMatrix.nativeObj, distCoeffs.nativeObj, R.nativeObj, P.nativeObj, criteria.type, criteria.maxCount, criteria.epsilon);</a>
<span class="sourceLineNo">11418</span><a id="line.11418">    }</a>
<span class="sourceLineNo">11419</span><a id="line.11419"></a>
<span class="sourceLineNo">11420</span><a id="line.11420"></a>
<span class="sourceLineNo">11421</span><a id="line.11421">    //</a>
<span class="sourceLineNo">11422</span><a id="line.11422">    // C++:  void cv::fisheye::projectPoints(Mat objectPoints, Mat&amp; imagePoints, Mat rvec, Mat tvec, Mat K, Mat D, double alpha = 0, Mat&amp; jacobian = Mat())</a>
<span class="sourceLineNo">11423</span><a id="line.11423">    //</a>
<span class="sourceLineNo">11424</span><a id="line.11424"></a>
<span class="sourceLineNo">11425</span><a id="line.11425">    public static void fisheye_projectPoints(Mat objectPoints, Mat imagePoints, Mat rvec, Mat tvec, Mat K, Mat D, double alpha, Mat jacobian) {</a>
<span class="sourceLineNo">11426</span><a id="line.11426">        fisheye_projectPoints_0(objectPoints.nativeObj, imagePoints.nativeObj, rvec.nativeObj, tvec.nativeObj, K.nativeObj, D.nativeObj, alpha, jacobian.nativeObj);</a>
<span class="sourceLineNo">11427</span><a id="line.11427">    }</a>
<span class="sourceLineNo">11428</span><a id="line.11428"></a>
<span class="sourceLineNo">11429</span><a id="line.11429">    public static void fisheye_projectPoints(Mat objectPoints, Mat imagePoints, Mat rvec, Mat tvec, Mat K, Mat D, double alpha) {</a>
<span class="sourceLineNo">11430</span><a id="line.11430">        fisheye_projectPoints_1(objectPoints.nativeObj, imagePoints.nativeObj, rvec.nativeObj, tvec.nativeObj, K.nativeObj, D.nativeObj, alpha);</a>
<span class="sourceLineNo">11431</span><a id="line.11431">    }</a>
<span class="sourceLineNo">11432</span><a id="line.11432"></a>
<span class="sourceLineNo">11433</span><a id="line.11433">    public static void fisheye_projectPoints(Mat objectPoints, Mat imagePoints, Mat rvec, Mat tvec, Mat K, Mat D) {</a>
<span class="sourceLineNo">11434</span><a id="line.11434">        fisheye_projectPoints_2(objectPoints.nativeObj, imagePoints.nativeObj, rvec.nativeObj, tvec.nativeObj, K.nativeObj, D.nativeObj);</a>
<span class="sourceLineNo">11435</span><a id="line.11435">    }</a>
<span class="sourceLineNo">11436</span><a id="line.11436"></a>
<span class="sourceLineNo">11437</span><a id="line.11437"></a>
<span class="sourceLineNo">11438</span><a id="line.11438">    //</a>
<span class="sourceLineNo">11439</span><a id="line.11439">    // C++:  void cv::fisheye::distortPoints(Mat undistorted, Mat&amp; distorted, Mat K, Mat D, double alpha = 0)</a>
<span class="sourceLineNo">11440</span><a id="line.11440">    //</a>
<span class="sourceLineNo">11441</span><a id="line.11441"></a>
<span class="sourceLineNo">11442</span><a id="line.11442">    /**</a>
<span class="sourceLineNo">11443</span><a id="line.11443">     * Distorts 2D points using fisheye model.</a>
<span class="sourceLineNo">11444</span><a id="line.11444">     *</a>
<span class="sourceLineNo">11445</span><a id="line.11445">     *     @param undistorted Array of object points, 1xN/Nx1 2-channel (or vector&amp;lt;Point2f&amp;gt; ), where N is</a>
<span class="sourceLineNo">11446</span><a id="line.11446">     *     the number of points in the view.</a>
<span class="sourceLineNo">11447</span><a id="line.11447">     *     @param K Camera intrinsic matrix \(cameramatrix{K}\).</a>
<span class="sourceLineNo">11448</span><a id="line.11448">     *     @param D Input vector of distortion coefficients \(\distcoeffsfisheye\).</a>
<span class="sourceLineNo">11449</span><a id="line.11449">     *     @param alpha The skew coefficient.</a>
<span class="sourceLineNo">11450</span><a id="line.11450">     *     @param distorted Output array of image points, 1xN/Nx1 2-channel, or vector&amp;lt;Point2f&amp;gt; .</a>
<span class="sourceLineNo">11451</span><a id="line.11451">     *</a>
<span class="sourceLineNo">11452</span><a id="line.11452">     *     Note that the function assumes the camera intrinsic matrix of the undistorted points to be identity.</a>
<span class="sourceLineNo">11453</span><a id="line.11453">     *     This means if you want to transform back points undistorted with undistortPoints() you have to</a>
<span class="sourceLineNo">11454</span><a id="line.11454">     *     multiply them with \(P^{-1}\).</a>
<span class="sourceLineNo">11455</span><a id="line.11455">     */</a>
<span class="sourceLineNo">11456</span><a id="line.11456">    public static void fisheye_distortPoints(Mat undistorted, Mat distorted, Mat K, Mat D, double alpha) {</a>
<span class="sourceLineNo">11457</span><a id="line.11457">        fisheye_distortPoints_0(undistorted.nativeObj, distorted.nativeObj, K.nativeObj, D.nativeObj, alpha);</a>
<span class="sourceLineNo">11458</span><a id="line.11458">    }</a>
<span class="sourceLineNo">11459</span><a id="line.11459"></a>
<span class="sourceLineNo">11460</span><a id="line.11460">    /**</a>
<span class="sourceLineNo">11461</span><a id="line.11461">     * Distorts 2D points using fisheye model.</a>
<span class="sourceLineNo">11462</span><a id="line.11462">     *</a>
<span class="sourceLineNo">11463</span><a id="line.11463">     *     @param undistorted Array of object points, 1xN/Nx1 2-channel (or vector&amp;lt;Point2f&amp;gt; ), where N is</a>
<span class="sourceLineNo">11464</span><a id="line.11464">     *     the number of points in the view.</a>
<span class="sourceLineNo">11465</span><a id="line.11465">     *     @param K Camera intrinsic matrix \(cameramatrix{K}\).</a>
<span class="sourceLineNo">11466</span><a id="line.11466">     *     @param D Input vector of distortion coefficients \(\distcoeffsfisheye\).</a>
<span class="sourceLineNo">11467</span><a id="line.11467">     *     @param distorted Output array of image points, 1xN/Nx1 2-channel, or vector&amp;lt;Point2f&amp;gt; .</a>
<span class="sourceLineNo">11468</span><a id="line.11468">     *</a>
<span class="sourceLineNo">11469</span><a id="line.11469">     *     Note that the function assumes the camera intrinsic matrix of the undistorted points to be identity.</a>
<span class="sourceLineNo">11470</span><a id="line.11470">     *     This means if you want to transform back points undistorted with undistortPoints() you have to</a>
<span class="sourceLineNo">11471</span><a id="line.11471">     *     multiply them with \(P^{-1}\).</a>
<span class="sourceLineNo">11472</span><a id="line.11472">     */</a>
<span class="sourceLineNo">11473</span><a id="line.11473">    public static void fisheye_distortPoints(Mat undistorted, Mat distorted, Mat K, Mat D) {</a>
<span class="sourceLineNo">11474</span><a id="line.11474">        fisheye_distortPoints_1(undistorted.nativeObj, distorted.nativeObj, K.nativeObj, D.nativeObj);</a>
<span class="sourceLineNo">11475</span><a id="line.11475">    }</a>
<span class="sourceLineNo">11476</span><a id="line.11476"></a>
<span class="sourceLineNo">11477</span><a id="line.11477"></a>
<span class="sourceLineNo">11478</span><a id="line.11478">    //</a>
<span class="sourceLineNo">11479</span><a id="line.11479">    // C++:  void cv::fisheye::undistortPoints(Mat distorted, Mat&amp; undistorted, Mat K, Mat D, Mat R = Mat(), Mat P = Mat())</a>
<span class="sourceLineNo">11480</span><a id="line.11480">    //</a>
<span class="sourceLineNo">11481</span><a id="line.11481"></a>
<span class="sourceLineNo">11482</span><a id="line.11482">    /**</a>
<span class="sourceLineNo">11483</span><a id="line.11483">     * Undistorts 2D points using fisheye model</a>
<span class="sourceLineNo">11484</span><a id="line.11484">     *</a>
<span class="sourceLineNo">11485</span><a id="line.11485">     *     @param distorted Array of object points, 1xN/Nx1 2-channel (or vector&amp;lt;Point2f&amp;gt; ), where N is the</a>
<span class="sourceLineNo">11486</span><a id="line.11486">     *     number of points in the view.</a>
<span class="sourceLineNo">11487</span><a id="line.11487">     *     @param K Camera intrinsic matrix \(cameramatrix{K}\).</a>
<span class="sourceLineNo">11488</span><a id="line.11488">     *     @param D Input vector of distortion coefficients \(\distcoeffsfisheye\).</a>
<span class="sourceLineNo">11489</span><a id="line.11489">     *     @param R Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3</a>
<span class="sourceLineNo">11490</span><a id="line.11490">     *     1-channel or 1x1 3-channel</a>
<span class="sourceLineNo">11491</span><a id="line.11491">     *     @param P New camera intrinsic matrix (3x3) or new projection matrix (3x4)</a>
<span class="sourceLineNo">11492</span><a id="line.11492">     *     @param undistorted Output array of image points, 1xN/Nx1 2-channel, or vector&amp;lt;Point2f&amp;gt; .</a>
<span class="sourceLineNo">11493</span><a id="line.11493">     */</a>
<span class="sourceLineNo">11494</span><a id="line.11494">    public static void fisheye_undistortPoints(Mat distorted, Mat undistorted, Mat K, Mat D, Mat R, Mat P) {</a>
<span class="sourceLineNo">11495</span><a id="line.11495">        fisheye_undistortPoints_0(distorted.nativeObj, undistorted.nativeObj, K.nativeObj, D.nativeObj, R.nativeObj, P.nativeObj);</a>
<span class="sourceLineNo">11496</span><a id="line.11496">    }</a>
<span class="sourceLineNo">11497</span><a id="line.11497"></a>
<span class="sourceLineNo">11498</span><a id="line.11498">    /**</a>
<span class="sourceLineNo">11499</span><a id="line.11499">     * Undistorts 2D points using fisheye model</a>
<span class="sourceLineNo">11500</span><a id="line.11500">     *</a>
<span class="sourceLineNo">11501</span><a id="line.11501">     *     @param distorted Array of object points, 1xN/Nx1 2-channel (or vector&amp;lt;Point2f&amp;gt; ), where N is the</a>
<span class="sourceLineNo">11502</span><a id="line.11502">     *     number of points in the view.</a>
<span class="sourceLineNo">11503</span><a id="line.11503">     *     @param K Camera intrinsic matrix \(cameramatrix{K}\).</a>
<span class="sourceLineNo">11504</span><a id="line.11504">     *     @param D Input vector of distortion coefficients \(\distcoeffsfisheye\).</a>
<span class="sourceLineNo">11505</span><a id="line.11505">     *     @param R Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3</a>
<span class="sourceLineNo">11506</span><a id="line.11506">     *     1-channel or 1x1 3-channel</a>
<span class="sourceLineNo">11507</span><a id="line.11507">     *     @param undistorted Output array of image points, 1xN/Nx1 2-channel, or vector&amp;lt;Point2f&amp;gt; .</a>
<span class="sourceLineNo">11508</span><a id="line.11508">     */</a>
<span class="sourceLineNo">11509</span><a id="line.11509">    public static void fisheye_undistortPoints(Mat distorted, Mat undistorted, Mat K, Mat D, Mat R) {</a>
<span class="sourceLineNo">11510</span><a id="line.11510">        fisheye_undistortPoints_1(distorted.nativeObj, undistorted.nativeObj, K.nativeObj, D.nativeObj, R.nativeObj);</a>
<span class="sourceLineNo">11511</span><a id="line.11511">    }</a>
<span class="sourceLineNo">11512</span><a id="line.11512"></a>
<span class="sourceLineNo">11513</span><a id="line.11513">    /**</a>
<span class="sourceLineNo">11514</span><a id="line.11514">     * Undistorts 2D points using fisheye model</a>
<span class="sourceLineNo">11515</span><a id="line.11515">     *</a>
<span class="sourceLineNo">11516</span><a id="line.11516">     *     @param distorted Array of object points, 1xN/Nx1 2-channel (or vector&amp;lt;Point2f&amp;gt; ), where N is the</a>
<span class="sourceLineNo">11517</span><a id="line.11517">     *     number of points in the view.</a>
<span class="sourceLineNo">11518</span><a id="line.11518">     *     @param K Camera intrinsic matrix \(cameramatrix{K}\).</a>
<span class="sourceLineNo">11519</span><a id="line.11519">     *     @param D Input vector of distortion coefficients \(\distcoeffsfisheye\).</a>
<span class="sourceLineNo">11520</span><a id="line.11520">     *     1-channel or 1x1 3-channel</a>
<span class="sourceLineNo">11521</span><a id="line.11521">     *     @param undistorted Output array of image points, 1xN/Nx1 2-channel, or vector&amp;lt;Point2f&amp;gt; .</a>
<span class="sourceLineNo">11522</span><a id="line.11522">     */</a>
<span class="sourceLineNo">11523</span><a id="line.11523">    public static void fisheye_undistortPoints(Mat distorted, Mat undistorted, Mat K, Mat D) {</a>
<span class="sourceLineNo">11524</span><a id="line.11524">        fisheye_undistortPoints_2(distorted.nativeObj, undistorted.nativeObj, K.nativeObj, D.nativeObj);</a>
<span class="sourceLineNo">11525</span><a id="line.11525">    }</a>
<span class="sourceLineNo">11526</span><a id="line.11526"></a>
<span class="sourceLineNo">11527</span><a id="line.11527"></a>
<span class="sourceLineNo">11528</span><a id="line.11528">    //</a>
<span class="sourceLineNo">11529</span><a id="line.11529">    // C++:  void cv::fisheye::initUndistortRectifyMap(Mat K, Mat D, Mat R, Mat P, Size size, int m1type, Mat&amp; map1, Mat&amp; map2)</a>
<span class="sourceLineNo">11530</span><a id="line.11530">    //</a>
<span class="sourceLineNo">11531</span><a id="line.11531"></a>
<span class="sourceLineNo">11532</span><a id="line.11532">    /**</a>
<span class="sourceLineNo">11533</span><a id="line.11533">     * Computes undistortion and rectification maps for image transform by cv::remap(). If D is empty zero</a>
<span class="sourceLineNo">11534</span><a id="line.11534">     *     distortion is used, if R or P is empty identity matrixes are used.</a>
<span class="sourceLineNo">11535</span><a id="line.11535">     *</a>
<span class="sourceLineNo">11536</span><a id="line.11536">     *     @param K Camera intrinsic matrix \(cameramatrix{K}\).</a>
<span class="sourceLineNo">11537</span><a id="line.11537">     *     @param D Input vector of distortion coefficients \(\distcoeffsfisheye\).</a>
<span class="sourceLineNo">11538</span><a id="line.11538">     *     @param R Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3</a>
<span class="sourceLineNo">11539</span><a id="line.11539">     *     1-channel or 1x1 3-channel</a>
<span class="sourceLineNo">11540</span><a id="line.11540">     *     @param P New camera intrinsic matrix (3x3) or new projection matrix (3x4)</a>
<span class="sourceLineNo">11541</span><a id="line.11541">     *     @param size Undistorted image size.</a>
<span class="sourceLineNo">11542</span><a id="line.11542">     *     @param m1type Type of the first output map that can be CV_32FC1 or CV_16SC2 . See convertMaps()</a>
<span class="sourceLineNo">11543</span><a id="line.11543">     *     for details.</a>
<span class="sourceLineNo">11544</span><a id="line.11544">     *     @param map1 The first output map.</a>
<span class="sourceLineNo">11545</span><a id="line.11545">     *     @param map2 The second output map.</a>
<span class="sourceLineNo">11546</span><a id="line.11546">     */</a>
<span class="sourceLineNo">11547</span><a id="line.11547">    public static void fisheye_initUndistortRectifyMap(Mat K, Mat D, Mat R, Mat P, Size size, int m1type, Mat map1, Mat map2) {</a>
<span class="sourceLineNo">11548</span><a id="line.11548">        fisheye_initUndistortRectifyMap_0(K.nativeObj, D.nativeObj, R.nativeObj, P.nativeObj, size.width, size.height, m1type, map1.nativeObj, map2.nativeObj);</a>
<span class="sourceLineNo">11549</span><a id="line.11549">    }</a>
<span class="sourceLineNo">11550</span><a id="line.11550"></a>
<span class="sourceLineNo">11551</span><a id="line.11551"></a>
<span class="sourceLineNo">11552</span><a id="line.11552">    //</a>
<span class="sourceLineNo">11553</span><a id="line.11553">    // C++:  void cv::fisheye::undistortImage(Mat distorted, Mat&amp; undistorted, Mat K, Mat D, Mat Knew = cv::Mat(), Size new_size = Size())</a>
<span class="sourceLineNo">11554</span><a id="line.11554">    //</a>
<span class="sourceLineNo">11555</span><a id="line.11555"></a>
<span class="sourceLineNo">11556</span><a id="line.11556">    /**</a>
<span class="sourceLineNo">11557</span><a id="line.11557">     * Transforms an image to compensate for fisheye lens distortion.</a>
<span class="sourceLineNo">11558</span><a id="line.11558">     *</a>
<span class="sourceLineNo">11559</span><a id="line.11559">     *     @param distorted image with fisheye lens distortion.</a>
<span class="sourceLineNo">11560</span><a id="line.11560">     *     @param undistorted Output image with compensated fisheye lens distortion.</a>
<span class="sourceLineNo">11561</span><a id="line.11561">     *     @param K Camera intrinsic matrix \(cameramatrix{K}\).</a>
<span class="sourceLineNo">11562</span><a id="line.11562">     *     @param D Input vector of distortion coefficients \(\distcoeffsfisheye\).</a>
<span class="sourceLineNo">11563</span><a id="line.11563">     *     @param Knew Camera intrinsic matrix of the distorted image. By default, it is the identity matrix but you</a>
<span class="sourceLineNo">11564</span><a id="line.11564">     *     may additionally scale and shift the result by using a different matrix.</a>
<span class="sourceLineNo">11565</span><a id="line.11565">     *     @param new_size the new size</a>
<span class="sourceLineNo">11566</span><a id="line.11566">     *</a>
<span class="sourceLineNo">11567</span><a id="line.11567">     *     The function transforms an image to compensate radial and tangential lens distortion.</a>
<span class="sourceLineNo">11568</span><a id="line.11568">     *</a>
<span class="sourceLineNo">11569</span><a id="line.11569">     *     The function is simply a combination of fisheye::initUndistortRectifyMap (with unity R ) and remap</a>
<span class="sourceLineNo">11570</span><a id="line.11570">     *     (with bilinear interpolation). See the former function for details of the transformation being</a>
<span class="sourceLineNo">11571</span><a id="line.11571">     *     performed.</a>
<span class="sourceLineNo">11572</span><a id="line.11572">     *</a>
<span class="sourceLineNo">11573</span><a id="line.11573">     *     See below the results of undistortImage.</a>
<span class="sourceLineNo">11574</span><a id="line.11574">     * &lt;ul&gt;</a>
<span class="sourceLineNo">11575</span><a id="line.11575">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11576</span><a id="line.11576">     *           a\) result of undistort of perspective camera model (all possible coefficients (k_1, k_2, k_3,</a>
<span class="sourceLineNo">11577</span><a id="line.11577">     *             k_4, k_5, k_6) of distortion were optimized under calibration)</a>
<span class="sourceLineNo">11578</span><a id="line.11578">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">11579</span><a id="line.11579">     *     &lt;li&gt;</a>
<span class="sourceLineNo">11580</span><a id="line.11580">     *            b\) result of fisheye::undistortImage of fisheye camera model (all possible coefficients (k_1, k_2,</a>
<span class="sourceLineNo">11581</span><a id="line.11581">     *             k_3, k_4) of fisheye distortion were optimized under calibration)</a>
<span class="sourceLineNo">11582</span><a id="line.11582">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">11583</span><a id="line.11583">     *     &lt;li&gt;</a>
<span class="sourceLineNo">11584</span><a id="line.11584">     *            c\) original image was captured with fisheye lens</a>
<span class="sourceLineNo">11585</span><a id="line.11585">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">11586</span><a id="line.11586">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">11587</span><a id="line.11587">     *</a>
<span class="sourceLineNo">11588</span><a id="line.11588">     *     Pictures a) and b) almost the same. But if we consider points of image located far from the center</a>
<span class="sourceLineNo">11589</span><a id="line.11589">     *     of image, we can notice that on image a) these points are distorted.</a>
<span class="sourceLineNo">11590</span><a id="line.11590">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11591</span><a id="line.11591">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">11592</span><a id="line.11592">     *</a>
<span class="sourceLineNo">11593</span><a id="line.11593">     *     ![image](pics/fisheye_undistorted.jpg)</a>
<span class="sourceLineNo">11594</span><a id="line.11594">     */</a>
<span class="sourceLineNo">11595</span><a id="line.11595">    public static void fisheye_undistortImage(Mat distorted, Mat undistorted, Mat K, Mat D, Mat Knew, Size new_size) {</a>
<span class="sourceLineNo">11596</span><a id="line.11596">        fisheye_undistortImage_0(distorted.nativeObj, undistorted.nativeObj, K.nativeObj, D.nativeObj, Knew.nativeObj, new_size.width, new_size.height);</a>
<span class="sourceLineNo">11597</span><a id="line.11597">    }</a>
<span class="sourceLineNo">11598</span><a id="line.11598"></a>
<span class="sourceLineNo">11599</span><a id="line.11599">    /**</a>
<span class="sourceLineNo">11600</span><a id="line.11600">     * Transforms an image to compensate for fisheye lens distortion.</a>
<span class="sourceLineNo">11601</span><a id="line.11601">     *</a>
<span class="sourceLineNo">11602</span><a id="line.11602">     *     @param distorted image with fisheye lens distortion.</a>
<span class="sourceLineNo">11603</span><a id="line.11603">     *     @param undistorted Output image with compensated fisheye lens distortion.</a>
<span class="sourceLineNo">11604</span><a id="line.11604">     *     @param K Camera intrinsic matrix \(cameramatrix{K}\).</a>
<span class="sourceLineNo">11605</span><a id="line.11605">     *     @param D Input vector of distortion coefficients \(\distcoeffsfisheye\).</a>
<span class="sourceLineNo">11606</span><a id="line.11606">     *     @param Knew Camera intrinsic matrix of the distorted image. By default, it is the identity matrix but you</a>
<span class="sourceLineNo">11607</span><a id="line.11607">     *     may additionally scale and shift the result by using a different matrix.</a>
<span class="sourceLineNo">11608</span><a id="line.11608">     *</a>
<span class="sourceLineNo">11609</span><a id="line.11609">     *     The function transforms an image to compensate radial and tangential lens distortion.</a>
<span class="sourceLineNo">11610</span><a id="line.11610">     *</a>
<span class="sourceLineNo">11611</span><a id="line.11611">     *     The function is simply a combination of fisheye::initUndistortRectifyMap (with unity R ) and remap</a>
<span class="sourceLineNo">11612</span><a id="line.11612">     *     (with bilinear interpolation). See the former function for details of the transformation being</a>
<span class="sourceLineNo">11613</span><a id="line.11613">     *     performed.</a>
<span class="sourceLineNo">11614</span><a id="line.11614">     *</a>
<span class="sourceLineNo">11615</span><a id="line.11615">     *     See below the results of undistortImage.</a>
<span class="sourceLineNo">11616</span><a id="line.11616">     * &lt;ul&gt;</a>
<span class="sourceLineNo">11617</span><a id="line.11617">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11618</span><a id="line.11618">     *           a\) result of undistort of perspective camera model (all possible coefficients (k_1, k_2, k_3,</a>
<span class="sourceLineNo">11619</span><a id="line.11619">     *             k_4, k_5, k_6) of distortion were optimized under calibration)</a>
<span class="sourceLineNo">11620</span><a id="line.11620">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">11621</span><a id="line.11621">     *     &lt;li&gt;</a>
<span class="sourceLineNo">11622</span><a id="line.11622">     *            b\) result of fisheye::undistortImage of fisheye camera model (all possible coefficients (k_1, k_2,</a>
<span class="sourceLineNo">11623</span><a id="line.11623">     *             k_3, k_4) of fisheye distortion were optimized under calibration)</a>
<span class="sourceLineNo">11624</span><a id="line.11624">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">11625</span><a id="line.11625">     *     &lt;li&gt;</a>
<span class="sourceLineNo">11626</span><a id="line.11626">     *            c\) original image was captured with fisheye lens</a>
<span class="sourceLineNo">11627</span><a id="line.11627">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">11628</span><a id="line.11628">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">11629</span><a id="line.11629">     *</a>
<span class="sourceLineNo">11630</span><a id="line.11630">     *     Pictures a) and b) almost the same. But if we consider points of image located far from the center</a>
<span class="sourceLineNo">11631</span><a id="line.11631">     *     of image, we can notice that on image a) these points are distorted.</a>
<span class="sourceLineNo">11632</span><a id="line.11632">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11633</span><a id="line.11633">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">11634</span><a id="line.11634">     *</a>
<span class="sourceLineNo">11635</span><a id="line.11635">     *     ![image](pics/fisheye_undistorted.jpg)</a>
<span class="sourceLineNo">11636</span><a id="line.11636">     */</a>
<span class="sourceLineNo">11637</span><a id="line.11637">    public static void fisheye_undistortImage(Mat distorted, Mat undistorted, Mat K, Mat D, Mat Knew) {</a>
<span class="sourceLineNo">11638</span><a id="line.11638">        fisheye_undistortImage_1(distorted.nativeObj, undistorted.nativeObj, K.nativeObj, D.nativeObj, Knew.nativeObj);</a>
<span class="sourceLineNo">11639</span><a id="line.11639">    }</a>
<span class="sourceLineNo">11640</span><a id="line.11640"></a>
<span class="sourceLineNo">11641</span><a id="line.11641">    /**</a>
<span class="sourceLineNo">11642</span><a id="line.11642">     * Transforms an image to compensate for fisheye lens distortion.</a>
<span class="sourceLineNo">11643</span><a id="line.11643">     *</a>
<span class="sourceLineNo">11644</span><a id="line.11644">     *     @param distorted image with fisheye lens distortion.</a>
<span class="sourceLineNo">11645</span><a id="line.11645">     *     @param undistorted Output image with compensated fisheye lens distortion.</a>
<span class="sourceLineNo">11646</span><a id="line.11646">     *     @param K Camera intrinsic matrix \(cameramatrix{K}\).</a>
<span class="sourceLineNo">11647</span><a id="line.11647">     *     @param D Input vector of distortion coefficients \(\distcoeffsfisheye\).</a>
<span class="sourceLineNo">11648</span><a id="line.11648">     *     may additionally scale and shift the result by using a different matrix.</a>
<span class="sourceLineNo">11649</span><a id="line.11649">     *</a>
<span class="sourceLineNo">11650</span><a id="line.11650">     *     The function transforms an image to compensate radial and tangential lens distortion.</a>
<span class="sourceLineNo">11651</span><a id="line.11651">     *</a>
<span class="sourceLineNo">11652</span><a id="line.11652">     *     The function is simply a combination of fisheye::initUndistortRectifyMap (with unity R ) and remap</a>
<span class="sourceLineNo">11653</span><a id="line.11653">     *     (with bilinear interpolation). See the former function for details of the transformation being</a>
<span class="sourceLineNo">11654</span><a id="line.11654">     *     performed.</a>
<span class="sourceLineNo">11655</span><a id="line.11655">     *</a>
<span class="sourceLineNo">11656</span><a id="line.11656">     *     See below the results of undistortImage.</a>
<span class="sourceLineNo">11657</span><a id="line.11657">     * &lt;ul&gt;</a>
<span class="sourceLineNo">11658</span><a id="line.11658">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11659</span><a id="line.11659">     *           a\) result of undistort of perspective camera model (all possible coefficients (k_1, k_2, k_3,</a>
<span class="sourceLineNo">11660</span><a id="line.11660">     *             k_4, k_5, k_6) of distortion were optimized under calibration)</a>
<span class="sourceLineNo">11661</span><a id="line.11661">     *   &lt;ul&gt;</a>
<span class="sourceLineNo">11662</span><a id="line.11662">     *     &lt;li&gt;</a>
<span class="sourceLineNo">11663</span><a id="line.11663">     *            b\) result of fisheye::undistortImage of fisheye camera model (all possible coefficients (k_1, k_2,</a>
<span class="sourceLineNo">11664</span><a id="line.11664">     *             k_3, k_4) of fisheye distortion were optimized under calibration)</a>
<span class="sourceLineNo">11665</span><a id="line.11665">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">11666</span><a id="line.11666">     *     &lt;li&gt;</a>
<span class="sourceLineNo">11667</span><a id="line.11667">     *            c\) original image was captured with fisheye lens</a>
<span class="sourceLineNo">11668</span><a id="line.11668">     *     &lt;/li&gt;</a>
<span class="sourceLineNo">11669</span><a id="line.11669">     *   &lt;/ul&gt;</a>
<span class="sourceLineNo">11670</span><a id="line.11670">     *</a>
<span class="sourceLineNo">11671</span><a id="line.11671">     *     Pictures a) and b) almost the same. But if we consider points of image located far from the center</a>
<span class="sourceLineNo">11672</span><a id="line.11672">     *     of image, we can notice that on image a) these points are distorted.</a>
<span class="sourceLineNo">11673</span><a id="line.11673">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11674</span><a id="line.11674">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">11675</span><a id="line.11675">     *</a>
<span class="sourceLineNo">11676</span><a id="line.11676">     *     ![image](pics/fisheye_undistorted.jpg)</a>
<span class="sourceLineNo">11677</span><a id="line.11677">     */</a>
<span class="sourceLineNo">11678</span><a id="line.11678">    public static void fisheye_undistortImage(Mat distorted, Mat undistorted, Mat K, Mat D) {</a>
<span class="sourceLineNo">11679</span><a id="line.11679">        fisheye_undistortImage_2(distorted.nativeObj, undistorted.nativeObj, K.nativeObj, D.nativeObj);</a>
<span class="sourceLineNo">11680</span><a id="line.11680">    }</a>
<span class="sourceLineNo">11681</span><a id="line.11681"></a>
<span class="sourceLineNo">11682</span><a id="line.11682"></a>
<span class="sourceLineNo">11683</span><a id="line.11683">    //</a>
<span class="sourceLineNo">11684</span><a id="line.11684">    // C++:  void cv::fisheye::estimateNewCameraMatrixForUndistortRectify(Mat K, Mat D, Size image_size, Mat R, Mat&amp; P, double balance = 0.0, Size new_size = Size(), double fov_scale = 1.0)</a>
<span class="sourceLineNo">11685</span><a id="line.11685">    //</a>
<span class="sourceLineNo">11686</span><a id="line.11686"></a>
<span class="sourceLineNo">11687</span><a id="line.11687">    /**</a>
<span class="sourceLineNo">11688</span><a id="line.11688">     * Estimates new camera intrinsic matrix for undistortion or rectification.</a>
<span class="sourceLineNo">11689</span><a id="line.11689">     *</a>
<span class="sourceLineNo">11690</span><a id="line.11690">     *     @param K Camera intrinsic matrix \(cameramatrix{K}\).</a>
<span class="sourceLineNo">11691</span><a id="line.11691">     *     @param image_size Size of the image</a>
<span class="sourceLineNo">11692</span><a id="line.11692">     *     @param D Input vector of distortion coefficients \(\distcoeffsfisheye\).</a>
<span class="sourceLineNo">11693</span><a id="line.11693">     *     @param R Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3</a>
<span class="sourceLineNo">11694</span><a id="line.11694">     *     1-channel or 1x1 3-channel</a>
<span class="sourceLineNo">11695</span><a id="line.11695">     *     @param P New camera intrinsic matrix (3x3) or new projection matrix (3x4)</a>
<span class="sourceLineNo">11696</span><a id="line.11696">     *     @param balance Sets the new focal length in range between the min focal length and the max focal</a>
<span class="sourceLineNo">11697</span><a id="line.11697">     *     length. Balance is in range of [0, 1].</a>
<span class="sourceLineNo">11698</span><a id="line.11698">     *     @param new_size the new size</a>
<span class="sourceLineNo">11699</span><a id="line.11699">     *     @param fov_scale Divisor for new focal length.</a>
<span class="sourceLineNo">11700</span><a id="line.11700">     */</a>
<span class="sourceLineNo">11701</span><a id="line.11701">    public static void fisheye_estimateNewCameraMatrixForUndistortRectify(Mat K, Mat D, Size image_size, Mat R, Mat P, double balance, Size new_size, double fov_scale) {</a>
<span class="sourceLineNo">11702</span><a id="line.11702">        fisheye_estimateNewCameraMatrixForUndistortRectify_0(K.nativeObj, D.nativeObj, image_size.width, image_size.height, R.nativeObj, P.nativeObj, balance, new_size.width, new_size.height, fov_scale);</a>
<span class="sourceLineNo">11703</span><a id="line.11703">    }</a>
<span class="sourceLineNo">11704</span><a id="line.11704"></a>
<span class="sourceLineNo">11705</span><a id="line.11705">    /**</a>
<span class="sourceLineNo">11706</span><a id="line.11706">     * Estimates new camera intrinsic matrix for undistortion or rectification.</a>
<span class="sourceLineNo">11707</span><a id="line.11707">     *</a>
<span class="sourceLineNo">11708</span><a id="line.11708">     *     @param K Camera intrinsic matrix \(cameramatrix{K}\).</a>
<span class="sourceLineNo">11709</span><a id="line.11709">     *     @param image_size Size of the image</a>
<span class="sourceLineNo">11710</span><a id="line.11710">     *     @param D Input vector of distortion coefficients \(\distcoeffsfisheye\).</a>
<span class="sourceLineNo">11711</span><a id="line.11711">     *     @param R Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3</a>
<span class="sourceLineNo">11712</span><a id="line.11712">     *     1-channel or 1x1 3-channel</a>
<span class="sourceLineNo">11713</span><a id="line.11713">     *     @param P New camera intrinsic matrix (3x3) or new projection matrix (3x4)</a>
<span class="sourceLineNo">11714</span><a id="line.11714">     *     @param balance Sets the new focal length in range between the min focal length and the max focal</a>
<span class="sourceLineNo">11715</span><a id="line.11715">     *     length. Balance is in range of [0, 1].</a>
<span class="sourceLineNo">11716</span><a id="line.11716">     *     @param new_size the new size</a>
<span class="sourceLineNo">11717</span><a id="line.11717">     */</a>
<span class="sourceLineNo">11718</span><a id="line.11718">    public static void fisheye_estimateNewCameraMatrixForUndistortRectify(Mat K, Mat D, Size image_size, Mat R, Mat P, double balance, Size new_size) {</a>
<span class="sourceLineNo">11719</span><a id="line.11719">        fisheye_estimateNewCameraMatrixForUndistortRectify_1(K.nativeObj, D.nativeObj, image_size.width, image_size.height, R.nativeObj, P.nativeObj, balance, new_size.width, new_size.height);</a>
<span class="sourceLineNo">11720</span><a id="line.11720">    }</a>
<span class="sourceLineNo">11721</span><a id="line.11721"></a>
<span class="sourceLineNo">11722</span><a id="line.11722">    /**</a>
<span class="sourceLineNo">11723</span><a id="line.11723">     * Estimates new camera intrinsic matrix for undistortion or rectification.</a>
<span class="sourceLineNo">11724</span><a id="line.11724">     *</a>
<span class="sourceLineNo">11725</span><a id="line.11725">     *     @param K Camera intrinsic matrix \(cameramatrix{K}\).</a>
<span class="sourceLineNo">11726</span><a id="line.11726">     *     @param image_size Size of the image</a>
<span class="sourceLineNo">11727</span><a id="line.11727">     *     @param D Input vector of distortion coefficients \(\distcoeffsfisheye\).</a>
<span class="sourceLineNo">11728</span><a id="line.11728">     *     @param R Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3</a>
<span class="sourceLineNo">11729</span><a id="line.11729">     *     1-channel or 1x1 3-channel</a>
<span class="sourceLineNo">11730</span><a id="line.11730">     *     @param P New camera intrinsic matrix (3x3) or new projection matrix (3x4)</a>
<span class="sourceLineNo">11731</span><a id="line.11731">     *     @param balance Sets the new focal length in range between the min focal length and the max focal</a>
<span class="sourceLineNo">11732</span><a id="line.11732">     *     length. Balance is in range of [0, 1].</a>
<span class="sourceLineNo">11733</span><a id="line.11733">     */</a>
<span class="sourceLineNo">11734</span><a id="line.11734">    public static void fisheye_estimateNewCameraMatrixForUndistortRectify(Mat K, Mat D, Size image_size, Mat R, Mat P, double balance) {</a>
<span class="sourceLineNo">11735</span><a id="line.11735">        fisheye_estimateNewCameraMatrixForUndistortRectify_2(K.nativeObj, D.nativeObj, image_size.width, image_size.height, R.nativeObj, P.nativeObj, balance);</a>
<span class="sourceLineNo">11736</span><a id="line.11736">    }</a>
<span class="sourceLineNo">11737</span><a id="line.11737"></a>
<span class="sourceLineNo">11738</span><a id="line.11738">    /**</a>
<span class="sourceLineNo">11739</span><a id="line.11739">     * Estimates new camera intrinsic matrix for undistortion or rectification.</a>
<span class="sourceLineNo">11740</span><a id="line.11740">     *</a>
<span class="sourceLineNo">11741</span><a id="line.11741">     *     @param K Camera intrinsic matrix \(cameramatrix{K}\).</a>
<span class="sourceLineNo">11742</span><a id="line.11742">     *     @param image_size Size of the image</a>
<span class="sourceLineNo">11743</span><a id="line.11743">     *     @param D Input vector of distortion coefficients \(\distcoeffsfisheye\).</a>
<span class="sourceLineNo">11744</span><a id="line.11744">     *     @param R Rectification transformation in the object space: 3x3 1-channel, or vector: 3x1/1x3</a>
<span class="sourceLineNo">11745</span><a id="line.11745">     *     1-channel or 1x1 3-channel</a>
<span class="sourceLineNo">11746</span><a id="line.11746">     *     @param P New camera intrinsic matrix (3x3) or new projection matrix (3x4)</a>
<span class="sourceLineNo">11747</span><a id="line.11747">     *     length. Balance is in range of [0, 1].</a>
<span class="sourceLineNo">11748</span><a id="line.11748">     */</a>
<span class="sourceLineNo">11749</span><a id="line.11749">    public static void fisheye_estimateNewCameraMatrixForUndistortRectify(Mat K, Mat D, Size image_size, Mat R, Mat P) {</a>
<span class="sourceLineNo">11750</span><a id="line.11750">        fisheye_estimateNewCameraMatrixForUndistortRectify_3(K.nativeObj, D.nativeObj, image_size.width, image_size.height, R.nativeObj, P.nativeObj);</a>
<span class="sourceLineNo">11751</span><a id="line.11751">    }</a>
<span class="sourceLineNo">11752</span><a id="line.11752"></a>
<span class="sourceLineNo">11753</span><a id="line.11753"></a>
<span class="sourceLineNo">11754</span><a id="line.11754">    //</a>
<span class="sourceLineNo">11755</span><a id="line.11755">    // C++:  double cv::fisheye::calibrate(vector_Mat objectPoints, vector_Mat imagePoints, Size image_size, Mat&amp; K, Mat&amp; D, vector_Mat&amp; rvecs, vector_Mat&amp; tvecs, int flags = 0, TermCriteria criteria = TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON))</a>
<span class="sourceLineNo">11756</span><a id="line.11756">    //</a>
<span class="sourceLineNo">11757</span><a id="line.11757"></a>
<span class="sourceLineNo">11758</span><a id="line.11758">    /**</a>
<span class="sourceLineNo">11759</span><a id="line.11759">     * Performs camera calibaration</a>
<span class="sourceLineNo">11760</span><a id="line.11760">     *</a>
<span class="sourceLineNo">11761</span><a id="line.11761">     *     @param objectPoints vector of vectors of calibration pattern points in the calibration pattern</a>
<span class="sourceLineNo">11762</span><a id="line.11762">     *     coordinate space.</a>
<span class="sourceLineNo">11763</span><a id="line.11763">     *     @param imagePoints vector of vectors of the projections of calibration pattern points.</a>
<span class="sourceLineNo">11764</span><a id="line.11764">     *     imagePoints.size() and objectPoints.size() and imagePoints[i].size() must be equal to</a>
<span class="sourceLineNo">11765</span><a id="line.11765">     *     objectPoints[i].size() for each i.</a>
<span class="sourceLineNo">11766</span><a id="line.11766">     *     @param image_size Size of the image used only to initialize the camera intrinsic matrix.</a>
<span class="sourceLineNo">11767</span><a id="line.11767">     *     @param K Output 3x3 floating-point camera intrinsic matrix</a>
<span class="sourceLineNo">11768</span><a id="line.11768">     *     \(\cameramatrix{A}\) . If</a>
<span class="sourceLineNo">11769</span><a id="line.11769">     *     REF: fisheye::CALIB_USE_INTRINSIC_GUESS is specified, some or all of fx, fy, cx, cy must be</a>
<span class="sourceLineNo">11770</span><a id="line.11770">     *     initialized before calling the function.</a>
<span class="sourceLineNo">11771</span><a id="line.11771">     *     @param D Output vector of distortion coefficients \(\distcoeffsfisheye\).</a>
<span class="sourceLineNo">11772</span><a id="line.11772">     *     @param rvecs Output vector of rotation vectors (see Rodrigues ) estimated for each pattern view.</a>
<span class="sourceLineNo">11773</span><a id="line.11773">     *     That is, each k-th rotation vector together with the corresponding k-th translation vector (see</a>
<span class="sourceLineNo">11774</span><a id="line.11774">     *     the next output parameter description) brings the calibration pattern from the model coordinate</a>
<span class="sourceLineNo">11775</span><a id="line.11775">     *     space (in which object points are specified) to the world coordinate space, that is, a real</a>
<span class="sourceLineNo">11776</span><a id="line.11776">     *     position of the calibration pattern in the k-th pattern view (k=0.. *M* -1).</a>
<span class="sourceLineNo">11777</span><a id="line.11777">     *     @param tvecs Output vector of translation vectors estimated for each pattern view.</a>
<span class="sourceLineNo">11778</span><a id="line.11778">     *     @param flags Different flags that may be zero or a combination of the following values:</a>
<span class="sourceLineNo">11779</span><a id="line.11779">     * &lt;ul&gt;</a>
<span class="sourceLineNo">11780</span><a id="line.11780">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11781</span><a id="line.11781">     *         REF: fisheye::CALIB_USE_INTRINSIC_GUESS  cameraMatrix contains valid initial values of</a>
<span class="sourceLineNo">11782</span><a id="line.11782">     *     fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image</a>
<span class="sourceLineNo">11783</span><a id="line.11783">     *     center ( imageSize is used), and focal distances are computed in a least-squares fashion.</a>
<span class="sourceLineNo">11784</span><a id="line.11784">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11785</span><a id="line.11785">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11786</span><a id="line.11786">     *         REF: fisheye::CALIB_RECOMPUTE_EXTRINSIC  Extrinsic will be recomputed after each iteration</a>
<span class="sourceLineNo">11787</span><a id="line.11787">     *     of intrinsic optimization.</a>
<span class="sourceLineNo">11788</span><a id="line.11788">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11789</span><a id="line.11789">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11790</span><a id="line.11790">     *         REF: fisheye::CALIB_CHECK_COND  The functions will check validity of condition number.</a>
<span class="sourceLineNo">11791</span><a id="line.11791">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11792</span><a id="line.11792">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11793</span><a id="line.11793">     *         REF: fisheye::CALIB_FIX_SKEW  Skew coefficient (alpha) is set to zero and stay zero.</a>
<span class="sourceLineNo">11794</span><a id="line.11794">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11795</span><a id="line.11795">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11796</span><a id="line.11796">     *         REF: fisheye::CALIB_FIX_K1,..., REF: fisheye::CALIB_FIX_K4 Selected distortion coefficients</a>
<span class="sourceLineNo">11797</span><a id="line.11797">     *     are set to zeros and stay zero.</a>
<span class="sourceLineNo">11798</span><a id="line.11798">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11799</span><a id="line.11799">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11800</span><a id="line.11800">     *         REF: fisheye::CALIB_FIX_PRINCIPAL_POINT  The principal point is not changed during the global</a>
<span class="sourceLineNo">11801</span><a id="line.11801">     * optimization. It stays at the center or at a different location specified when REF: fisheye::CALIB_USE_INTRINSIC_GUESS is set too.</a>
<span class="sourceLineNo">11802</span><a id="line.11802">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11803</span><a id="line.11803">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11804</span><a id="line.11804">     *         REF: fisheye::CALIB_FIX_FOCAL_LENGTH The focal length is not changed during the global</a>
<span class="sourceLineNo">11805</span><a id="line.11805">     * optimization. It is the \(max(width,height)/\pi\) or the provided \(f_x\), \(f_y\) when REF: fisheye::CALIB_USE_INTRINSIC_GUESS is set too.</a>
<span class="sourceLineNo">11806</span><a id="line.11806">     *     @param criteria Termination criteria for the iterative optimization algorithm.</a>
<span class="sourceLineNo">11807</span><a id="line.11807">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11808</span><a id="line.11808">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">11809</span><a id="line.11809">     * @return automatically generated</a>
<span class="sourceLineNo">11810</span><a id="line.11810">     */</a>
<span class="sourceLineNo">11811</span><a id="line.11811">    public static double fisheye_calibrate(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints, Size image_size, Mat K, Mat D, List&lt;Mat&gt; rvecs, List&lt;Mat&gt; tvecs, int flags, TermCriteria criteria) {</a>
<span class="sourceLineNo">11812</span><a id="line.11812">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">11813</span><a id="line.11813">        Mat imagePoints_mat = Converters.vector_Mat_to_Mat(imagePoints);</a>
<span class="sourceLineNo">11814</span><a id="line.11814">        Mat rvecs_mat = new Mat();</a>
<span class="sourceLineNo">11815</span><a id="line.11815">        Mat tvecs_mat = new Mat();</a>
<span class="sourceLineNo">11816</span><a id="line.11816">        double retVal = fisheye_calibrate_0(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, image_size.width, image_size.height, K.nativeObj, D.nativeObj, rvecs_mat.nativeObj, tvecs_mat.nativeObj, flags, criteria.type, criteria.maxCount, criteria.epsilon);</a>
<span class="sourceLineNo">11817</span><a id="line.11817">        Converters.Mat_to_vector_Mat(rvecs_mat, rvecs);</a>
<span class="sourceLineNo">11818</span><a id="line.11818">        rvecs_mat.release();</a>
<span class="sourceLineNo">11819</span><a id="line.11819">        Converters.Mat_to_vector_Mat(tvecs_mat, tvecs);</a>
<span class="sourceLineNo">11820</span><a id="line.11820">        tvecs_mat.release();</a>
<span class="sourceLineNo">11821</span><a id="line.11821">        return retVal;</a>
<span class="sourceLineNo">11822</span><a id="line.11822">    }</a>
<span class="sourceLineNo">11823</span><a id="line.11823"></a>
<span class="sourceLineNo">11824</span><a id="line.11824">    /**</a>
<span class="sourceLineNo">11825</span><a id="line.11825">     * Performs camera calibaration</a>
<span class="sourceLineNo">11826</span><a id="line.11826">     *</a>
<span class="sourceLineNo">11827</span><a id="line.11827">     *     @param objectPoints vector of vectors of calibration pattern points in the calibration pattern</a>
<span class="sourceLineNo">11828</span><a id="line.11828">     *     coordinate space.</a>
<span class="sourceLineNo">11829</span><a id="line.11829">     *     @param imagePoints vector of vectors of the projections of calibration pattern points.</a>
<span class="sourceLineNo">11830</span><a id="line.11830">     *     imagePoints.size() and objectPoints.size() and imagePoints[i].size() must be equal to</a>
<span class="sourceLineNo">11831</span><a id="line.11831">     *     objectPoints[i].size() for each i.</a>
<span class="sourceLineNo">11832</span><a id="line.11832">     *     @param image_size Size of the image used only to initialize the camera intrinsic matrix.</a>
<span class="sourceLineNo">11833</span><a id="line.11833">     *     @param K Output 3x3 floating-point camera intrinsic matrix</a>
<span class="sourceLineNo">11834</span><a id="line.11834">     *     \(\cameramatrix{A}\) . If</a>
<span class="sourceLineNo">11835</span><a id="line.11835">     *     REF: fisheye::CALIB_USE_INTRINSIC_GUESS is specified, some or all of fx, fy, cx, cy must be</a>
<span class="sourceLineNo">11836</span><a id="line.11836">     *     initialized before calling the function.</a>
<span class="sourceLineNo">11837</span><a id="line.11837">     *     @param D Output vector of distortion coefficients \(\distcoeffsfisheye\).</a>
<span class="sourceLineNo">11838</span><a id="line.11838">     *     @param rvecs Output vector of rotation vectors (see Rodrigues ) estimated for each pattern view.</a>
<span class="sourceLineNo">11839</span><a id="line.11839">     *     That is, each k-th rotation vector together with the corresponding k-th translation vector (see</a>
<span class="sourceLineNo">11840</span><a id="line.11840">     *     the next output parameter description) brings the calibration pattern from the model coordinate</a>
<span class="sourceLineNo">11841</span><a id="line.11841">     *     space (in which object points are specified) to the world coordinate space, that is, a real</a>
<span class="sourceLineNo">11842</span><a id="line.11842">     *     position of the calibration pattern in the k-th pattern view (k=0.. *M* -1).</a>
<span class="sourceLineNo">11843</span><a id="line.11843">     *     @param tvecs Output vector of translation vectors estimated for each pattern view.</a>
<span class="sourceLineNo">11844</span><a id="line.11844">     *     @param flags Different flags that may be zero or a combination of the following values:</a>
<span class="sourceLineNo">11845</span><a id="line.11845">     * &lt;ul&gt;</a>
<span class="sourceLineNo">11846</span><a id="line.11846">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11847</span><a id="line.11847">     *         REF: fisheye::CALIB_USE_INTRINSIC_GUESS  cameraMatrix contains valid initial values of</a>
<span class="sourceLineNo">11848</span><a id="line.11848">     *     fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image</a>
<span class="sourceLineNo">11849</span><a id="line.11849">     *     center ( imageSize is used), and focal distances are computed in a least-squares fashion.</a>
<span class="sourceLineNo">11850</span><a id="line.11850">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11851</span><a id="line.11851">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11852</span><a id="line.11852">     *         REF: fisheye::CALIB_RECOMPUTE_EXTRINSIC  Extrinsic will be recomputed after each iteration</a>
<span class="sourceLineNo">11853</span><a id="line.11853">     *     of intrinsic optimization.</a>
<span class="sourceLineNo">11854</span><a id="line.11854">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11855</span><a id="line.11855">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11856</span><a id="line.11856">     *         REF: fisheye::CALIB_CHECK_COND  The functions will check validity of condition number.</a>
<span class="sourceLineNo">11857</span><a id="line.11857">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11858</span><a id="line.11858">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11859</span><a id="line.11859">     *         REF: fisheye::CALIB_FIX_SKEW  Skew coefficient (alpha) is set to zero and stay zero.</a>
<span class="sourceLineNo">11860</span><a id="line.11860">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11861</span><a id="line.11861">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11862</span><a id="line.11862">     *         REF: fisheye::CALIB_FIX_K1,..., REF: fisheye::CALIB_FIX_K4 Selected distortion coefficients</a>
<span class="sourceLineNo">11863</span><a id="line.11863">     *     are set to zeros and stay zero.</a>
<span class="sourceLineNo">11864</span><a id="line.11864">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11865</span><a id="line.11865">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11866</span><a id="line.11866">     *         REF: fisheye::CALIB_FIX_PRINCIPAL_POINT  The principal point is not changed during the global</a>
<span class="sourceLineNo">11867</span><a id="line.11867">     * optimization. It stays at the center or at a different location specified when REF: fisheye::CALIB_USE_INTRINSIC_GUESS is set too.</a>
<span class="sourceLineNo">11868</span><a id="line.11868">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11869</span><a id="line.11869">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11870</span><a id="line.11870">     *         REF: fisheye::CALIB_FIX_FOCAL_LENGTH The focal length is not changed during the global</a>
<span class="sourceLineNo">11871</span><a id="line.11871">     * optimization. It is the \(max(width,height)/\pi\) or the provided \(f_x\), \(f_y\) when REF: fisheye::CALIB_USE_INTRINSIC_GUESS is set too.</a>
<span class="sourceLineNo">11872</span><a id="line.11872">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11873</span><a id="line.11873">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">11874</span><a id="line.11874">     * @return automatically generated</a>
<span class="sourceLineNo">11875</span><a id="line.11875">     */</a>
<span class="sourceLineNo">11876</span><a id="line.11876">    public static double fisheye_calibrate(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints, Size image_size, Mat K, Mat D, List&lt;Mat&gt; rvecs, List&lt;Mat&gt; tvecs, int flags) {</a>
<span class="sourceLineNo">11877</span><a id="line.11877">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">11878</span><a id="line.11878">        Mat imagePoints_mat = Converters.vector_Mat_to_Mat(imagePoints);</a>
<span class="sourceLineNo">11879</span><a id="line.11879">        Mat rvecs_mat = new Mat();</a>
<span class="sourceLineNo">11880</span><a id="line.11880">        Mat tvecs_mat = new Mat();</a>
<span class="sourceLineNo">11881</span><a id="line.11881">        double retVal = fisheye_calibrate_1(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, image_size.width, image_size.height, K.nativeObj, D.nativeObj, rvecs_mat.nativeObj, tvecs_mat.nativeObj, flags);</a>
<span class="sourceLineNo">11882</span><a id="line.11882">        Converters.Mat_to_vector_Mat(rvecs_mat, rvecs);</a>
<span class="sourceLineNo">11883</span><a id="line.11883">        rvecs_mat.release();</a>
<span class="sourceLineNo">11884</span><a id="line.11884">        Converters.Mat_to_vector_Mat(tvecs_mat, tvecs);</a>
<span class="sourceLineNo">11885</span><a id="line.11885">        tvecs_mat.release();</a>
<span class="sourceLineNo">11886</span><a id="line.11886">        return retVal;</a>
<span class="sourceLineNo">11887</span><a id="line.11887">    }</a>
<span class="sourceLineNo">11888</span><a id="line.11888"></a>
<span class="sourceLineNo">11889</span><a id="line.11889">    /**</a>
<span class="sourceLineNo">11890</span><a id="line.11890">     * Performs camera calibaration</a>
<span class="sourceLineNo">11891</span><a id="line.11891">     *</a>
<span class="sourceLineNo">11892</span><a id="line.11892">     *     @param objectPoints vector of vectors of calibration pattern points in the calibration pattern</a>
<span class="sourceLineNo">11893</span><a id="line.11893">     *     coordinate space.</a>
<span class="sourceLineNo">11894</span><a id="line.11894">     *     @param imagePoints vector of vectors of the projections of calibration pattern points.</a>
<span class="sourceLineNo">11895</span><a id="line.11895">     *     imagePoints.size() and objectPoints.size() and imagePoints[i].size() must be equal to</a>
<span class="sourceLineNo">11896</span><a id="line.11896">     *     objectPoints[i].size() for each i.</a>
<span class="sourceLineNo">11897</span><a id="line.11897">     *     @param image_size Size of the image used only to initialize the camera intrinsic matrix.</a>
<span class="sourceLineNo">11898</span><a id="line.11898">     *     @param K Output 3x3 floating-point camera intrinsic matrix</a>
<span class="sourceLineNo">11899</span><a id="line.11899">     *     \(\cameramatrix{A}\) . If</a>
<span class="sourceLineNo">11900</span><a id="line.11900">     *     REF: fisheye::CALIB_USE_INTRINSIC_GUESS is specified, some or all of fx, fy, cx, cy must be</a>
<span class="sourceLineNo">11901</span><a id="line.11901">     *     initialized before calling the function.</a>
<span class="sourceLineNo">11902</span><a id="line.11902">     *     @param D Output vector of distortion coefficients \(\distcoeffsfisheye\).</a>
<span class="sourceLineNo">11903</span><a id="line.11903">     *     @param rvecs Output vector of rotation vectors (see Rodrigues ) estimated for each pattern view.</a>
<span class="sourceLineNo">11904</span><a id="line.11904">     *     That is, each k-th rotation vector together with the corresponding k-th translation vector (see</a>
<span class="sourceLineNo">11905</span><a id="line.11905">     *     the next output parameter description) brings the calibration pattern from the model coordinate</a>
<span class="sourceLineNo">11906</span><a id="line.11906">     *     space (in which object points are specified) to the world coordinate space, that is, a real</a>
<span class="sourceLineNo">11907</span><a id="line.11907">     *     position of the calibration pattern in the k-th pattern view (k=0.. *M* -1).</a>
<span class="sourceLineNo">11908</span><a id="line.11908">     *     @param tvecs Output vector of translation vectors estimated for each pattern view.</a>
<span class="sourceLineNo">11909</span><a id="line.11909">     * &lt;ul&gt;</a>
<span class="sourceLineNo">11910</span><a id="line.11910">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11911</span><a id="line.11911">     *         REF: fisheye::CALIB_USE_INTRINSIC_GUESS  cameraMatrix contains valid initial values of</a>
<span class="sourceLineNo">11912</span><a id="line.11912">     *     fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image</a>
<span class="sourceLineNo">11913</span><a id="line.11913">     *     center ( imageSize is used), and focal distances are computed in a least-squares fashion.</a>
<span class="sourceLineNo">11914</span><a id="line.11914">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11915</span><a id="line.11915">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11916</span><a id="line.11916">     *         REF: fisheye::CALIB_RECOMPUTE_EXTRINSIC  Extrinsic will be recomputed after each iteration</a>
<span class="sourceLineNo">11917</span><a id="line.11917">     *     of intrinsic optimization.</a>
<span class="sourceLineNo">11918</span><a id="line.11918">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11919</span><a id="line.11919">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11920</span><a id="line.11920">     *         REF: fisheye::CALIB_CHECK_COND  The functions will check validity of condition number.</a>
<span class="sourceLineNo">11921</span><a id="line.11921">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11922</span><a id="line.11922">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11923</span><a id="line.11923">     *         REF: fisheye::CALIB_FIX_SKEW  Skew coefficient (alpha) is set to zero and stay zero.</a>
<span class="sourceLineNo">11924</span><a id="line.11924">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11925</span><a id="line.11925">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11926</span><a id="line.11926">     *         REF: fisheye::CALIB_FIX_K1,..., REF: fisheye::CALIB_FIX_K4 Selected distortion coefficients</a>
<span class="sourceLineNo">11927</span><a id="line.11927">     *     are set to zeros and stay zero.</a>
<span class="sourceLineNo">11928</span><a id="line.11928">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11929</span><a id="line.11929">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11930</span><a id="line.11930">     *         REF: fisheye::CALIB_FIX_PRINCIPAL_POINT  The principal point is not changed during the global</a>
<span class="sourceLineNo">11931</span><a id="line.11931">     * optimization. It stays at the center or at a different location specified when REF: fisheye::CALIB_USE_INTRINSIC_GUESS is set too.</a>
<span class="sourceLineNo">11932</span><a id="line.11932">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11933</span><a id="line.11933">     *   &lt;li&gt;</a>
<span class="sourceLineNo">11934</span><a id="line.11934">     *         REF: fisheye::CALIB_FIX_FOCAL_LENGTH The focal length is not changed during the global</a>
<span class="sourceLineNo">11935</span><a id="line.11935">     * optimization. It is the \(max(width,height)/\pi\) or the provided \(f_x\), \(f_y\) when REF: fisheye::CALIB_USE_INTRINSIC_GUESS is set too.</a>
<span class="sourceLineNo">11936</span><a id="line.11936">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">11937</span><a id="line.11937">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">11938</span><a id="line.11938">     * @return automatically generated</a>
<span class="sourceLineNo">11939</span><a id="line.11939">     */</a>
<span class="sourceLineNo">11940</span><a id="line.11940">    public static double fisheye_calibrate(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints, Size image_size, Mat K, Mat D, List&lt;Mat&gt; rvecs, List&lt;Mat&gt; tvecs) {</a>
<span class="sourceLineNo">11941</span><a id="line.11941">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">11942</span><a id="line.11942">        Mat imagePoints_mat = Converters.vector_Mat_to_Mat(imagePoints);</a>
<span class="sourceLineNo">11943</span><a id="line.11943">        Mat rvecs_mat = new Mat();</a>
<span class="sourceLineNo">11944</span><a id="line.11944">        Mat tvecs_mat = new Mat();</a>
<span class="sourceLineNo">11945</span><a id="line.11945">        double retVal = fisheye_calibrate_2(objectPoints_mat.nativeObj, imagePoints_mat.nativeObj, image_size.width, image_size.height, K.nativeObj, D.nativeObj, rvecs_mat.nativeObj, tvecs_mat.nativeObj);</a>
<span class="sourceLineNo">11946</span><a id="line.11946">        Converters.Mat_to_vector_Mat(rvecs_mat, rvecs);</a>
<span class="sourceLineNo">11947</span><a id="line.11947">        rvecs_mat.release();</a>
<span class="sourceLineNo">11948</span><a id="line.11948">        Converters.Mat_to_vector_Mat(tvecs_mat, tvecs);</a>
<span class="sourceLineNo">11949</span><a id="line.11949">        tvecs_mat.release();</a>
<span class="sourceLineNo">11950</span><a id="line.11950">        return retVal;</a>
<span class="sourceLineNo">11951</span><a id="line.11951">    }</a>
<span class="sourceLineNo">11952</span><a id="line.11952"></a>
<span class="sourceLineNo">11953</span><a id="line.11953"></a>
<span class="sourceLineNo">11954</span><a id="line.11954">    //</a>
<span class="sourceLineNo">11955</span><a id="line.11955">    // C++:  void cv::fisheye::stereoRectify(Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat tvec, Mat&amp; R1, Mat&amp; R2, Mat&amp; P1, Mat&amp; P2, Mat&amp; Q, int flags, Size newImageSize = Size(), double balance = 0.0, double fov_scale = 1.0)</a>
<span class="sourceLineNo">11956</span><a id="line.11956">    //</a>
<span class="sourceLineNo">11957</span><a id="line.11957"></a>
<span class="sourceLineNo">11958</span><a id="line.11958">    /**</a>
<span class="sourceLineNo">11959</span><a id="line.11959">     * Stereo rectification for fisheye camera model</a>
<span class="sourceLineNo">11960</span><a id="line.11960">     *</a>
<span class="sourceLineNo">11961</span><a id="line.11961">     *     @param K1 First camera intrinsic matrix.</a>
<span class="sourceLineNo">11962</span><a id="line.11962">     *     @param D1 First camera distortion parameters.</a>
<span class="sourceLineNo">11963</span><a id="line.11963">     *     @param K2 Second camera intrinsic matrix.</a>
<span class="sourceLineNo">11964</span><a id="line.11964">     *     @param D2 Second camera distortion parameters.</a>
<span class="sourceLineNo">11965</span><a id="line.11965">     *     @param imageSize Size of the image used for stereo calibration.</a>
<span class="sourceLineNo">11966</span><a id="line.11966">     *     @param R Rotation matrix between the coordinate systems of the first and the second</a>
<span class="sourceLineNo">11967</span><a id="line.11967">     *     cameras.</a>
<span class="sourceLineNo">11968</span><a id="line.11968">     *     @param tvec Translation vector between coordinate systems of the cameras.</a>
<span class="sourceLineNo">11969</span><a id="line.11969">     *     @param R1 Output 3x3 rectification transform (rotation matrix) for the first camera.</a>
<span class="sourceLineNo">11970</span><a id="line.11970">     *     @param R2 Output 3x3 rectification transform (rotation matrix) for the second camera.</a>
<span class="sourceLineNo">11971</span><a id="line.11971">     *     @param P1 Output 3x4 projection matrix in the new (rectified) coordinate systems for the first</a>
<span class="sourceLineNo">11972</span><a id="line.11972">     *     camera.</a>
<span class="sourceLineNo">11973</span><a id="line.11973">     *     @param P2 Output 3x4 projection matrix in the new (rectified) coordinate systems for the second</a>
<span class="sourceLineNo">11974</span><a id="line.11974">     *     camera.</a>
<span class="sourceLineNo">11975</span><a id="line.11975">     *     @param Q Output \(4 \times 4\) disparity-to-depth mapping matrix (see reprojectImageTo3D ).</a>
<span class="sourceLineNo">11976</span><a id="line.11976">     *     @param flags Operation flags that may be zero or REF: fisheye::CALIB_ZERO_DISPARITY . If the flag is set,</a>
<span class="sourceLineNo">11977</span><a id="line.11977">     *     the function makes the principal points of each camera have the same pixel coordinates in the</a>
<span class="sourceLineNo">11978</span><a id="line.11978">     *     rectified views. And if the flag is not set, the function may still shift the images in the</a>
<span class="sourceLineNo">11979</span><a id="line.11979">     *     horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the</a>
<span class="sourceLineNo">11980</span><a id="line.11980">     *     useful image area.</a>
<span class="sourceLineNo">11981</span><a id="line.11981">     *     @param newImageSize New image resolution after rectification. The same size should be passed to</a>
<span class="sourceLineNo">11982</span><a id="line.11982">     *     initUndistortRectifyMap (see the stereo_calib.cpp sample in OpenCV samples directory). When (0,0)</a>
<span class="sourceLineNo">11983</span><a id="line.11983">     *     is passed (default), it is set to the original imageSize . Setting it to larger value can help you</a>
<span class="sourceLineNo">11984</span><a id="line.11984">     *     preserve details in the original image, especially when there is a big radial distortion.</a>
<span class="sourceLineNo">11985</span><a id="line.11985">     *     @param balance Sets the new focal length in range between the min focal length and the max focal</a>
<span class="sourceLineNo">11986</span><a id="line.11986">     *     length. Balance is in range of [0, 1].</a>
<span class="sourceLineNo">11987</span><a id="line.11987">     *     @param fov_scale Divisor for new focal length.</a>
<span class="sourceLineNo">11988</span><a id="line.11988">     */</a>
<span class="sourceLineNo">11989</span><a id="line.11989">    public static void fisheye_stereoRectify(Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat tvec, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, Size newImageSize, double balance, double fov_scale) {</a>
<span class="sourceLineNo">11990</span><a id="line.11990">        fisheye_stereoRectify_0(K1.nativeObj, D1.nativeObj, K2.nativeObj, D2.nativeObj, imageSize.width, imageSize.height, R.nativeObj, tvec.nativeObj, R1.nativeObj, R2.nativeObj, P1.nativeObj, P2.nativeObj, Q.nativeObj, flags, newImageSize.width, newImageSize.height, balance, fov_scale);</a>
<span class="sourceLineNo">11991</span><a id="line.11991">    }</a>
<span class="sourceLineNo">11992</span><a id="line.11992"></a>
<span class="sourceLineNo">11993</span><a id="line.11993">    /**</a>
<span class="sourceLineNo">11994</span><a id="line.11994">     * Stereo rectification for fisheye camera model</a>
<span class="sourceLineNo">11995</span><a id="line.11995">     *</a>
<span class="sourceLineNo">11996</span><a id="line.11996">     *     @param K1 First camera intrinsic matrix.</a>
<span class="sourceLineNo">11997</span><a id="line.11997">     *     @param D1 First camera distortion parameters.</a>
<span class="sourceLineNo">11998</span><a id="line.11998">     *     @param K2 Second camera intrinsic matrix.</a>
<span class="sourceLineNo">11999</span><a id="line.11999">     *     @param D2 Second camera distortion parameters.</a>
<span class="sourceLineNo">12000</span><a id="line.12000">     *     @param imageSize Size of the image used for stereo calibration.</a>
<span class="sourceLineNo">12001</span><a id="line.12001">     *     @param R Rotation matrix between the coordinate systems of the first and the second</a>
<span class="sourceLineNo">12002</span><a id="line.12002">     *     cameras.</a>
<span class="sourceLineNo">12003</span><a id="line.12003">     *     @param tvec Translation vector between coordinate systems of the cameras.</a>
<span class="sourceLineNo">12004</span><a id="line.12004">     *     @param R1 Output 3x3 rectification transform (rotation matrix) for the first camera.</a>
<span class="sourceLineNo">12005</span><a id="line.12005">     *     @param R2 Output 3x3 rectification transform (rotation matrix) for the second camera.</a>
<span class="sourceLineNo">12006</span><a id="line.12006">     *     @param P1 Output 3x4 projection matrix in the new (rectified) coordinate systems for the first</a>
<span class="sourceLineNo">12007</span><a id="line.12007">     *     camera.</a>
<span class="sourceLineNo">12008</span><a id="line.12008">     *     @param P2 Output 3x4 projection matrix in the new (rectified) coordinate systems for the second</a>
<span class="sourceLineNo">12009</span><a id="line.12009">     *     camera.</a>
<span class="sourceLineNo">12010</span><a id="line.12010">     *     @param Q Output \(4 \times 4\) disparity-to-depth mapping matrix (see reprojectImageTo3D ).</a>
<span class="sourceLineNo">12011</span><a id="line.12011">     *     @param flags Operation flags that may be zero or REF: fisheye::CALIB_ZERO_DISPARITY . If the flag is set,</a>
<span class="sourceLineNo">12012</span><a id="line.12012">     *     the function makes the principal points of each camera have the same pixel coordinates in the</a>
<span class="sourceLineNo">12013</span><a id="line.12013">     *     rectified views. And if the flag is not set, the function may still shift the images in the</a>
<span class="sourceLineNo">12014</span><a id="line.12014">     *     horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the</a>
<span class="sourceLineNo">12015</span><a id="line.12015">     *     useful image area.</a>
<span class="sourceLineNo">12016</span><a id="line.12016">     *     @param newImageSize New image resolution after rectification. The same size should be passed to</a>
<span class="sourceLineNo">12017</span><a id="line.12017">     *     initUndistortRectifyMap (see the stereo_calib.cpp sample in OpenCV samples directory). When (0,0)</a>
<span class="sourceLineNo">12018</span><a id="line.12018">     *     is passed (default), it is set to the original imageSize . Setting it to larger value can help you</a>
<span class="sourceLineNo">12019</span><a id="line.12019">     *     preserve details in the original image, especially when there is a big radial distortion.</a>
<span class="sourceLineNo">12020</span><a id="line.12020">     *     @param balance Sets the new focal length in range between the min focal length and the max focal</a>
<span class="sourceLineNo">12021</span><a id="line.12021">     *     length. Balance is in range of [0, 1].</a>
<span class="sourceLineNo">12022</span><a id="line.12022">     */</a>
<span class="sourceLineNo">12023</span><a id="line.12023">    public static void fisheye_stereoRectify(Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat tvec, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, Size newImageSize, double balance) {</a>
<span class="sourceLineNo">12024</span><a id="line.12024">        fisheye_stereoRectify_1(K1.nativeObj, D1.nativeObj, K2.nativeObj, D2.nativeObj, imageSize.width, imageSize.height, R.nativeObj, tvec.nativeObj, R1.nativeObj, R2.nativeObj, P1.nativeObj, P2.nativeObj, Q.nativeObj, flags, newImageSize.width, newImageSize.height, balance);</a>
<span class="sourceLineNo">12025</span><a id="line.12025">    }</a>
<span class="sourceLineNo">12026</span><a id="line.12026"></a>
<span class="sourceLineNo">12027</span><a id="line.12027">    /**</a>
<span class="sourceLineNo">12028</span><a id="line.12028">     * Stereo rectification for fisheye camera model</a>
<span class="sourceLineNo">12029</span><a id="line.12029">     *</a>
<span class="sourceLineNo">12030</span><a id="line.12030">     *     @param K1 First camera intrinsic matrix.</a>
<span class="sourceLineNo">12031</span><a id="line.12031">     *     @param D1 First camera distortion parameters.</a>
<span class="sourceLineNo">12032</span><a id="line.12032">     *     @param K2 Second camera intrinsic matrix.</a>
<span class="sourceLineNo">12033</span><a id="line.12033">     *     @param D2 Second camera distortion parameters.</a>
<span class="sourceLineNo">12034</span><a id="line.12034">     *     @param imageSize Size of the image used for stereo calibration.</a>
<span class="sourceLineNo">12035</span><a id="line.12035">     *     @param R Rotation matrix between the coordinate systems of the first and the second</a>
<span class="sourceLineNo">12036</span><a id="line.12036">     *     cameras.</a>
<span class="sourceLineNo">12037</span><a id="line.12037">     *     @param tvec Translation vector between coordinate systems of the cameras.</a>
<span class="sourceLineNo">12038</span><a id="line.12038">     *     @param R1 Output 3x3 rectification transform (rotation matrix) for the first camera.</a>
<span class="sourceLineNo">12039</span><a id="line.12039">     *     @param R2 Output 3x3 rectification transform (rotation matrix) for the second camera.</a>
<span class="sourceLineNo">12040</span><a id="line.12040">     *     @param P1 Output 3x4 projection matrix in the new (rectified) coordinate systems for the first</a>
<span class="sourceLineNo">12041</span><a id="line.12041">     *     camera.</a>
<span class="sourceLineNo">12042</span><a id="line.12042">     *     @param P2 Output 3x4 projection matrix in the new (rectified) coordinate systems for the second</a>
<span class="sourceLineNo">12043</span><a id="line.12043">     *     camera.</a>
<span class="sourceLineNo">12044</span><a id="line.12044">     *     @param Q Output \(4 \times 4\) disparity-to-depth mapping matrix (see reprojectImageTo3D ).</a>
<span class="sourceLineNo">12045</span><a id="line.12045">     *     @param flags Operation flags that may be zero or REF: fisheye::CALIB_ZERO_DISPARITY . If the flag is set,</a>
<span class="sourceLineNo">12046</span><a id="line.12046">     *     the function makes the principal points of each camera have the same pixel coordinates in the</a>
<span class="sourceLineNo">12047</span><a id="line.12047">     *     rectified views. And if the flag is not set, the function may still shift the images in the</a>
<span class="sourceLineNo">12048</span><a id="line.12048">     *     horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the</a>
<span class="sourceLineNo">12049</span><a id="line.12049">     *     useful image area.</a>
<span class="sourceLineNo">12050</span><a id="line.12050">     *     @param newImageSize New image resolution after rectification. The same size should be passed to</a>
<span class="sourceLineNo">12051</span><a id="line.12051">     *     initUndistortRectifyMap (see the stereo_calib.cpp sample in OpenCV samples directory). When (0,0)</a>
<span class="sourceLineNo">12052</span><a id="line.12052">     *     is passed (default), it is set to the original imageSize . Setting it to larger value can help you</a>
<span class="sourceLineNo">12053</span><a id="line.12053">     *     preserve details in the original image, especially when there is a big radial distortion.</a>
<span class="sourceLineNo">12054</span><a id="line.12054">     *     length. Balance is in range of [0, 1].</a>
<span class="sourceLineNo">12055</span><a id="line.12055">     */</a>
<span class="sourceLineNo">12056</span><a id="line.12056">    public static void fisheye_stereoRectify(Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat tvec, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, Size newImageSize) {</a>
<span class="sourceLineNo">12057</span><a id="line.12057">        fisheye_stereoRectify_2(K1.nativeObj, D1.nativeObj, K2.nativeObj, D2.nativeObj, imageSize.width, imageSize.height, R.nativeObj, tvec.nativeObj, R1.nativeObj, R2.nativeObj, P1.nativeObj, P2.nativeObj, Q.nativeObj, flags, newImageSize.width, newImageSize.height);</a>
<span class="sourceLineNo">12058</span><a id="line.12058">    }</a>
<span class="sourceLineNo">12059</span><a id="line.12059"></a>
<span class="sourceLineNo">12060</span><a id="line.12060">    /**</a>
<span class="sourceLineNo">12061</span><a id="line.12061">     * Stereo rectification for fisheye camera model</a>
<span class="sourceLineNo">12062</span><a id="line.12062">     *</a>
<span class="sourceLineNo">12063</span><a id="line.12063">     *     @param K1 First camera intrinsic matrix.</a>
<span class="sourceLineNo">12064</span><a id="line.12064">     *     @param D1 First camera distortion parameters.</a>
<span class="sourceLineNo">12065</span><a id="line.12065">     *     @param K2 Second camera intrinsic matrix.</a>
<span class="sourceLineNo">12066</span><a id="line.12066">     *     @param D2 Second camera distortion parameters.</a>
<span class="sourceLineNo">12067</span><a id="line.12067">     *     @param imageSize Size of the image used for stereo calibration.</a>
<span class="sourceLineNo">12068</span><a id="line.12068">     *     @param R Rotation matrix between the coordinate systems of the first and the second</a>
<span class="sourceLineNo">12069</span><a id="line.12069">     *     cameras.</a>
<span class="sourceLineNo">12070</span><a id="line.12070">     *     @param tvec Translation vector between coordinate systems of the cameras.</a>
<span class="sourceLineNo">12071</span><a id="line.12071">     *     @param R1 Output 3x3 rectification transform (rotation matrix) for the first camera.</a>
<span class="sourceLineNo">12072</span><a id="line.12072">     *     @param R2 Output 3x3 rectification transform (rotation matrix) for the second camera.</a>
<span class="sourceLineNo">12073</span><a id="line.12073">     *     @param P1 Output 3x4 projection matrix in the new (rectified) coordinate systems for the first</a>
<span class="sourceLineNo">12074</span><a id="line.12074">     *     camera.</a>
<span class="sourceLineNo">12075</span><a id="line.12075">     *     @param P2 Output 3x4 projection matrix in the new (rectified) coordinate systems for the second</a>
<span class="sourceLineNo">12076</span><a id="line.12076">     *     camera.</a>
<span class="sourceLineNo">12077</span><a id="line.12077">     *     @param Q Output \(4 \times 4\) disparity-to-depth mapping matrix (see reprojectImageTo3D ).</a>
<span class="sourceLineNo">12078</span><a id="line.12078">     *     @param flags Operation flags that may be zero or REF: fisheye::CALIB_ZERO_DISPARITY . If the flag is set,</a>
<span class="sourceLineNo">12079</span><a id="line.12079">     *     the function makes the principal points of each camera have the same pixel coordinates in the</a>
<span class="sourceLineNo">12080</span><a id="line.12080">     *     rectified views. And if the flag is not set, the function may still shift the images in the</a>
<span class="sourceLineNo">12081</span><a id="line.12081">     *     horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the</a>
<span class="sourceLineNo">12082</span><a id="line.12082">     *     useful image area.</a>
<span class="sourceLineNo">12083</span><a id="line.12083">     *     initUndistortRectifyMap (see the stereo_calib.cpp sample in OpenCV samples directory). When (0,0)</a>
<span class="sourceLineNo">12084</span><a id="line.12084">     *     is passed (default), it is set to the original imageSize . Setting it to larger value can help you</a>
<span class="sourceLineNo">12085</span><a id="line.12085">     *     preserve details in the original image, especially when there is a big radial distortion.</a>
<span class="sourceLineNo">12086</span><a id="line.12086">     *     length. Balance is in range of [0, 1].</a>
<span class="sourceLineNo">12087</span><a id="line.12087">     */</a>
<span class="sourceLineNo">12088</span><a id="line.12088">    public static void fisheye_stereoRectify(Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat tvec, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags) {</a>
<span class="sourceLineNo">12089</span><a id="line.12089">        fisheye_stereoRectify_3(K1.nativeObj, D1.nativeObj, K2.nativeObj, D2.nativeObj, imageSize.width, imageSize.height, R.nativeObj, tvec.nativeObj, R1.nativeObj, R2.nativeObj, P1.nativeObj, P2.nativeObj, Q.nativeObj, flags);</a>
<span class="sourceLineNo">12090</span><a id="line.12090">    }</a>
<span class="sourceLineNo">12091</span><a id="line.12091"></a>
<span class="sourceLineNo">12092</span><a id="line.12092"></a>
<span class="sourceLineNo">12093</span><a id="line.12093">    //</a>
<span class="sourceLineNo">12094</span><a id="line.12094">    // C++:  double cv::fisheye::stereoCalibrate(vector_Mat objectPoints, vector_Mat imagePoints1, vector_Mat imagePoints2, Mat&amp; K1, Mat&amp; D1, Mat&amp; K2, Mat&amp; D2, Size imageSize, Mat&amp; R, Mat&amp; T, int flags = fisheye::CALIB_FIX_INTRINSIC, TermCriteria criteria = TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON))</a>
<span class="sourceLineNo">12095</span><a id="line.12095">    //</a>
<span class="sourceLineNo">12096</span><a id="line.12096"></a>
<span class="sourceLineNo">12097</span><a id="line.12097">    /**</a>
<span class="sourceLineNo">12098</span><a id="line.12098">     * Performs stereo calibration</a>
<span class="sourceLineNo">12099</span><a id="line.12099">     *</a>
<span class="sourceLineNo">12100</span><a id="line.12100">     *     @param objectPoints Vector of vectors of the calibration pattern points.</a>
<span class="sourceLineNo">12101</span><a id="line.12101">     *     @param imagePoints1 Vector of vectors of the projections of the calibration pattern points,</a>
<span class="sourceLineNo">12102</span><a id="line.12102">     *     observed by the first camera.</a>
<span class="sourceLineNo">12103</span><a id="line.12103">     *     @param imagePoints2 Vector of vectors of the projections of the calibration pattern points,</a>
<span class="sourceLineNo">12104</span><a id="line.12104">     *     observed by the second camera.</a>
<span class="sourceLineNo">12105</span><a id="line.12105">     *     @param K1 Input/output first camera intrinsic matrix:</a>
<span class="sourceLineNo">12106</span><a id="line.12106">     *     \(\vecthreethree{f_x^{(j)}}{0}{c_x^{(j)}}{0}{f_y^{(j)}}{c_y^{(j)}}{0}{0}{1}\) , \(j = 0,\, 1\) . If</a>
<span class="sourceLineNo">12107</span><a id="line.12107">     *     any of REF: fisheye::CALIB_USE_INTRINSIC_GUESS , REF: fisheye::CALIB_FIX_INTRINSIC are specified,</a>
<span class="sourceLineNo">12108</span><a id="line.12108">     *     some or all of the matrix components must be initialized.</a>
<span class="sourceLineNo">12109</span><a id="line.12109">     *     @param D1 Input/output vector of distortion coefficients \(\distcoeffsfisheye\) of 4 elements.</a>
<span class="sourceLineNo">12110</span><a id="line.12110">     *     @param K2 Input/output second camera intrinsic matrix. The parameter is similar to K1 .</a>
<span class="sourceLineNo">12111</span><a id="line.12111">     *     @param D2 Input/output lens distortion coefficients for the second camera. The parameter is</a>
<span class="sourceLineNo">12112</span><a id="line.12112">     *     similar to D1 .</a>
<span class="sourceLineNo">12113</span><a id="line.12113">     *     @param imageSize Size of the image used only to initialize camera intrinsic matrix.</a>
<span class="sourceLineNo">12114</span><a id="line.12114">     *     @param R Output rotation matrix between the 1st and the 2nd camera coordinate systems.</a>
<span class="sourceLineNo">12115</span><a id="line.12115">     *     @param T Output translation vector between the coordinate systems of the cameras.</a>
<span class="sourceLineNo">12116</span><a id="line.12116">     *     @param flags Different flags that may be zero or a combination of the following values:</a>
<span class="sourceLineNo">12117</span><a id="line.12117">     * &lt;ul&gt;</a>
<span class="sourceLineNo">12118</span><a id="line.12118">     *   &lt;li&gt;</a>
<span class="sourceLineNo">12119</span><a id="line.12119">     *         REF: fisheye::CALIB_FIX_INTRINSIC  Fix K1, K2? and D1, D2? so that only R, T matrices</a>
<span class="sourceLineNo">12120</span><a id="line.12120">     *     are estimated.</a>
<span class="sourceLineNo">12121</span><a id="line.12121">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">12122</span><a id="line.12122">     *   &lt;li&gt;</a>
<span class="sourceLineNo">12123</span><a id="line.12123">     *         REF: fisheye::CALIB_USE_INTRINSIC_GUESS  K1, K2 contains valid initial values of</a>
<span class="sourceLineNo">12124</span><a id="line.12124">     *     fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image</a>
<span class="sourceLineNo">12125</span><a id="line.12125">     *     center (imageSize is used), and focal distances are computed in a least-squares fashion.</a>
<span class="sourceLineNo">12126</span><a id="line.12126">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">12127</span><a id="line.12127">     *   &lt;li&gt;</a>
<span class="sourceLineNo">12128</span><a id="line.12128">     *         REF: fisheye::CALIB_RECOMPUTE_EXTRINSIC  Extrinsic will be recomputed after each iteration</a>
<span class="sourceLineNo">12129</span><a id="line.12129">     *     of intrinsic optimization.</a>
<span class="sourceLineNo">12130</span><a id="line.12130">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">12131</span><a id="line.12131">     *   &lt;li&gt;</a>
<span class="sourceLineNo">12132</span><a id="line.12132">     *         REF: fisheye::CALIB_CHECK_COND  The functions will check validity of condition number.</a>
<span class="sourceLineNo">12133</span><a id="line.12133">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">12134</span><a id="line.12134">     *   &lt;li&gt;</a>
<span class="sourceLineNo">12135</span><a id="line.12135">     *         REF: fisheye::CALIB_FIX_SKEW  Skew coefficient (alpha) is set to zero and stay zero.</a>
<span class="sourceLineNo">12136</span><a id="line.12136">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">12137</span><a id="line.12137">     *   &lt;li&gt;</a>
<span class="sourceLineNo">12138</span><a id="line.12138">     *        REF: fisheye::CALIB_FIX_K1,..., REF: fisheye::CALIB_FIX_K4 Selected distortion coefficients are set to zeros and stay</a>
<span class="sourceLineNo">12139</span><a id="line.12139">     *     zero.</a>
<span class="sourceLineNo">12140</span><a id="line.12140">     *     @param criteria Termination criteria for the iterative optimization algorithm.</a>
<span class="sourceLineNo">12141</span><a id="line.12141">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">12142</span><a id="line.12142">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">12143</span><a id="line.12143">     * @return automatically generated</a>
<span class="sourceLineNo">12144</span><a id="line.12144">     */</a>
<span class="sourceLineNo">12145</span><a id="line.12145">    public static double fisheye_stereoCalibrate(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints1, List&lt;Mat&gt; imagePoints2, Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat T, int flags, TermCriteria criteria) {</a>
<span class="sourceLineNo">12146</span><a id="line.12146">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">12147</span><a id="line.12147">        Mat imagePoints1_mat = Converters.vector_Mat_to_Mat(imagePoints1);</a>
<span class="sourceLineNo">12148</span><a id="line.12148">        Mat imagePoints2_mat = Converters.vector_Mat_to_Mat(imagePoints2);</a>
<span class="sourceLineNo">12149</span><a id="line.12149">        return fisheye_stereoCalibrate_0(objectPoints_mat.nativeObj, imagePoints1_mat.nativeObj, imagePoints2_mat.nativeObj, K1.nativeObj, D1.nativeObj, K2.nativeObj, D2.nativeObj, imageSize.width, imageSize.height, R.nativeObj, T.nativeObj, flags, criteria.type, criteria.maxCount, criteria.epsilon);</a>
<span class="sourceLineNo">12150</span><a id="line.12150">    }</a>
<span class="sourceLineNo">12151</span><a id="line.12151"></a>
<span class="sourceLineNo">12152</span><a id="line.12152">    /**</a>
<span class="sourceLineNo">12153</span><a id="line.12153">     * Performs stereo calibration</a>
<span class="sourceLineNo">12154</span><a id="line.12154">     *</a>
<span class="sourceLineNo">12155</span><a id="line.12155">     *     @param objectPoints Vector of vectors of the calibration pattern points.</a>
<span class="sourceLineNo">12156</span><a id="line.12156">     *     @param imagePoints1 Vector of vectors of the projections of the calibration pattern points,</a>
<span class="sourceLineNo">12157</span><a id="line.12157">     *     observed by the first camera.</a>
<span class="sourceLineNo">12158</span><a id="line.12158">     *     @param imagePoints2 Vector of vectors of the projections of the calibration pattern points,</a>
<span class="sourceLineNo">12159</span><a id="line.12159">     *     observed by the second camera.</a>
<span class="sourceLineNo">12160</span><a id="line.12160">     *     @param K1 Input/output first camera intrinsic matrix:</a>
<span class="sourceLineNo">12161</span><a id="line.12161">     *     \(\vecthreethree{f_x^{(j)}}{0}{c_x^{(j)}}{0}{f_y^{(j)}}{c_y^{(j)}}{0}{0}{1}\) , \(j = 0,\, 1\) . If</a>
<span class="sourceLineNo">12162</span><a id="line.12162">     *     any of REF: fisheye::CALIB_USE_INTRINSIC_GUESS , REF: fisheye::CALIB_FIX_INTRINSIC are specified,</a>
<span class="sourceLineNo">12163</span><a id="line.12163">     *     some or all of the matrix components must be initialized.</a>
<span class="sourceLineNo">12164</span><a id="line.12164">     *     @param D1 Input/output vector of distortion coefficients \(\distcoeffsfisheye\) of 4 elements.</a>
<span class="sourceLineNo">12165</span><a id="line.12165">     *     @param K2 Input/output second camera intrinsic matrix. The parameter is similar to K1 .</a>
<span class="sourceLineNo">12166</span><a id="line.12166">     *     @param D2 Input/output lens distortion coefficients for the second camera. The parameter is</a>
<span class="sourceLineNo">12167</span><a id="line.12167">     *     similar to D1 .</a>
<span class="sourceLineNo">12168</span><a id="line.12168">     *     @param imageSize Size of the image used only to initialize camera intrinsic matrix.</a>
<span class="sourceLineNo">12169</span><a id="line.12169">     *     @param R Output rotation matrix between the 1st and the 2nd camera coordinate systems.</a>
<span class="sourceLineNo">12170</span><a id="line.12170">     *     @param T Output translation vector between the coordinate systems of the cameras.</a>
<span class="sourceLineNo">12171</span><a id="line.12171">     *     @param flags Different flags that may be zero or a combination of the following values:</a>
<span class="sourceLineNo">12172</span><a id="line.12172">     * &lt;ul&gt;</a>
<span class="sourceLineNo">12173</span><a id="line.12173">     *   &lt;li&gt;</a>
<span class="sourceLineNo">12174</span><a id="line.12174">     *         REF: fisheye::CALIB_FIX_INTRINSIC  Fix K1, K2? and D1, D2? so that only R, T matrices</a>
<span class="sourceLineNo">12175</span><a id="line.12175">     *     are estimated.</a>
<span class="sourceLineNo">12176</span><a id="line.12176">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">12177</span><a id="line.12177">     *   &lt;li&gt;</a>
<span class="sourceLineNo">12178</span><a id="line.12178">     *         REF: fisheye::CALIB_USE_INTRINSIC_GUESS  K1, K2 contains valid initial values of</a>
<span class="sourceLineNo">12179</span><a id="line.12179">     *     fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image</a>
<span class="sourceLineNo">12180</span><a id="line.12180">     *     center (imageSize is used), and focal distances are computed in a least-squares fashion.</a>
<span class="sourceLineNo">12181</span><a id="line.12181">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">12182</span><a id="line.12182">     *   &lt;li&gt;</a>
<span class="sourceLineNo">12183</span><a id="line.12183">     *         REF: fisheye::CALIB_RECOMPUTE_EXTRINSIC  Extrinsic will be recomputed after each iteration</a>
<span class="sourceLineNo">12184</span><a id="line.12184">     *     of intrinsic optimization.</a>
<span class="sourceLineNo">12185</span><a id="line.12185">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">12186</span><a id="line.12186">     *   &lt;li&gt;</a>
<span class="sourceLineNo">12187</span><a id="line.12187">     *         REF: fisheye::CALIB_CHECK_COND  The functions will check validity of condition number.</a>
<span class="sourceLineNo">12188</span><a id="line.12188">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">12189</span><a id="line.12189">     *   &lt;li&gt;</a>
<span class="sourceLineNo">12190</span><a id="line.12190">     *         REF: fisheye::CALIB_FIX_SKEW  Skew coefficient (alpha) is set to zero and stay zero.</a>
<span class="sourceLineNo">12191</span><a id="line.12191">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">12192</span><a id="line.12192">     *   &lt;li&gt;</a>
<span class="sourceLineNo">12193</span><a id="line.12193">     *        REF: fisheye::CALIB_FIX_K1,..., REF: fisheye::CALIB_FIX_K4 Selected distortion coefficients are set to zeros and stay</a>
<span class="sourceLineNo">12194</span><a id="line.12194">     *     zero.</a>
<span class="sourceLineNo">12195</span><a id="line.12195">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">12196</span><a id="line.12196">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">12197</span><a id="line.12197">     * @return automatically generated</a>
<span class="sourceLineNo">12198</span><a id="line.12198">     */</a>
<span class="sourceLineNo">12199</span><a id="line.12199">    public static double fisheye_stereoCalibrate(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints1, List&lt;Mat&gt; imagePoints2, Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat T, int flags) {</a>
<span class="sourceLineNo">12200</span><a id="line.12200">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">12201</span><a id="line.12201">        Mat imagePoints1_mat = Converters.vector_Mat_to_Mat(imagePoints1);</a>
<span class="sourceLineNo">12202</span><a id="line.12202">        Mat imagePoints2_mat = Converters.vector_Mat_to_Mat(imagePoints2);</a>
<span class="sourceLineNo">12203</span><a id="line.12203">        return fisheye_stereoCalibrate_1(objectPoints_mat.nativeObj, imagePoints1_mat.nativeObj, imagePoints2_mat.nativeObj, K1.nativeObj, D1.nativeObj, K2.nativeObj, D2.nativeObj, imageSize.width, imageSize.height, R.nativeObj, T.nativeObj, flags);</a>
<span class="sourceLineNo">12204</span><a id="line.12204">    }</a>
<span class="sourceLineNo">12205</span><a id="line.12205"></a>
<span class="sourceLineNo">12206</span><a id="line.12206">    /**</a>
<span class="sourceLineNo">12207</span><a id="line.12207">     * Performs stereo calibration</a>
<span class="sourceLineNo">12208</span><a id="line.12208">     *</a>
<span class="sourceLineNo">12209</span><a id="line.12209">     *     @param objectPoints Vector of vectors of the calibration pattern points.</a>
<span class="sourceLineNo">12210</span><a id="line.12210">     *     @param imagePoints1 Vector of vectors of the projections of the calibration pattern points,</a>
<span class="sourceLineNo">12211</span><a id="line.12211">     *     observed by the first camera.</a>
<span class="sourceLineNo">12212</span><a id="line.12212">     *     @param imagePoints2 Vector of vectors of the projections of the calibration pattern points,</a>
<span class="sourceLineNo">12213</span><a id="line.12213">     *     observed by the second camera.</a>
<span class="sourceLineNo">12214</span><a id="line.12214">     *     @param K1 Input/output first camera intrinsic matrix:</a>
<span class="sourceLineNo">12215</span><a id="line.12215">     *     \(\vecthreethree{f_x^{(j)}}{0}{c_x^{(j)}}{0}{f_y^{(j)}}{c_y^{(j)}}{0}{0}{1}\) , \(j = 0,\, 1\) . If</a>
<span class="sourceLineNo">12216</span><a id="line.12216">     *     any of REF: fisheye::CALIB_USE_INTRINSIC_GUESS , REF: fisheye::CALIB_FIX_INTRINSIC are specified,</a>
<span class="sourceLineNo">12217</span><a id="line.12217">     *     some or all of the matrix components must be initialized.</a>
<span class="sourceLineNo">12218</span><a id="line.12218">     *     @param D1 Input/output vector of distortion coefficients \(\distcoeffsfisheye\) of 4 elements.</a>
<span class="sourceLineNo">12219</span><a id="line.12219">     *     @param K2 Input/output second camera intrinsic matrix. The parameter is similar to K1 .</a>
<span class="sourceLineNo">12220</span><a id="line.12220">     *     @param D2 Input/output lens distortion coefficients for the second camera. The parameter is</a>
<span class="sourceLineNo">12221</span><a id="line.12221">     *     similar to D1 .</a>
<span class="sourceLineNo">12222</span><a id="line.12222">     *     @param imageSize Size of the image used only to initialize camera intrinsic matrix.</a>
<span class="sourceLineNo">12223</span><a id="line.12223">     *     @param R Output rotation matrix between the 1st and the 2nd camera coordinate systems.</a>
<span class="sourceLineNo">12224</span><a id="line.12224">     *     @param T Output translation vector between the coordinate systems of the cameras.</a>
<span class="sourceLineNo">12225</span><a id="line.12225">     * &lt;ul&gt;</a>
<span class="sourceLineNo">12226</span><a id="line.12226">     *   &lt;li&gt;</a>
<span class="sourceLineNo">12227</span><a id="line.12227">     *         REF: fisheye::CALIB_FIX_INTRINSIC  Fix K1, K2? and D1, D2? so that only R, T matrices</a>
<span class="sourceLineNo">12228</span><a id="line.12228">     *     are estimated.</a>
<span class="sourceLineNo">12229</span><a id="line.12229">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">12230</span><a id="line.12230">     *   &lt;li&gt;</a>
<span class="sourceLineNo">12231</span><a id="line.12231">     *         REF: fisheye::CALIB_USE_INTRINSIC_GUESS  K1, K2 contains valid initial values of</a>
<span class="sourceLineNo">12232</span><a id="line.12232">     *     fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image</a>
<span class="sourceLineNo">12233</span><a id="line.12233">     *     center (imageSize is used), and focal distances are computed in a least-squares fashion.</a>
<span class="sourceLineNo">12234</span><a id="line.12234">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">12235</span><a id="line.12235">     *   &lt;li&gt;</a>
<span class="sourceLineNo">12236</span><a id="line.12236">     *         REF: fisheye::CALIB_RECOMPUTE_EXTRINSIC  Extrinsic will be recomputed after each iteration</a>
<span class="sourceLineNo">12237</span><a id="line.12237">     *     of intrinsic optimization.</a>
<span class="sourceLineNo">12238</span><a id="line.12238">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">12239</span><a id="line.12239">     *   &lt;li&gt;</a>
<span class="sourceLineNo">12240</span><a id="line.12240">     *         REF: fisheye::CALIB_CHECK_COND  The functions will check validity of condition number.</a>
<span class="sourceLineNo">12241</span><a id="line.12241">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">12242</span><a id="line.12242">     *   &lt;li&gt;</a>
<span class="sourceLineNo">12243</span><a id="line.12243">     *         REF: fisheye::CALIB_FIX_SKEW  Skew coefficient (alpha) is set to zero and stay zero.</a>
<span class="sourceLineNo">12244</span><a id="line.12244">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">12245</span><a id="line.12245">     *   &lt;li&gt;</a>
<span class="sourceLineNo">12246</span><a id="line.12246">     *        REF: fisheye::CALIB_FIX_K1,..., REF: fisheye::CALIB_FIX_K4 Selected distortion coefficients are set to zeros and stay</a>
<span class="sourceLineNo">12247</span><a id="line.12247">     *     zero.</a>
<span class="sourceLineNo">12248</span><a id="line.12248">     *   &lt;/li&gt;</a>
<span class="sourceLineNo">12249</span><a id="line.12249">     * &lt;/ul&gt;</a>
<span class="sourceLineNo">12250</span><a id="line.12250">     * @return automatically generated</a>
<span class="sourceLineNo">12251</span><a id="line.12251">     */</a>
<span class="sourceLineNo">12252</span><a id="line.12252">    public static double fisheye_stereoCalibrate(List&lt;Mat&gt; objectPoints, List&lt;Mat&gt; imagePoints1, List&lt;Mat&gt; imagePoints2, Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat T) {</a>
<span class="sourceLineNo">12253</span><a id="line.12253">        Mat objectPoints_mat = Converters.vector_Mat_to_Mat(objectPoints);</a>
<span class="sourceLineNo">12254</span><a id="line.12254">        Mat imagePoints1_mat = Converters.vector_Mat_to_Mat(imagePoints1);</a>
<span class="sourceLineNo">12255</span><a id="line.12255">        Mat imagePoints2_mat = Converters.vector_Mat_to_Mat(imagePoints2);</a>
<span class="sourceLineNo">12256</span><a id="line.12256">        return fisheye_stereoCalibrate_2(objectPoints_mat.nativeObj, imagePoints1_mat.nativeObj, imagePoints2_mat.nativeObj, K1.nativeObj, D1.nativeObj, K2.nativeObj, D2.nativeObj, imageSize.width, imageSize.height, R.nativeObj, T.nativeObj);</a>
<span class="sourceLineNo">12257</span><a id="line.12257">    }</a>
<span class="sourceLineNo">12258</span><a id="line.12258"></a>
<span class="sourceLineNo">12259</span><a id="line.12259"></a>
<span class="sourceLineNo">12260</span><a id="line.12260"></a>
<span class="sourceLineNo">12261</span><a id="line.12261"></a>
<span class="sourceLineNo">12262</span><a id="line.12262">    // C++:  void cv::Rodrigues(Mat src, Mat&amp; dst, Mat&amp; jacobian = Mat())</a>
<span class="sourceLineNo">12263</span><a id="line.12263">    private static native void Rodrigues_0(long src_nativeObj, long dst_nativeObj, long jacobian_nativeObj);</a>
<span class="sourceLineNo">12264</span><a id="line.12264">    private static native void Rodrigues_1(long src_nativeObj, long dst_nativeObj);</a>
<span class="sourceLineNo">12265</span><a id="line.12265"></a>
<span class="sourceLineNo">12266</span><a id="line.12266">    // C++:  Mat cv::findHomography(vector_Point2f srcPoints, vector_Point2f dstPoints, int method = 0, double ransacReprojThreshold = 3, Mat&amp; mask = Mat(), int maxIters = 2000, double confidence = 0.995)</a>
<span class="sourceLineNo">12267</span><a id="line.12267">    private static native long findHomography_0(long srcPoints_mat_nativeObj, long dstPoints_mat_nativeObj, int method, double ransacReprojThreshold, long mask_nativeObj, int maxIters, double confidence);</a>
<span class="sourceLineNo">12268</span><a id="line.12268">    private static native long findHomography_1(long srcPoints_mat_nativeObj, long dstPoints_mat_nativeObj, int method, double ransacReprojThreshold, long mask_nativeObj, int maxIters);</a>
<span class="sourceLineNo">12269</span><a id="line.12269">    private static native long findHomography_2(long srcPoints_mat_nativeObj, long dstPoints_mat_nativeObj, int method, double ransacReprojThreshold, long mask_nativeObj);</a>
<span class="sourceLineNo">12270</span><a id="line.12270">    private static native long findHomography_3(long srcPoints_mat_nativeObj, long dstPoints_mat_nativeObj, int method, double ransacReprojThreshold);</a>
<span class="sourceLineNo">12271</span><a id="line.12271">    private static native long findHomography_4(long srcPoints_mat_nativeObj, long dstPoints_mat_nativeObj, int method);</a>
<span class="sourceLineNo">12272</span><a id="line.12272">    private static native long findHomography_5(long srcPoints_mat_nativeObj, long dstPoints_mat_nativeObj);</a>
<span class="sourceLineNo">12273</span><a id="line.12273"></a>
<span class="sourceLineNo">12274</span><a id="line.12274">    // C++:  Mat cv::findHomography(vector_Point2f srcPoints, vector_Point2f dstPoints, Mat&amp; mask, UsacParams params)</a>
<span class="sourceLineNo">12275</span><a id="line.12275">    private static native long findHomography_6(long srcPoints_mat_nativeObj, long dstPoints_mat_nativeObj, long mask_nativeObj, long params_nativeObj);</a>
<span class="sourceLineNo">12276</span><a id="line.12276"></a>
<span class="sourceLineNo">12277</span><a id="line.12277">    // C++:  Vec3d cv::RQDecomp3x3(Mat src, Mat&amp; mtxR, Mat&amp; mtxQ, Mat&amp; Qx = Mat(), Mat&amp; Qy = Mat(), Mat&amp; Qz = Mat())</a>
<span class="sourceLineNo">12278</span><a id="line.12278">    private static native double[] RQDecomp3x3_0(long src_nativeObj, long mtxR_nativeObj, long mtxQ_nativeObj, long Qx_nativeObj, long Qy_nativeObj, long Qz_nativeObj);</a>
<span class="sourceLineNo">12279</span><a id="line.12279">    private static native double[] RQDecomp3x3_1(long src_nativeObj, long mtxR_nativeObj, long mtxQ_nativeObj, long Qx_nativeObj, long Qy_nativeObj);</a>
<span class="sourceLineNo">12280</span><a id="line.12280">    private static native double[] RQDecomp3x3_2(long src_nativeObj, long mtxR_nativeObj, long mtxQ_nativeObj, long Qx_nativeObj);</a>
<span class="sourceLineNo">12281</span><a id="line.12281">    private static native double[] RQDecomp3x3_3(long src_nativeObj, long mtxR_nativeObj, long mtxQ_nativeObj);</a>
<span class="sourceLineNo">12282</span><a id="line.12282"></a>
<span class="sourceLineNo">12283</span><a id="line.12283">    // C++:  void cv::decomposeProjectionMatrix(Mat projMatrix, Mat&amp; cameraMatrix, Mat&amp; rotMatrix, Mat&amp; transVect, Mat&amp; rotMatrixX = Mat(), Mat&amp; rotMatrixY = Mat(), Mat&amp; rotMatrixZ = Mat(), Mat&amp; eulerAngles = Mat())</a>
<span class="sourceLineNo">12284</span><a id="line.12284">    private static native void decomposeProjectionMatrix_0(long projMatrix_nativeObj, long cameraMatrix_nativeObj, long rotMatrix_nativeObj, long transVect_nativeObj, long rotMatrixX_nativeObj, long rotMatrixY_nativeObj, long rotMatrixZ_nativeObj, long eulerAngles_nativeObj);</a>
<span class="sourceLineNo">12285</span><a id="line.12285">    private static native void decomposeProjectionMatrix_1(long projMatrix_nativeObj, long cameraMatrix_nativeObj, long rotMatrix_nativeObj, long transVect_nativeObj, long rotMatrixX_nativeObj, long rotMatrixY_nativeObj, long rotMatrixZ_nativeObj);</a>
<span class="sourceLineNo">12286</span><a id="line.12286">    private static native void decomposeProjectionMatrix_2(long projMatrix_nativeObj, long cameraMatrix_nativeObj, long rotMatrix_nativeObj, long transVect_nativeObj, long rotMatrixX_nativeObj, long rotMatrixY_nativeObj);</a>
<span class="sourceLineNo">12287</span><a id="line.12287">    private static native void decomposeProjectionMatrix_3(long projMatrix_nativeObj, long cameraMatrix_nativeObj, long rotMatrix_nativeObj, long transVect_nativeObj, long rotMatrixX_nativeObj);</a>
<span class="sourceLineNo">12288</span><a id="line.12288">    private static native void decomposeProjectionMatrix_4(long projMatrix_nativeObj, long cameraMatrix_nativeObj, long rotMatrix_nativeObj, long transVect_nativeObj);</a>
<span class="sourceLineNo">12289</span><a id="line.12289"></a>
<span class="sourceLineNo">12290</span><a id="line.12290">    // C++:  void cv::matMulDeriv(Mat A, Mat B, Mat&amp; dABdA, Mat&amp; dABdB)</a>
<span class="sourceLineNo">12291</span><a id="line.12291">    private static native void matMulDeriv_0(long A_nativeObj, long B_nativeObj, long dABdA_nativeObj, long dABdB_nativeObj);</a>
<span class="sourceLineNo">12292</span><a id="line.12292"></a>
<span class="sourceLineNo">12293</span><a id="line.12293">    // C++:  void cv::composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat&amp; rvec3, Mat&amp; tvec3, Mat&amp; dr3dr1 = Mat(), Mat&amp; dr3dt1 = Mat(), Mat&amp; dr3dr2 = Mat(), Mat&amp; dr3dt2 = Mat(), Mat&amp; dt3dr1 = Mat(), Mat&amp; dt3dt1 = Mat(), Mat&amp; dt3dr2 = Mat(), Mat&amp; dt3dt2 = Mat())</a>
<span class="sourceLineNo">12294</span><a id="line.12294">    private static native void composeRT_0(long rvec1_nativeObj, long tvec1_nativeObj, long rvec2_nativeObj, long tvec2_nativeObj, long rvec3_nativeObj, long tvec3_nativeObj, long dr3dr1_nativeObj, long dr3dt1_nativeObj, long dr3dr2_nativeObj, long dr3dt2_nativeObj, long dt3dr1_nativeObj, long dt3dt1_nativeObj, long dt3dr2_nativeObj, long dt3dt2_nativeObj);</a>
<span class="sourceLineNo">12295</span><a id="line.12295">    private static native void composeRT_1(long rvec1_nativeObj, long tvec1_nativeObj, long rvec2_nativeObj, long tvec2_nativeObj, long rvec3_nativeObj, long tvec3_nativeObj, long dr3dr1_nativeObj, long dr3dt1_nativeObj, long dr3dr2_nativeObj, long dr3dt2_nativeObj, long dt3dr1_nativeObj, long dt3dt1_nativeObj, long dt3dr2_nativeObj);</a>
<span class="sourceLineNo">12296</span><a id="line.12296">    private static native void composeRT_2(long rvec1_nativeObj, long tvec1_nativeObj, long rvec2_nativeObj, long tvec2_nativeObj, long rvec3_nativeObj, long tvec3_nativeObj, long dr3dr1_nativeObj, long dr3dt1_nativeObj, long dr3dr2_nativeObj, long dr3dt2_nativeObj, long dt3dr1_nativeObj, long dt3dt1_nativeObj);</a>
<span class="sourceLineNo">12297</span><a id="line.12297">    private static native void composeRT_3(long rvec1_nativeObj, long tvec1_nativeObj, long rvec2_nativeObj, long tvec2_nativeObj, long rvec3_nativeObj, long tvec3_nativeObj, long dr3dr1_nativeObj, long dr3dt1_nativeObj, long dr3dr2_nativeObj, long dr3dt2_nativeObj, long dt3dr1_nativeObj);</a>
<span class="sourceLineNo">12298</span><a id="line.12298">    private static native void composeRT_4(long rvec1_nativeObj, long tvec1_nativeObj, long rvec2_nativeObj, long tvec2_nativeObj, long rvec3_nativeObj, long tvec3_nativeObj, long dr3dr1_nativeObj, long dr3dt1_nativeObj, long dr3dr2_nativeObj, long dr3dt2_nativeObj);</a>
<span class="sourceLineNo">12299</span><a id="line.12299">    private static native void composeRT_5(long rvec1_nativeObj, long tvec1_nativeObj, long rvec2_nativeObj, long tvec2_nativeObj, long rvec3_nativeObj, long tvec3_nativeObj, long dr3dr1_nativeObj, long dr3dt1_nativeObj, long dr3dr2_nativeObj);</a>
<span class="sourceLineNo">12300</span><a id="line.12300">    private static native void composeRT_6(long rvec1_nativeObj, long tvec1_nativeObj, long rvec2_nativeObj, long tvec2_nativeObj, long rvec3_nativeObj, long tvec3_nativeObj, long dr3dr1_nativeObj, long dr3dt1_nativeObj);</a>
<span class="sourceLineNo">12301</span><a id="line.12301">    private static native void composeRT_7(long rvec1_nativeObj, long tvec1_nativeObj, long rvec2_nativeObj, long tvec2_nativeObj, long rvec3_nativeObj, long tvec3_nativeObj, long dr3dr1_nativeObj);</a>
<span class="sourceLineNo">12302</span><a id="line.12302">    private static native void composeRT_8(long rvec1_nativeObj, long tvec1_nativeObj, long rvec2_nativeObj, long tvec2_nativeObj, long rvec3_nativeObj, long tvec3_nativeObj);</a>
<span class="sourceLineNo">12303</span><a id="line.12303"></a>
<span class="sourceLineNo">12304</span><a id="line.12304">    // C++:  void cv::projectPoints(vector_Point3f objectPoints, Mat rvec, Mat tvec, Mat cameraMatrix, vector_double distCoeffs, vector_Point2f&amp; imagePoints, Mat&amp; jacobian = Mat(), double aspectRatio = 0)</a>
<span class="sourceLineNo">12305</span><a id="line.12305">    private static native void projectPoints_0(long objectPoints_mat_nativeObj, long rvec_nativeObj, long tvec_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_mat_nativeObj, long imagePoints_mat_nativeObj, long jacobian_nativeObj, double aspectRatio);</a>
<span class="sourceLineNo">12306</span><a id="line.12306">    private static native void projectPoints_1(long objectPoints_mat_nativeObj, long rvec_nativeObj, long tvec_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_mat_nativeObj, long imagePoints_mat_nativeObj, long jacobian_nativeObj);</a>
<span class="sourceLineNo">12307</span><a id="line.12307">    private static native void projectPoints_2(long objectPoints_mat_nativeObj, long rvec_nativeObj, long tvec_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_mat_nativeObj, long imagePoints_mat_nativeObj);</a>
<span class="sourceLineNo">12308</span><a id="line.12308"></a>
<span class="sourceLineNo">12309</span><a id="line.12309">    // C++:  bool cv::solvePnP(vector_Point3f objectPoints, vector_Point2f imagePoints, Mat cameraMatrix, vector_double distCoeffs, Mat&amp; rvec, Mat&amp; tvec, bool useExtrinsicGuess = false, int flags = SOLVEPNP_ITERATIVE)</a>
<span class="sourceLineNo">12310</span><a id="line.12310">    private static native boolean solvePnP_0(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_mat_nativeObj, long rvec_nativeObj, long tvec_nativeObj, boolean useExtrinsicGuess, int flags);</a>
<span class="sourceLineNo">12311</span><a id="line.12311">    private static native boolean solvePnP_1(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_mat_nativeObj, long rvec_nativeObj, long tvec_nativeObj, boolean useExtrinsicGuess);</a>
<span class="sourceLineNo">12312</span><a id="line.12312">    private static native boolean solvePnP_2(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_mat_nativeObj, long rvec_nativeObj, long tvec_nativeObj);</a>
<span class="sourceLineNo">12313</span><a id="line.12313"></a>
<span class="sourceLineNo">12314</span><a id="line.12314">    // C++:  bool cv::solvePnPRansac(vector_Point3f objectPoints, vector_Point2f imagePoints, Mat cameraMatrix, vector_double distCoeffs, Mat&amp; rvec, Mat&amp; tvec, bool useExtrinsicGuess = false, int iterationsCount = 100, float reprojectionError = 8.0, double confidence = 0.99, Mat&amp; inliers = Mat(), int flags = SOLVEPNP_ITERATIVE)</a>
<span class="sourceLineNo">12315</span><a id="line.12315">    private static native boolean solvePnPRansac_0(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_mat_nativeObj, long rvec_nativeObj, long tvec_nativeObj, boolean useExtrinsicGuess, int iterationsCount, float reprojectionError, double confidence, long inliers_nativeObj, int flags);</a>
<span class="sourceLineNo">12316</span><a id="line.12316">    private static native boolean solvePnPRansac_1(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_mat_nativeObj, long rvec_nativeObj, long tvec_nativeObj, boolean useExtrinsicGuess, int iterationsCount, float reprojectionError, double confidence, long inliers_nativeObj);</a>
<span class="sourceLineNo">12317</span><a id="line.12317">    private static native boolean solvePnPRansac_2(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_mat_nativeObj, long rvec_nativeObj, long tvec_nativeObj, boolean useExtrinsicGuess, int iterationsCount, float reprojectionError, double confidence);</a>
<span class="sourceLineNo">12318</span><a id="line.12318">    private static native boolean solvePnPRansac_3(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_mat_nativeObj, long rvec_nativeObj, long tvec_nativeObj, boolean useExtrinsicGuess, int iterationsCount, float reprojectionError);</a>
<span class="sourceLineNo">12319</span><a id="line.12319">    private static native boolean solvePnPRansac_4(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_mat_nativeObj, long rvec_nativeObj, long tvec_nativeObj, boolean useExtrinsicGuess, int iterationsCount);</a>
<span class="sourceLineNo">12320</span><a id="line.12320">    private static native boolean solvePnPRansac_5(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_mat_nativeObj, long rvec_nativeObj, long tvec_nativeObj, boolean useExtrinsicGuess);</a>
<span class="sourceLineNo">12321</span><a id="line.12321">    private static native boolean solvePnPRansac_6(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_mat_nativeObj, long rvec_nativeObj, long tvec_nativeObj);</a>
<span class="sourceLineNo">12322</span><a id="line.12322"></a>
<span class="sourceLineNo">12323</span><a id="line.12323">    // C++:  bool cv::solvePnPRansac(vector_Point3f objectPoints, vector_Point2f imagePoints, Mat&amp; cameraMatrix, vector_double distCoeffs, Mat&amp; rvec, Mat&amp; tvec, Mat&amp; inliers, UsacParams params = UsacParams())</a>
<span class="sourceLineNo">12324</span><a id="line.12324">    private static native boolean solvePnPRansac_7(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_mat_nativeObj, long rvec_nativeObj, long tvec_nativeObj, long inliers_nativeObj, long params_nativeObj);</a>
<span class="sourceLineNo">12325</span><a id="line.12325">    private static native boolean solvePnPRansac_8(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_mat_nativeObj, long rvec_nativeObj, long tvec_nativeObj, long inliers_nativeObj);</a>
<span class="sourceLineNo">12326</span><a id="line.12326"></a>
<span class="sourceLineNo">12327</span><a id="line.12327">    // C++:  int cv::solveP3P(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, vector_Mat&amp; rvecs, vector_Mat&amp; tvecs, int flags)</a>
<span class="sourceLineNo">12328</span><a id="line.12328">    private static native int solveP3P_0(long objectPoints_nativeObj, long imagePoints_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvecs_mat_nativeObj, long tvecs_mat_nativeObj, int flags);</a>
<span class="sourceLineNo">12329</span><a id="line.12329"></a>
<span class="sourceLineNo">12330</span><a id="line.12330">    // C++:  void cv::solvePnPRefineLM(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat&amp; rvec, Mat&amp; tvec, TermCriteria criteria = TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON))</a>
<span class="sourceLineNo">12331</span><a id="line.12331">    private static native void solvePnPRefineLM_0(long objectPoints_nativeObj, long imagePoints_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvec_nativeObj, long tvec_nativeObj, int criteria_type, int criteria_maxCount, double criteria_epsilon);</a>
<span class="sourceLineNo">12332</span><a id="line.12332">    private static native void solvePnPRefineLM_1(long objectPoints_nativeObj, long imagePoints_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvec_nativeObj, long tvec_nativeObj);</a>
<span class="sourceLineNo">12333</span><a id="line.12333"></a>
<span class="sourceLineNo">12334</span><a id="line.12334">    // C++:  void cv::solvePnPRefineVVS(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat&amp; rvec, Mat&amp; tvec, TermCriteria criteria = TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON), double VVSlambda = 1)</a>
<span class="sourceLineNo">12335</span><a id="line.12335">    private static native void solvePnPRefineVVS_0(long objectPoints_nativeObj, long imagePoints_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvec_nativeObj, long tvec_nativeObj, int criteria_type, int criteria_maxCount, double criteria_epsilon, double VVSlambda);</a>
<span class="sourceLineNo">12336</span><a id="line.12336">    private static native void solvePnPRefineVVS_1(long objectPoints_nativeObj, long imagePoints_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvec_nativeObj, long tvec_nativeObj, int criteria_type, int criteria_maxCount, double criteria_epsilon);</a>
<span class="sourceLineNo">12337</span><a id="line.12337">    private static native void solvePnPRefineVVS_2(long objectPoints_nativeObj, long imagePoints_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvec_nativeObj, long tvec_nativeObj);</a>
<span class="sourceLineNo">12338</span><a id="line.12338"></a>
<span class="sourceLineNo">12339</span><a id="line.12339">    // C++:  int cv::solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, vector_Mat&amp; rvecs, vector_Mat&amp; tvecs, bool useExtrinsicGuess = false, SolvePnPMethod flags = SOLVEPNP_ITERATIVE, Mat rvec = Mat(), Mat tvec = Mat(), Mat&amp; reprojectionError = Mat())</a>
<span class="sourceLineNo">12340</span><a id="line.12340">    private static native int solvePnPGeneric_0(long objectPoints_nativeObj, long imagePoints_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvecs_mat_nativeObj, long tvecs_mat_nativeObj, boolean useExtrinsicGuess, int flags, long rvec_nativeObj, long tvec_nativeObj, long reprojectionError_nativeObj);</a>
<span class="sourceLineNo">12341</span><a id="line.12341">    private static native int solvePnPGeneric_1(long objectPoints_nativeObj, long imagePoints_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvecs_mat_nativeObj, long tvecs_mat_nativeObj, boolean useExtrinsicGuess, int flags, long rvec_nativeObj, long tvec_nativeObj);</a>
<span class="sourceLineNo">12342</span><a id="line.12342">    private static native int solvePnPGeneric_2(long objectPoints_nativeObj, long imagePoints_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvecs_mat_nativeObj, long tvecs_mat_nativeObj, boolean useExtrinsicGuess, int flags, long rvec_nativeObj);</a>
<span class="sourceLineNo">12343</span><a id="line.12343">    private static native int solvePnPGeneric_3(long objectPoints_nativeObj, long imagePoints_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvecs_mat_nativeObj, long tvecs_mat_nativeObj, boolean useExtrinsicGuess, int flags);</a>
<span class="sourceLineNo">12344</span><a id="line.12344">    private static native int solvePnPGeneric_4(long objectPoints_nativeObj, long imagePoints_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvecs_mat_nativeObj, long tvecs_mat_nativeObj, boolean useExtrinsicGuess);</a>
<span class="sourceLineNo">12345</span><a id="line.12345">    private static native int solvePnPGeneric_5(long objectPoints_nativeObj, long imagePoints_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvecs_mat_nativeObj, long tvecs_mat_nativeObj);</a>
<span class="sourceLineNo">12346</span><a id="line.12346"></a>
<span class="sourceLineNo">12347</span><a id="line.12347">    // C++:  Mat cv::initCameraMatrix2D(vector_vector_Point3f objectPoints, vector_vector_Point2f imagePoints, Size imageSize, double aspectRatio = 1.0)</a>
<span class="sourceLineNo">12348</span><a id="line.12348">    private static native long initCameraMatrix2D_0(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, double imageSize_width, double imageSize_height, double aspectRatio);</a>
<span class="sourceLineNo">12349</span><a id="line.12349">    private static native long initCameraMatrix2D_1(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, double imageSize_width, double imageSize_height);</a>
<span class="sourceLineNo">12350</span><a id="line.12350"></a>
<span class="sourceLineNo">12351</span><a id="line.12351">    // C++:  bool cv::findChessboardCorners(Mat image, Size patternSize, vector_Point2f&amp; corners, int flags = CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE)</a>
<span class="sourceLineNo">12352</span><a id="line.12352">    private static native boolean findChessboardCorners_0(long image_nativeObj, double patternSize_width, double patternSize_height, long corners_mat_nativeObj, int flags);</a>
<span class="sourceLineNo">12353</span><a id="line.12353">    private static native boolean findChessboardCorners_1(long image_nativeObj, double patternSize_width, double patternSize_height, long corners_mat_nativeObj);</a>
<span class="sourceLineNo">12354</span><a id="line.12354"></a>
<span class="sourceLineNo">12355</span><a id="line.12355">    // C++:  bool cv::checkChessboard(Mat img, Size size)</a>
<span class="sourceLineNo">12356</span><a id="line.12356">    private static native boolean checkChessboard_0(long img_nativeObj, double size_width, double size_height);</a>
<span class="sourceLineNo">12357</span><a id="line.12357"></a>
<span class="sourceLineNo">12358</span><a id="line.12358">    // C++:  bool cv::findChessboardCornersSB(Mat image, Size patternSize, Mat&amp; corners, int flags, Mat&amp; meta)</a>
<span class="sourceLineNo">12359</span><a id="line.12359">    private static native boolean findChessboardCornersSBWithMeta_0(long image_nativeObj, double patternSize_width, double patternSize_height, long corners_nativeObj, int flags, long meta_nativeObj);</a>
<span class="sourceLineNo">12360</span><a id="line.12360"></a>
<span class="sourceLineNo">12361</span><a id="line.12361">    // C++:  bool cv::findChessboardCornersSB(Mat image, Size patternSize, Mat&amp; corners, int flags = 0)</a>
<span class="sourceLineNo">12362</span><a id="line.12362">    private static native boolean findChessboardCornersSB_0(long image_nativeObj, double patternSize_width, double patternSize_height, long corners_nativeObj, int flags);</a>
<span class="sourceLineNo">12363</span><a id="line.12363">    private static native boolean findChessboardCornersSB_1(long image_nativeObj, double patternSize_width, double patternSize_height, long corners_nativeObj);</a>
<span class="sourceLineNo">12364</span><a id="line.12364"></a>
<span class="sourceLineNo">12365</span><a id="line.12365">    // C++:  Scalar cv::estimateChessboardSharpness(Mat image, Size patternSize, Mat corners, float rise_distance = 0.8F, bool vertical = false, Mat&amp; sharpness = Mat())</a>
<span class="sourceLineNo">12366</span><a id="line.12366">    private static native double[] estimateChessboardSharpness_0(long image_nativeObj, double patternSize_width, double patternSize_height, long corners_nativeObj, float rise_distance, boolean vertical, long sharpness_nativeObj);</a>
<span class="sourceLineNo">12367</span><a id="line.12367">    private static native double[] estimateChessboardSharpness_1(long image_nativeObj, double patternSize_width, double patternSize_height, long corners_nativeObj, float rise_distance, boolean vertical);</a>
<span class="sourceLineNo">12368</span><a id="line.12368">    private static native double[] estimateChessboardSharpness_2(long image_nativeObj, double patternSize_width, double patternSize_height, long corners_nativeObj, float rise_distance);</a>
<span class="sourceLineNo">12369</span><a id="line.12369">    private static native double[] estimateChessboardSharpness_3(long image_nativeObj, double patternSize_width, double patternSize_height, long corners_nativeObj);</a>
<span class="sourceLineNo">12370</span><a id="line.12370"></a>
<span class="sourceLineNo">12371</span><a id="line.12371">    // C++:  bool cv::find4QuadCornerSubpix(Mat img, Mat&amp; corners, Size region_size)</a>
<span class="sourceLineNo">12372</span><a id="line.12372">    private static native boolean find4QuadCornerSubpix_0(long img_nativeObj, long corners_nativeObj, double region_size_width, double region_size_height);</a>
<span class="sourceLineNo">12373</span><a id="line.12373"></a>
<span class="sourceLineNo">12374</span><a id="line.12374">    // C++:  void cv::drawChessboardCorners(Mat&amp; image, Size patternSize, vector_Point2f corners, bool patternWasFound)</a>
<span class="sourceLineNo">12375</span><a id="line.12375">    private static native void drawChessboardCorners_0(long image_nativeObj, double patternSize_width, double patternSize_height, long corners_mat_nativeObj, boolean patternWasFound);</a>
<span class="sourceLineNo">12376</span><a id="line.12376"></a>
<span class="sourceLineNo">12377</span><a id="line.12377">    // C++:  void cv::drawFrameAxes(Mat&amp; image, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, float length, int thickness = 3)</a>
<span class="sourceLineNo">12378</span><a id="line.12378">    private static native void drawFrameAxes_0(long image_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvec_nativeObj, long tvec_nativeObj, float length, int thickness);</a>
<span class="sourceLineNo">12379</span><a id="line.12379">    private static native void drawFrameAxes_1(long image_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvec_nativeObj, long tvec_nativeObj, float length);</a>
<span class="sourceLineNo">12380</span><a id="line.12380"></a>
<span class="sourceLineNo">12381</span><a id="line.12381">    // C++:  bool cv::findCirclesGrid(Mat image, Size patternSize, Mat&amp; centers, int flags = CALIB_CB_SYMMETRIC_GRID, Ptr_FeatureDetector blobDetector = SimpleBlobDetector::create())</a>
<span class="sourceLineNo">12382</span><a id="line.12382">    private static native boolean findCirclesGrid_0(long image_nativeObj, double patternSize_width, double patternSize_height, long centers_nativeObj, int flags);</a>
<span class="sourceLineNo">12383</span><a id="line.12383">    private static native boolean findCirclesGrid_2(long image_nativeObj, double patternSize_width, double patternSize_height, long centers_nativeObj);</a>
<span class="sourceLineNo">12384</span><a id="line.12384"></a>
<span class="sourceLineNo">12385</span><a id="line.12385">    // C++:  double cv::calibrateCamera(vector_Mat objectPoints, vector_Mat imagePoints, Size imageSize, Mat&amp; cameraMatrix, Mat&amp; distCoeffs, vector_Mat&amp; rvecs, vector_Mat&amp; tvecs, Mat&amp; stdDeviationsIntrinsics, Mat&amp; stdDeviationsExtrinsics, Mat&amp; perViewErrors, int flags = 0, TermCriteria criteria = TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON))</a>
<span class="sourceLineNo">12386</span><a id="line.12386">    private static native double calibrateCameraExtended_0(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, double imageSize_width, double imageSize_height, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvecs_mat_nativeObj, long tvecs_mat_nativeObj, long stdDeviationsIntrinsics_nativeObj, long stdDeviationsExtrinsics_nativeObj, long perViewErrors_nativeObj, int flags, int criteria_type, int criteria_maxCount, double criteria_epsilon);</a>
<span class="sourceLineNo">12387</span><a id="line.12387">    private static native double calibrateCameraExtended_1(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, double imageSize_width, double imageSize_height, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvecs_mat_nativeObj, long tvecs_mat_nativeObj, long stdDeviationsIntrinsics_nativeObj, long stdDeviationsExtrinsics_nativeObj, long perViewErrors_nativeObj, int flags);</a>
<span class="sourceLineNo">12388</span><a id="line.12388">    private static native double calibrateCameraExtended_2(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, double imageSize_width, double imageSize_height, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvecs_mat_nativeObj, long tvecs_mat_nativeObj, long stdDeviationsIntrinsics_nativeObj, long stdDeviationsExtrinsics_nativeObj, long perViewErrors_nativeObj);</a>
<span class="sourceLineNo">12389</span><a id="line.12389"></a>
<span class="sourceLineNo">12390</span><a id="line.12390">    // C++:  double cv::calibrateCamera(vector_Mat objectPoints, vector_Mat imagePoints, Size imageSize, Mat&amp; cameraMatrix, Mat&amp; distCoeffs, vector_Mat&amp; rvecs, vector_Mat&amp; tvecs, int flags = 0, TermCriteria criteria = TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON))</a>
<span class="sourceLineNo">12391</span><a id="line.12391">    private static native double calibrateCamera_0(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, double imageSize_width, double imageSize_height, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvecs_mat_nativeObj, long tvecs_mat_nativeObj, int flags, int criteria_type, int criteria_maxCount, double criteria_epsilon);</a>
<span class="sourceLineNo">12392</span><a id="line.12392">    private static native double calibrateCamera_1(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, double imageSize_width, double imageSize_height, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvecs_mat_nativeObj, long tvecs_mat_nativeObj, int flags);</a>
<span class="sourceLineNo">12393</span><a id="line.12393">    private static native double calibrateCamera_2(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, double imageSize_width, double imageSize_height, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvecs_mat_nativeObj, long tvecs_mat_nativeObj);</a>
<span class="sourceLineNo">12394</span><a id="line.12394"></a>
<span class="sourceLineNo">12395</span><a id="line.12395">    // C++:  double cv::calibrateCameraRO(vector_Mat objectPoints, vector_Mat imagePoints, Size imageSize, int iFixedPoint, Mat&amp; cameraMatrix, Mat&amp; distCoeffs, vector_Mat&amp; rvecs, vector_Mat&amp; tvecs, Mat&amp; newObjPoints, Mat&amp; stdDeviationsIntrinsics, Mat&amp; stdDeviationsExtrinsics, Mat&amp; stdDeviationsObjPoints, Mat&amp; perViewErrors, int flags = 0, TermCriteria criteria = TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON))</a>
<span class="sourceLineNo">12396</span><a id="line.12396">    private static native double calibrateCameraROExtended_0(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, double imageSize_width, double imageSize_height, int iFixedPoint, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvecs_mat_nativeObj, long tvecs_mat_nativeObj, long newObjPoints_nativeObj, long stdDeviationsIntrinsics_nativeObj, long stdDeviationsExtrinsics_nativeObj, long stdDeviationsObjPoints_nativeObj, long perViewErrors_nativeObj, int flags, int criteria_type, int criteria_maxCount, double criteria_epsilon);</a>
<span class="sourceLineNo">12397</span><a id="line.12397">    private static native double calibrateCameraROExtended_1(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, double imageSize_width, double imageSize_height, int iFixedPoint, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvecs_mat_nativeObj, long tvecs_mat_nativeObj, long newObjPoints_nativeObj, long stdDeviationsIntrinsics_nativeObj, long stdDeviationsExtrinsics_nativeObj, long stdDeviationsObjPoints_nativeObj, long perViewErrors_nativeObj, int flags);</a>
<span class="sourceLineNo">12398</span><a id="line.12398">    private static native double calibrateCameraROExtended_2(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, double imageSize_width, double imageSize_height, int iFixedPoint, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvecs_mat_nativeObj, long tvecs_mat_nativeObj, long newObjPoints_nativeObj, long stdDeviationsIntrinsics_nativeObj, long stdDeviationsExtrinsics_nativeObj, long stdDeviationsObjPoints_nativeObj, long perViewErrors_nativeObj);</a>
<span class="sourceLineNo">12399</span><a id="line.12399"></a>
<span class="sourceLineNo">12400</span><a id="line.12400">    // C++:  double cv::calibrateCameraRO(vector_Mat objectPoints, vector_Mat imagePoints, Size imageSize, int iFixedPoint, Mat&amp; cameraMatrix, Mat&amp; distCoeffs, vector_Mat&amp; rvecs, vector_Mat&amp; tvecs, Mat&amp; newObjPoints, int flags = 0, TermCriteria criteria = TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON))</a>
<span class="sourceLineNo">12401</span><a id="line.12401">    private static native double calibrateCameraRO_0(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, double imageSize_width, double imageSize_height, int iFixedPoint, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvecs_mat_nativeObj, long tvecs_mat_nativeObj, long newObjPoints_nativeObj, int flags, int criteria_type, int criteria_maxCount, double criteria_epsilon);</a>
<span class="sourceLineNo">12402</span><a id="line.12402">    private static native double calibrateCameraRO_1(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, double imageSize_width, double imageSize_height, int iFixedPoint, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvecs_mat_nativeObj, long tvecs_mat_nativeObj, long newObjPoints_nativeObj, int flags);</a>
<span class="sourceLineNo">12403</span><a id="line.12403">    private static native double calibrateCameraRO_2(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, double imageSize_width, double imageSize_height, int iFixedPoint, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long rvecs_mat_nativeObj, long tvecs_mat_nativeObj, long newObjPoints_nativeObj);</a>
<span class="sourceLineNo">12404</span><a id="line.12404"></a>
<span class="sourceLineNo">12405</span><a id="line.12405">    // C++:  void cv::calibrationMatrixValues(Mat cameraMatrix, Size imageSize, double apertureWidth, double apertureHeight, double&amp; fovx, double&amp; fovy, double&amp; focalLength, Point2d&amp; principalPoint, double&amp; aspectRatio)</a>
<span class="sourceLineNo">12406</span><a id="line.12406">    private static native void calibrationMatrixValues_0(long cameraMatrix_nativeObj, double imageSize_width, double imageSize_height, double apertureWidth, double apertureHeight, double[] fovx_out, double[] fovy_out, double[] focalLength_out, double[] principalPoint_out, double[] aspectRatio_out);</a>
<span class="sourceLineNo">12407</span><a id="line.12407"></a>
<span class="sourceLineNo">12408</span><a id="line.12408">    // C++:  double cv::stereoCalibrate(vector_Mat objectPoints, vector_Mat imagePoints1, vector_Mat imagePoints2, Mat&amp; cameraMatrix1, Mat&amp; distCoeffs1, Mat&amp; cameraMatrix2, Mat&amp; distCoeffs2, Size imageSize, Mat&amp; R, Mat&amp; T, Mat&amp; E, Mat&amp; F, Mat&amp; perViewErrors, int flags = CALIB_FIX_INTRINSIC, TermCriteria criteria = TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6))</a>
<span class="sourceLineNo">12409</span><a id="line.12409">    private static native double stereoCalibrateExtended_0(long objectPoints_mat_nativeObj, long imagePoints1_mat_nativeObj, long imagePoints2_mat_nativeObj, long cameraMatrix1_nativeObj, long distCoeffs1_nativeObj, long cameraMatrix2_nativeObj, long distCoeffs2_nativeObj, double imageSize_width, double imageSize_height, long R_nativeObj, long T_nativeObj, long E_nativeObj, long F_nativeObj, long perViewErrors_nativeObj, int flags, int criteria_type, int criteria_maxCount, double criteria_epsilon);</a>
<span class="sourceLineNo">12410</span><a id="line.12410">    private static native double stereoCalibrateExtended_1(long objectPoints_mat_nativeObj, long imagePoints1_mat_nativeObj, long imagePoints2_mat_nativeObj, long cameraMatrix1_nativeObj, long distCoeffs1_nativeObj, long cameraMatrix2_nativeObj, long distCoeffs2_nativeObj, double imageSize_width, double imageSize_height, long R_nativeObj, long T_nativeObj, long E_nativeObj, long F_nativeObj, long perViewErrors_nativeObj, int flags);</a>
<span class="sourceLineNo">12411</span><a id="line.12411">    private static native double stereoCalibrateExtended_2(long objectPoints_mat_nativeObj, long imagePoints1_mat_nativeObj, long imagePoints2_mat_nativeObj, long cameraMatrix1_nativeObj, long distCoeffs1_nativeObj, long cameraMatrix2_nativeObj, long distCoeffs2_nativeObj, double imageSize_width, double imageSize_height, long R_nativeObj, long T_nativeObj, long E_nativeObj, long F_nativeObj, long perViewErrors_nativeObj);</a>
<span class="sourceLineNo">12412</span><a id="line.12412"></a>
<span class="sourceLineNo">12413</span><a id="line.12413">    // C++:  double cv::stereoCalibrate(vector_Mat objectPoints, vector_Mat imagePoints1, vector_Mat imagePoints2, Mat&amp; cameraMatrix1, Mat&amp; distCoeffs1, Mat&amp; cameraMatrix2, Mat&amp; distCoeffs2, Size imageSize, Mat&amp; R, Mat&amp; T, Mat&amp; E, Mat&amp; F, int flags = CALIB_FIX_INTRINSIC, TermCriteria criteria = TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6))</a>
<span class="sourceLineNo">12414</span><a id="line.12414">    private static native double stereoCalibrate_0(long objectPoints_mat_nativeObj, long imagePoints1_mat_nativeObj, long imagePoints2_mat_nativeObj, long cameraMatrix1_nativeObj, long distCoeffs1_nativeObj, long cameraMatrix2_nativeObj, long distCoeffs2_nativeObj, double imageSize_width, double imageSize_height, long R_nativeObj, long T_nativeObj, long E_nativeObj, long F_nativeObj, int flags, int criteria_type, int criteria_maxCount, double criteria_epsilon);</a>
<span class="sourceLineNo">12415</span><a id="line.12415">    private static native double stereoCalibrate_1(long objectPoints_mat_nativeObj, long imagePoints1_mat_nativeObj, long imagePoints2_mat_nativeObj, long cameraMatrix1_nativeObj, long distCoeffs1_nativeObj, long cameraMatrix2_nativeObj, long distCoeffs2_nativeObj, double imageSize_width, double imageSize_height, long R_nativeObj, long T_nativeObj, long E_nativeObj, long F_nativeObj, int flags);</a>
<span class="sourceLineNo">12416</span><a id="line.12416">    private static native double stereoCalibrate_2(long objectPoints_mat_nativeObj, long imagePoints1_mat_nativeObj, long imagePoints2_mat_nativeObj, long cameraMatrix1_nativeObj, long distCoeffs1_nativeObj, long cameraMatrix2_nativeObj, long distCoeffs2_nativeObj, double imageSize_width, double imageSize_height, long R_nativeObj, long T_nativeObj, long E_nativeObj, long F_nativeObj);</a>
<span class="sourceLineNo">12417</span><a id="line.12417"></a>
<span class="sourceLineNo">12418</span><a id="line.12418">    // C++:  void cv::stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat&amp; R1, Mat&amp; R2, Mat&amp; P1, Mat&amp; P2, Mat&amp; Q, int flags = CALIB_ZERO_DISPARITY, double alpha = -1, Size newImageSize = Size(), Rect* validPixROI1 = 0, Rect* validPixROI2 = 0)</a>
<span class="sourceLineNo">12419</span><a id="line.12419">    private static native void stereoRectify_0(long cameraMatrix1_nativeObj, long distCoeffs1_nativeObj, long cameraMatrix2_nativeObj, long distCoeffs2_nativeObj, double imageSize_width, double imageSize_height, long R_nativeObj, long T_nativeObj, long R1_nativeObj, long R2_nativeObj, long P1_nativeObj, long P2_nativeObj, long Q_nativeObj, int flags, double alpha, double newImageSize_width, double newImageSize_height, double[] validPixROI1_out, double[] validPixROI2_out);</a>
<span class="sourceLineNo">12420</span><a id="line.12420">    private static native void stereoRectify_1(long cameraMatrix1_nativeObj, long distCoeffs1_nativeObj, long cameraMatrix2_nativeObj, long distCoeffs2_nativeObj, double imageSize_width, double imageSize_height, long R_nativeObj, long T_nativeObj, long R1_nativeObj, long R2_nativeObj, long P1_nativeObj, long P2_nativeObj, long Q_nativeObj, int flags, double alpha, double newImageSize_width, double newImageSize_height, double[] validPixROI1_out);</a>
<span class="sourceLineNo">12421</span><a id="line.12421">    private static native void stereoRectify_2(long cameraMatrix1_nativeObj, long distCoeffs1_nativeObj, long cameraMatrix2_nativeObj, long distCoeffs2_nativeObj, double imageSize_width, double imageSize_height, long R_nativeObj, long T_nativeObj, long R1_nativeObj, long R2_nativeObj, long P1_nativeObj, long P2_nativeObj, long Q_nativeObj, int flags, double alpha, double newImageSize_width, double newImageSize_height);</a>
<span class="sourceLineNo">12422</span><a id="line.12422">    private static native void stereoRectify_3(long cameraMatrix1_nativeObj, long distCoeffs1_nativeObj, long cameraMatrix2_nativeObj, long distCoeffs2_nativeObj, double imageSize_width, double imageSize_height, long R_nativeObj, long T_nativeObj, long R1_nativeObj, long R2_nativeObj, long P1_nativeObj, long P2_nativeObj, long Q_nativeObj, int flags, double alpha);</a>
<span class="sourceLineNo">12423</span><a id="line.12423">    private static native void stereoRectify_4(long cameraMatrix1_nativeObj, long distCoeffs1_nativeObj, long cameraMatrix2_nativeObj, long distCoeffs2_nativeObj, double imageSize_width, double imageSize_height, long R_nativeObj, long T_nativeObj, long R1_nativeObj, long R2_nativeObj, long P1_nativeObj, long P2_nativeObj, long Q_nativeObj, int flags);</a>
<span class="sourceLineNo">12424</span><a id="line.12424">    private static native void stereoRectify_5(long cameraMatrix1_nativeObj, long distCoeffs1_nativeObj, long cameraMatrix2_nativeObj, long distCoeffs2_nativeObj, double imageSize_width, double imageSize_height, long R_nativeObj, long T_nativeObj, long R1_nativeObj, long R2_nativeObj, long P1_nativeObj, long P2_nativeObj, long Q_nativeObj);</a>
<span class="sourceLineNo">12425</span><a id="line.12425"></a>
<span class="sourceLineNo">12426</span><a id="line.12426">    // C++:  bool cv::stereoRectifyUncalibrated(Mat points1, Mat points2, Mat F, Size imgSize, Mat&amp; H1, Mat&amp; H2, double threshold = 5)</a>
<span class="sourceLineNo">12427</span><a id="line.12427">    private static native boolean stereoRectifyUncalibrated_0(long points1_nativeObj, long points2_nativeObj, long F_nativeObj, double imgSize_width, double imgSize_height, long H1_nativeObj, long H2_nativeObj, double threshold);</a>
<span class="sourceLineNo">12428</span><a id="line.12428">    private static native boolean stereoRectifyUncalibrated_1(long points1_nativeObj, long points2_nativeObj, long F_nativeObj, double imgSize_width, double imgSize_height, long H1_nativeObj, long H2_nativeObj);</a>
<span class="sourceLineNo">12429</span><a id="line.12429"></a>
<span class="sourceLineNo">12430</span><a id="line.12430">    // C++:  float cv::rectify3Collinear(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Mat cameraMatrix3, Mat distCoeffs3, vector_Mat imgpt1, vector_Mat imgpt3, Size imageSize, Mat R12, Mat T12, Mat R13, Mat T13, Mat&amp; R1, Mat&amp; R2, Mat&amp; R3, Mat&amp; P1, Mat&amp; P2, Mat&amp; P3, Mat&amp; Q, double alpha, Size newImgSize, Rect* roi1, Rect* roi2, int flags)</a>
<span class="sourceLineNo">12431</span><a id="line.12431">    private static native float rectify3Collinear_0(long cameraMatrix1_nativeObj, long distCoeffs1_nativeObj, long cameraMatrix2_nativeObj, long distCoeffs2_nativeObj, long cameraMatrix3_nativeObj, long distCoeffs3_nativeObj, long imgpt1_mat_nativeObj, long imgpt3_mat_nativeObj, double imageSize_width, double imageSize_height, long R12_nativeObj, long T12_nativeObj, long R13_nativeObj, long T13_nativeObj, long R1_nativeObj, long R2_nativeObj, long R3_nativeObj, long P1_nativeObj, long P2_nativeObj, long P3_nativeObj, long Q_nativeObj, double alpha, double newImgSize_width, double newImgSize_height, double[] roi1_out, double[] roi2_out, int flags);</a>
<span class="sourceLineNo">12432</span><a id="line.12432"></a>
<span class="sourceLineNo">12433</span><a id="line.12433">    // C++:  Mat cv::getOptimalNewCameraMatrix(Mat cameraMatrix, Mat distCoeffs, Size imageSize, double alpha, Size newImgSize = Size(), Rect* validPixROI = 0, bool centerPrincipalPoint = false)</a>
<span class="sourceLineNo">12434</span><a id="line.12434">    private static native long getOptimalNewCameraMatrix_0(long cameraMatrix_nativeObj, long distCoeffs_nativeObj, double imageSize_width, double imageSize_height, double alpha, double newImgSize_width, double newImgSize_height, double[] validPixROI_out, boolean centerPrincipalPoint);</a>
<span class="sourceLineNo">12435</span><a id="line.12435">    private static native long getOptimalNewCameraMatrix_1(long cameraMatrix_nativeObj, long distCoeffs_nativeObj, double imageSize_width, double imageSize_height, double alpha, double newImgSize_width, double newImgSize_height, double[] validPixROI_out);</a>
<span class="sourceLineNo">12436</span><a id="line.12436">    private static native long getOptimalNewCameraMatrix_2(long cameraMatrix_nativeObj, long distCoeffs_nativeObj, double imageSize_width, double imageSize_height, double alpha, double newImgSize_width, double newImgSize_height);</a>
<span class="sourceLineNo">12437</span><a id="line.12437">    private static native long getOptimalNewCameraMatrix_3(long cameraMatrix_nativeObj, long distCoeffs_nativeObj, double imageSize_width, double imageSize_height, double alpha);</a>
<span class="sourceLineNo">12438</span><a id="line.12438"></a>
<span class="sourceLineNo">12439</span><a id="line.12439">    // C++:  void cv::calibrateHandEye(vector_Mat R_gripper2base, vector_Mat t_gripper2base, vector_Mat R_target2cam, vector_Mat t_target2cam, Mat&amp; R_cam2gripper, Mat&amp; t_cam2gripper, HandEyeCalibrationMethod method = CALIB_HAND_EYE_TSAI)</a>
<span class="sourceLineNo">12440</span><a id="line.12440">    private static native void calibrateHandEye_0(long R_gripper2base_mat_nativeObj, long t_gripper2base_mat_nativeObj, long R_target2cam_mat_nativeObj, long t_target2cam_mat_nativeObj, long R_cam2gripper_nativeObj, long t_cam2gripper_nativeObj, int method);</a>
<span class="sourceLineNo">12441</span><a id="line.12441">    private static native void calibrateHandEye_1(long R_gripper2base_mat_nativeObj, long t_gripper2base_mat_nativeObj, long R_target2cam_mat_nativeObj, long t_target2cam_mat_nativeObj, long R_cam2gripper_nativeObj, long t_cam2gripper_nativeObj);</a>
<span class="sourceLineNo">12442</span><a id="line.12442"></a>
<span class="sourceLineNo">12443</span><a id="line.12443">    // C++:  void cv::calibrateRobotWorldHandEye(vector_Mat R_world2cam, vector_Mat t_world2cam, vector_Mat R_base2gripper, vector_Mat t_base2gripper, Mat&amp; R_base2world, Mat&amp; t_base2world, Mat&amp; R_gripper2cam, Mat&amp; t_gripper2cam, RobotWorldHandEyeCalibrationMethod method = CALIB_ROBOT_WORLD_HAND_EYE_SHAH)</a>
<span class="sourceLineNo">12444</span><a id="line.12444">    private static native void calibrateRobotWorldHandEye_0(long R_world2cam_mat_nativeObj, long t_world2cam_mat_nativeObj, long R_base2gripper_mat_nativeObj, long t_base2gripper_mat_nativeObj, long R_base2world_nativeObj, long t_base2world_nativeObj, long R_gripper2cam_nativeObj, long t_gripper2cam_nativeObj, int method);</a>
<span class="sourceLineNo">12445</span><a id="line.12445">    private static native void calibrateRobotWorldHandEye_1(long R_world2cam_mat_nativeObj, long t_world2cam_mat_nativeObj, long R_base2gripper_mat_nativeObj, long t_base2gripper_mat_nativeObj, long R_base2world_nativeObj, long t_base2world_nativeObj, long R_gripper2cam_nativeObj, long t_gripper2cam_nativeObj);</a>
<span class="sourceLineNo">12446</span><a id="line.12446"></a>
<span class="sourceLineNo">12447</span><a id="line.12447">    // C++:  void cv::convertPointsToHomogeneous(Mat src, Mat&amp; dst)</a>
<span class="sourceLineNo">12448</span><a id="line.12448">    private static native void convertPointsToHomogeneous_0(long src_nativeObj, long dst_nativeObj);</a>
<span class="sourceLineNo">12449</span><a id="line.12449"></a>
<span class="sourceLineNo">12450</span><a id="line.12450">    // C++:  void cv::convertPointsFromHomogeneous(Mat src, Mat&amp; dst)</a>
<span class="sourceLineNo">12451</span><a id="line.12451">    private static native void convertPointsFromHomogeneous_0(long src_nativeObj, long dst_nativeObj);</a>
<span class="sourceLineNo">12452</span><a id="line.12452"></a>
<span class="sourceLineNo">12453</span><a id="line.12453">    // C++:  Mat cv::findFundamentalMat(vector_Point2f points1, vector_Point2f points2, int method, double ransacReprojThreshold, double confidence, int maxIters, Mat&amp; mask = Mat())</a>
<span class="sourceLineNo">12454</span><a id="line.12454">    private static native long findFundamentalMat_0(long points1_mat_nativeObj, long points2_mat_nativeObj, int method, double ransacReprojThreshold, double confidence, int maxIters, long mask_nativeObj);</a>
<span class="sourceLineNo">12455</span><a id="line.12455">    private static native long findFundamentalMat_1(long points1_mat_nativeObj, long points2_mat_nativeObj, int method, double ransacReprojThreshold, double confidence, int maxIters);</a>
<span class="sourceLineNo">12456</span><a id="line.12456"></a>
<span class="sourceLineNo">12457</span><a id="line.12457">    // C++:  Mat cv::findFundamentalMat(vector_Point2f points1, vector_Point2f points2, int method = FM_RANSAC, double ransacReprojThreshold = 3., double confidence = 0.99, Mat&amp; mask = Mat())</a>
<span class="sourceLineNo">12458</span><a id="line.12458">    private static native long findFundamentalMat_2(long points1_mat_nativeObj, long points2_mat_nativeObj, int method, double ransacReprojThreshold, double confidence, long mask_nativeObj);</a>
<span class="sourceLineNo">12459</span><a id="line.12459">    private static native long findFundamentalMat_3(long points1_mat_nativeObj, long points2_mat_nativeObj, int method, double ransacReprojThreshold, double confidence);</a>
<span class="sourceLineNo">12460</span><a id="line.12460">    private static native long findFundamentalMat_4(long points1_mat_nativeObj, long points2_mat_nativeObj, int method, double ransacReprojThreshold);</a>
<span class="sourceLineNo">12461</span><a id="line.12461">    private static native long findFundamentalMat_5(long points1_mat_nativeObj, long points2_mat_nativeObj, int method);</a>
<span class="sourceLineNo">12462</span><a id="line.12462">    private static native long findFundamentalMat_6(long points1_mat_nativeObj, long points2_mat_nativeObj);</a>
<span class="sourceLineNo">12463</span><a id="line.12463"></a>
<span class="sourceLineNo">12464</span><a id="line.12464">    // C++:  Mat cv::findFundamentalMat(vector_Point2f points1, vector_Point2f points2, Mat&amp; mask, UsacParams params)</a>
<span class="sourceLineNo">12465</span><a id="line.12465">    private static native long findFundamentalMat_7(long points1_mat_nativeObj, long points2_mat_nativeObj, long mask_nativeObj, long params_nativeObj);</a>
<span class="sourceLineNo">12466</span><a id="line.12466"></a>
<span class="sourceLineNo">12467</span><a id="line.12467">    // C++:  Mat cv::findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix, int method = RANSAC, double prob = 0.999, double threshold = 1.0, Mat&amp; mask = Mat())</a>
<span class="sourceLineNo">12468</span><a id="line.12468">    private static native long findEssentialMat_0(long points1_nativeObj, long points2_nativeObj, long cameraMatrix_nativeObj, int method, double prob, double threshold, long mask_nativeObj);</a>
<span class="sourceLineNo">12469</span><a id="line.12469">    private static native long findEssentialMat_1(long points1_nativeObj, long points2_nativeObj, long cameraMatrix_nativeObj, int method, double prob, double threshold);</a>
<span class="sourceLineNo">12470</span><a id="line.12470">    private static native long findEssentialMat_2(long points1_nativeObj, long points2_nativeObj, long cameraMatrix_nativeObj, int method, double prob);</a>
<span class="sourceLineNo">12471</span><a id="line.12471">    private static native long findEssentialMat_3(long points1_nativeObj, long points2_nativeObj, long cameraMatrix_nativeObj, int method);</a>
<span class="sourceLineNo">12472</span><a id="line.12472">    private static native long findEssentialMat_4(long points1_nativeObj, long points2_nativeObj, long cameraMatrix_nativeObj);</a>
<span class="sourceLineNo">12473</span><a id="line.12473"></a>
<span class="sourceLineNo">12474</span><a id="line.12474">    // C++:  Mat cv::findEssentialMat(Mat points1, Mat points2, double focal = 1.0, Point2d pp = Point2d(0, 0), int method = RANSAC, double prob = 0.999, double threshold = 1.0, Mat&amp; mask = Mat())</a>
<span class="sourceLineNo">12475</span><a id="line.12475">    private static native long findEssentialMat_5(long points1_nativeObj, long points2_nativeObj, double focal, double pp_x, double pp_y, int method, double prob, double threshold, long mask_nativeObj);</a>
<span class="sourceLineNo">12476</span><a id="line.12476">    private static native long findEssentialMat_6(long points1_nativeObj, long points2_nativeObj, double focal, double pp_x, double pp_y, int method, double prob, double threshold);</a>
<span class="sourceLineNo">12477</span><a id="line.12477">    private static native long findEssentialMat_7(long points1_nativeObj, long points2_nativeObj, double focal, double pp_x, double pp_y, int method, double prob);</a>
<span class="sourceLineNo">12478</span><a id="line.12478">    private static native long findEssentialMat_8(long points1_nativeObj, long points2_nativeObj, double focal, double pp_x, double pp_y, int method);</a>
<span class="sourceLineNo">12479</span><a id="line.12479">    private static native long findEssentialMat_9(long points1_nativeObj, long points2_nativeObj, double focal, double pp_x, double pp_y);</a>
<span class="sourceLineNo">12480</span><a id="line.12480">    private static native long findEssentialMat_10(long points1_nativeObj, long points2_nativeObj, double focal);</a>
<span class="sourceLineNo">12481</span><a id="line.12481">    private static native long findEssentialMat_11(long points1_nativeObj, long points2_nativeObj);</a>
<span class="sourceLineNo">12482</span><a id="line.12482"></a>
<span class="sourceLineNo">12483</span><a id="line.12483">    // C++:  Mat cv::findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, int method = RANSAC, double prob = 0.999, double threshold = 1.0, Mat&amp; mask = Mat())</a>
<span class="sourceLineNo">12484</span><a id="line.12484">    private static native long findEssentialMat_12(long points1_nativeObj, long points2_nativeObj, long cameraMatrix1_nativeObj, long distCoeffs1_nativeObj, long cameraMatrix2_nativeObj, long distCoeffs2_nativeObj, int method, double prob, double threshold, long mask_nativeObj);</a>
<span class="sourceLineNo">12485</span><a id="line.12485">    private static native long findEssentialMat_13(long points1_nativeObj, long points2_nativeObj, long cameraMatrix1_nativeObj, long distCoeffs1_nativeObj, long cameraMatrix2_nativeObj, long distCoeffs2_nativeObj, int method, double prob, double threshold);</a>
<span class="sourceLineNo">12486</span><a id="line.12486">    private static native long findEssentialMat_14(long points1_nativeObj, long points2_nativeObj, long cameraMatrix1_nativeObj, long distCoeffs1_nativeObj, long cameraMatrix2_nativeObj, long distCoeffs2_nativeObj, int method, double prob);</a>
<span class="sourceLineNo">12487</span><a id="line.12487">    private static native long findEssentialMat_15(long points1_nativeObj, long points2_nativeObj, long cameraMatrix1_nativeObj, long distCoeffs1_nativeObj, long cameraMatrix2_nativeObj, long distCoeffs2_nativeObj, int method);</a>
<span class="sourceLineNo">12488</span><a id="line.12488">    private static native long findEssentialMat_16(long points1_nativeObj, long points2_nativeObj, long cameraMatrix1_nativeObj, long distCoeffs1_nativeObj, long cameraMatrix2_nativeObj, long distCoeffs2_nativeObj);</a>
<span class="sourceLineNo">12489</span><a id="line.12489"></a>
<span class="sourceLineNo">12490</span><a id="line.12490">    // C++:  Mat cv::findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix1, Mat cameraMatrix2, Mat dist_coeff1, Mat dist_coeff2, Mat&amp; mask, UsacParams params)</a>
<span class="sourceLineNo">12491</span><a id="line.12491">    private static native long findEssentialMat_17(long points1_nativeObj, long points2_nativeObj, long cameraMatrix1_nativeObj, long cameraMatrix2_nativeObj, long dist_coeff1_nativeObj, long dist_coeff2_nativeObj, long mask_nativeObj, long params_nativeObj);</a>
<span class="sourceLineNo">12492</span><a id="line.12492"></a>
<span class="sourceLineNo">12493</span><a id="line.12493">    // C++:  void cv::decomposeEssentialMat(Mat E, Mat&amp; R1, Mat&amp; R2, Mat&amp; t)</a>
<span class="sourceLineNo">12494</span><a id="line.12494">    private static native void decomposeEssentialMat_0(long E_nativeObj, long R1_nativeObj, long R2_nativeObj, long t_nativeObj);</a>
<span class="sourceLineNo">12495</span><a id="line.12495"></a>
<span class="sourceLineNo">12496</span><a id="line.12496">    // C++:  int cv::recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat&amp; R, Mat&amp; t, Mat&amp; mask = Mat())</a>
<span class="sourceLineNo">12497</span><a id="line.12497">    private static native int recoverPose_0(long E_nativeObj, long points1_nativeObj, long points2_nativeObj, long cameraMatrix_nativeObj, long R_nativeObj, long t_nativeObj, long mask_nativeObj);</a>
<span class="sourceLineNo">12498</span><a id="line.12498">    private static native int recoverPose_1(long E_nativeObj, long points1_nativeObj, long points2_nativeObj, long cameraMatrix_nativeObj, long R_nativeObj, long t_nativeObj);</a>
<span class="sourceLineNo">12499</span><a id="line.12499"></a>
<span class="sourceLineNo">12500</span><a id="line.12500">    // C++:  int cv::recoverPose(Mat E, Mat points1, Mat points2, Mat&amp; R, Mat&amp; t, double focal = 1.0, Point2d pp = Point2d(0, 0), Mat&amp; mask = Mat())</a>
<span class="sourceLineNo">12501</span><a id="line.12501">    private static native int recoverPose_2(long E_nativeObj, long points1_nativeObj, long points2_nativeObj, long R_nativeObj, long t_nativeObj, double focal, double pp_x, double pp_y, long mask_nativeObj);</a>
<span class="sourceLineNo">12502</span><a id="line.12502">    private static native int recoverPose_3(long E_nativeObj, long points1_nativeObj, long points2_nativeObj, long R_nativeObj, long t_nativeObj, double focal, double pp_x, double pp_y);</a>
<span class="sourceLineNo">12503</span><a id="line.12503">    private static native int recoverPose_4(long E_nativeObj, long points1_nativeObj, long points2_nativeObj, long R_nativeObj, long t_nativeObj, double focal);</a>
<span class="sourceLineNo">12504</span><a id="line.12504">    private static native int recoverPose_5(long E_nativeObj, long points1_nativeObj, long points2_nativeObj, long R_nativeObj, long t_nativeObj);</a>
<span class="sourceLineNo">12505</span><a id="line.12505"></a>
<span class="sourceLineNo">12506</span><a id="line.12506">    // C++:  int cv::recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat&amp; R, Mat&amp; t, double distanceThresh, Mat&amp; mask = Mat(), Mat&amp; triangulatedPoints = Mat())</a>
<span class="sourceLineNo">12507</span><a id="line.12507">    private static native int recoverPose_6(long E_nativeObj, long points1_nativeObj, long points2_nativeObj, long cameraMatrix_nativeObj, long R_nativeObj, long t_nativeObj, double distanceThresh, long mask_nativeObj, long triangulatedPoints_nativeObj);</a>
<span class="sourceLineNo">12508</span><a id="line.12508">    private static native int recoverPose_7(long E_nativeObj, long points1_nativeObj, long points2_nativeObj, long cameraMatrix_nativeObj, long R_nativeObj, long t_nativeObj, double distanceThresh, long mask_nativeObj);</a>
<span class="sourceLineNo">12509</span><a id="line.12509">    private static native int recoverPose_8(long E_nativeObj, long points1_nativeObj, long points2_nativeObj, long cameraMatrix_nativeObj, long R_nativeObj, long t_nativeObj, double distanceThresh);</a>
<span class="sourceLineNo">12510</span><a id="line.12510"></a>
<span class="sourceLineNo">12511</span><a id="line.12511">    // C++:  void cv::computeCorrespondEpilines(Mat points, int whichImage, Mat F, Mat&amp; lines)</a>
<span class="sourceLineNo">12512</span><a id="line.12512">    private static native void computeCorrespondEpilines_0(long points_nativeObj, int whichImage, long F_nativeObj, long lines_nativeObj);</a>
<span class="sourceLineNo">12513</span><a id="line.12513"></a>
<span class="sourceLineNo">12514</span><a id="line.12514">    // C++:  void cv::triangulatePoints(Mat projMatr1, Mat projMatr2, Mat projPoints1, Mat projPoints2, Mat&amp; points4D)</a>
<span class="sourceLineNo">12515</span><a id="line.12515">    private static native void triangulatePoints_0(long projMatr1_nativeObj, long projMatr2_nativeObj, long projPoints1_nativeObj, long projPoints2_nativeObj, long points4D_nativeObj);</a>
<span class="sourceLineNo">12516</span><a id="line.12516"></a>
<span class="sourceLineNo">12517</span><a id="line.12517">    // C++:  void cv::correctMatches(Mat F, Mat points1, Mat points2, Mat&amp; newPoints1, Mat&amp; newPoints2)</a>
<span class="sourceLineNo">12518</span><a id="line.12518">    private static native void correctMatches_0(long F_nativeObj, long points1_nativeObj, long points2_nativeObj, long newPoints1_nativeObj, long newPoints2_nativeObj);</a>
<span class="sourceLineNo">12519</span><a id="line.12519"></a>
<span class="sourceLineNo">12520</span><a id="line.12520">    // C++:  void cv::filterSpeckles(Mat&amp; img, double newVal, int maxSpeckleSize, double maxDiff, Mat&amp; buf = Mat())</a>
<span class="sourceLineNo">12521</span><a id="line.12521">    private static native void filterSpeckles_0(long img_nativeObj, double newVal, int maxSpeckleSize, double maxDiff, long buf_nativeObj);</a>
<span class="sourceLineNo">12522</span><a id="line.12522">    private static native void filterSpeckles_1(long img_nativeObj, double newVal, int maxSpeckleSize, double maxDiff);</a>
<span class="sourceLineNo">12523</span><a id="line.12523"></a>
<span class="sourceLineNo">12524</span><a id="line.12524">    // C++:  Rect cv::getValidDisparityROI(Rect roi1, Rect roi2, int minDisparity, int numberOfDisparities, int blockSize)</a>
<span class="sourceLineNo">12525</span><a id="line.12525">    private static native double[] getValidDisparityROI_0(int roi1_x, int roi1_y, int roi1_width, int roi1_height, int roi2_x, int roi2_y, int roi2_width, int roi2_height, int minDisparity, int numberOfDisparities, int blockSize);</a>
<span class="sourceLineNo">12526</span><a id="line.12526"></a>
<span class="sourceLineNo">12527</span><a id="line.12527">    // C++:  void cv::validateDisparity(Mat&amp; disparity, Mat cost, int minDisparity, int numberOfDisparities, int disp12MaxDisp = 1)</a>
<span class="sourceLineNo">12528</span><a id="line.12528">    private static native void validateDisparity_0(long disparity_nativeObj, long cost_nativeObj, int minDisparity, int numberOfDisparities, int disp12MaxDisp);</a>
<span class="sourceLineNo">12529</span><a id="line.12529">    private static native void validateDisparity_1(long disparity_nativeObj, long cost_nativeObj, int minDisparity, int numberOfDisparities);</a>
<span class="sourceLineNo">12530</span><a id="line.12530"></a>
<span class="sourceLineNo">12531</span><a id="line.12531">    // C++:  void cv::reprojectImageTo3D(Mat disparity, Mat&amp; _3dImage, Mat Q, bool handleMissingValues = false, int ddepth = -1)</a>
<span class="sourceLineNo">12532</span><a id="line.12532">    private static native void reprojectImageTo3D_0(long disparity_nativeObj, long _3dImage_nativeObj, long Q_nativeObj, boolean handleMissingValues, int ddepth);</a>
<span class="sourceLineNo">12533</span><a id="line.12533">    private static native void reprojectImageTo3D_1(long disparity_nativeObj, long _3dImage_nativeObj, long Q_nativeObj, boolean handleMissingValues);</a>
<span class="sourceLineNo">12534</span><a id="line.12534">    private static native void reprojectImageTo3D_2(long disparity_nativeObj, long _3dImage_nativeObj, long Q_nativeObj);</a>
<span class="sourceLineNo">12535</span><a id="line.12535"></a>
<span class="sourceLineNo">12536</span><a id="line.12536">    // C++:  double cv::sampsonDistance(Mat pt1, Mat pt2, Mat F)</a>
<span class="sourceLineNo">12537</span><a id="line.12537">    private static native double sampsonDistance_0(long pt1_nativeObj, long pt2_nativeObj, long F_nativeObj);</a>
<span class="sourceLineNo">12538</span><a id="line.12538"></a>
<span class="sourceLineNo">12539</span><a id="line.12539">    // C++:  int cv::estimateAffine3D(Mat src, Mat dst, Mat&amp; out, Mat&amp; inliers, double ransacThreshold = 3, double confidence = 0.99)</a>
<span class="sourceLineNo">12540</span><a id="line.12540">    private static native int estimateAffine3D_0(long src_nativeObj, long dst_nativeObj, long out_nativeObj, long inliers_nativeObj, double ransacThreshold, double confidence);</a>
<span class="sourceLineNo">12541</span><a id="line.12541">    private static native int estimateAffine3D_1(long src_nativeObj, long dst_nativeObj, long out_nativeObj, long inliers_nativeObj, double ransacThreshold);</a>
<span class="sourceLineNo">12542</span><a id="line.12542">    private static native int estimateAffine3D_2(long src_nativeObj, long dst_nativeObj, long out_nativeObj, long inliers_nativeObj);</a>
<span class="sourceLineNo">12543</span><a id="line.12543"></a>
<span class="sourceLineNo">12544</span><a id="line.12544">    // C++:  int cv::estimateTranslation3D(Mat src, Mat dst, Mat&amp; out, Mat&amp; inliers, double ransacThreshold = 3, double confidence = 0.99)</a>
<span class="sourceLineNo">12545</span><a id="line.12545">    private static native int estimateTranslation3D_0(long src_nativeObj, long dst_nativeObj, long out_nativeObj, long inliers_nativeObj, double ransacThreshold, double confidence);</a>
<span class="sourceLineNo">12546</span><a id="line.12546">    private static native int estimateTranslation3D_1(long src_nativeObj, long dst_nativeObj, long out_nativeObj, long inliers_nativeObj, double ransacThreshold);</a>
<span class="sourceLineNo">12547</span><a id="line.12547">    private static native int estimateTranslation3D_2(long src_nativeObj, long dst_nativeObj, long out_nativeObj, long inliers_nativeObj);</a>
<span class="sourceLineNo">12548</span><a id="line.12548"></a>
<span class="sourceLineNo">12549</span><a id="line.12549">    // C++:  Mat cv::estimateAffine2D(Mat from, Mat to, Mat&amp; inliers = Mat(), int method = RANSAC, double ransacReprojThreshold = 3, size_t maxIters = 2000, double confidence = 0.99, size_t refineIters = 10)</a>
<span class="sourceLineNo">12550</span><a id="line.12550">    private static native long estimateAffine2D_0(long from_nativeObj, long to_nativeObj, long inliers_nativeObj, int method, double ransacReprojThreshold, long maxIters, double confidence, long refineIters);</a>
<span class="sourceLineNo">12551</span><a id="line.12551">    private static native long estimateAffine2D_1(long from_nativeObj, long to_nativeObj, long inliers_nativeObj, int method, double ransacReprojThreshold, long maxIters, double confidence);</a>
<span class="sourceLineNo">12552</span><a id="line.12552">    private static native long estimateAffine2D_2(long from_nativeObj, long to_nativeObj, long inliers_nativeObj, int method, double ransacReprojThreshold, long maxIters);</a>
<span class="sourceLineNo">12553</span><a id="line.12553">    private static native long estimateAffine2D_3(long from_nativeObj, long to_nativeObj, long inliers_nativeObj, int method, double ransacReprojThreshold);</a>
<span class="sourceLineNo">12554</span><a id="line.12554">    private static native long estimateAffine2D_4(long from_nativeObj, long to_nativeObj, long inliers_nativeObj, int method);</a>
<span class="sourceLineNo">12555</span><a id="line.12555">    private static native long estimateAffine2D_5(long from_nativeObj, long to_nativeObj, long inliers_nativeObj);</a>
<span class="sourceLineNo">12556</span><a id="line.12556">    private static native long estimateAffine2D_6(long from_nativeObj, long to_nativeObj);</a>
<span class="sourceLineNo">12557</span><a id="line.12557"></a>
<span class="sourceLineNo">12558</span><a id="line.12558">    // C++:  Mat cv::estimateAffine2D(Mat pts1, Mat pts2, Mat&amp; inliers, UsacParams params)</a>
<span class="sourceLineNo">12559</span><a id="line.12559">    private static native long estimateAffine2D_7(long pts1_nativeObj, long pts2_nativeObj, long inliers_nativeObj, long params_nativeObj);</a>
<span class="sourceLineNo">12560</span><a id="line.12560"></a>
<span class="sourceLineNo">12561</span><a id="line.12561">    // C++:  Mat cv::estimateAffinePartial2D(Mat from, Mat to, Mat&amp; inliers = Mat(), int method = RANSAC, double ransacReprojThreshold = 3, size_t maxIters = 2000, double confidence = 0.99, size_t refineIters = 10)</a>
<span class="sourceLineNo">12562</span><a id="line.12562">    private static native long estimateAffinePartial2D_0(long from_nativeObj, long to_nativeObj, long inliers_nativeObj, int method, double ransacReprojThreshold, long maxIters, double confidence, long refineIters);</a>
<span class="sourceLineNo">12563</span><a id="line.12563">    private static native long estimateAffinePartial2D_1(long from_nativeObj, long to_nativeObj, long inliers_nativeObj, int method, double ransacReprojThreshold, long maxIters, double confidence);</a>
<span class="sourceLineNo">12564</span><a id="line.12564">    private static native long estimateAffinePartial2D_2(long from_nativeObj, long to_nativeObj, long inliers_nativeObj, int method, double ransacReprojThreshold, long maxIters);</a>
<span class="sourceLineNo">12565</span><a id="line.12565">    private static native long estimateAffinePartial2D_3(long from_nativeObj, long to_nativeObj, long inliers_nativeObj, int method, double ransacReprojThreshold);</a>
<span class="sourceLineNo">12566</span><a id="line.12566">    private static native long estimateAffinePartial2D_4(long from_nativeObj, long to_nativeObj, long inliers_nativeObj, int method);</a>
<span class="sourceLineNo">12567</span><a id="line.12567">    private static native long estimateAffinePartial2D_5(long from_nativeObj, long to_nativeObj, long inliers_nativeObj);</a>
<span class="sourceLineNo">12568</span><a id="line.12568">    private static native long estimateAffinePartial2D_6(long from_nativeObj, long to_nativeObj);</a>
<span class="sourceLineNo">12569</span><a id="line.12569"></a>
<span class="sourceLineNo">12570</span><a id="line.12570">    // C++:  int cv::decomposeHomographyMat(Mat H, Mat K, vector_Mat&amp; rotations, vector_Mat&amp; translations, vector_Mat&amp; normals)</a>
<span class="sourceLineNo">12571</span><a id="line.12571">    private static native int decomposeHomographyMat_0(long H_nativeObj, long K_nativeObj, long rotations_mat_nativeObj, long translations_mat_nativeObj, long normals_mat_nativeObj);</a>
<span class="sourceLineNo">12572</span><a id="line.12572"></a>
<span class="sourceLineNo">12573</span><a id="line.12573">    // C++:  void cv::filterHomographyDecompByVisibleRefpoints(vector_Mat rotations, vector_Mat normals, Mat beforePoints, Mat afterPoints, Mat&amp; possibleSolutions, Mat pointsMask = Mat())</a>
<span class="sourceLineNo">12574</span><a id="line.12574">    private static native void filterHomographyDecompByVisibleRefpoints_0(long rotations_mat_nativeObj, long normals_mat_nativeObj, long beforePoints_nativeObj, long afterPoints_nativeObj, long possibleSolutions_nativeObj, long pointsMask_nativeObj);</a>
<span class="sourceLineNo">12575</span><a id="line.12575">    private static native void filterHomographyDecompByVisibleRefpoints_1(long rotations_mat_nativeObj, long normals_mat_nativeObj, long beforePoints_nativeObj, long afterPoints_nativeObj, long possibleSolutions_nativeObj);</a>
<span class="sourceLineNo">12576</span><a id="line.12576"></a>
<span class="sourceLineNo">12577</span><a id="line.12577">    // C++:  void cv::undistort(Mat src, Mat&amp; dst, Mat cameraMatrix, Mat distCoeffs, Mat newCameraMatrix = Mat())</a>
<span class="sourceLineNo">12578</span><a id="line.12578">    private static native void undistort_0(long src_nativeObj, long dst_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long newCameraMatrix_nativeObj);</a>
<span class="sourceLineNo">12579</span><a id="line.12579">    private static native void undistort_1(long src_nativeObj, long dst_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_nativeObj);</a>
<span class="sourceLineNo">12580</span><a id="line.12580"></a>
<span class="sourceLineNo">12581</span><a id="line.12581">    // C++:  void cv::initUndistortRectifyMap(Mat cameraMatrix, Mat distCoeffs, Mat R, Mat newCameraMatrix, Size size, int m1type, Mat&amp; map1, Mat&amp; map2)</a>
<span class="sourceLineNo">12582</span><a id="line.12582">    private static native void initUndistortRectifyMap_0(long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long R_nativeObj, long newCameraMatrix_nativeObj, double size_width, double size_height, int m1type, long map1_nativeObj, long map2_nativeObj);</a>
<span class="sourceLineNo">12583</span><a id="line.12583"></a>
<span class="sourceLineNo">12584</span><a id="line.12584">    // C++:  Mat cv::getDefaultNewCameraMatrix(Mat cameraMatrix, Size imgsize = Size(), bool centerPrincipalPoint = false)</a>
<span class="sourceLineNo">12585</span><a id="line.12585">    private static native long getDefaultNewCameraMatrix_0(long cameraMatrix_nativeObj, double imgsize_width, double imgsize_height, boolean centerPrincipalPoint);</a>
<span class="sourceLineNo">12586</span><a id="line.12586">    private static native long getDefaultNewCameraMatrix_1(long cameraMatrix_nativeObj, double imgsize_width, double imgsize_height);</a>
<span class="sourceLineNo">12587</span><a id="line.12587">    private static native long getDefaultNewCameraMatrix_2(long cameraMatrix_nativeObj);</a>
<span class="sourceLineNo">12588</span><a id="line.12588"></a>
<span class="sourceLineNo">12589</span><a id="line.12589">    // C++:  void cv::undistortPoints(vector_Point2f src, vector_Point2f&amp; dst, Mat cameraMatrix, Mat distCoeffs, Mat R = Mat(), Mat P = Mat())</a>
<span class="sourceLineNo">12590</span><a id="line.12590">    private static native void undistortPoints_0(long src_mat_nativeObj, long dst_mat_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long R_nativeObj, long P_nativeObj);</a>
<span class="sourceLineNo">12591</span><a id="line.12591">    private static native void undistortPoints_1(long src_mat_nativeObj, long dst_mat_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long R_nativeObj);</a>
<span class="sourceLineNo">12592</span><a id="line.12592">    private static native void undistortPoints_2(long src_mat_nativeObj, long dst_mat_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_nativeObj);</a>
<span class="sourceLineNo">12593</span><a id="line.12593"></a>
<span class="sourceLineNo">12594</span><a id="line.12594">    // C++:  void cv::undistortPoints(Mat src, Mat&amp; dst, Mat cameraMatrix, Mat distCoeffs, Mat R, Mat P, TermCriteria criteria)</a>
<span class="sourceLineNo">12595</span><a id="line.12595">    private static native void undistortPointsIter_0(long src_nativeObj, long dst_nativeObj, long cameraMatrix_nativeObj, long distCoeffs_nativeObj, long R_nativeObj, long P_nativeObj, int criteria_type, int criteria_maxCount, double criteria_epsilon);</a>
<span class="sourceLineNo">12596</span><a id="line.12596"></a>
<span class="sourceLineNo">12597</span><a id="line.12597">    // C++:  void cv::fisheye::projectPoints(Mat objectPoints, Mat&amp; imagePoints, Mat rvec, Mat tvec, Mat K, Mat D, double alpha = 0, Mat&amp; jacobian = Mat())</a>
<span class="sourceLineNo">12598</span><a id="line.12598">    private static native void fisheye_projectPoints_0(long objectPoints_nativeObj, long imagePoints_nativeObj, long rvec_nativeObj, long tvec_nativeObj, long K_nativeObj, long D_nativeObj, double alpha, long jacobian_nativeObj);</a>
<span class="sourceLineNo">12599</span><a id="line.12599">    private static native void fisheye_projectPoints_1(long objectPoints_nativeObj, long imagePoints_nativeObj, long rvec_nativeObj, long tvec_nativeObj, long K_nativeObj, long D_nativeObj, double alpha);</a>
<span class="sourceLineNo">12600</span><a id="line.12600">    private static native void fisheye_projectPoints_2(long objectPoints_nativeObj, long imagePoints_nativeObj, long rvec_nativeObj, long tvec_nativeObj, long K_nativeObj, long D_nativeObj);</a>
<span class="sourceLineNo">12601</span><a id="line.12601"></a>
<span class="sourceLineNo">12602</span><a id="line.12602">    // C++:  void cv::fisheye::distortPoints(Mat undistorted, Mat&amp; distorted, Mat K, Mat D, double alpha = 0)</a>
<span class="sourceLineNo">12603</span><a id="line.12603">    private static native void fisheye_distortPoints_0(long undistorted_nativeObj, long distorted_nativeObj, long K_nativeObj, long D_nativeObj, double alpha);</a>
<span class="sourceLineNo">12604</span><a id="line.12604">    private static native void fisheye_distortPoints_1(long undistorted_nativeObj, long distorted_nativeObj, long K_nativeObj, long D_nativeObj);</a>
<span class="sourceLineNo">12605</span><a id="line.12605"></a>
<span class="sourceLineNo">12606</span><a id="line.12606">    // C++:  void cv::fisheye::undistortPoints(Mat distorted, Mat&amp; undistorted, Mat K, Mat D, Mat R = Mat(), Mat P = Mat())</a>
<span class="sourceLineNo">12607</span><a id="line.12607">    private static native void fisheye_undistortPoints_0(long distorted_nativeObj, long undistorted_nativeObj, long K_nativeObj, long D_nativeObj, long R_nativeObj, long P_nativeObj);</a>
<span class="sourceLineNo">12608</span><a id="line.12608">    private static native void fisheye_undistortPoints_1(long distorted_nativeObj, long undistorted_nativeObj, long K_nativeObj, long D_nativeObj, long R_nativeObj);</a>
<span class="sourceLineNo">12609</span><a id="line.12609">    private static native void fisheye_undistortPoints_2(long distorted_nativeObj, long undistorted_nativeObj, long K_nativeObj, long D_nativeObj);</a>
<span class="sourceLineNo">12610</span><a id="line.12610"></a>
<span class="sourceLineNo">12611</span><a id="line.12611">    // C++:  void cv::fisheye::initUndistortRectifyMap(Mat K, Mat D, Mat R, Mat P, Size size, int m1type, Mat&amp; map1, Mat&amp; map2)</a>
<span class="sourceLineNo">12612</span><a id="line.12612">    private static native void fisheye_initUndistortRectifyMap_0(long K_nativeObj, long D_nativeObj, long R_nativeObj, long P_nativeObj, double size_width, double size_height, int m1type, long map1_nativeObj, long map2_nativeObj);</a>
<span class="sourceLineNo">12613</span><a id="line.12613"></a>
<span class="sourceLineNo">12614</span><a id="line.12614">    // C++:  void cv::fisheye::undistortImage(Mat distorted, Mat&amp; undistorted, Mat K, Mat D, Mat Knew = cv::Mat(), Size new_size = Size())</a>
<span class="sourceLineNo">12615</span><a id="line.12615">    private static native void fisheye_undistortImage_0(long distorted_nativeObj, long undistorted_nativeObj, long K_nativeObj, long D_nativeObj, long Knew_nativeObj, double new_size_width, double new_size_height);</a>
<span class="sourceLineNo">12616</span><a id="line.12616">    private static native void fisheye_undistortImage_1(long distorted_nativeObj, long undistorted_nativeObj, long K_nativeObj, long D_nativeObj, long Knew_nativeObj);</a>
<span class="sourceLineNo">12617</span><a id="line.12617">    private static native void fisheye_undistortImage_2(long distorted_nativeObj, long undistorted_nativeObj, long K_nativeObj, long D_nativeObj);</a>
<span class="sourceLineNo">12618</span><a id="line.12618"></a>
<span class="sourceLineNo">12619</span><a id="line.12619">    // C++:  void cv::fisheye::estimateNewCameraMatrixForUndistortRectify(Mat K, Mat D, Size image_size, Mat R, Mat&amp; P, double balance = 0.0, Size new_size = Size(), double fov_scale = 1.0)</a>
<span class="sourceLineNo">12620</span><a id="line.12620">    private static native void fisheye_estimateNewCameraMatrixForUndistortRectify_0(long K_nativeObj, long D_nativeObj, double image_size_width, double image_size_height, long R_nativeObj, long P_nativeObj, double balance, double new_size_width, double new_size_height, double fov_scale);</a>
<span class="sourceLineNo">12621</span><a id="line.12621">    private static native void fisheye_estimateNewCameraMatrixForUndistortRectify_1(long K_nativeObj, long D_nativeObj, double image_size_width, double image_size_height, long R_nativeObj, long P_nativeObj, double balance, double new_size_width, double new_size_height);</a>
<span class="sourceLineNo">12622</span><a id="line.12622">    private static native void fisheye_estimateNewCameraMatrixForUndistortRectify_2(long K_nativeObj, long D_nativeObj, double image_size_width, double image_size_height, long R_nativeObj, long P_nativeObj, double balance);</a>
<span class="sourceLineNo">12623</span><a id="line.12623">    private static native void fisheye_estimateNewCameraMatrixForUndistortRectify_3(long K_nativeObj, long D_nativeObj, double image_size_width, double image_size_height, long R_nativeObj, long P_nativeObj);</a>
<span class="sourceLineNo">12624</span><a id="line.12624"></a>
<span class="sourceLineNo">12625</span><a id="line.12625">    // C++:  double cv::fisheye::calibrate(vector_Mat objectPoints, vector_Mat imagePoints, Size image_size, Mat&amp; K, Mat&amp; D, vector_Mat&amp; rvecs, vector_Mat&amp; tvecs, int flags = 0, TermCriteria criteria = TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON))</a>
<span class="sourceLineNo">12626</span><a id="line.12626">    private static native double fisheye_calibrate_0(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, double image_size_width, double image_size_height, long K_nativeObj, long D_nativeObj, long rvecs_mat_nativeObj, long tvecs_mat_nativeObj, int flags, int criteria_type, int criteria_maxCount, double criteria_epsilon);</a>
<span class="sourceLineNo">12627</span><a id="line.12627">    private static native double fisheye_calibrate_1(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, double image_size_width, double image_size_height, long K_nativeObj, long D_nativeObj, long rvecs_mat_nativeObj, long tvecs_mat_nativeObj, int flags);</a>
<span class="sourceLineNo">12628</span><a id="line.12628">    private static native double fisheye_calibrate_2(long objectPoints_mat_nativeObj, long imagePoints_mat_nativeObj, double image_size_width, double image_size_height, long K_nativeObj, long D_nativeObj, long rvecs_mat_nativeObj, long tvecs_mat_nativeObj);</a>
<span class="sourceLineNo">12629</span><a id="line.12629"></a>
<span class="sourceLineNo">12630</span><a id="line.12630">    // C++:  void cv::fisheye::stereoRectify(Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat tvec, Mat&amp; R1, Mat&amp; R2, Mat&amp; P1, Mat&amp; P2, Mat&amp; Q, int flags, Size newImageSize = Size(), double balance = 0.0, double fov_scale = 1.0)</a>
<span class="sourceLineNo">12631</span><a id="line.12631">    private static native void fisheye_stereoRectify_0(long K1_nativeObj, long D1_nativeObj, long K2_nativeObj, long D2_nativeObj, double imageSize_width, double imageSize_height, long R_nativeObj, long tvec_nativeObj, long R1_nativeObj, long R2_nativeObj, long P1_nativeObj, long P2_nativeObj, long Q_nativeObj, int flags, double newImageSize_width, double newImageSize_height, double balance, double fov_scale);</a>
<span class="sourceLineNo">12632</span><a id="line.12632">    private static native void fisheye_stereoRectify_1(long K1_nativeObj, long D1_nativeObj, long K2_nativeObj, long D2_nativeObj, double imageSize_width, double imageSize_height, long R_nativeObj, long tvec_nativeObj, long R1_nativeObj, long R2_nativeObj, long P1_nativeObj, long P2_nativeObj, long Q_nativeObj, int flags, double newImageSize_width, double newImageSize_height, double balance);</a>
<span class="sourceLineNo">12633</span><a id="line.12633">    private static native void fisheye_stereoRectify_2(long K1_nativeObj, long D1_nativeObj, long K2_nativeObj, long D2_nativeObj, double imageSize_width, double imageSize_height, long R_nativeObj, long tvec_nativeObj, long R1_nativeObj, long R2_nativeObj, long P1_nativeObj, long P2_nativeObj, long Q_nativeObj, int flags, double newImageSize_width, double newImageSize_height);</a>
<span class="sourceLineNo">12634</span><a id="line.12634">    private static native void fisheye_stereoRectify_3(long K1_nativeObj, long D1_nativeObj, long K2_nativeObj, long D2_nativeObj, double imageSize_width, double imageSize_height, long R_nativeObj, long tvec_nativeObj, long R1_nativeObj, long R2_nativeObj, long P1_nativeObj, long P2_nativeObj, long Q_nativeObj, int flags);</a>
<span class="sourceLineNo">12635</span><a id="line.12635"></a>
<span class="sourceLineNo">12636</span><a id="line.12636">    // C++:  double cv::fisheye::stereoCalibrate(vector_Mat objectPoints, vector_Mat imagePoints1, vector_Mat imagePoints2, Mat&amp; K1, Mat&amp; D1, Mat&amp; K2, Mat&amp; D2, Size imageSize, Mat&amp; R, Mat&amp; T, int flags = fisheye::CALIB_FIX_INTRINSIC, TermCriteria criteria = TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON))</a>
<span class="sourceLineNo">12637</span><a id="line.12637">    private static native double fisheye_stereoCalibrate_0(long objectPoints_mat_nativeObj, long imagePoints1_mat_nativeObj, long imagePoints2_mat_nativeObj, long K1_nativeObj, long D1_nativeObj, long K2_nativeObj, long D2_nativeObj, double imageSize_width, double imageSize_height, long R_nativeObj, long T_nativeObj, int flags, int criteria_type, int criteria_maxCount, double criteria_epsilon);</a>
<span class="sourceLineNo">12638</span><a id="line.12638">    private static native double fisheye_stereoCalibrate_1(long objectPoints_mat_nativeObj, long imagePoints1_mat_nativeObj, long imagePoints2_mat_nativeObj, long K1_nativeObj, long D1_nativeObj, long K2_nativeObj, long D2_nativeObj, double imageSize_width, double imageSize_height, long R_nativeObj, long T_nativeObj, int flags);</a>
<span class="sourceLineNo">12639</span><a id="line.12639">    private static native double fisheye_stereoCalibrate_2(long objectPoints_mat_nativeObj, long imagePoints1_mat_nativeObj, long imagePoints2_mat_nativeObj, long K1_nativeObj, long D1_nativeObj, long K2_nativeObj, long D2_nativeObj, double imageSize_width, double imageSize_height, long R_nativeObj, long T_nativeObj);</a>
<span class="sourceLineNo">12640</span><a id="line.12640"></a>
<span class="sourceLineNo">12641</span><a id="line.12641">}</a>




























































</pre>
</div>
</main>
</body>
</html>
