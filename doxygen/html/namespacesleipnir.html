<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: sleipnir Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="wpilib-128.png"/></td>
  <td id="projectalign">
   <div id="projectname">WPILibC++<span id="projectnumber">&#160;2025.1.1-beta-1-35-g9a5f73d</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacesleipnir.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">sleipnir Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesleipnir_1_1slicing.html">slicing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsleipnir_1_1_equality_constraints.html">EqualityConstraints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of equality constraints of the form cₑ(x) = 0.  <a href="structsleipnir_1_1_equality_constraints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of std::function_ref, a lightweight non-owning reference to a callable.  <a href="classsleipnir_1_1function__ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1function__ref_3_01_r_07_args_8_8_8_08_4.html">function_ref&lt; R(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_gradient.html">Gradient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class calculates the gradient of a a variable with respect to a vector of variables.  <a href="classsleipnir_1_1_gradient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_hessian.html">Hessian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class calculates the <a class="el" href="classsleipnir_1_1_hessian.html" title="This class calculates the Hessian of a variable with respect to a vector of variables.">Hessian</a> of a variable with respect to a vector of variables.  <a href="classsleipnir_1_1_hessian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsleipnir_1_1_inequality_constraints.html">InequalityConstraints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of inequality constraints of the form cᵢ(x) ≥ 0.  <a href="structsleipnir_1_1_inequality_constraints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_intrusive_shared_ptr.html">IntrusiveSharedPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A custom intrusive shared pointer implementation without thread synchronization overhead.  <a href="classsleipnir_1_1_intrusive_shared_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_jacobian.html">Jacobian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class calculates the <a class="el" href="classsleipnir_1_1_jacobian.html" title="This class calculates the Jacobian of a vector of variables with respect to a vector of variables.">Jacobian</a> of a vector of variables with respect to a vector of variables.  <a href="classsleipnir_1_1_jacobian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsleipnir_1_1_multistart_result.html">MultistartResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of a multistart solve.  <a href="structsleipnir_1_1_multistart_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_o_c_p_solver.html">OCPSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows the user to pose and solve a constrained optimal control problem (OCP) in a variety of ways.  <a href="classsleipnir_1_1_o_c_p_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_optimization_problem.html">OptimizationProblem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows the user to pose a constrained nonlinear optimization problem in natural mathematical notation and solve it.  <a href="classsleipnir_1_1_optimization_problem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_pool_allocator.html">PoolAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is an allocator for the pool resource.  <a href="classsleipnir_1_1_pool_allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_pool_resource.html">PoolResource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a pool memory resource.  <a href="classsleipnir_1_1_pool_resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_profiler.html">Profiler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records the number of profiler measurements (start/stop pairs) and the average duration between each start and stop call.  <a href="classsleipnir_1_1_profiler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_slice.html">Slice</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsleipnir_1_1_solver_config.html">SolverConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver configuration.  <a href="structsleipnir_1_1_solver_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsleipnir_1_1_solver_iteration_info.html">SolverIterationInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver iteration information exposed to a user callback.  <a href="structsleipnir_1_1_solver_iteration_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsleipnir_1_1_solver_status.html">SolverStatus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return value of <a class="el" href="classsleipnir_1_1_optimization_problem.html#a9b9e483026fddcd34a110790916e8f92" title="Solve the optimization problem.">OptimizationProblem::Solve()</a> containing the cost function and constraint types and solver's exit condition.  <a href="structsleipnir_1_1_solver_status.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An autodiff variable pointing to an expression node.  <a href="classsleipnir_1_1_variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_variable_block.html">VariableBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A submatrix of autodiff variables with reference semantics.  <a href="classsleipnir_1_1_variable_block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of autodiff variables.  <a href="classsleipnir_1_1_variable_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptsleipnir_1_1_scalar_like.html">ScalarLike</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptsleipnir_1_1_sleipnir_matrix_like.html">SleipnirMatrixLike</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptsleipnir_1_1_eigen_matrix_like.html">EigenMatrixLike</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptsleipnir_1_1_matrix_like.html">MatrixLike</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptsleipnir_1_1_eigen_solver.html">EigenSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7b6ff477fca07d31231aade7ce57207a" id="r_a7b6ff477fca07d31231aade7ce57207a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b6ff477fca07d31231aade7ce57207a">TranscriptionMethod</a> : uint8_t { <a class="el" href="#a7b6ff477fca07d31231aade7ce57207aae09070d9a1cb5eaf8c431ff130d77254">kDirectTranscription</a>
, <a class="el" href="#a7b6ff477fca07d31231aade7ce57207aaeadf163719d8eaba16f306e4623348ae">kDirectCollocation</a>
, <a class="el" href="#a7b6ff477fca07d31231aade7ce57207aa6d0c9c617bab8979ca91133854abe778">kSingleShooting</a>
 }</td></tr>
<tr class="memdesc:a7b6ff477fca07d31231aade7ce57207a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum describing an OCP transcription method.  <a href="#a7b6ff477fca07d31231aade7ce57207a">More...</a><br /></td></tr>
<tr class="separator:a7b6ff477fca07d31231aade7ce57207a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e60fa99ee023884ea7a163a67169f7" id="r_a38e60fa99ee023884ea7a163a67169f7"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38e60fa99ee023884ea7a163a67169f7">DynamicsType</a> : uint8_t { <a class="el" href="#a38e60fa99ee023884ea7a163a67169f7a6976d4824b9f5192d274a69163d67423">kExplicitODE</a>
, <a class="el" href="#a38e60fa99ee023884ea7a163a67169f7a7095b968071a21b3995448cd36a11cef">kDiscrete</a>
 }</td></tr>
<tr class="memdesc:a38e60fa99ee023884ea7a163a67169f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum describing a type of system dynamics constraints.  <a href="#a38e60fa99ee023884ea7a163a67169f7">More...</a><br /></td></tr>
<tr class="separator:a38e60fa99ee023884ea7a163a67169f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c8390ba2ad034b958630d8b7d962b4" id="r_aa0c8390ba2ad034b958630d8b7d962b4"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0c8390ba2ad034b958630d8b7d962b4">TimestepMethod</a> : uint8_t { <a class="el" href="#aa0c8390ba2ad034b958630d8b7d962b4a826888a09763de7e2a9f60eb85d88b24">kFixed</a>
, <a class="el" href="#aa0c8390ba2ad034b958630d8b7d962b4afb751f6ee1af15e773242f2accd2dbff">kVariable</a>
, <a class="el" href="#aa0c8390ba2ad034b958630d8b7d962b4a0b8eddab15f53a79424adf236397d84b">kVariableSingle</a>
 }</td></tr>
<tr class="memdesc:aa0c8390ba2ad034b958630d8b7d962b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum describing the type of system timestep.  <a href="#aa0c8390ba2ad034b958630d8b7d962b4">More...</a><br /></td></tr>
<tr class="separator:aa0c8390ba2ad034b958630d8b7d962b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63018833d7a0635f244a22539dfc76d1" id="r_a63018833d7a0635f244a22539dfc76d1"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63018833d7a0635f244a22539dfc76d1">ExpressionType</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="#a63018833d7a0635f244a22539dfc76d1a35c3ace1970663a16e5c65baa5941b13">kNone</a>
, <a class="el" href="#a63018833d7a0635f244a22539dfc76d1a043b62a71551e8b511099802b2b59a98">kConstant</a>
, <a class="el" href="#a63018833d7a0635f244a22539dfc76d1aac97f0008bcf7c7fe4f2ff94160e1385">kLinear</a>
, <a class="el" href="#a63018833d7a0635f244a22539dfc76d1af841876fc54bbdba16a4ae2e0d070714">kQuadratic</a>
, <br />
&#160;&#160;<a class="el" href="#a63018833d7a0635f244a22539dfc76d1aca517032c6fda1fd3881f922c50ed8d6">kNonlinear</a>
<br />
 }</td></tr>
<tr class="memdesc:a63018833d7a0635f244a22539dfc76d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression type.  <a href="#a63018833d7a0635f244a22539dfc76d1">More...</a><br /></td></tr>
<tr class="separator:a63018833d7a0635f244a22539dfc76d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c3ac8825940144e76ed87f719b68d4" id="r_a79c3ac8825940144e76ed87f719b68d4"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79c3ac8825940144e76ed87f719b68d4">SolverExitCondition</a> : int8_t { <br />
&#160;&#160;<a class="el" href="#a79c3ac8825940144e76ed87f719b68d4a8c632159fa131f09d04f94e3cbcd8782">kSuccess</a> = 0
, <a class="el" href="#a79c3ac8825940144e76ed87f719b68d4a9545092cb61579e7f46a975d689b1bb8">kSolvedToAcceptableTolerance</a> = 1
, <a class="el" href="#a79c3ac8825940144e76ed87f719b68d4ad4c976257a619492860b8840abbcaf42">kCallbackRequestedStop</a> = 2
, <a class="el" href="#a79c3ac8825940144e76ed87f719b68d4aa80022963c2851dfd91949197cac8966">kTooFewDOFs</a> = -1
, <br />
&#160;&#160;<a class="el" href="#a79c3ac8825940144e76ed87f719b68d4a53ed66e6fa1f49615898ecce46fdbcb3">kLocallyInfeasible</a> = -2
, <a class="el" href="#a79c3ac8825940144e76ed87f719b68d4a23de0db053f48655155d173a39c62892">kFeasibilityRestorationFailed</a> = -3
, <a class="el" href="#a79c3ac8825940144e76ed87f719b68d4a08b5756e830054c09726f2d6ddfc98e4">kNonfiniteInitialCostOrConstraints</a> = -4
, <a class="el" href="#a79c3ac8825940144e76ed87f719b68d4abbefad5cbd24b04a4e4fb6bcae075c67">kDivergingIterates</a> = -5
, <br />
&#160;&#160;<a class="el" href="#a79c3ac8825940144e76ed87f719b68d4aad44d676f2d7acde9d736d83919b077f">kMaxIterationsExceeded</a> = -6
, <a class="el" href="#a79c3ac8825940144e76ed87f719b68d4a7f27861ff1d3f550c6aa77150d7edabd">kTimeout</a> = -7
<br />
 }</td></tr>
<tr class="memdesc:a79c3ac8825940144e76ed87f719b68d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver exit condition.  <a href="#a79c3ac8825940144e76ed87f719b68d4">More...</a><br /></td></tr>
<tr class="separator:a79c3ac8825940144e76ed87f719b68d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3b5b1386ff2d4a6e7d88f8be112082d2" id="r_a3b5b1386ff2d4a6e7d88f8be112082d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b5b1386ff2d4a6e7d88f8be112082d2">CwiseReduce</a> (const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;lhs, const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;rhs, <a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>(const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x, const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;y)&gt; binaryOp)</td></tr>
<tr class="memdesc:a3b5b1386ff2d4a6e7d88f8be112082d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a coefficient-wise reduce operation to two matrices.  <br /></td></tr>
<tr class="separator:a3b5b1386ff2d4a6e7d88f8be112082d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b87e3e8a405ae19e2f83758cd190d51" id="r_a4b87e3e8a405ae19e2f83758cd190d51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b87e3e8a405ae19e2f83758cd190d51">Block</a> (std::initializer_list&lt; std::initializer_list&lt; <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &gt; &gt; list)</td></tr>
<tr class="memdesc:a4b87e3e8a405ae19e2f83758cd190d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble a <a class="el" href="classsleipnir_1_1_variable_matrix.html" title="A matrix of autodiff variables.">VariableMatrix</a> from a nested list of blocks.  <br /></td></tr>
<tr class="separator:a4b87e3e8a405ae19e2f83758cd190d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9db48477b508d1ee300f7bfea891e1" id="r_a6d9db48477b508d1ee300f7bfea891e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d9db48477b508d1ee300f7bfea891e1">Block</a> (const std::vector&lt; std::vector&lt; <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &gt; &gt; &amp;list)</td></tr>
<tr class="memdesc:a6d9db48477b508d1ee300f7bfea891e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble a <a class="el" href="classsleipnir_1_1_variable_matrix.html" title="A matrix of autodiff variables.">VariableMatrix</a> from a nested list of blocks.  <br /></td></tr>
<tr class="separator:a6d9db48477b508d1ee300f7bfea891e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069c0c391e426f231f1ed5e28288fbe9" id="r_a069c0c391e426f231f1ed5e28288fbe9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a069c0c391e426f231f1ed5e28288fbe9">Solve</a> (const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;A, const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;B)</td></tr>
<tr class="memdesc:a069c0c391e426f231f1ed5e28288fbe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the <a class="el" href="classsleipnir_1_1_variable_matrix.html" title="A matrix of autodiff variables.">VariableMatrix</a> equation AX = B for X.  <br /></td></tr>
<tr class="separator:a069c0c391e426f231f1ed5e28288fbe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e055561e1b55a4f4efdfc1dcb06ff8" id="r_ac3e055561e1b55a4f4efdfc1dcb06ff8"><td class="memTemplParams" colspan="2">template&lt;typename F , typename State , typename Input , typename Time &gt; </td></tr>
<tr class="memitem:ac3e055561e1b55a4f4efdfc1dcb06ff8"><td class="memTemplItemLeft" align="right" valign="top">State&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac3e055561e1b55a4f4efdfc1dcb06ff8">RK4</a> (F &amp;&amp;f, State x, Input u, Time t0, Time dt)</td></tr>
<tr class="memdesc:ac3e055561e1b55a4f4efdfc1dcb06ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 4th order Runge-Kutta integration of dx/dt = f(t, x, u) for dt.  <br /></td></tr>
<tr class="separator:ac3e055561e1b55a4f4efdfc1dcb06ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b18604d3561d5bacf5281f1e6cf1993" id="r_a7b18604d3561d5bacf5281f1e6cf1993"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:a7b18604d3561d5bacf5281f1e6cf1993"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7b18604d3561d5bacf5281f1e6cf1993">swap</a> (<a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;lhs, <a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a7b18604d3561d5bacf5281f1e6cf1993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the referred callables of <code>lhs</code> and <code>rhs</code>.  <br /></td></tr>
<tr class="separator:a7b18604d3561d5bacf5281f1e6cf1993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed489757f97c9302617cb499226741c2" id="r_aed489757f97c9302617cb499226741c2"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:aed489757f97c9302617cb499226741c2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aed489757f97c9302617cb499226741c2">function_ref</a> (R(*)(Args...)) -&gt; function_ref&lt; R(Args...)&gt;</td></tr>
<tr class="separator:aed489757f97c9302617cb499226741c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a4065c9b3ad44d3d1a77f6fa9600ee" id="r_a55a4065c9b3ad44d3d1a77f6fa9600ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55a4065c9b3ad44d3d1a77f6fa9600ee">ToMessage</a> (const <a class="el" href="#a79c3ac8825940144e76ed87f719b68d4">SolverExitCondition</a> &amp;exitCondition)</td></tr>
<tr class="memdesc:a55a4065c9b3ad44d3d1a77f6fa9600ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns user-readable message corresponding to the exit condition.  <br /></td></tr>
<tr class="separator:a55a4065c9b3ad44d3d1a77f6fa9600ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e2d9ee285c6a874e470ddfe192bd50" id="r_ab1e2d9ee285c6a874e470ddfe192bd50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_pool_resource.html">PoolResource</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1e2d9ee285c6a874e470ddfe192bd50">GlobalPoolResource</a> ()</td></tr>
<tr class="memdesc:ab1e2d9ee285c6a874e470ddfe192bd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a global pool memory resource.  <br /></td></tr>
<tr class="separator:ab1e2d9ee285c6a874e470ddfe192bd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c3a2b931fa1c5fccccd2740e9ef94d" id="r_a75c3a2b931fa1c5fccccd2740e9ef94d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a75c3a2b931fa1c5fccccd2740e9ef94d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsleipnir_1_1_pool_allocator.html">PoolAllocator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a75c3a2b931fa1c5fccccd2740e9ef94d">GlobalPoolAllocator</a> ()</td></tr>
<tr class="memdesc:a75c3a2b931fa1c5fccccd2740e9ef94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an allocator for a global pool memory resource.  <br /></td></tr>
<tr class="separator:a75c3a2b931fa1c5fccccd2740e9ef94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcb7ba159c1d2c57e30301122d332ce" id="r_a8bcb7ba159c1d2c57e30301122d332ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bcb7ba159c1d2c57e30301122d332ce">abs</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a8bcb7ba159c1d2c57e30301122d332ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::abs() for Variables.  <br /></td></tr>
<tr class="separator:a8bcb7ba159c1d2c57e30301122d332ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93830608ececa1b6655278a6c405de7" id="r_ad93830608ececa1b6655278a6c405de7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad93830608ececa1b6655278a6c405de7">acos</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:ad93830608ececa1b6655278a6c405de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::acos() for Variables.  <br /></td></tr>
<tr class="separator:ad93830608ececa1b6655278a6c405de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33bb89eba6454138b7cd58a64054a7c8" id="r_a33bb89eba6454138b7cd58a64054a7c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33bb89eba6454138b7cd58a64054a7c8">asin</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a33bb89eba6454138b7cd58a64054a7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::asin() for Variables.  <br /></td></tr>
<tr class="separator:a33bb89eba6454138b7cd58a64054a7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f210b7e74658edaf15731391a5cc30" id="r_aa0f210b7e74658edaf15731391a5cc30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0f210b7e74658edaf15731391a5cc30">atan</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:aa0f210b7e74658edaf15731391a5cc30"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::atan() for Variables.  <br /></td></tr>
<tr class="separator:aa0f210b7e74658edaf15731391a5cc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630df7b189e4d16bff3726fe721d6152" id="r_a630df7b189e4d16bff3726fe721d6152"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a630df7b189e4d16bff3726fe721d6152">atan2</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;y, const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a630df7b189e4d16bff3726fe721d6152"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::atan2() for Variables.  <br /></td></tr>
<tr class="separator:a630df7b189e4d16bff3726fe721d6152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ae23d1e0093b86bc44621c4c49c0ea" id="r_aa1ae23d1e0093b86bc44621c4c49c0ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1ae23d1e0093b86bc44621c4c49c0ea">cos</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:aa1ae23d1e0093b86bc44621c4c49c0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::cos() for Variables.  <br /></td></tr>
<tr class="separator:aa1ae23d1e0093b86bc44621c4c49c0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340047f0b6fb9d03a760f5804e2ddf07" id="r_a340047f0b6fb9d03a760f5804e2ddf07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a340047f0b6fb9d03a760f5804e2ddf07">cosh</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a340047f0b6fb9d03a760f5804e2ddf07"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::cosh() for Variables.  <br /></td></tr>
<tr class="separator:a340047f0b6fb9d03a760f5804e2ddf07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a197c5c59bf157df1f414d7c2ccfe3b" id="r_a6a197c5c59bf157df1f414d7c2ccfe3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a197c5c59bf157df1f414d7c2ccfe3b">erf</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a6a197c5c59bf157df1f414d7c2ccfe3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::erf() for Variables.  <br /></td></tr>
<tr class="separator:a6a197c5c59bf157df1f414d7c2ccfe3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f351c4c585bd5b7962a89f2e2a1155" id="r_ac3f351c4c585bd5b7962a89f2e2a1155"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3f351c4c585bd5b7962a89f2e2a1155">exp</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:ac3f351c4c585bd5b7962a89f2e2a1155"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::exp() for Variables.  <br /></td></tr>
<tr class="separator:ac3f351c4c585bd5b7962a89f2e2a1155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6e8e37214d28794471c8b01409a128" id="r_a9f6e8e37214d28794471c8b01409a128"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f6e8e37214d28794471c8b01409a128">hypot</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x, const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;y)</td></tr>
<tr class="memdesc:a9f6e8e37214d28794471c8b01409a128"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::hypot() for Variables.  <br /></td></tr>
<tr class="separator:a9f6e8e37214d28794471c8b01409a128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f18573caf44bef6642332ad98ff4f9a" id="r_a9f18573caf44bef6642332ad98ff4f9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f18573caf44bef6642332ad98ff4f9a">pow</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;base, const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;power)</td></tr>
<tr class="memdesc:a9f18573caf44bef6642332ad98ff4f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::pow() for Variables.  <br /></td></tr>
<tr class="separator:a9f18573caf44bef6642332ad98ff4f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c000918d7d254f363e71def1a77cce9" id="r_a9c000918d7d254f363e71def1a77cce9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c000918d7d254f363e71def1a77cce9">log</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a9c000918d7d254f363e71def1a77cce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::log() for Variables.  <br /></td></tr>
<tr class="separator:a9c000918d7d254f363e71def1a77cce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f6511dbade8eb4e8486c5718015ddb" id="r_ad5f6511dbade8eb4e8486c5718015ddb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5f6511dbade8eb4e8486c5718015ddb">log10</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:ad5f6511dbade8eb4e8486c5718015ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::log10() for Variables.  <br /></td></tr>
<tr class="separator:ad5f6511dbade8eb4e8486c5718015ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ee3b7626080eaba8e8b65467bf23b2" id="r_a36ee3b7626080eaba8e8b65467bf23b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36ee3b7626080eaba8e8b65467bf23b2">sign</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a36ee3b7626080eaba8e8b65467bf23b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">sign() for Variables.  <br /></td></tr>
<tr class="separator:a36ee3b7626080eaba8e8b65467bf23b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2f17480dc7667bca2b8f027a9ff1f1" id="r_a1a2f17480dc7667bca2b8f027a9ff1f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a2f17480dc7667bca2b8f027a9ff1f1">sin</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a1a2f17480dc7667bca2b8f027a9ff1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::sin() for Variables.  <br /></td></tr>
<tr class="separator:a1a2f17480dc7667bca2b8f027a9ff1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdce37409d87f0aa0d5c124ff555a58" id="r_a7fdce37409d87f0aa0d5c124ff555a58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fdce37409d87f0aa0d5c124ff555a58">sinh</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a7fdce37409d87f0aa0d5c124ff555a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::sinh() for Variables.  <br /></td></tr>
<tr class="separator:a7fdce37409d87f0aa0d5c124ff555a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab400367eb603c4220c814bde2ef91c5f" id="r_ab400367eb603c4220c814bde2ef91c5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab400367eb603c4220c814bde2ef91c5f">sqrt</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:ab400367eb603c4220c814bde2ef91c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::sqrt() for Variables.  <br /></td></tr>
<tr class="separator:ab400367eb603c4220c814bde2ef91c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2190666baa579f39848387efb37a228" id="r_ab2190666baa579f39848387efb37a228"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2190666baa579f39848387efb37a228">tan</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:ab2190666baa579f39848387efb37a228"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::tan() for Variables.  <br /></td></tr>
<tr class="separator:ab2190666baa579f39848387efb37a228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241833c33e81b406cfbfc069342c339a" id="r_a241833c33e81b406cfbfc069342c339a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a241833c33e81b406cfbfc069342c339a">tanh</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a241833c33e81b406cfbfc069342c339a"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::tanh() for Variables.  <br /></td></tr>
<tr class="separator:a241833c33e81b406cfbfc069342c339a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75aa3a7748057d8c986042ad330758e4" id="r_a75aa3a7748057d8c986042ad330758e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75aa3a7748057d8c986042ad330758e4">hypot</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x, const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;y, const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;z)</td></tr>
<tr class="memdesc:a75aa3a7748057d8c986042ad330758e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::hypot() for Variables.  <br /></td></tr>
<tr class="separator:a75aa3a7748057d8c986042ad330758e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5505c6a23325ef4c196f9de5a694504" id="r_af5505c6a23325ef4c196f9de5a694504"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</td></tr>
<tr class="memitem:af5505c6a23325ef4c196f9de5a694504"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1_small_vector.html">wpi::SmallVector</a>&lt; <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af5505c6a23325ef4c196f9de5a694504">MakeConstraints</a> (LHS &amp;&amp;lhs, RHS &amp;&amp;rhs)</td></tr>
<tr class="memdesc:af5505c6a23325ef4c196f9de5a694504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a list of constraints.  <br /></td></tr>
<tr class="separator:af5505c6a23325ef4c196f9de5a694504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cac593a1dd030744b85cbe3d0e7da6" id="r_a58cac593a1dd030744b85cbe3d0e7da6"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</td></tr>
<tr class="memitem:a58cac593a1dd030744b85cbe3d0e7da6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsleipnir_1_1_equality_constraints.html">EqualityConstraints</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a58cac593a1dd030744b85cbe3d0e7da6">operator==</a> (LHS &amp;&amp;lhs, RHS &amp;&amp;rhs)</td></tr>
<tr class="memdesc:a58cac593a1dd030744b85cbe3d0e7da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator that returns an equality constraint for two Variables.  <br /></td></tr>
<tr class="separator:a58cac593a1dd030744b85cbe3d0e7da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5f8232b7a7dfbd13239455ef47da5b" id="r_add5f8232b7a7dfbd13239455ef47da5b"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</td></tr>
<tr class="memitem:add5f8232b7a7dfbd13239455ef47da5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsleipnir_1_1_inequality_constraints.html">InequalityConstraints</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#add5f8232b7a7dfbd13239455ef47da5b">operator&lt;</a> (LHS &amp;&amp;lhs, RHS &amp;&amp;rhs)</td></tr>
<tr class="memdesc:add5f8232b7a7dfbd13239455ef47da5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison operator that returns an inequality constraint for two Variables.  <br /></td></tr>
<tr class="separator:add5f8232b7a7dfbd13239455ef47da5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d6a0d536d82302d3e3c29786e53219" id="r_a22d6a0d536d82302d3e3c29786e53219"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</td></tr>
<tr class="memitem:a22d6a0d536d82302d3e3c29786e53219"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsleipnir_1_1_inequality_constraints.html">InequalityConstraints</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a22d6a0d536d82302d3e3c29786e53219">operator&lt;=</a> (LHS &amp;&amp;lhs, RHS &amp;&amp;rhs)</td></tr>
<tr class="memdesc:a22d6a0d536d82302d3e3c29786e53219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than-or-equal-to comparison operator that returns an inequality constraint for two Variables.  <br /></td></tr>
<tr class="separator:a22d6a0d536d82302d3e3c29786e53219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2eb85f8960aa6b9efc40aabb9b1a2fa" id="r_ab2eb85f8960aa6b9efc40aabb9b1a2fa"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</td></tr>
<tr class="memitem:ab2eb85f8960aa6b9efc40aabb9b1a2fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsleipnir_1_1_inequality_constraints.html">InequalityConstraints</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab2eb85f8960aa6b9efc40aabb9b1a2fa">operator&gt;</a> (LHS &amp;&amp;lhs, RHS &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ab2eb85f8960aa6b9efc40aabb9b1a2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison operator that returns an inequality constraint for two Variables.  <br /></td></tr>
<tr class="separator:ab2eb85f8960aa6b9efc40aabb9b1a2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababe98061e7c0f7d6e1334457af169ac" id="r_ababe98061e7c0f7d6e1334457af169ac"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</td></tr>
<tr class="memitem:ababe98061e7c0f7d6e1334457af169ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsleipnir_1_1_inequality_constraints.html">InequalityConstraints</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ababe98061e7c0f7d6e1334457af169ac">operator&gt;=</a> (LHS &amp;&amp;lhs, RHS &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ababe98061e7c0f7d6e1334457af169ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than-or-equal-to comparison operator that returns an inequality constraint for two Variables.  <br /></td></tr>
<tr class="separator:ababe98061e7c0f7d6e1334457af169ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7912f1f51db075b3acf93320281326f7" id="r_a7912f1f51db075b3acf93320281326f7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a7912f1f51db075b3acf93320281326f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsleipnir_1_1_intrusive_shared_ptr.html">IntrusiveSharedPtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7912f1f51db075b3acf93320281326f7">MakeIntrusiveShared</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7912f1f51db075b3acf93320281326f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of type T and wraps it in an intrusive shared pointer using args as the parameter list for the constructor of T.  <br /></td></tr>
<tr class="separator:a7912f1f51db075b3acf93320281326f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080968b3ea028d444bc29448bfa29e97" id="r_a080968b3ea028d444bc29448bfa29e97"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Alloc , typename... Args&gt; </td></tr>
<tr class="memitem:a080968b3ea028d444bc29448bfa29e97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsleipnir_1_1_intrusive_shared_ptr.html">IntrusiveSharedPtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a080968b3ea028d444bc29448bfa29e97">AllocateIntrusiveShared</a> (Alloc alloc, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a080968b3ea028d444bc29448bfa29e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of type T and wraps it in an intrusive shared pointer using alloc as the storage allocator of T and args as the parameter list for the constructor of T.  <br /></td></tr>
<tr class="separator:a080968b3ea028d444bc29448bfa29e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf6e456201217a8892f48e190dd1e82" id="r_a1bf6e456201217a8892f48e190dd1e82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bf6e456201217a8892f48e190dd1e82">InteriorPoint</a> (std::span&lt; <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &gt; decisionVariables, std::span&lt; <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &gt; equalityConstraints, std::span&lt; <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &gt; inequalityConstraints, <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;f, <a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; bool(const <a class="el" href="structsleipnir_1_1_solver_iteration_info.html">SolverIterationInfo</a> &amp;info)&gt; callback, const <a class="el" href="structsleipnir_1_1_solver_config.html">SolverConfig</a> &amp;config, bool feasibilityRestoration, Eigen::VectorXd &amp;x, Eigen::VectorXd &amp;s, <a class="el" href="structsleipnir_1_1_solver_status.html">SolverStatus</a> *status)</td></tr>
<tr class="memdesc:a1bf6e456201217a8892f48e190dd1e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the optimal solution to a nonlinear program using the interior-point method.  <br /></td></tr>
<tr class="separator:a1bf6e456201217a8892f48e190dd1e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16e9a34bdfc2fc303b1c9f278196001" id="r_ab16e9a34bdfc2fc303b1c9f278196001"><td class="memTemplParams" colspan="2">template&lt;typename DecisionVariables &gt; </td></tr>
<tr class="memitem:ab16e9a34bdfc2fc303b1c9f278196001"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsleipnir_1_1_multistart_result.html">MultistartResult</a>&lt; DecisionVariables &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab16e9a34bdfc2fc303b1c9f278196001">Multistart</a> (<a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="structsleipnir_1_1_multistart_result.html">MultistartResult</a>&lt; DecisionVariables &gt;(const DecisionVariables &amp;initialGuess)&gt; solve, std::span&lt; const DecisionVariables &gt; initialGuesses)</td></tr>
<tr class="memdesc:ab16e9a34bdfc2fc303b1c9f278196001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves an optimization problem from different starting points in parallel, then returns the solution with the lowest cost.  <br /></td></tr>
<tr class="separator:ab16e9a34bdfc2fc303b1c9f278196001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7317a14ecb6fd2609fc40a0ea2577cc1" id="r_a7317a14ecb6fd2609fc40a0ea2577cc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7317a14ecb6fd2609fc40a0ea2577cc1">Spy</a> (std::ostream &amp;file, const Eigen::SparseMatrix&lt; double &gt; &amp;mat)</td></tr>
<tr class="memdesc:a7317a14ecb6fd2609fc40a0ea2577cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the sparsity pattern of a sparse matrix to a file.  <br /></td></tr>
<tr class="separator:a7317a14ecb6fd2609fc40a0ea2577cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c613f4826d87e80d9ee015cc56a5ff" id="r_a89c613f4826d87e80d9ee015cc56a5ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89c613f4826d87e80d9ee015cc56a5ff">Spy</a> (std::string_view filename, const Eigen::SparseMatrix&lt; double &gt; &amp;mat)</td></tr>
<tr class="memdesc:a89c613f4826d87e80d9ee015cc56a5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the sparsity pattern of a sparse matrix to a file.  <br /></td></tr>
<tr class="separator:a89c613f4826d87e80d9ee015cc56a5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9442c1a3c76b61a27bfc46bed4a0cc5b" id="r_a9442c1a3c76b61a27bfc46bed4a0cc5b"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a9442c1a3c76b61a27bfc46bed4a0cc5b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9442c1a3c76b61a27bfc46bed4a0cc5b">print</a> (fmt::format_string&lt; T... &gt; fmt, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a9442c1a3c76b61a27bfc46bed4a0cc5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around fmt::print() that squelches write failure exceptions.  <br /></td></tr>
<tr class="separator:a9442c1a3c76b61a27bfc46bed4a0cc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d0e712de46cfa1e7a9456b0519257e" id="r_a70d0e712de46cfa1e7a9456b0519257e"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a70d0e712de46cfa1e7a9456b0519257e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a70d0e712de46cfa1e7a9456b0519257e">print</a> (std::FILE *f, fmt::format_string&lt; T... &gt; fmt, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a70d0e712de46cfa1e7a9456b0519257e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around fmt::print() that squelches write failure exceptions.  <br /></td></tr>
<tr class="separator:a70d0e712de46cfa1e7a9456b0519257e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0758fba396daf7bac66206f04df32b31" id="r_a0758fba396daf7bac66206f04df32b31"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a0758fba396daf7bac66206f04df32b31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0758fba396daf7bac66206f04df32b31">println</a> (fmt::format_string&lt; T... &gt; fmt, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a0758fba396daf7bac66206f04df32b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around fmt::println() that squelches write failure exceptions.  <br /></td></tr>
<tr class="separator:a0758fba396daf7bac66206f04df32b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225e73b7f33254984c4bd99107c5e564" id="r_a225e73b7f33254984c4bd99107c5e564"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a225e73b7f33254984c4bd99107c5e564"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a225e73b7f33254984c4bd99107c5e564">println</a> (std::FILE *f, fmt::format_string&lt; T... &gt; fmt, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a225e73b7f33254984c4bd99107c5e564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around fmt::println() that squelches write failure exceptions.  <br /></td></tr>
<tr class="separator:a225e73b7f33254984c4bd99107c5e564"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a703d7cfeaa4b7bfabb6c20675a7e9055" id="r_a703d7cfeaa4b7bfabb6c20675a7e9055"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a703d7cfeaa4b7bfabb6c20675a7e9055">Hessian</a></td></tr>
<tr class="separator:a703d7cfeaa4b7bfabb6c20675a7e9055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad566a82c0d33a39db1e2398075083bd8" id="r_ad566a82c0d33a39db1e2398075083bd8"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad566a82c0d33a39db1e2398075083bd8">Jacobian</a></td></tr>
<tr class="separator:ad566a82c0d33a39db1e2398075083bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a38e60fa99ee023884ea7a163a67169f7" name="a38e60fa99ee023884ea7a163a67169f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e60fa99ee023884ea7a163a67169f7">&#9670;&#160;</a></span>DynamicsType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a38e60fa99ee023884ea7a163a67169f7">sleipnir::DynamicsType</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum describing a type of system dynamics constraints. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a38e60fa99ee023884ea7a163a67169f7a6976d4824b9f5192d274a69163d67423" name="a38e60fa99ee023884ea7a163a67169f7a6976d4824b9f5192d274a69163d67423"></a>kExplicitODE&#160;</td><td class="fielddoc"><p>The dynamics are a function in the form dx/dt = f(t, x, u). </p>
</td></tr>
<tr><td class="fieldname"><a id="a38e60fa99ee023884ea7a163a67169f7a7095b968071a21b3995448cd36a11cef" name="a38e60fa99ee023884ea7a163a67169f7a7095b968071a21b3995448cd36a11cef"></a>kDiscrete&#160;</td><td class="fielddoc"><p>The dynamics are a function in the form xₖ₊₁ = f(t, xₖ, uₖ). </p>
</td></tr>
</table>

</div>
</div>
<a id="a63018833d7a0635f244a22539dfc76d1" name="a63018833d7a0635f244a22539dfc76d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63018833d7a0635f244a22539dfc76d1">&#9670;&#160;</a></span>ExpressionType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a63018833d7a0635f244a22539dfc76d1">sleipnir::ExpressionType</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expression type. </p>
<p>Used for autodiff caching. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a63018833d7a0635f244a22539dfc76d1a35c3ace1970663a16e5c65baa5941b13" name="a63018833d7a0635f244a22539dfc76d1a35c3ace1970663a16e5c65baa5941b13"></a>kNone&#160;</td><td class="fielddoc"><p>There is no expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a63018833d7a0635f244a22539dfc76d1a043b62a71551e8b511099802b2b59a98" name="a63018833d7a0635f244a22539dfc76d1a043b62a71551e8b511099802b2b59a98"></a>kConstant&#160;</td><td class="fielddoc"><p>The expression is a constant. </p>
</td></tr>
<tr><td class="fieldname"><a id="a63018833d7a0635f244a22539dfc76d1aac97f0008bcf7c7fe4f2ff94160e1385" name="a63018833d7a0635f244a22539dfc76d1aac97f0008bcf7c7fe4f2ff94160e1385"></a>kLinear&#160;</td><td class="fielddoc"><p>The expression is composed of linear and lower-order operators. </p>
</td></tr>
<tr><td class="fieldname"><a id="a63018833d7a0635f244a22539dfc76d1af841876fc54bbdba16a4ae2e0d070714" name="a63018833d7a0635f244a22539dfc76d1af841876fc54bbdba16a4ae2e0d070714"></a>kQuadratic&#160;</td><td class="fielddoc"><p>The expression is composed of quadratic and lower-order operators. </p>
</td></tr>
<tr><td class="fieldname"><a id="a63018833d7a0635f244a22539dfc76d1aca517032c6fda1fd3881f922c50ed8d6" name="a63018833d7a0635f244a22539dfc76d1aca517032c6fda1fd3881f922c50ed8d6"></a>kNonlinear&#160;</td><td class="fielddoc"><p>The expression is composed of nonlinear and lower-order operators. </p>
</td></tr>
</table>

</div>
</div>
<a id="a79c3ac8825940144e76ed87f719b68d4" name="a79c3ac8825940144e76ed87f719b68d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c3ac8825940144e76ed87f719b68d4">&#9670;&#160;</a></span>SolverExitCondition</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a79c3ac8825940144e76ed87f719b68d4">sleipnir::SolverExitCondition</a> : int8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solver exit condition. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a79c3ac8825940144e76ed87f719b68d4a8c632159fa131f09d04f94e3cbcd8782" name="a79c3ac8825940144e76ed87f719b68d4a8c632159fa131f09d04f94e3cbcd8782"></a>kSuccess&#160;</td><td class="fielddoc"><p>Solved the problem to the desired tolerance. </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c3ac8825940144e76ed87f719b68d4a9545092cb61579e7f46a975d689b1bb8" name="a79c3ac8825940144e76ed87f719b68d4a9545092cb61579e7f46a975d689b1bb8"></a>kSolvedToAcceptableTolerance&#160;</td><td class="fielddoc"><p>Solved the problem to an acceptable tolerance, but not the desired one. </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c3ac8825940144e76ed87f719b68d4ad4c976257a619492860b8840abbcaf42" name="a79c3ac8825940144e76ed87f719b68d4ad4c976257a619492860b8840abbcaf42"></a>kCallbackRequestedStop&#160;</td><td class="fielddoc"><p>The solver returned its solution so far after the user requested a stop. </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c3ac8825940144e76ed87f719b68d4aa80022963c2851dfd91949197cac8966" name="a79c3ac8825940144e76ed87f719b68d4aa80022963c2851dfd91949197cac8966"></a>kTooFewDOFs&#160;</td><td class="fielddoc"><p>The solver determined the problem to be overconstrained and gave up. </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c3ac8825940144e76ed87f719b68d4a53ed66e6fa1f49615898ecce46fdbcb3" name="a79c3ac8825940144e76ed87f719b68d4a53ed66e6fa1f49615898ecce46fdbcb3"></a>kLocallyInfeasible&#160;</td><td class="fielddoc"><p>The solver determined the problem to be locally infeasible and gave up. </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c3ac8825940144e76ed87f719b68d4a23de0db053f48655155d173a39c62892" name="a79c3ac8825940144e76ed87f719b68d4a23de0db053f48655155d173a39c62892"></a>kFeasibilityRestorationFailed&#160;</td><td class="fielddoc"><p>The solver failed to reach the desired tolerance, and feasibility restoration failed to converge. </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c3ac8825940144e76ed87f719b68d4a08b5756e830054c09726f2d6ddfc98e4" name="a79c3ac8825940144e76ed87f719b68d4a08b5756e830054c09726f2d6ddfc98e4"></a>kNonfiniteInitialCostOrConstraints&#160;</td><td class="fielddoc"><p>The solver encountered nonfinite initial cost or constraints and gave up. </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c3ac8825940144e76ed87f719b68d4abbefad5cbd24b04a4e4fb6bcae075c67" name="a79c3ac8825940144e76ed87f719b68d4abbefad5cbd24b04a4e4fb6bcae075c67"></a>kDivergingIterates&#160;</td><td class="fielddoc"><p>The solver encountered diverging primal iterates xₖ and/or sₖ and gave up. </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c3ac8825940144e76ed87f719b68d4aad44d676f2d7acde9d736d83919b077f" name="a79c3ac8825940144e76ed87f719b68d4aad44d676f2d7acde9d736d83919b077f"></a>kMaxIterationsExceeded&#160;</td><td class="fielddoc"><p>The solver returned its solution so far after exceeding the maximum number of iterations. </p>
</td></tr>
<tr><td class="fieldname"><a id="a79c3ac8825940144e76ed87f719b68d4a7f27861ff1d3f550c6aa77150d7edabd" name="a79c3ac8825940144e76ed87f719b68d4a7f27861ff1d3f550c6aa77150d7edabd"></a>kTimeout&#160;</td><td class="fielddoc"><p>The solver returned its solution so far after exceeding the maximum elapsed wall clock time. </p>
</td></tr>
</table>

</div>
</div>
<a id="aa0c8390ba2ad034b958630d8b7d962b4" name="aa0c8390ba2ad034b958630d8b7d962b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c8390ba2ad034b958630d8b7d962b4">&#9670;&#160;</a></span>TimestepMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#aa0c8390ba2ad034b958630d8b7d962b4">sleipnir::TimestepMethod</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum describing the type of system timestep. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa0c8390ba2ad034b958630d8b7d962b4a826888a09763de7e2a9f60eb85d88b24" name="aa0c8390ba2ad034b958630d8b7d962b4a826888a09763de7e2a9f60eb85d88b24"></a>kFixed&#160;</td><td class="fielddoc"><p>The timestep is a fixed constant. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa0c8390ba2ad034b958630d8b7d962b4afb751f6ee1af15e773242f2accd2dbff" name="aa0c8390ba2ad034b958630d8b7d962b4afb751f6ee1af15e773242f2accd2dbff"></a>kVariable&#160;</td><td class="fielddoc"><p>The timesteps are allowed to vary as independent decision variables. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa0c8390ba2ad034b958630d8b7d962b4a0b8eddab15f53a79424adf236397d84b" name="aa0c8390ba2ad034b958630d8b7d962b4a0b8eddab15f53a79424adf236397d84b"></a>kVariableSingle&#160;</td><td class="fielddoc"><p>The timesteps are equal length but allowed to vary as a single decision variable. </p>
</td></tr>
</table>

</div>
</div>
<a id="a7b6ff477fca07d31231aade7ce57207a" name="a7b6ff477fca07d31231aade7ce57207a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6ff477fca07d31231aade7ce57207a">&#9670;&#160;</a></span>TranscriptionMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a7b6ff477fca07d31231aade7ce57207a">sleipnir::TranscriptionMethod</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum describing an OCP transcription method. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7b6ff477fca07d31231aade7ce57207aae09070d9a1cb5eaf8c431ff130d77254" name="a7b6ff477fca07d31231aade7ce57207aae09070d9a1cb5eaf8c431ff130d77254"></a>kDirectTranscription&#160;</td><td class="fielddoc"><p>Each state is a decision variable constrained to the integrated dynamics of the previous state. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7b6ff477fca07d31231aade7ce57207aaeadf163719d8eaba16f306e4623348ae" name="a7b6ff477fca07d31231aade7ce57207aaeadf163719d8eaba16f306e4623348ae"></a>kDirectCollocation&#160;</td><td class="fielddoc"><p>The trajectory is modeled as a series of cubic polynomials where the centerpoint slope is constrained. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7b6ff477fca07d31231aade7ce57207aa6d0c9c617bab8979ca91133854abe778" name="a7b6ff477fca07d31231aade7ce57207aa6d0c9c617bab8979ca91133854abe778"></a>kSingleShooting&#160;</td><td class="fielddoc"><p>States depend explicitly as a function of all previous states and all previous inputs. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8bcb7ba159c1d2c57e30301122d332ce" name="a8bcb7ba159c1d2c57e30301122d332ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bcb7ba159c1d2c57e30301122d332ce">&#9670;&#160;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::abs() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad93830608ececa1b6655278a6c405de7" name="ad93830608ececa1b6655278a6c405de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93830608ececa1b6655278a6c405de7">&#9670;&#160;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::acos() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a080968b3ea028d444bc29448bfa29e97" name="a080968b3ea028d444bc29448bfa29e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080968b3ea028d444bc29448bfa29e97">&#9670;&#160;</a></span>AllocateIntrusiveShared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsleipnir_1_1_intrusive_shared_ptr.html">IntrusiveSharedPtr</a>&lt; T &gt; sleipnir::AllocateIntrusiveShared </td>
          <td>(</td>
          <td class="paramtype">Alloc</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an object of type T and wraps it in an intrusive shared pointer using alloc as the storage allocator of T and args as the parameter list for the constructor of T. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object for intrusive shared pointer. </td></tr>
    <tr><td class="paramname">Alloc</td><td>Type of allocator for T. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of constructor arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>The allocator for T. </td></tr>
    <tr><td class="paramname">args</td><td>Constructor arguments for T. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33bb89eba6454138b7cd58a64054a7c8" name="a33bb89eba6454138b7cd58a64054a7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33bb89eba6454138b7cd58a64054a7c8">&#9670;&#160;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::asin() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0f210b7e74658edaf15731391a5cc30" name="aa0f210b7e74658edaf15731391a5cc30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f210b7e74658edaf15731391a5cc30">&#9670;&#160;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::atan() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a630df7b189e4d16bff3726fe721d6152" name="a630df7b189e4d16bff3726fe721d6152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630df7b189e4d16bff3726fe721d6152">&#9670;&#160;</a></span>atan2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::atan2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::atan2() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>The y argument. </td></tr>
    <tr><td class="paramname">x</td><td>The x argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d9db48477b508d1ee300f7bfea891e1" name="a6d9db48477b508d1ee300f7bfea891e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9db48477b508d1ee300f7bfea891e1">&#9670;&#160;</a></span>Block() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> sleipnir::Block </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assemble a <a class="el" href="classsleipnir_1_1_variable_matrix.html" title="A matrix of autodiff variables.">VariableMatrix</a> from a nested list of blocks. </p>
<p>Each row's blocks must have the same height, and the assembled block rows must have the same width. For example, for the block matrix [[A, B], [C]] to be constructible, the number of rows in A and B must match, and the number of columns in [A, B] and [C] must match.</p>
<p>This overload is for Python bindings only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The nested list of blocks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b87e3e8a405ae19e2f83758cd190d51" name="a4b87e3e8a405ae19e2f83758cd190d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b87e3e8a405ae19e2f83758cd190d51">&#9670;&#160;</a></span>Block() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> sleipnir::Block </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::initializer_list&lt; <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>list</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assemble a <a class="el" href="classsleipnir_1_1_variable_matrix.html" title="A matrix of autodiff variables.">VariableMatrix</a> from a nested list of blocks. </p>
<p>Each row's blocks must have the same height, and the assembled block rows must have the same width. For example, for the block matrix [[A, B], [C]] to be constructible, the number of rows in A and B must match, and the number of columns in [A, B] and [C] must match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The nested list of blocks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1ae23d1e0093b86bc44621c4c49c0ea" name="aa1ae23d1e0093b86bc44621c4c49c0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ae23d1e0093b86bc44621c4c49c0ea">&#9670;&#160;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::cos() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a340047f0b6fb9d03a760f5804e2ddf07" name="a340047f0b6fb9d03a760f5804e2ddf07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340047f0b6fb9d03a760f5804e2ddf07">&#9670;&#160;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::cosh() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b5b1386ff2d4a6e7d88f8be112082d2" name="a3b5b1386ff2d4a6e7d88f8be112082d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5b1386ff2d4a6e7d88f8be112082d2">&#9670;&#160;</a></span>CwiseReduce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> sleipnir::CwiseReduce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classsleipnir_1_1_variable.html">Variable</a>(const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;x, const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;y)&gt;</td>          <td class="paramname"><span class="paramname"><em>binaryOp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a coefficient-wise reduce operation to two matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side of the binary operator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side of the binary operator. </td></tr>
    <tr><td class="paramname">binaryOp</td><td>The binary operator to use for the reduce operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a197c5c59bf157df1f414d7c2ccfe3b" name="a6a197c5c59bf157df1f414d7c2ccfe3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a197c5c59bf157df1f414d7c2ccfe3b">&#9670;&#160;</a></span>erf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::erf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::erf() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3f351c4c585bd5b7962a89f2e2a1155" name="ac3f351c4c585bd5b7962a89f2e2a1155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f351c4c585bd5b7962a89f2e2a1155">&#9670;&#160;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::exp() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed489757f97c9302617cb499226741c2" name="aed489757f97c9302617cb499226741c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed489757f97c9302617cb499226741c2">&#9670;&#160;</a></span>function_ref()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">sleipnir::function_ref </td>
          <td>(</td>
          <td class="paramtype">R(*</td>          <td class="paramname"><span class="paramname"><em>&#160;</em></span>)(Args...)</td><td>)</td>
          <td> -&gt;  function_ref&lt; R(Args...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a75c3a2b931fa1c5fccccd2740e9ef94d" name="a75c3a2b931fa1c5fccccd2740e9ef94d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c3a2b931fa1c5fccccd2740e9ef94d">&#9670;&#160;</a></span>GlobalPoolAllocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsleipnir_1_1_pool_allocator.html">PoolAllocator</a>&lt; T &gt; sleipnir::GlobalPoolAllocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an allocator for a global pool memory resource. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of object in the pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1e2d9ee285c6a874e470ddfe192bd50" name="ab1e2d9ee285c6a874e470ddfe192bd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e2d9ee285c6a874e470ddfe192bd50">&#9670;&#160;</a></span>GlobalPoolResource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_pool_resource.html">PoolResource</a> &amp; sleipnir::GlobalPoolResource </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a global pool memory resource. </p>

</div>
</div>
<a id="a9f6e8e37214d28794471c8b01409a128" name="a9f6e8e37214d28794471c8b01409a128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6e8e37214d28794471c8b01409a128">&#9670;&#160;</a></span>hypot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::hypot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::hypot() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x argument. </td></tr>
    <tr><td class="paramname">y</td><td>The y argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75aa3a7748057d8c986042ad330758e4" name="a75aa3a7748057d8c986042ad330758e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75aa3a7748057d8c986042ad330758e4">&#9670;&#160;</a></span>hypot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::hypot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::hypot() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x argument. </td></tr>
    <tr><td class="paramname">y</td><td>The y argument. </td></tr>
    <tr><td class="paramname">z</td><td>The z argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bf6e456201217a8892f48e190dd1e82" name="a1bf6e456201217a8892f48e190dd1e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf6e456201217a8892f48e190dd1e82">&#9670;&#160;</a></span>InteriorPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> void sleipnir::InteriorPoint </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>decisionVariables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>equalityConstraints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>inequalityConstraints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; bool(const <a class="el" href="structsleipnir_1_1_solver_iteration_info.html">SolverIterationInfo</a> &amp;info)&gt;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsleipnir_1_1_solver_config.html">SolverConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>feasibilityRestoration</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsleipnir_1_1_solver_status.html">SolverStatus</a> *</td>          <td class="paramname"><span class="paramname"><em>status</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the optimal solution to a nonlinear program using the interior-point method. </p>
<p>A nonlinear program has the form:</p>
<pre class="fragment">     min_x f(x)
subject to cₑ(x) = 0
           cᵢ(x) ≥ 0
</pre><p>where f(x) is the cost function, cₑ(x) are the equality constraints, and cᵢ(x) are the inequality constraints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decisionVariables</td><td>The list of decision variables. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">equalityConstraints</td><td>The list of equality constraints. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inequalityConstraints</td><td>The list of inequality constraints. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The cost function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The user callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Configuration options for the solver. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">feasibilityRestoration</td><td>Whether to use feasibility restoration instead of the normal algorithm. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>The initial guess and output location for the decision variables. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s</td><td>The initial guess and output location for the inequality constraint slack variables. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>The solver status. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c000918d7d254f363e71def1a77cce9" name="a9c000918d7d254f363e71def1a77cce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c000918d7d254f363e71def1a77cce9">&#9670;&#160;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::log() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5f6511dbade8eb4e8486c5718015ddb" name="ad5f6511dbade8eb4e8486c5718015ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f6511dbade8eb4e8486c5718015ddb">&#9670;&#160;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::log10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::log10() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5505c6a23325ef4c196f9de5a694504" name="af5505c6a23325ef4c196f9de5a694504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5505c6a23325ef4c196f9de5a694504">&#9670;&#160;</a></span>MakeConstraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1_small_vector.html">wpi::SmallVector</a>&lt; <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &gt; sleipnir::MakeConstraints </td>
          <td>(</td>
          <td class="paramtype">LHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a list of constraints. </p>
<p>The standard form for equality constraints is c(x) = 0, and the standard form for inequality constraints is c(x) ≥ 0. This function takes constraints of the form lhs = rhs or lhs ≥ rhs and converts them to lhs - rhs = 0 or lhs - rhs ≥ 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7912f1f51db075b3acf93320281326f7" name="a7912f1f51db075b3acf93320281326f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7912f1f51db075b3acf93320281326f7">&#9670;&#160;</a></span>MakeIntrusiveShared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsleipnir_1_1_intrusive_shared_ptr.html">IntrusiveSharedPtr</a>&lt; T &gt; sleipnir::MakeIntrusiveShared </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an object of type T and wraps it in an intrusive shared pointer using args as the parameter list for the constructor of T. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object for intrusive shared pointer. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of constructor arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Constructor arguments for T. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab16e9a34bdfc2fc303b1c9f278196001" name="ab16e9a34bdfc2fc303b1c9f278196001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16e9a34bdfc2fc303b1c9f278196001">&#9670;&#160;</a></span>Multistart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DecisionVariables &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsleipnir_1_1_multistart_result.html">MultistartResult</a>&lt; DecisionVariables &gt; sleipnir::Multistart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="structsleipnir_1_1_multistart_result.html">MultistartResult</a>&lt; DecisionVariables &gt;(const DecisionVariables &amp;initialGuess)&gt;</td>          <td class="paramname"><span class="paramname"><em>solve</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const DecisionVariables &gt;</td>          <td class="paramname"><span class="paramname"><em>initialGuesses</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves an optimization problem from different starting points in parallel, then returns the solution with the lowest cost. </p>
<p>Each solve is performed on a separate thread. Solutions from successful solves are always preferred over solutions from unsuccessful solves, and cost (lower is better) is the tiebreaker between successful solves.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DecisionVariables</td><td>The type containing the decision variable initial guess. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solve</td><td>A user-provided function that takes a decision variable initial guess and returns a <a class="el" href="structsleipnir_1_1_multistart_result.html" title="The result of a multistart solve.">MultistartResult</a>. </td></tr>
    <tr><td class="paramname">initialGuesses</td><td>A list of decision variable initial guesses to try. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add5f8232b7a7dfbd13239455ef47da5b" name="add5f8232b7a7dfbd13239455ef47da5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5f8232b7a7dfbd13239455ef47da5b">&#9670;&#160;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsleipnir_1_1_inequality_constraints.html">InequalityConstraints</a> sleipnir::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">LHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Less-than comparison operator that returns an inequality constraint for two Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramname">rhs</td><td>Left-hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22d6a0d536d82302d3e3c29786e53219" name="a22d6a0d536d82302d3e3c29786e53219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d6a0d536d82302d3e3c29786e53219">&#9670;&#160;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsleipnir_1_1_inequality_constraints.html">InequalityConstraints</a> sleipnir::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">LHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Less-than-or-equal-to comparison operator that returns an inequality constraint for two Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramname">rhs</td><td>Left-hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58cac593a1dd030744b85cbe3d0e7da6" name="a58cac593a1dd030744b85cbe3d0e7da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58cac593a1dd030744b85cbe3d0e7da6">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsleipnir_1_1_equality_constraints.html">EqualityConstraints</a> sleipnir::operator== </td>
          <td>(</td>
          <td class="paramtype">LHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality operator that returns an equality constraint for two Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramname">rhs</td><td>Left-hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2eb85f8960aa6b9efc40aabb9b1a2fa" name="ab2eb85f8960aa6b9efc40aabb9b1a2fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2eb85f8960aa6b9efc40aabb9b1a2fa">&#9670;&#160;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsleipnir_1_1_inequality_constraints.html">InequalityConstraints</a> sleipnir::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">LHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Greater-than comparison operator that returns an inequality constraint for two Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramname">rhs</td><td>Left-hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ababe98061e7c0f7d6e1334457af169ac" name="ababe98061e7c0f7d6e1334457af169ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ababe98061e7c0f7d6e1334457af169ac">&#9670;&#160;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;std::decay_t&lt;LHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;LHS&gt;&gt;) &amp;&amp; (ScalarLike&lt;std::decay_t&lt;RHS&gt;&gt; || MatrixLike&lt;std::decay_t&lt;RHS&gt;&gt;) &amp;&amp; (!std::same_as&lt;std::decay_t&lt;LHS&gt;, double&gt; || !std::same_as&lt;std::decay_t&lt;RHS&gt;, double&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsleipnir_1_1_inequality_constraints.html">InequalityConstraints</a> sleipnir::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">LHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Greater-than-or-equal-to comparison operator that returns an inequality constraint for two Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramname">rhs</td><td>Left-hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f18573caf44bef6642332ad98ff4f9a" name="a9f18573caf44bef6642332ad98ff4f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f18573caf44bef6642332ad98ff4f9a">&#9670;&#160;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>base</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>power</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::pow() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base. </td></tr>
    <tr><td class="paramname">power</td><td>The power. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9442c1a3c76b61a27bfc46bed4a0cc5b" name="a9442c1a3c76b61a27bfc46bed4a0cc5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9442c1a3c76b61a27bfc46bed4a0cc5b">&#9670;&#160;</a></span>print() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sleipnir::print </td>
          <td>(</td>
          <td class="paramtype">fmt::format_string&lt; T... &gt;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around fmt::print() that squelches write failure exceptions. </p>

</div>
</div>
<a id="a70d0e712de46cfa1e7a9456b0519257e" name="a70d0e712de46cfa1e7a9456b0519257e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d0e712de46cfa1e7a9456b0519257e">&#9670;&#160;</a></span>print() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sleipnir::print </td>
          <td>(</td>
          <td class="paramtype">std::FILE *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmt::format_string&lt; T... &gt;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around fmt::print() that squelches write failure exceptions. </p>

</div>
</div>
<a id="a0758fba396daf7bac66206f04df32b31" name="a0758fba396daf7bac66206f04df32b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0758fba396daf7bac66206f04df32b31">&#9670;&#160;</a></span>println() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sleipnir::println </td>
          <td>(</td>
          <td class="paramtype">fmt::format_string&lt; T... &gt;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around fmt::println() that squelches write failure exceptions. </p>

</div>
</div>
<a id="a225e73b7f33254984c4bd99107c5e564" name="a225e73b7f33254984c4bd99107c5e564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225e73b7f33254984c4bd99107c5e564">&#9670;&#160;</a></span>println() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sleipnir::println </td>
          <td>(</td>
          <td class="paramtype">std::FILE *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmt::format_string&lt; T... &gt;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around fmt::println() that squelches write failure exceptions. </p>

</div>
</div>
<a id="ac3e055561e1b55a4f4efdfc1dcb06ff8" name="ac3e055561e1b55a4f4efdfc1dcb06ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e055561e1b55a4f4efdfc1dcb06ff8">&#9670;&#160;</a></span>RK4()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename State , typename Input , typename Time &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">State sleipnir::RK4 </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">State</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Time</td>          <td class="paramname"><span class="paramname"><em>t0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Time</td>          <td class="paramname"><span class="paramname"><em>dt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs 4th order Runge-Kutta integration of dx/dt = f(t, x, u) for dt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate. It must take two arguments x and u. </td></tr>
    <tr><td class="paramname">x</td><td>The initial value of x. </td></tr>
    <tr><td class="paramname">u</td><td>The value u held constant over the integration period. </td></tr>
    <tr><td class="paramname">t0</td><td>The initial time. </td></tr>
    <tr><td class="paramname">dt</td><td>The time over which to integrate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36ee3b7626080eaba8e8b65467bf23b2" name="a36ee3b7626080eaba8e8b65467bf23b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ee3b7626080eaba8e8b65467bf23b2">&#9670;&#160;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::sign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sign() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a2f17480dc7667bca2b8f027a9ff1f1" name="a1a2f17480dc7667bca2b8f027a9ff1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2f17480dc7667bca2b8f027a9ff1f1">&#9670;&#160;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::sin() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fdce37409d87f0aa0d5c124ff555a58" name="a7fdce37409d87f0aa0d5c124ff555a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdce37409d87f0aa0d5c124ff555a58">&#9670;&#160;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::sinh() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a069c0c391e426f231f1ed5e28288fbe9" name="a069c0c391e426f231f1ed5e28288fbe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069c0c391e426f231f1ed5e28288fbe9">&#9670;&#160;</a></span>Solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> sleipnir::Solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the <a class="el" href="classsleipnir_1_1_variable_matrix.html" title="A matrix of autodiff variables.">VariableMatrix</a> equation AX = B for X. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The left-hand side. </td></tr>
    <tr><td class="paramname">B</td><td>The right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The solution X. </dd></dl>

</div>
</div>
<a id="a7317a14ecb6fd2609fc40a0ea2577cc1" name="a7317a14ecb6fd2609fc40a0ea2577cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7317a14ecb6fd2609fc40a0ea2577cc1">&#9670;&#160;</a></span>Spy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> void sleipnir::Spy </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mat</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the sparsity pattern of a sparse matrix to a file. </p>
<p>Each character represents an element with '.' representing zero, '+' representing positive, and '-' representing negative. Here's an example for a 3x3 identity matrix.</p>
<p>"+.." ".+." "..+"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">file</td><td>A file stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>The sparse matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89c613f4826d87e80d9ee015cc56a5ff" name="a89c613f4826d87e80d9ee015cc56a5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c613f4826d87e80d9ee015cc56a5ff">&#9670;&#160;</a></span>Spy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> void sleipnir::Spy </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mat</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the sparsity pattern of a sparse matrix to a file. </p>
<p>Each character represents an element with "." representing zero, "+" representing positive, and "-" representing negative. Here's an example for a 3x3 identity matrix.</p>
<p>"+.." ".+." "..+"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The filename. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>The sparse matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab400367eb603c4220c814bde2ef91c5f" name="ab400367eb603c4220c814bde2ef91c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab400367eb603c4220c814bde2ef91c5f">&#9670;&#160;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::sqrt() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b18604d3561d5bacf5281f1e6cf1993" name="a7b18604d3561d5bacf5281f1e6cf1993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b18604d3561d5bacf5281f1e6cf1993">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sleipnir::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the referred callables of <code>lhs</code> and <code>rhs</code>. </p>

</div>
</div>
<a id="ab2190666baa579f39848387efb37a228" name="ab2190666baa579f39848387efb37a228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2190666baa579f39848387efb37a228">&#9670;&#160;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::tan() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a241833c33e81b406cfbfc069342c339a" name="a241833c33e81b406cfbfc069342c339a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241833c33e81b406cfbfc069342c339a">&#9670;&#160;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> sleipnir::tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::tanh() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55a4065c9b3ad44d3d1a77f6fa9600ee" name="a55a4065c9b3ad44d3d1a77f6fa9600ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a4065c9b3ad44d3d1a77f6fa9600ee">&#9670;&#160;</a></span>ToMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> constexpr std::string_view sleipnir::ToMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a79c3ac8825940144e76ed87f719b68d4">SolverExitCondition</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>exitCondition</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns user-readable message corresponding to the exit condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exitCondition</td><td>Solver exit condition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a703d7cfeaa4b7bfabb6c20675a7e9055" name="a703d7cfeaa4b7bfabb6c20675a7e9055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703d7cfeaa4b7bfabb6c20675a7e9055">&#9670;&#160;</a></span>Hessian</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> sleipnir::Hessian</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad566a82c0d33a39db1e2398075083bd8" name="ad566a82c0d33a39db1e2398075083bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad566a82c0d33a39db1e2398075083bd8">&#9670;&#160;</a></span>Jacobian</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="_symbol_exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> sleipnir::Jacobian</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesleipnir.html">sleipnir</a></li>
    <li class="footer">Generated on Thu Oct 24 2024 04:48:55 for WPILibC++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
