<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: wpi::memory::memory_pool_collection&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="wpilib-128.png"/></td>
  <td id="projectalign">
   <div id="projectname">WPILibC++<span id="projectnumber">&#160;2025.1.1-beta-1-35-g9a5f73d</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classwpi_1_1memory_1_1memory__pool__collection.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classwpi_1_1memory_1_1memory__pool__collection-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">wpi::memory::memory_pool_collection&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__memory.html">Memory Allocator Library</a> &raquo; <a class="el" href="group__memory__allocator.html">Allocator implementations</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A stateful RawAllocator that behaves as a collection of multiple <a class="el" href="classwpi_1_1memory_1_1memory__pool.html">memory_pool</a> objects.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="memory__pool__collection_8hpp_source.html">/home/runner/work/allwpilib/allwpilib/wpiutil/src/main/native/thirdparty/memory/include/wpi/memory/memory_pool_collection.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3faae02a1d2c0e38cf9f31702d5da3c7" id="r_a3faae02a1d2c0e38cf9f31702d5da3c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3faae02a1d2c0e38cf9f31702d5da3c7">allocator_type</a> = <a class="el" href="group__memory__core.html#ga2c98b0ef7658d9beda86fa166f4c02fb">make_block_allocator_t</a>&lt;BlockOrRawAllocator&gt;</td></tr>
<tr class="separator:a3faae02a1d2c0e38cf9f31702d5da3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7454dbe692e2ab670cae86f0cfbe3e97" id="r_a7454dbe692e2ab670cae86f0cfbe3e97"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7454dbe692e2ab670cae86f0cfbe3e97">pool_type</a> = PoolType</td></tr>
<tr class="separator:a7454dbe692e2ab670cae86f0cfbe3e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b065b24b1ac024bb7d3894ecf5561e" id="r_a23b065b24b1ac024bb7d3894ecf5561e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23b065b24b1ac024bb7d3894ecf5561e">bucket_distribution</a> = BucketDistribution</td></tr>
<tr class="separator:a23b065b24b1ac024bb7d3894ecf5561e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a00a9beecea3a4e2f30741833823befd4" id="r_a00a9beecea3a4e2f30741833823befd4"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a00a9beecea3a4e2f30741833823befd4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a00a9beecea3a4e2f30741833823befd4">memory_pool_collection</a> (std::size_t <a class="el" href="#ae6ef0aeec59076e5bcd42f6a31a7db44">max_node_size</a>, std::size_t block_size, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a00a9beecea3a4e2f30741833823befd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa1b8df2730209880964e4d0003f2d6" id="r_abaa1b8df2730209880964e4d0003f2d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abaa1b8df2730209880964e4d0003f2d6">~memory_pool_collection</a> () noexcept=default</td></tr>
<tr class="separator:abaa1b8df2730209880964e4d0003f2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759828ff5eea5c9a6c859b74f1ab27df" id="r_a759828ff5eea5c9a6c859b74f1ab27df"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a759828ff5eea5c9a6c859b74f1ab27df">allocate_node</a> (std::size_t node_size)</td></tr>
<tr class="separator:a759828ff5eea5c9a6c859b74f1ab27df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44e58c37889e35029004d2fbd412157" id="r_ae44e58c37889e35029004d2fbd412157"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae44e58c37889e35029004d2fbd412157">try_allocate_node</a> (std::size_t node_size) noexcept</td></tr>
<tr class="separator:ae44e58c37889e35029004d2fbd412157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7947efd817b6c5caa21969dfbae5a741" id="r_a7947efd817b6c5caa21969dfbae5a741"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7947efd817b6c5caa21969dfbae5a741">allocate_array</a> (std::size_t count, std::size_t node_size)</td></tr>
<tr class="separator:a7947efd817b6c5caa21969dfbae5a741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c3bbd6d7a79d1ac99017fea40dd3ad" id="r_ab5c3bbd6d7a79d1ac99017fea40dd3ad"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5c3bbd6d7a79d1ac99017fea40dd3ad">try_allocate_array</a> (std::size_t count, std::size_t node_size) noexcept</td></tr>
<tr class="separator:ab5c3bbd6d7a79d1ac99017fea40dd3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5be8411adf1365b9599b9d2c49a955" id="r_a1d5be8411adf1365b9599b9d2c49a955"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d5be8411adf1365b9599b9d2c49a955">deallocate_node</a> (void *<a class="el" href="format_8h.html#adb6e274f8eb0b74b2865215e1b49c535">ptr</a>, std::size_t node_size) noexcept</td></tr>
<tr class="separator:a1d5be8411adf1365b9599b9d2c49a955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf69b3a69e0e74e6e96e0311ebc3dbd0" id="r_abf69b3a69e0e74e6e96e0311ebc3dbd0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf69b3a69e0e74e6e96e0311ebc3dbd0">try_deallocate_node</a> (void *<a class="el" href="format_8h.html#adb6e274f8eb0b74b2865215e1b49c535">ptr</a>, std::size_t node_size) noexcept</td></tr>
<tr class="separator:abf69b3a69e0e74e6e96e0311ebc3dbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84c01a99510ca1243fa4e86444364d9" id="r_ab84c01a99510ca1243fa4e86444364d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab84c01a99510ca1243fa4e86444364d9">deallocate_array</a> (void *<a class="el" href="format_8h.html#adb6e274f8eb0b74b2865215e1b49c535">ptr</a>, std::size_t count, std::size_t node_size) noexcept</td></tr>
<tr class="separator:ab84c01a99510ca1243fa4e86444364d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e28f862458976bed915f5a7cc23fb3" id="r_a86e28f862458976bed915f5a7cc23fb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86e28f862458976bed915f5a7cc23fb3">try_deallocate_array</a> (void *<a class="el" href="format_8h.html#adb6e274f8eb0b74b2865215e1b49c535">ptr</a>, std::size_t count, std::size_t node_size) noexcept</td></tr>
<tr class="separator:a86e28f862458976bed915f5a7cc23fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ea58980e773578acd0f8108eedf53a" id="r_a73ea58980e773578acd0f8108eedf53a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73ea58980e773578acd0f8108eedf53a">reserve</a> (std::size_t node_size, std::size_t capacity)</td></tr>
<tr class="separator:a73ea58980e773578acd0f8108eedf53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ef0aeec59076e5bcd42f6a31a7db44" id="r_ae6ef0aeec59076e5bcd42f6a31a7db44"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6ef0aeec59076e5bcd42f6a31a7db44">max_node_size</a> () const noexcept</td></tr>
<tr class="separator:ae6ef0aeec59076e5bcd42f6a31a7db44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2ed774fa30c56bfc6d6f805829a514" id="r_abe2ed774fa30c56bfc6d6f805829a514"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe2ed774fa30c56bfc6d6f805829a514">pool_capacity_left</a> (std::size_t node_size) const noexcept</td></tr>
<tr class="separator:abe2ed774fa30c56bfc6d6f805829a514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd67d1fab2d8ddef380fda19e66f99e" id="r_a3dd67d1fab2d8ddef380fda19e66f99e"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3dd67d1fab2d8ddef380fda19e66f99e">capacity_left</a> () const noexcept</td></tr>
<tr class="separator:a3dd67d1fab2d8ddef380fda19e66f99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c65295efa2135390cce701bfab4d8d7" id="r_a0c65295efa2135390cce701bfab4d8d7"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c65295efa2135390cce701bfab4d8d7">next_capacity</a> () const noexcept</td></tr>
<tr class="separator:a0c65295efa2135390cce701bfab4d8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4692140d6c9bcfd2a39d4a5416d179" id="r_a5d4692140d6c9bcfd2a39d4a5416d179"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3faae02a1d2c0e38cf9f31702d5da3c7">allocator_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d4692140d6c9bcfd2a39d4a5416d179">get_allocator</a> () noexcept</td></tr>
<tr class="separator:a5d4692140d6c9bcfd2a39d4a5416d179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a068f60ccda0505ac3723015596c048e6" id="r_a068f60ccda0505ac3723015596c048e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a068f60ccda0505ac3723015596c048e6">memory_pool_collection</a> (<a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a068f60ccda0505ac3723015596c048e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fcf36058c9cbe205fd28f56b88531b9" id="r_a6fcf36058c9cbe205fd28f56b88531b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fcf36058c9cbe205fd28f56b88531b9">operator=</a> (<a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a6fcf36058c9cbe205fd28f56b88531b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class PoolType, class BucketDistribution, class BlockOrRawAllocator = default_allocator&gt;<br />
class wpi::memory::memory_pool_collection&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt;</div><p>A stateful RawAllocator that behaves as a collection of multiple <a class="el" href="classwpi_1_1memory_1_1memory__pool.html">memory_pool</a> objects. </p>
<p>It maintains a list of multiple free lists, whose types are controlled via the <code>PoolType</code> tags defined in <a class="el" href="memory__pool__type_8hpp.html">memory_pool_type.hpp</a>, each of a different size as defined in the <code>BucketDistribution</code> (<a class="el" href="structwpi_1_1memory_1_1identity__buckets.html">identity_buckets</a> or <a class="el" href="structwpi_1_1memory_1_1log2__buckets.html">log2_buckets</a>). Allocating a node of given size will use the appropriate free list.<br  />
 This allocator is ideal for node allocations in any order but with a predefined set of sizes, not only one size like <a class="el" href="classwpi_1_1memory_1_1memory__pool.html">memory_pool</a>. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3faae02a1d2c0e38cf9f31702d5da3c7" name="a3faae02a1d2c0e38cf9f31702d5da3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3faae02a1d2c0e38cf9f31702d5da3c7">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PoolType , class BucketDistribution , class BlockOrRawAllocator  = default_allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">wpi::memory::memory_pool_collection</a>&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt;::allocator_type = <a class="el" href="group__memory__core.html#ga2c98b0ef7658d9beda86fa166f4c02fb">make_block_allocator_t</a>&lt;BlockOrRawAllocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a23b065b24b1ac024bb7d3894ecf5561e" name="a23b065b24b1ac024bb7d3894ecf5561e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b065b24b1ac024bb7d3894ecf5561e">&#9670;&#160;</a></span>bucket_distribution</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PoolType , class BucketDistribution , class BlockOrRawAllocator  = default_allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">wpi::memory::memory_pool_collection</a>&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt;::bucket_distribution = BucketDistribution</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7454dbe692e2ab670cae86f0cfbe3e97" name="a7454dbe692e2ab670cae86f0cfbe3e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7454dbe692e2ab670cae86f0cfbe3e97">&#9670;&#160;</a></span>pool_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PoolType , class BucketDistribution , class BlockOrRawAllocator  = default_allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">wpi::memory::memory_pool_collection</a>&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt;::pool_type = PoolType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a00a9beecea3a4e2f30741833823befd4" name="a00a9beecea3a4e2f30741833823befd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a9beecea3a4e2f30741833823befd4">&#9670;&#160;</a></span>memory_pool_collection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PoolType , class BucketDistribution , class BlockOrRawAllocator  = default_allocator&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">wpi::memory::memory_pool_collection</a>&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt;::memory_pool_collection </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_node_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>block_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Creates it by giving it the maximum node size it should be able to allocate, the size of the initial memory block and other constructor arguments for the BlockAllocator. The <code>BucketDistribution</code> controls how many free lists are created, but unlike in <a class="el" href="classwpi_1_1memory_1_1memory__pool.html">memory_pool</a> all free lists are initially empty and the first memory block queued. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd><code>block_size</code> must be non-zero and <code>max_node_size</code> must be a valid node size and smaller than <code>block_size</code> divided by the number of pools. </dd></dl>

</div>
</div>
<a id="abaa1b8df2730209880964e4d0003f2d6" name="abaa1b8df2730209880964e4d0003f2d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa1b8df2730209880964e4d0003f2d6">&#9670;&#160;</a></span>~memory_pool_collection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PoolType , class BucketDistribution , class BlockOrRawAllocator  = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">wpi::memory::memory_pool_collection</a>&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt;::~<a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Destroys the <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a> by returning all memory blocks, regardless of properly deallocated back to the BlockAllocator. </dd></dl>

</div>
</div>
<a id="a068f60ccda0505ac3723015596c048e6" name="a068f60ccda0505ac3723015596c048e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068f60ccda0505ac3723015596c048e6">&#9670;&#160;</a></span>memory_pool_collection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PoolType , class BucketDistribution , class BlockOrRawAllocator  = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">wpi::memory::memory_pool_collection</a>&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt;::memory_pool_collection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a>&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Moving a <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a> object transfers ownership over the free lists, i.e. the moved from pool is completely empty and the new one has all its memory. That means that it is not allowed to call <a class="el" href="#a1d5be8411adf1365b9599b9d2c49a955">deallocate_node()</a> on a moved-from allocator even when passing it memory that was previously allocated by this object. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7947efd817b6c5caa21969dfbae5a741" name="a7947efd817b6c5caa21969dfbae5a741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7947efd817b6c5caa21969dfbae5a741">&#9670;&#160;</a></span>allocate_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PoolType , class BucketDistribution , class BlockOrRawAllocator  = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">wpi::memory::memory_pool_collection</a>&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt;::allocate_array </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>node_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Allocates an array of nodes by searching for <code>n</code> continuous nodes on the appropriate free list and removing them. Depending on the <code>PoolType</code> this can be a slow operation or not allowed at all. This can sometimes lead to a growth on the free list, even if technically there is enough continuous memory on the free list. Otherwise has the same behavior as <a class="el" href="#a759828ff5eea5c9a6c859b74f1ab27df">allocate_node()</a>. </dd></dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>An array of <code>n</code> nodes of size <code>node_size</code> suitable aligned. </dd></dl>
<dl class="section user"><dt><em>Throws:</em></dt><dd>Anything thrown by the used BlockAllocator's allocation function if a growth is needed, or a <a class="el" href="classwpi_1_1memory_1_1bad__allocation__size.html">bad_allocation_size</a> exception. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd><code>count</code> must be valid array count and <code>node_size</code> must be valid node size. </dd></dl>

</div>
</div>
<a id="a759828ff5eea5c9a6c859b74f1ab27df" name="a759828ff5eea5c9a6c859b74f1ab27df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759828ff5eea5c9a6c859b74f1ab27df">&#9670;&#160;</a></span>allocate_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PoolType , class BucketDistribution , class BlockOrRawAllocator  = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">wpi::memory::memory_pool_collection</a>&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt;::allocate_node </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>node_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Allocates a node of given size. It first finds the appropriate free list as defined in the <code>BucketDistribution</code>. If it is empty, it will use an implementation defined amount of memory from the arena and inserts it in it. If the arena is empty too, it will request a new memory block from the BlockAllocator of size <a class="el" href="#a0c65295efa2135390cce701bfab4d8d7">next_capacity()</a> and puts part of it onto this free list. Then it removes a node from it. </dd></dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>A node of given size suitable aligned, i.e. suitable for any type where <code>sizeof(T) &lt; node_size</code>. </dd></dl>
<dl class="section user"><dt><em>Throws:</em></dt><dd>Anything thrown by the BlockAllocator if a growth is needed or a <a class="el" href="classwpi_1_1memory_1_1bad__node__size.html">bad_node_size</a> exception if the node size is too big. </dd></dl>

</div>
</div>
<a id="a3dd67d1fab2d8ddef380fda19e66f99e" name="a3dd67d1fab2d8ddef380fda19e66f99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd67d1fab2d8ddef380fda19e66f99e">&#9670;&#160;</a></span>capacity_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PoolType , class BucketDistribution , class BlockOrRawAllocator  = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">wpi::memory::memory_pool_collection</a>&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt;::capacity_left </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>The amount of memory available in the arena not inside the free lists. This is the number of bytes that can be inserted into the free lists without requesting more memory from the BlockAllocator. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Array allocations may lead to a growth even if the capacity is big enough. </dd></dl>

</div>
</div>
<a id="ab84c01a99510ca1243fa4e86444364d9" name="ab84c01a99510ca1243fa4e86444364d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84c01a99510ca1243fa4e86444364d9">&#9670;&#160;</a></span>deallocate_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PoolType , class BucketDistribution , class BlockOrRawAllocator  = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">wpi::memory::memory_pool_collection</a>&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt;::deallocate_array </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>node_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Deallocates an array by putting it back onto the free list. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd><code>ptr</code> must be a result from a previous call to <a class="el" href="#a7947efd817b6c5caa21969dfbae5a741">allocate_array()</a> with the same sizes on the same free list, i.e. either this allocator object or a new object created by moving this to it. </dd></dl>

</div>
</div>
<a id="a1d5be8411adf1365b9599b9d2c49a955" name="a1d5be8411adf1365b9599b9d2c49a955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5be8411adf1365b9599b9d2c49a955">&#9670;&#160;</a></span>deallocate_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PoolType , class BucketDistribution , class BlockOrRawAllocator  = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">wpi::memory::memory_pool_collection</a>&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt;::deallocate_node </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>node_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Deallocates a node by putting it back onto the appropriate free list. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd><code>ptr</code> must be a result from a previous call to <a class="el" href="#a759828ff5eea5c9a6c859b74f1ab27df">allocate_node()</a> with the same size on the same free list, i.e. either this allocator object or a new object created by moving this to it. </dd></dl>

</div>
</div>
<a id="a5d4692140d6c9bcfd2a39d4a5416d179" name="a5d4692140d6c9bcfd2a39d4a5416d179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4692140d6c9bcfd2a39d4a5416d179">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PoolType , class BucketDistribution , class BlockOrRawAllocator  = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3faae02a1d2c0e38cf9f31702d5da3c7">allocator_type</a> &amp; <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">wpi::memory::memory_pool_collection</a>&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>A reference to the BlockAllocator used for managing the arena. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd>It is undefined behavior to move this allocator out into another object. </dd></dl>

</div>
</div>
<a id="ae6ef0aeec59076e5bcd42f6a31a7db44" name="ae6ef0aeec59076e5bcd42f6a31a7db44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ef0aeec59076e5bcd42f6a31a7db44">&#9670;&#160;</a></span>max_node_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PoolType , class BucketDistribution , class BlockOrRawAllocator  = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">wpi::memory::memory_pool_collection</a>&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt;::max_node_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>The maximum node size for which is a free list. This is the value passed to it in the constructor. </dd></dl>

</div>
</div>
<a id="a0c65295efa2135390cce701bfab4d8d7" name="a0c65295efa2135390cce701bfab4d8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c65295efa2135390cce701bfab4d8d7">&#9670;&#160;</a></span>next_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PoolType , class BucketDistribution , class BlockOrRawAllocator  = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">wpi::memory::memory_pool_collection</a>&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt;::next_capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>The size of the next memory block after <a class="el" href="#a3dd67d1fab2d8ddef380fda19e66f99e">capacity_left()</a> arena grows. This is the amount of memory that can be distributed in the pools. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the <code>PoolType</code> is <a class="el" href="structwpi_1_1memory_1_1small__node__pool.html">small_node_pool</a>, the exact usable memory is lower than that. </dd></dl>

</div>
</div>
<a id="a6fcf36058c9cbe205fd28f56b88531b9" name="a6fcf36058c9cbe205fd28f56b88531b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fcf36058c9cbe205fd28f56b88531b9">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PoolType , class BucketDistribution , class BlockOrRawAllocator  = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a> &amp; <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">wpi::memory::memory_pool_collection</a>&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a>&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abe2ed774fa30c56bfc6d6f805829a514" name="abe2ed774fa30c56bfc6d6f805829a514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2ed774fa30c56bfc6d6f805829a514">&#9670;&#160;</a></span>pool_capacity_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PoolType , class BucketDistribution , class BlockOrRawAllocator  = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">wpi::memory::memory_pool_collection</a>&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt;::pool_capacity_left </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>node_size</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>The amount of nodes available in the free list for nodes of given size as defined over the <code>BucketDistribution</code>. This is the number of nodes that can be allocated without the free list requesting more memory from the arena. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Array allocations may lead to a growth even if the capacity_left is big enough. </dd></dl>

</div>
</div>
<a id="a73ea58980e773578acd0f8108eedf53a" name="a73ea58980e773578acd0f8108eedf53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ea58980e773578acd0f8108eedf53a">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PoolType , class BucketDistribution , class BlockOrRawAllocator  = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">wpi::memory::memory_pool_collection</a>&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>node_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Inserts more memory on the free list for nodes of given size. It will try to put <code>capacity_left</code> bytes from the arena onto the free list defined over the <code>BucketDistribution</code>, if the arena is empty, a new memory block is requested from the BlockAllocator and it will be used. </dd></dl>
<dl class="section user"><dt><em>Throws:</em></dt><dd>Anything thrown by the BlockAllocator if a growth is needed. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd><code>node_size</code> must be valid node size less than or equal to <a class="el" href="#ae6ef0aeec59076e5bcd42f6a31a7db44">max_node_size()</a>, <code>capacity_left</code> must be less than <a class="el" href="#a0c65295efa2135390cce701bfab4d8d7">next_capacity()</a>. </dd></dl>

</div>
</div>
<a id="ab5c3bbd6d7a79d1ac99017fea40dd3ad" name="ab5c3bbd6d7a79d1ac99017fea40dd3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c3bbd6d7a79d1ac99017fea40dd3ad">&#9670;&#160;</a></span>try_allocate_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PoolType , class BucketDistribution , class BlockOrRawAllocator  = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">wpi::memory::memory_pool_collection</a>&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt;::try_allocate_array </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>node_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Allocates a array of given size. It is similar to <a class="el" href="#a759828ff5eea5c9a6c859b74f1ab27df">allocate_node()</a> but will return <code>nullptr</code> on any failure, instead of growing the arnea and possibly throwing. </dd></dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>A array of given size suitable aligned or <code>nullptr</code> in case of failure. </dd></dl>

</div>
</div>
<a id="ae44e58c37889e35029004d2fbd412157" name="ae44e58c37889e35029004d2fbd412157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44e58c37889e35029004d2fbd412157">&#9670;&#160;</a></span>try_allocate_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PoolType , class BucketDistribution , class BlockOrRawAllocator  = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">wpi::memory::memory_pool_collection</a>&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt;::try_allocate_node </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>node_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Allocates a node of given size. It is similar to <a class="el" href="#a759828ff5eea5c9a6c859b74f1ab27df">allocate_node()</a> but will return <code>nullptr</code> on any failure, instead of growing the arnea and possibly throwing. </dd></dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>A node of given size suitable aligned or <code>nullptr</code> in case of failure. </dd></dl>

</div>
</div>
<a id="a86e28f862458976bed915f5a7cc23fb3" name="a86e28f862458976bed915f5a7cc23fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e28f862458976bed915f5a7cc23fb3">&#9670;&#160;</a></span>try_deallocate_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PoolType , class BucketDistribution , class BlockOrRawAllocator  = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">wpi::memory::memory_pool_collection</a>&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt;::try_deallocate_array </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>node_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Deallocates a array similar to <a class="el" href="#ab84c01a99510ca1243fa4e86444364d9">deallocate_array()</a>. But it checks if it can deallocate this memory. </dd></dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd><code>true</code> if the array could be deallocated, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="abf69b3a69e0e74e6e96e0311ebc3dbd0" name="abf69b3a69e0e74e6e96e0311ebc3dbd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf69b3a69e0e74e6e96e0311ebc3dbd0">&#9670;&#160;</a></span>try_deallocate_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PoolType , class BucketDistribution , class BlockOrRawAllocator  = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">wpi::memory::memory_pool_collection</a>&lt; PoolType, BucketDistribution, BlockOrRawAllocator &gt;::try_deallocate_node </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>node_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Deallocates a node similar to <a class="el" href="#a1d5be8411adf1365b9599b9d2c49a955">deallocate_node()</a>. But it checks if it can deallocate this memory. </dd></dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd><code>true</code> if the node could be deallocated, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/allwpilib/allwpilib/wpiutil/src/main/native/thirdparty/memory/include/wpi/memory/<a class="el" href="memory__pool__collection_8hpp_source.html">memory_pool_collection.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacewpi.html">wpi</a></li><li class="navelem"><a class="el" href="namespacewpi_1_1memory.html">memory</a></li><li class="navelem"><a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a></li>
    <li class="footer">Generated on Thu Oct 24 2024 04:48:57 for WPILibC++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
