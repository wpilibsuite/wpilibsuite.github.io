<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: wpi Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="wpilib-128.png"/></td>
  <td id="projectalign">
   <div id="projectname">WPILibC++<span id="projectnumber">&#160;2025.1.1-beta-1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacewpi.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">wpi Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Foonathan namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1adl__detail.html">adl_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1detail__expected.html">detail_expected</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1details.html">details</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1hashing.html">hashing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1impl.html">impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1java.html">java</a></td></tr>
<tr class="memdesc:namespacewpi_1_1java"><td class="mdescLeft">&#160;</td><td class="mdescRight">Java Native Interface (JNI) utility functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1literals.html">literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1log.html">log</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1math.html">math</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory.html">memory</a></td></tr>
<tr class="memdesc:namespacewpi_1_1memory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1pointer__union__detail.html">pointer_union_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1sig.html">sig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1structparser.html">structparser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1support.html">support</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1sys.html">sys</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1uv.html">uv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1add__const__past__pointer.html">add_const_past_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a pointer to X, return a pointer to const X.  <a href="structwpi_1_1add__const__past__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1add__const__past__pointer_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer__v_3_01_t_01_4_01_4_01_4.html">add_const_past_pointer&lt; T, std::enable_if_t&lt; std::is_pointer_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1add__lvalue__reference__if__not__pointer.html">add_lvalue_reference_if_not_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a pointer, just return it. If it is not, return T&amp;.  <a href="structwpi_1_1add__lvalue__reference__if__not__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1add__lvalue__reference__if__not__pointer_3_01_t_00_01std_1_1enable__if__t_3_01std_19f98510cd772f33187d5abbb107fec88.html">add_lvalue_reference_if_not_pointer&lt; T, std::enable_if_t&lt; std::is_pointer_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_aligned_char_array_union.html">AlignedCharArrayUnion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A suitably aligned and sized character array member which can hold elements of any type.  <a href="structwpi_1_1_aligned_char_array_union.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_allocator_base.html">AllocatorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP base class providing obvious overloads for the core <code><a class="el" href="classwpi_1_1_allocator_base.html#a6240cd736c1f584d88fc7b7f0d747a2e" title="Allocate Size bytes of Alignment aligned memory.">Allocate()</a></code> methods of LLVM-style allocators.  <a href="classwpi_1_1_allocator_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_argument.html">Argument</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_argument_parser.html">ArgumentParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a wrapper around std::array that does compile time size checking.  <a href="classwpi_1_1array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1bad__expected__access.html">bad_expected_access</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1buffer__ostream.html">buffer_ostream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1buffer__unique__ostream.html">buffer_unique_ostream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_calculate_small_vector_default_inlined_elements.html">CalculateSmallVectorDefaultInlinedElements</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for calculating the default number of inline elements for <code><a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a>&lt;T&gt;</code>.  <a href="structwpi_1_1_calculate_small_vector_default_inlined_elements.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_callback_listener_data.html">CallbackListenerData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_callback_manager.html">CallbackManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_callback_thread.html">CallbackThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1cast__convert__val.html">cast_convert_val</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1cast__convert__val_3_01_to_00_01_from_ty_01_5_00_01_from_ty_01_5_01_4.html">cast_convert_val&lt; To, FromTy *, FromTy * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1cast__convert__val_3_01_to_00_01_from_ty_00_01_from_ty_01_4.html">cast_convert_val&lt; To, FromTy, FromTy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1cast__retty.html">cast_retty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1cast__retty__impl.html">cast_retty_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1cast__retty__impl_3_01_to_00_01const_01_from_01_5_01_4.html">cast_retty_impl&lt; To, const From * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1cast__retty__impl_3_01_to_00_01const_01_from_01_5const_01_4.html">cast_retty_impl&lt; To, const From *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1cast__retty__impl_3_01_to_00_01const_01_from_01_4.html">cast_retty_impl&lt; To, const From &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1cast__retty__impl_3_01_to_00_01_from_01_5_01_4.html">cast_retty_impl&lt; To, From * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1cast__retty__impl_3_01_to_00_01std_1_1unique__ptr_3_01_from_01_4_01_4.html">cast_retty_impl&lt; To, std::unique_ptr&lt; From &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1cast__retty__wrap.html">cast_retty_wrap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1cast__retty__wrap_3_01_to_00_01_from_ty_00_01_from_ty_01_4.html">cast_retty_wrap&lt; To, FromTy, FromTy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_cast_info.html">CastInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct provides a method for customizing the way a cast is performed.  <a href="structwpi_1_1_cast_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_cast_info_3_01_to_00_01const_01_pointer_union_3_01_p_ts_8_8_8_01_4_01_4.html">CastInfo&lt; To, const PointerUnion&lt; PTs... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_cast_info_3_01_to_00_01_from_00_01std_1_1enable__if__t_3_9is__simple__type_3_01_from_01_4_1_1value_01_4_01_4.html">CastInfo&lt; To, From, std::enable_if_t&lt;!is_simple_type&lt; From &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct provides an overload for <a class="el" href="structwpi_1_1_cast_info.html" title="This struct provides a method for customizing the way a cast is performed.">CastInfo</a> where From has <a class="el" href="structwpi_1_1simplify__type.html" title="Define a template that can be specialized by smart pointers to reflect the fact that they are automat...">simplify_type</a> defined.  <a href="structwpi_1_1_cast_info_3_01_to_00_01_from_00_01std_1_1enable__if__t_3_9is__simple__type_3_01_from_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_cast_info_3_01_to_00_01_pointer_union_3_01_p_ts_8_8_8_01_4_01_4.html">CastInfo&lt; To, PointerUnion&lt; PTs... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_cast_info_3_01_to_00_01std_1_1optional_3_01_from_01_4_01_4.html">CastInfo&lt; To, std::optional&lt; From &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a <a class="el" href="structwpi_1_1_cast_info.html" title="This struct provides a method for customizing the way a cast is performed.">CastInfo</a> specialized for std::optional&lt;From&gt;.  <a href="structwpi_1_1_cast_info_3_01_to_00_01std_1_1optional_3_01_from_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_cast_info_3_01_to_00_01std_1_1unique__ptr_3_01_from_01_4_01_4.html">CastInfo&lt; To, std::unique_ptr&lt; From &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a <a class="el" href="structwpi_1_1_cast_info.html" title="This struct provides a method for customizing the way a cast is performed.">CastInfo</a> specialized for std::unique_ptr.  <a href="structwpi_1_1_cast_info_3_01_to_00_01std_1_1unique__ptr_3_01_from_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_cast_info_pointer_union_impl.html">CastInfoPointerUnionImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">We can't (at least, at this moment with C++14) declare <a class="el" href="structwpi_1_1_cast_info.html" title="This struct provides a method for customizing the way a cast is performed.">CastInfo</a> as a friend of <a class="el" href="classwpi_1_1_pointer_union.html" title="A discriminated union of two or more pointer types, with the discriminator in the low bit of the poin...">PointerUnion</a> like this:  <a href="structwpi_1_1_cast_info_pointer_union_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_cast_is_possible.html">CastIsPossible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct provides a way to check if a given cast is possible.  <a href="structwpi_1_1_cast_is_possible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_cast_is_possible_3_01_to_00_01_from_00_01std_1_1enable__if__t_3_01std_1_1is__base_1c214df6ffdda690d98f99a198daeb50.html">CastIsPossible&lt; To, From, std::enable_if_t&lt; std::is_base_of_v&lt; To, From &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upcasting (from derived to base) and casting from a type to itself should always be possible.  <a href="structwpi_1_1_cast_is_possible_3_01_to_00_01_from_00_01std_1_1enable__if__t_3_01std_1_1is__base_1c214df6ffdda690d98f99a198daeb50.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_cast_is_possible_3_01_to_00_01std_1_1optional_3_01_from_01_4_01_4.html">CastIsPossible&lt; To, std::optional&lt; From &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1circular__buffer.html">circular_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple circular buffer so we don't need to "bucket brigade" copy old values.  <a href="classwpi_1_1circular__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1const__pointer__or__const__ref.html">const_pointer_or_const_ref</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1const__pointer__or__const__ref_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer__v_3_01_t_01_4_01_4_01_4.html">const_pointer_or_const_ref&lt; T, std::enable_if_t&lt; std::is_pointer_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_const_stripping_forwarding_cast.html">ConstStrippingForwardingCast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a cast trait that strips <code>const</code> from types to make it easier to implement a const-version of a non-const cast.  <a href="structwpi_1_1_const_stripping_forwarding_cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1ct__string.html">ct_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed length string (array of character) for compile time use.  <a href="structwpi_1_1ct__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_debug_epoch_base.html">DebugEpochBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for data structure classes wishing to make iterators ("handles") pointing into themselves fail-fast.  <a href="classwpi_1_1_debug_epoch_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_default_do_cast_if_possible.html">DefaultDoCastIfPossible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This cast trait just provides the default implementation of doCastIfPossible to make <a class="el" href="structwpi_1_1_cast_info.html" title="This struct provides a method for customizing the way a cast is performed.">CastInfo</a> specializations more declarative.  <a href="structwpi_1_1_default_do_cast_if_possible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_dense_map.html">DenseMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_dense_map_base.html">DenseMapBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info.html">DenseMapInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An information struct used to provide <a class="el" href="classwpi_1_1_dense_map.html">DenseMap</a> with the various necessary components for a given value type <code>T</code>.  <a href="structwpi_1_1_dense_map_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01char_01_4.html">DenseMapInfo&lt; char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01hash__code_00_01void_01_4.html">DenseMapInfo&lt; hash_code, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01int_01_4.html">DenseMapInfo&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01long_01_4.html">DenseMapInfo&lt; long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01long_01long_01_4.html">DenseMapInfo&lt; long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01_pointer_int_pair_3_01_pointer_ty_00_01_int_bits_00_01_int_type_01_4_00_01void_01_4.html">DenseMapInfo&lt; PointerIntPair&lt; PointerTy, IntBits, IntType &gt;, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01_pointer_union_3_01_p_ts_8_8_8_01_4_01_4.html">DenseMapInfo&lt; PointerUnion&lt; PTs... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01short_01_4.html">DenseMapInfo&lt; short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01std_1_1pair_3_01_t_00_01_u_01_4_01_4.html">DenseMapInfo&lt; std::pair&lt; T, U &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01std_1_1tuple_3_01_ts_8_8_8_01_4_01_4.html">DenseMapInfo&lt; std::tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01std_1_1variant_3_01_ts_8_8_8_01_4_01_4.html">DenseMapInfo&lt; std::variant&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01_t_01_5_01_4.html">DenseMapInfo&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01unsigned_01_4.html">DenseMapInfo&lt; unsigned &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01unsigned_01char_01_4.html">DenseMapInfo&lt; unsigned char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01unsigned_01long_01_4.html">DenseMapInfo&lt; unsigned long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01unsigned_01long_01long_01_4.html">DenseMapInfo&lt; unsigned long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_dense_map_info_3_01unsigned_01short_01_4.html">DenseMapInfo&lt; unsigned short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_dense_map_iterator.html">DenseMapIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_ds_client.html">DsClient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_dynamic_struct.html">DynamicStruct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic (run-time) read-only access to a serialized raw struct.  <a href="classwpi_1_1_dynamic_struct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_dynamic_struct_object.html">DynamicStructObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic (run-time) mutable access to a serialized raw struct, with internal data storage.  <a href="classwpi_1_1_dynamic_struct_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1empty__array__t.html">empty_array_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_event.html">Event</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An atomic signaling event for synchronization.  <a href="classwpi_1_1_event.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_event_loop_runner.html">EventLoopRunner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes an event loop on a separate thread.  <a href="classwpi_1_1_event_loop_runner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_event_vector.html">EventVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1expected.html">expected</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <code>expected&lt;T, E&gt;</code> object is an object that contains the storage for another object and manages the lifetime of this contained object <code>T</code>.  <a href="classwpi_1_1expected.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1explicitly__convertible.html">explicitly_convertible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1explicitly__convertible_3_01_from_00_01_to_00_01std_1_1void__t_3_01decltype_07stati8d38664c660ad9d857b68ee304dd14a8.html">explicitly_convertible&lt; From, To, std::void_t&lt; decltype(static_cast&lt; To &gt;(std::declval&lt; std::add_rvalue_reference_t&lt; From &gt; &gt;()))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_fast_queue.html">FastQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_file_logger.html">FileLogger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class version of <code>tail -f</code>, otherwise known as <code>tail -f</code> at home.  <a href="classwpi_1_1_file_logger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_first_index_of_type.html">FirstIndexOfType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first index where a type appears in a list of types.  <a href="structwpi_1_1_first_index_of_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_first_index_of_type_3_01_t_00_01_t_00_01_us_8_8_8_01_4.html">FirstIndexOfType&lt; T, T, Us... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_first_index_of_type_3_01_t_00_01_u_00_01_us_8_8_8_01_4.html">FirstIndexOfType&lt; T, U, Us... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_forward_to_pointer_cast.html">ForwardToPointerCast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a cast trait that uses a defined pointer to pointer cast as a base for reference-to-reference casts.  <a href="structwpi_1_1_forward_to_pointer_cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1function__ref.html">function_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An efficient, type-erasing, non-owning reference to a callable.  <a href="classwpi_1_1function__ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1function__ref_3_01_ret_07_params_8_8_8_08_4.html">function_ref&lt; Ret(Params...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_function_pointer_like_type_traits.html">FunctionPointerLikeTypeTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide suitable custom traits struct for function pointers.  <a href="structwpi_1_1_function_pointer_like_type_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1future.html">future</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight version of std::future.  <a href="classwpi_1_1future.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1future_3_01void_01_4.html">future&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit specialization for <a class="el" href="classwpi_1_1future_3_01void_01_4.html" title="Explicit specialization for future&lt;void&gt;.">future&lt;void&gt;</a>.  <a href="classwpi_1_1future_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque object representing a hash code.  <a href="classwpi_1_1hash__code.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_hash_builder.html">HashBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1http__parser.html">http_parser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1http__parser__settings.html">http_parser_settings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1http__parser__url.html">http_parser_url</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_http_connection.html">HttpConnection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_http_location.html">HttpLocation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_http_multipart_scanner.html">HttpMultipartScanner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_http_parser.html">HttpParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">HTTP protocol parser.  <a href="classwpi_1_1_http_parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_http_path.html">HttpPath</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for HTTP path matching.  <a href="classwpi_1_1_http_path.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_http_path_ref.html">HttpPathRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy reference object for a portion of a <a class="el" href="classwpi_1_1_http_path.html" title="Class for HTTP path matching.">HttpPath</a>.  <a href="classwpi_1_1_http_path_ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_http_query_map.html">HttpQueryMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map for looking up elements of the query portion of a URI.  <a href="classwpi_1_1_http_query_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_http_request.html">HttpRequest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_http_server_connection.html">HttpServerConnection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_http_web_socket_server_connection.html">HttpWebSocketServerConnection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A server-side HTTP connection that also accepts <a class="el" href="classwpi_1_1_web_socket.html" title="RFC 6455 compliant WebSocket client and server implementation.">WebSocket</a> upgrades.  <a href="classwpi_1_1_http_web_socket_server_connection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1in__place__t.html">in_place_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1interpolating__map.html">interpolating_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a table of key-value pairs with linear interpolation between values.  <a href="classwpi_1_1interpolating__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1is__integral__or__enum.html">is_integral_or_enum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction that determines whether the given type is either an integral type or an enumeration type, including enum classes.  <a href="classwpi_1_1is__integral__or__enum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1is__simple__type.html">is_simple_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1isa__impl.html">isa_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1isa__impl_3_01_to_00_01_from_00_01std_1_1enable__if__t_3_01std_1_1is__base__of__v_357c8de4dbc532e0dce3d4d07d5457cf9.html">isa_impl&lt; To, From, std::enable_if_t&lt; std::is_base_of_v&lt; To, From &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1isa__impl__cl.html">isa_impl_cl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1isa__impl__cl_3_01_to_00_01const_01_from_01_5_01_4.html">isa_impl_cl&lt; To, const From * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1isa__impl__cl_3_01_to_00_01const_01_from_01_5const_01_4.html">isa_impl_cl&lt; To, const From *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1isa__impl__cl_3_01_to_00_01const_01_from_01_4.html">isa_impl_cl&lt; To, const From &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1isa__impl__cl_3_01_to_00_01const_01std_1_1unique__ptr_3_01_from_01_4_01_4.html">isa_impl_cl&lt; To, const std::unique_ptr&lt; From &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1isa__impl__cl_3_01_to_00_01_from_01_5_01_4.html">isa_impl_cl&lt; To, From * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1isa__impl__cl_3_01_to_00_01_from_01_5const_01_4.html">isa_impl_cl&lt; To, From *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1isa__impl__wrap.html">isa_impl_wrap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1isa__impl__wrap_3_01_to_00_01_from_ty_00_01_from_ty_01_4.html">isa_impl_wrap&lt; To, FromTy, FromTy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1iterator__adaptor__base.html">iterator_adaptor_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP base class for adapting an iterator to a different type.  <a href="classwpi_1_1iterator__adaptor__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1iterator__facade__base.html">iterator_facade_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP base class which implements the entire standard iterator facade in terms of a minimal subset of the interface.  <a href="classwpi_1_1iterator__facade__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1iterator__range.html">iterator_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range adaptor for a pair of iterators.  <a href="classwpi_1_1iterator__range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_logger.html">Logger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_malloc_allocator.html">MallocAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_mapped_file_region.html">MappedFileRegion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_map_vector.html">MapVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a map that also provides access to all stored values in a deterministic order.  <a href="classwpi_1_1_map_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_memory_buffer.html">MemoryBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface provides simple read-only access to a block of memory, and provides simple methods for reading files and standard input into a memory buffer.  <a href="classwpi_1_1_memory_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_memory_buffer_ref.html">MemoryBufferRef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1monostate.html">monostate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_multicast_service_announcer.html">MulticastServiceAnnouncer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_multicast_service_resolver.html">MulticastServiceResolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_mutable_dynamic_struct.html">MutableDynamicStruct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic (run-time) mutable access to a serialized raw struct.  <a href="classwpi_1_1_mutable_dynamic_struct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_network_acceptor.html">NetworkAcceptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_network_stream.html">NetworkStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_nullable_value_cast_failed.html">NullableValueCastFailed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">All of these cast traits are meant to be implementations for useful casts that users may want to use that are outside the standard behavior.  <a href="structwpi_1_1_nullable_value_cast_failed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_null_deleter.html">NullDeleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_optional_value_cast.html">OptionalValueCast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This cast trait provides std::optional&lt;T&gt; casting.  <a href="structwpi_1_1_optional_value_cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_parallel_tcp_connector.html">ParallelTcpConnector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel TCP connector.  <a href="classwpi_1_1_parallel_tcp_connector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1pointee__iterator.html">pointee_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator type that allows iterating over the pointees via some other iterator.  <a href="structwpi_1_1pointee__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1pointer__iterator.html">pointer_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_pointer_int_pair.html">PointerIntPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_pointer_int_pair.html" title="PointerIntPair - This class implements a pair of a pointer and small integer.">PointerIntPair</a> - This class implements a pair of a pointer and small integer.  <a href="classwpi_1_1_pointer_int_pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_pointer_int_pair_info.html">PointerIntPairInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_pointer_like_type_traits.html">PointerLikeTypeTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A traits type that is used to handle pointer types and things that are just wrappers for pointers as a uniform entity.  <a href="structwpi_1_1_pointer_like_type_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_pointer_like_type_traits_3_01const_01_t_01_5_01_4.html">PointerLikeTypeTraits&lt; const T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_pointer_like_type_traits_3_01const_01_t_01_4.html">PointerLikeTypeTraits&lt; const T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_pointer_like_type_traits_3_01_pointer_int_pair_3_01_pointer_ty_00_01_int_bits_00_07d15f14192fcce1c1fa879f2bfdb0181.html">PointerLikeTypeTraits&lt; PointerIntPair&lt; PointerTy, IntBits, IntType, PtrTraits &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_pointer_like_type_traits_3_01_pointer_union_3_01_p_ts_8_8_8_01_4_01_4.html">PointerLikeTypeTraits&lt; PointerUnion&lt; PTs... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_pointer_like_type_traits_3_01_return_t_07_5_08_07_param_ts_8_8_8_08_4.html">PointerLikeTypeTraits&lt; ReturnT(*)(ParamTs...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a default specialization for function pointers that assumes 4-byte alignment.  <a href="structwpi_1_1_pointer_like_type_traits_3_01_return_t_07_5_08_07_param_ts_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_pointer_like_type_traits_3_01_t_01_5_01_4.html">PointerLikeTypeTraits&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_pointer_like_type_traits_3_01uintptr__t_01_4.html">PointerLikeTypeTraits&lt; uintptr_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_pointer_like_type_traits_3_01void_01_5_01_4.html">PointerLikeTypeTraits&lt; void * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A discriminated union of two or more pointer types, with the discriminator in the low bit of the pointer.  <a href="classwpi_1_1_pointer_union.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_port_forwarder.html">PortForwarder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward ports to another host.  <a href="classwpi_1_1_port_forwarder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1priority__queue.html">priority_queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the same as std::priority_queue with two changes:  <a href="classwpi_1_1priority__queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1promise.html">promise</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight version of std::promise.  <a href="classwpi_1_1promise.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1promise_3_01void_01_4.html">promise&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit specialization for <a class="el" href="classwpi_1_1promise_3_01void_01_4.html" title="Explicit specialization for promise&lt;void&gt;.">promise&lt;void&gt;</a>.  <a href="classwpi_1_1promise_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_promise_factory.html">PromiseFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A promise factory for lightweight futures.  <a href="classwpi_1_1_promise_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_promise_factory_3_01void_01_4.html">PromiseFactory&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit specialization for <a class="el" href="classwpi_1_1_promise_factory_3_01void_01_4.html" title="Explicit specialization for PromiseFactory&lt;void&gt;.">PromiseFactory&lt;void&gt;</a>.  <a href="classwpi_1_1_promise_factory_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf.html">Protobuf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structwpi_1_1_protobuf.html" title="Protobuf serialization template.">Protobuf</a> serialization template.  <a href="structwpi_1_1_protobuf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_arm_feedforward_01_4.html">Protobuf&lt; frc::ArmFeedforward &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_chassis_speeds_01_4.html">Protobuf&lt; frc::ChassisSpeeds &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_cubic_hermite_spline_01_4.html">Protobuf&lt; frc::CubicHermiteSpline &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_d_c_motor_01_4.html">Protobuf&lt; frc::DCMotor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_differential_drive_feedforward_01_4.html">Protobuf&lt; frc::DifferentialDriveFeedforward &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_differential_drive_kinematics_01_4.html">Protobuf&lt; frc::DifferentialDriveKinematics &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_differential_drive_wheel_positions_01_4.html">Protobuf&lt; frc::DifferentialDriveWheelPositions &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_differential_drive_wheel_speeds_01_4.html">Protobuf&lt; frc::DifferentialDriveWheelSpeeds &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_differential_drive_wheel_voltages_01_4.html">Protobuf&lt; frc::DifferentialDriveWheelVoltages &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_elevator_feedforward_01_4.html">Protobuf&lt; frc::ElevatorFeedforward &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_ellipse2d_01_4.html">Protobuf&lt; frc::Ellipse2d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_linear_system_3_01_states_00_01_inputs_00_01_outputs_01_4_01_4.html">Protobuf&lt; frc::LinearSystem&lt; States, Inputs, Outputs &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_matrixd_3_01_rows_00_01_cols_00_01_options_00_01_max_rows_00_01_max_cols_01_4_01_4.html">Protobuf&lt; frc::Matrixd&lt; Rows, Cols, Options, MaxRows, MaxCols &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_matrixd_3_01_size_00_011_00_01_options_00_01_max_rows_00_01_max_cols_01_4_01_4.html">Protobuf&lt; frc::Matrixd&lt; Size, 1, Options, MaxRows, MaxCols &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_mecanum_drive_kinematics_01_4.html">Protobuf&lt; frc::MecanumDriveKinematics &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_mecanum_drive_wheel_positions_01_4.html">Protobuf&lt; frc::MecanumDriveWheelPositions &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_mecanum_drive_wheel_speeds_01_4.html">Protobuf&lt; frc::MecanumDriveWheelSpeeds &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_pose2d_01_4.html">Protobuf&lt; frc::Pose2d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_pose3d_01_4.html">Protobuf&lt; frc::Pose3d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_quaternion_01_4.html">Protobuf&lt; frc::Quaternion &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_quintic_hermite_spline_01_4.html">Protobuf&lt; frc::QuinticHermiteSpline &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_rectangle2d_01_4.html">Protobuf&lt; frc::Rectangle2d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_rotation2d_01_4.html">Protobuf&lt; frc::Rotation2d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_rotation3d_01_4.html">Protobuf&lt; frc::Rotation3d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_simple_motor_feedforward_3_01_distance_01_4_01_4.html">Protobuf&lt; frc::SimpleMotorFeedforward&lt; Distance &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_swerve_drive_kinematics_3_01_num_modules_01_4_01_4.html">Protobuf&lt; frc::SwerveDriveKinematics&lt; NumModules &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_swerve_module_position_01_4.html">Protobuf&lt; frc::SwerveModulePosition &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_swerve_module_state_01_4.html">Protobuf&lt; frc::SwerveModuleState &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_trajectory_01_4.html">Protobuf&lt; frc::Trajectory &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_trajectory_1_1_state_01_4.html">Protobuf&lt; frc::Trajectory::State &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_transform2d_01_4.html">Protobuf&lt; frc::Transform2d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_transform3d_01_4.html">Protobuf&lt; frc::Transform3d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_translation2d_01_4.html">Protobuf&lt; frc::Translation2d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_translation3d_01_4.html">Protobuf&lt; frc::Translation3d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_twist2d_01_4.html">Protobuf&lt; frc::Twist2d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_protobuf_3_01frc_1_1_twist3d_01_4.html">Protobuf&lt; frc::Twist3d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_protobuf_message.html">ProtobufMessage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owning wrapper (ala std::unique_ptr) for google::protobuf::Message* that does not require the protobuf headers be included.  <a href="classwpi_1_1_protobuf_message.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_protobuf_message_database.html">ProtobufMessageDatabase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Database of protobuf dynamic messages.  <a href="classwpi_1_1_protobuf_message_database.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__fd__istream.html">raw_fd_istream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__fd__ostream.html">raw_fd_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> that writes to a file descriptor.  <a href="classwpi_1_1raw__fd__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__fd__stream.html">raw_fd_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> of a file for reading/writing/seeking.  <a href="classwpi_1_1raw__fd__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__istream.html">raw_istream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__mem__istream.html">raw_mem_istream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__null__ostream.html">raw_null_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> that discards all output.  <a href="classwpi_1_1raw__null__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__os__ostream.html">raw_os_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1raw__os__ostream.html" title="raw_os_ostream - A raw_ostream that writes to an std::ostream.">raw_os_ostream</a> - A <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> that writes to an std::ostream.  <a href="classwpi_1_1raw__os__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements an extremely fast bulk output stream that can <em>only</em> output to a stream.  <a href="classwpi_1_1raw__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__pwrite__stream.html">raw_pwrite_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract base class for streams implementations that also support a pwrite operation.  <a href="classwpi_1_1raw__pwrite__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__socket__istream.html">raw_socket_istream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__socket__ostream.html">raw_socket_ostream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__string__ostream.html">raw_string_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> that writes to an std::string.  <a href="classwpi_1_1raw__string__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__svector__ostream.html">raw_svector_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> that writes to an <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> or <a class="el" href="classwpi_1_1_small_string.html" title="SmallString - A SmallString is just a SmallVector with methods and accessors that make it work better...">SmallString</a>.  <a href="classwpi_1_1raw__svector__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__usvector__ostream.html">raw_usvector_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> that writes to an <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> or <a class="el" href="classwpi_1_1_small_string.html" title="SmallString - A SmallString is just a SmallVector with methods and accessors that make it work better...">SmallString</a>.  <a href="classwpi_1_1raw__usvector__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__uv__ostream.html">raw_uv_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> style output to a <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> of <a class="el" href="classwpi_1_1uv_1_1_buffer.html" title="Data buffer.">uv::Buffer</a> buffers.  <a href="classwpi_1_1raw__uv__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__uvector__ostream.html">raw_uvector_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> that writes to a vector.  <a href="classwpi_1_1raw__uvector__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1raw__vector__ostream.html">raw_vector_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> that writes to a vector.  <a href="classwpi_1_1raw__vector__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_raw_frame.html">RawFrame</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1recursive__spinlock1.html">recursive_spinlock1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A recursive spinlock mutex.  <a href="classwpi_1_1recursive__spinlock1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1recursive__spinlock2.html">recursive_spinlock2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A recursive spinlock mutex.  <a href="classwpi_1_1recursive__spinlock2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1remove__cvref.html">remove_cvref</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1rotated__span.html">rotated_span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple rotated span view.  <a href="classwpi_1_1rotated__span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_round_up_to_power_of_two.html">RoundUpToPowerOfTwo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structwpi_1_1_round_up_to_power_of_two.html" title="RoundUpToPowerOfTwo - This is a helper template that rounds N up to the next power of two (which mean...">RoundUpToPowerOfTwo</a> - This is a helper template that rounds N up to the next power of two (which means N itself if N is already a power of two).  <a href="structwpi_1_1_round_up_to_power_of_two.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_round_up_to_power_of_two_h.html">RoundUpToPowerOfTwoH</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structwpi_1_1_round_up_to_power_of_two_h.html" title="RoundUpToPowerOfTwoH - If N is not a power of two, increase it.">RoundUpToPowerOfTwoH</a> - If N is not a power of two, increase it.  <a href="structwpi_1_1_round_up_to_power_of_two_h.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_round_up_to_power_of_two_h_3_01_n_00_01false_01_4.html">RoundUpToPowerOfTwoH&lt; N, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_safe_thread.html">SafeThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_safe_thread_base.html">SafeThreadBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="classwpi_1_1_safe_thread_owner.html">SafeThreadOwner</a> threads.  <a href="classwpi_1_1_safe_thread_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_safe_thread_event.html">SafeThreadEvent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_safe_thread_owner.html">SafeThreadOwner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_same_type.html">SameType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1scope__exit.html">scope_exit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_scoped_fatal_error_handler.html">ScopedFatalErrorHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structwpi_1_1_scoped_fatal_error_handler.html" title="ScopedFatalErrorHandler - This is a simple helper class which just calls install_fatal_error_handler ...">ScopedFatalErrorHandler</a> - This is a simple helper class which just calls install_fatal_error_handler in its constructor and remove_fatal_error_handler in its destructor.  <a href="structwpi_1_1_scoped_fatal_error_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_semaphore.html">Semaphore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A semaphore for synchronization.  <a href="classwpi_1_1_semaphore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_sendable.html">Sendable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for <a class="el" href="classwpi_1_1_sendable.html" title="Interface for Sendable objects.">Sendable</a> objects.  <a href="classwpi_1_1_sendable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_sendable_builder.html">SendableBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for building <a class="el" href="classwpi_1_1_sendable.html" title="Interface for Sendable objects.">Sendable</a> dashboard representations.  <a href="classwpi_1_1_sendable_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_sendable_helper.html">SendableHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for use with objects that add themselves to <a class="el" href="classwpi_1_1_sendable_registry.html" title="The SendableRegistry class is the public interface for registering sensors and actuators for use on d...">SendableRegistry</a>.  <a href="classwpi_1_1_sendable_helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_sendable_registry.html">SendableRegistry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classwpi_1_1_sendable_registry.html" title="The SendableRegistry class is the public interface for registering sensors and actuators for use on d...">SendableRegistry</a> class is the public interface for registering sensors and actuators for use on dashboards and LiveWindow.  <a href="classwpi_1_1_sendable_registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_s_h_a1.html">SHA1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_signal_object.html">SignalObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII wrapper for signaling handles.  <a href="classwpi_1_1_signal_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1simplify__type.html">simplify_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a template that can be specialized by smart pointers to reflect the fact that they are automatically dereferenced, and are not involved with the template selection process... the default implementation is a noop.  <a href="structwpi_1_1simplify__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1simplify__type_3_01const_01_from_01_4.html">simplify_type&lt; const From &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_dense_map.html">SmallDenseMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_small_map_vector.html">SmallMapVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classwpi_1_1_map_vector.html" title="This class implements a map that also provides access to all stored values in a deterministic order.">MapVector</a> that performs no allocations if smaller than a certain size.  <a href="structwpi_1_1_small_map_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_ptr_set.html">SmallPtrSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_small_ptr_set.html" title="SmallPtrSet - This class implements a set which is optimized for holding SmallSize or less elements.">SmallPtrSet</a> - This class implements a set which is optimized for holding SmallSize or less elements.  <a href="classwpi_1_1_small_ptr_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_ptr_set_impl.html">SmallPtrSetImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A templated base class for <code><a class="el" href="classwpi_1_1_small_ptr_set.html" title="SmallPtrSet - This class implements a set which is optimized for holding SmallSize or less elements.">SmallPtrSet</a></code> which provides the typesafe interface that is common across all small sizes.  <a href="classwpi_1_1_small_ptr_set_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_ptr_set_impl_base.html">SmallPtrSetImplBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_small_ptr_set_impl_base.html" title="SmallPtrSetImplBase - This is the common code shared among all the SmallPtrSet&lt;&gt;&#39;s,...">SmallPtrSetImplBase</a> - This is the common code shared among all the SmallPtrSet&lt;&gt;'s, which is almost everything.  <a href="classwpi_1_1_small_ptr_set_impl_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_ptr_set_iterator.html">SmallPtrSetIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_small_ptr_set_iterator.html" title="SmallPtrSetIterator - This implements a const_iterator for SmallPtrSet.">SmallPtrSetIterator</a> - This implements a const_iterator for <a class="el" href="classwpi_1_1_small_ptr_set.html" title="SmallPtrSet - This class implements a set which is optimized for holding SmallSize or less elements.">SmallPtrSet</a>.  <a href="classwpi_1_1_small_ptr_set_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_ptr_set_iterator_impl.html">SmallPtrSetIteratorImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_small_ptr_set_iterator_impl.html" title="SmallPtrSetIteratorImpl - This is the common base class shared between all instances of SmallPtrSetIt...">SmallPtrSetIteratorImpl</a> - This is the common base class shared between all instances of <a class="el" href="classwpi_1_1_small_ptr_set_iterator.html" title="SmallPtrSetIterator - This implements a const_iterator for SmallPtrSet.">SmallPtrSetIterator</a>.  <a href="classwpi_1_1_small_ptr_set_iterator_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_set.html">SmallSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_small_set.html" title="SmallSet - This maintains a set of unique values, optimizing for the case when the set is small (less...">SmallSet</a> - This maintains a set of unique values, optimizing for the case when the set is small (less than N).  <a href="classwpi_1_1_small_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_set_3_01_pointee_type_01_5_00_01_n_01_4.html">SmallSet&lt; PointeeType *, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this set is of pointer values, transparently switch over to using <a class="el" href="classwpi_1_1_small_ptr_set.html" title="SmallPtrSet - This class implements a set which is optimized for holding SmallSize or less elements.">SmallPtrSet</a> for performance.  <a href="classwpi_1_1_small_set_3_01_pointee_type_01_5_00_01_n_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_set_iterator.html">SmallSetIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_small_set_iterator.html" title="SmallSetIterator - This class implements a const_iterator for SmallSet by delegating to the underlyin...">SmallSetIterator</a> - This class implements a const_iterator for <a class="el" href="classwpi_1_1_small_set.html" title="SmallSet - This maintains a set of unique values, optimizing for the case when the set is small (less...">SmallSet</a> by delegating to the underlying <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> or Set iterators.  <a href="classwpi_1_1_small_set_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_string.html">SmallString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_small_string.html" title="SmallString - A SmallString is just a SmallVector with methods and accessors that make it work better...">SmallString</a> - A <a class="el" href="classwpi_1_1_small_string.html" title="SmallString - A SmallString is just a SmallVector with methods and accessors that make it work better...">SmallString</a> is just a <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> with methods and accessors that make it work better as a string (e.g.  <a href="classwpi_1_1_small_string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_vector.html">SmallVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a 'vector' (really, a variable-sized array), optimized for the case when the array is small.  <a href="classwpi_1_1_small_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_small_vector_alignment_and_size.html">SmallVectorAlignmentAndSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Figure out the offset of the first element.  <a href="structwpi_1_1_small_vector_alignment_and_size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_vector_base.html">SmallVectorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is all the stuff common to all SmallVectors.  <a href="classwpi_1_1_small_vector_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class consists of common code factored out of the <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> class to reduce code duplication based on the <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> 'N' template parameter.  <a href="classwpi_1_1_small_vector_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_vector_memory_buffer.html">SmallVectorMemoryBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SmallVector-backed <a class="el" href="classwpi_1_1_memory_buffer.html" title="This interface provides simple read-only access to a block of memory, and provides simple methods for...">MemoryBuffer</a> instance.  <a href="classwpi_1_1_small_vector_memory_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_small_vector_storage.html">SmallVectorStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for the <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> elements.  <a href="structwpi_1_1_small_vector_storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_small_vector_storage_3_01_t_00_010_01_4.html">SmallVectorStorage&lt; T, 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">We need the storage to be properly aligned even for small-size of 0 so that the pointer math in <em><a class="el" href="classwpi_1_1_small_vector_template_common.html#a2bda554d6506dda1276c1a382a385503" title="Find the address of the first element.">SmallVectorTemplateCommon::getFirstEl()</a></em> is well-defined.  <a href="structwpi_1_1_small_vector_storage_3_01_t_00_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_vector_template_base.html">SmallVectorTemplateBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_small_vector_template_base.html" title="SmallVectorTemplateBase&lt;TriviallyCopyable = false&gt; - This is where we put method implementations that...">SmallVectorTemplateBase</a>&lt;TriviallyCopyable = false&gt; - This is where we put method implementations that are designed to work with non-trivial T's.  <a href="classwpi_1_1_small_vector_template_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_vector_template_base_3_01_t_00_01true_01_4.html">SmallVectorTemplateBase&lt; T, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_small_vector_template_base.html" title="SmallVectorTemplateBase&lt;TriviallyCopyable = false&gt; - This is where we put method implementations that...">SmallVectorTemplateBase</a>&lt;TriviallyCopyable = true&gt; - This is where we put method implementations that are designed to work with trivially copyable T's.  <a href="classwpi_1_1_small_vector_template_base_3_01_t_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_small_vector_template_common.html">SmallVectorTemplateCommon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the part of <a class="el" href="classwpi_1_1_small_vector_template_base.html" title="SmallVectorTemplateBase&lt;TriviallyCopyable = false&gt; - This is where we put method implementations that...">SmallVectorTemplateBase</a> which does not depend on whether the type T is a POD.  <a href="classwpi_1_1_small_vector_template_common.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1spinlock.html">spinlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A spinlock mutex.  <a href="classwpi_1_1spinlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1static__circular__buffer.html">static_circular_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple circular buffer so we don't need to "bucket brigade" copy old values.  <a href="classwpi_1_1static__circular__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_string_map.html">StringMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_string_map.html" title="StringMap - This is an unconventional map that is specialized for handling keys that are &quot;strings&quot;,...">StringMap</a> - This is an unconventional map that is specialized for handling keys that are "strings", which are basically ranges of bytes.  <a href="classwpi_1_1_string_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_string_map_const_iterator.html">StringMapConstIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_string_map_entry.html">StringMapEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_string_map_entry.html" title="StringMapEntry - This is used to represent one value that is inserted into a StringMap.">StringMapEntry</a> - This is used to represent one value that is inserted into a <a class="el" href="classwpi_1_1_string_map.html" title="StringMap - This is an unconventional map that is specialized for handling keys that are &quot;strings&quot;,...">StringMap</a>.  <a href="classwpi_1_1_string_map_entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_string_map_entry_base.html">StringMapEntryBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_string_map_entry_base.html" title="StringMapEntryBase - Shared base class of StringMapEntry instances.">StringMapEntryBase</a> - Shared base class of <a class="el" href="classwpi_1_1_string_map_entry.html" title="StringMapEntry - This is used to represent one value that is inserted into a StringMap.">StringMapEntry</a> instances.  <a href="classwpi_1_1_string_map_entry_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_string_map_entry_storage.html">StringMapEntryStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_string_map_entry_storage.html" title="StringMapEntryStorage - Holds the value in a StringMapEntry.">StringMapEntryStorage</a> - Holds the value in a <a class="el" href="classwpi_1_1_string_map_entry.html" title="StringMapEntry - This is used to represent one value that is inserted into a StringMap.">StringMapEntry</a>.  <a href="classwpi_1_1_string_map_entry_storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_string_map_entry_storage_3_01std_1_1nullopt__t_01_4.html">StringMapEntryStorage&lt; std::nullopt_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_string_map_impl.html">StringMapImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_string_map_impl.html" title="StringMapImpl - This is the base class of StringMap that is shared among all of its instantiations.">StringMapImpl</a> - This is the base class of <a class="el" href="classwpi_1_1_string_map.html" title="StringMap - This is an unconventional map that is specialized for handling keys that are &quot;strings&quot;,...">StringMap</a> that is shared among all of its instantiations.  <a href="classwpi_1_1_string_map_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_string_map_iterator.html">StringMapIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_string_map_iter_base.html">StringMapIterBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_string_map_key_iterator.html">StringMapKeyIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct.html">Struct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structwpi_1_1_struct.html" title="Struct serialization template.">Struct</a> serialization template.  <a href="structwpi_1_1_struct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01bool_01_4.html">Struct&lt; bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw struct support for boolean values.  <a href="structwpi_1_1_struct_3_01bool_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01double_01_4.html">Struct&lt; double &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw struct support for double values.  <a href="structwpi_1_1_struct_3_01double_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01float_01_4.html">Struct&lt; float &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw struct support for float values.  <a href="structwpi_1_1_struct_3_01float_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_arm_feedforward_01_4.html">Struct&lt; frc::ArmFeedforward &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_chassis_speeds_01_4.html">Struct&lt; frc::ChassisSpeeds &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_cubic_hermite_spline_01_4.html">Struct&lt; frc::CubicHermiteSpline &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_d_c_motor_01_4.html">Struct&lt; frc::DCMotor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_differential_drive_feedforward_01_4.html">Struct&lt; frc::DifferentialDriveFeedforward &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_differential_drive_kinematics_01_4.html">Struct&lt; frc::DifferentialDriveKinematics &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_differential_drive_wheel_positions_01_4.html">Struct&lt; frc::DifferentialDriveWheelPositions &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_differential_drive_wheel_speeds_01_4.html">Struct&lt; frc::DifferentialDriveWheelSpeeds &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_differential_drive_wheel_voltages_01_4.html">Struct&lt; frc::DifferentialDriveWheelVoltages &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_elevator_feedforward_01_4.html">Struct&lt; frc::ElevatorFeedforward &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_ellipse2d_01_4.html">Struct&lt; frc::Ellipse2d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_linear_system_3_01_states_00_01_inputs_00_01_outputs_01_4_01_4.html">Struct&lt; frc::LinearSystem&lt; States, Inputs, Outputs &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_matrixd_3_01_rows_00_01_cols_00_01_options_00_01_max_rows_00_01_max_cols_01_4_01_4.html">Struct&lt; frc::Matrixd&lt; Rows, Cols, Options, MaxRows, MaxCols &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_matrixd_3_01_size_00_011_00_01_options_00_01_max_rows_00_01_max_cols_01_4_01_4.html">Struct&lt; frc::Matrixd&lt; Size, 1, Options, MaxRows, MaxCols &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_mecanum_drive_kinematics_01_4.html">Struct&lt; frc::MecanumDriveKinematics &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_mecanum_drive_wheel_positions_01_4.html">Struct&lt; frc::MecanumDriveWheelPositions &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_mecanum_drive_wheel_speeds_01_4.html">Struct&lt; frc::MecanumDriveWheelSpeeds &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_pose2d_01_4.html">Struct&lt; frc::Pose2d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_pose3d_01_4.html">Struct&lt; frc::Pose3d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_quaternion_01_4.html">Struct&lt; frc::Quaternion &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_quintic_hermite_spline_01_4.html">Struct&lt; frc::QuinticHermiteSpline &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_rectangle2d_01_4.html">Struct&lt; frc::Rectangle2d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_rotation2d_01_4.html">Struct&lt; frc::Rotation2d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_rotation3d_01_4.html">Struct&lt; frc::Rotation3d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_simple_motor_feedforward_3_01_distance_01_4_01_4.html">Struct&lt; frc::SimpleMotorFeedforward&lt; Distance &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_swerve_drive_kinematics_3_01_num_modules_01_4_01_4.html">Struct&lt; frc::SwerveDriveKinematics&lt; NumModules &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_swerve_module_position_01_4.html">Struct&lt; frc::SwerveModulePosition &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_swerve_module_state_01_4.html">Struct&lt; frc::SwerveModuleState &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_transform2d_01_4.html">Struct&lt; frc::Transform2d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_transform3d_01_4.html">Struct&lt; frc::Transform3d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_translation2d_01_4.html">Struct&lt; frc::Translation2d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_translation3d_01_4.html">Struct&lt; frc::Translation3d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_twist2d_01_4.html">Struct&lt; frc::Twist2d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01frc_1_1_twist3d_01_4.html">Struct&lt; frc::Twist3d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01int16__t_01_4.html">Struct&lt; int16_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw struct support for int16_t values.  <a href="structwpi_1_1_struct_3_01int16__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01int32__t_01_4.html">Struct&lt; int32_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw struct support for int32_t values.  <a href="structwpi_1_1_struct_3_01int32__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01int64__t_01_4.html">Struct&lt; int64_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw struct support for int64_t values.  <a href="structwpi_1_1_struct_3_01int64__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01int8__t_01_4.html">Struct&lt; int8_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw struct support for int8_t values.  <a href="structwpi_1_1_struct_3_01int8__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01std_1_1array_3_01_t_00_01_n_01_4_00_01_i_8_8_8_01_4.html">Struct&lt; std::array&lt; T, N &gt;, I... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw struct support for fixed-size arrays of other structs.  <a href="structwpi_1_1_struct_3_01std_1_1array_3_01_t_00_01_n_01_4_00_01_i_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01uint16__t_01_4.html">Struct&lt; uint16_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw struct support for uint16_t values.  <a href="structwpi_1_1_struct_3_01uint16__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01uint32__t_01_4.html">Struct&lt; uint32_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw struct support for uint32_t values.  <a href="structwpi_1_1_struct_3_01uint32__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01uint64__t_01_4.html">Struct&lt; uint64_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw struct support for uint64_t values.  <a href="structwpi_1_1_struct_3_01uint64__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_struct_3_01uint8__t_01_4.html">Struct&lt; uint8_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw struct support for uint8_t values.  <a href="structwpi_1_1_struct_3_01uint8__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_struct_array_buffer.html">StructArrayBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_struct_descriptor.html">StructDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw struct dynamic struct descriptor.  <a href="classwpi_1_1_struct_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_struct_descriptor_database.html">StructDescriptorDatabase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Database of raw struct dynamic descriptors.  <a href="classwpi_1_1_struct_descriptor_database.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_struct_field_descriptor.html">StructFieldDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw struct dynamic field descriptor.  <a href="classwpi_1_1_struct_field_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_t_c_p_acceptor.html">TCPAcceptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_t_c_p_connector.html">TCPConnector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_t_c_p_stream.html">TCPStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_types_are_distinct.html">TypesAreDistinct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if all types in Ts are distinct.  <a href="structwpi_1_1_types_are_distinct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_types_are_distinct_3_4.html">TypesAreDistinct&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_u_d_p_client.html">UDPClient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_uid_vector.html">UidVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector which provides an integrated freelist for removal and reuse of individual elements.  <a href="classwpi_1_1_uid_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_uleb128_reader.html">Uleb128Reader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned LEB128 streaming reader.  <a href="classwpi_1_1_uleb128_reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1unexpect__t.html">unexpect_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1unexpected.html">unexpected</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1unique__function.html">unique_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1unique__function.html" title="unique_function is a type-erasing functor similar to std::function.">unique_function</a> is a type-erasing functor similar to std::function.  <a href="classwpi_1_1unique__function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1unique__function_3_01_r_07_p_8_8_8_08_01const_01_4.html">unique_function&lt; R(P...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1unique__function_3_01_r_07_p_8_8_8_08_4.html">unique_function&lt; R(P...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_unique_ptr_cast.html">UniquePtrCast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This cast trait provides std::unique_ptr casting.  <a href="structwpi_1_1_unique_ptr_cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_url_parser.html">UrlParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a URL into its constituent components.  <a href="classwpi_1_1_url_parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_value_from_pointer_cast.html">ValueFromPointerCast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This cast trait provides casting for the specific case of casting to a value-typed object from a pointer-typed object.  <a href="structwpi_1_1_value_from_pointer_cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_value_is_present.html">ValueIsPresent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structwpi_1_1_value_is_present.html" title="ValueIsPresent provides a way to check if a value is, well, present.">ValueIsPresent</a> provides a way to check if a value is, well, present.  <a href="structwpi_1_1_value_is_present.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_value_is_present_3_01std_1_1optional_3_01_t_01_4_01_4.html">ValueIsPresent&lt; std::optional&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1_value_is_present_3_01_t_00_01std_1_1enable__if__t_3_01_is_nullable_3_01_t_01_4_01_4_01_4.html">ValueIsPresent&lt; T, std::enable_if_t&lt; IsNullable&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_version_tuple.html">VersionTuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a version number in the form major[.minor[.subminor[.build]]].  <a href="classwpi_1_1_version_tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_web_socket.html">WebSocket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RFC 6455 compliant <a class="el" href="classwpi_1_1_web_socket.html" title="RFC 6455 compliant WebSocket client and server implementation.">WebSocket</a> client and server implementation.  <a href="classwpi_1_1_web_socket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_web_socket_server.html">WebSocketServer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dedicated <a class="el" href="classwpi_1_1_web_socket.html" title="RFC 6455 compliant WebSocket client and server implementation.">WebSocket</a> server.  <a href="classwpi_1_1_web_socket_server.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_web_socket_server_helper.html">WebSocketServerHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwpi_1_1_web_socket.html" title="RFC 6455 compliant WebSocket client and server implementation.">WebSocket</a> HTTP server helper.  <a href="classwpi_1_1_web_socket_server_helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_worker_thread.html">WorkerThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_worker_thread_3_01_r_07_t_8_8_8_08_4.html">WorkerThread&lt; R(T...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_writable_memory_buffer.html">WritableMemoryBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is an extension of <a class="el" href="classwpi_1_1_memory_buffer.html" title="This interface provides simple read-only access to a block of memory, and provides simple methods for...">MemoryBuffer</a>, which allows copy-on-write access to the underlying contents.  <a href="classwpi_1_1_writable_memory_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1_write_through_memory_buffer.html">WriteThroughMemoryBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is an extension of <a class="el" href="classwpi_1_1_memory_buffer.html" title="This interface provides simple read-only access to a block of memory, and provides simple methods for...">MemoryBuffer</a>, which allows write access to the underlying contents and committing those changes to the original source.  <a href="classwpi_1_1_write_through_memory_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1_decayed_derived_from.html">DecayedDerivedFrom</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1_struct_serializable.html">StructSerializable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is capable of raw struct serialization and deserialization. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1_mutable_struct_serializable.html">MutableStructSerializable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is capable of in-place raw struct deserialization. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1_has_nested_struct.html">HasNestedStruct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a struct type has nested struct declarations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1_protobuf_serializable.html">ProtobufSerializable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is capable of protobuf serialization and deserialization. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptwpi_1_1_mutable_protobuf_serializable.html">MutableProtobufSerializable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is capable of in-place protobuf deserialization. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad2f449b8813b6175c38218ad8b8996ea" id="r_ad2f449b8813b6175c38218ad8b8996ea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2f449b8813b6175c38218ad8b8996ea">mutex</a> = ::std::mutex</td></tr>
<tr class="separator:ad2f449b8813b6175c38218ad8b8996ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfebff14457dadb6a3abf2edf9d4d8b5" id="r_acfebff14457dadb6a3abf2edf9d4d8b5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfebff14457dadb6a3abf2edf9d4d8b5">recursive_mutex</a> = ::std::recursive_mutex</td></tr>
<tr class="separator:acfebff14457dadb6a3abf2edf9d4d8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e586095a24baa7bbd27dcc50251c47" id="r_a34e586095a24baa7bbd27dcc50251c47"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34e586095a24baa7bbd27dcc50251c47">condition_variable</a> = ::std::condition_variable</td></tr>
<tr class="separator:a34e586095a24baa7bbd27dcc50251c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30c1ffd4dedd4ff88adccac000e4c18" id="r_af30c1ffd4dedd4ff88adccac000e4c18"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af30c1ffd4dedd4ff88adccac000e4c18">http_data_cb</a>) (<a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *, const char *at, size_t length)</td></tr>
<tr class="separator:af30c1ffd4dedd4ff88adccac000e4c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15767624048ad142d04bc6b1eab0d646" id="r_a15767624048ad142d04bc6b1eab0d646"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15767624048ad142d04bc6b1eab0d646">http_cb</a>) (<a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *)</td></tr>
<tr class="separator:a15767624048ad142d04bc6b1eab0d646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cccdd003c725c1d8558b97727563972" id="r_a6cccdd003c725c1d8558b97727563972"><td class="memTemplParams" colspan="2">template&lt;typename WrappedIteratorT , typename T1  = std::remove_reference_t&lt;decltype(              **std::declval&lt;WrappedIteratorT&gt;())&gt;, typename T2  = std::add_pointer_t&lt;T1&gt;&gt; </td></tr>
<tr class="memitem:a6cccdd003c725c1d8558b97727563972"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6cccdd003c725c1d8558b97727563972">raw_pointer_iterator</a></td></tr>
<tr class="separator:a6cccdd003c725c1d8558b97727563972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacde1332b72e968317ed516552a07ca8" id="r_aacde1332b72e968317ed516552a07ca8"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacde1332b72e968317ed516552a07ca8">fatal_error_handler_t</a>) (void *user_data, const char *reason, bool gen_crash_diag)</td></tr>
<tr class="memdesc:aacde1332b72e968317ed516552a07ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error handler callback.  <br /></td></tr>
<tr class="separator:aacde1332b72e968317ed516552a07ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63bc458144009d9a09693c274d6001e" id="r_ab63bc458144009d9a09693c274d6001e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab63bc458144009d9a09693c274d6001e">recursive_spinlock</a> = <a class="el" href="classwpi_1_1recursive__spinlock1.html">recursive_spinlock1</a></td></tr>
<tr class="separator:ab63bc458144009d9a09693c274d6001e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31f8b5d3b4b5750e308b9486c8063cf" id="r_ab31f8b5d3b4b5750e308b9486c8063cf"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a></td></tr>
<tr class="separator:ab31f8b5d3b4b5750e308b9486c8063cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f45c50238ed154108c2d79c37d19ab" id="r_a45f45c50238ed154108c2d79c37d19ab"><td class="memItemLeft" align="right" valign="top">typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45f45c50238ed154108c2d79c37d19ab">UTF16</a></td></tr>
<tr class="separator:a45f45c50238ed154108c2d79c37d19ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bbc3b1e95b6409a042b8089d3d8c00" id="r_a37bbc3b1e95b6409a042b8089d3d8c00"><td class="memItemLeft" align="right" valign="top">typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a></td></tr>
<tr class="separator:a37bbc3b1e95b6409a042b8089d3d8c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9954615e01ad150570a0e1d4548d879" id="r_ac9954615e01ad150570a0e1d4548d879"><td class="memItemLeft" align="right" valign="top">typedef bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9954615e01ad150570a0e1d4548d879">Boolean</a></td></tr>
<tr class="separator:ac9954615e01ad150570a0e1d4548d879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f37036e786223b476f02676130eaf20" id="r_a7f37036e786223b476f02676130eaf20"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:a7f37036e786223b476f02676130eaf20"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7f37036e786223b476f02676130eaf20">EnableIfConvertibleToInputIterator</a></td></tr>
<tr class="separator:a7f37036e786223b476f02676130eaf20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba14c6ed82a2230ba7b7f9152d1e6af" id="r_a5ba14c6ed82a2230ba7b7f9152d1e6af"><td class="memTemplParams" colspan="2">template&lt;typename RangeType &gt; </td></tr>
<tr class="memitem:a5ba14c6ed82a2230ba7b7f9152d1e6af"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5ba14c6ed82a2230ba7b7f9152d1e6af">ValueTypeFromRangeType</a></td></tr>
<tr class="separator:a5ba14c6ed82a2230ba7b7f9152d1e6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ebe279c9afb4e51ea32f9d690c9561" id="r_a32ebe279c9afb4e51ea32f9d690c9561"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:a32ebe279c9afb4e51ea32f9d690c9561"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a32ebe279c9afb4e51ea32f9d690c9561">TypeAtIndex</a> = std::tuple_element_t&lt;I, std::tuple&lt;Ts...&gt;&gt;</td></tr>
<tr class="memdesc:a32ebe279c9afb4e51ea32f9d690c9561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the type at a given index in a list of types.  <br /></td></tr>
<tr class="separator:a32ebe279c9afb4e51ea32f9d690c9561"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae89a1f90a8603e399f9cc0465b0ce21e" id="r_ae89a1f90a8603e399f9cc0465b0ce21e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae89a1f90a8603e399f9cc0465b0ce21e">http_status</a> </td></tr>
<tr class="separator:ae89a1f90a8603e399f9cc0465b0ce21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3458579fc7214ea6b0411bbadf6ffcbc" id="r_a3458579fc7214ea6b0411bbadf6ffcbc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3458579fc7214ea6b0411bbadf6ffcbc">http_method</a> </td></tr>
<tr class="separator:a3458579fc7214ea6b0411bbadf6ffcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37735642db3ab741e86bf064b2ddbbd" id="r_ab37735642db3ab741e86bf064b2ddbbd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab37735642db3ab741e86bf064b2ddbbd">http_parser_type</a> { <a class="el" href="#ab37735642db3ab741e86bf064b2ddbbda83022e72aaa06928c047700a88837608">HTTP_REQUEST</a>
, <a class="el" href="#ab37735642db3ab741e86bf064b2ddbbdaa131b28da3205e7a497320d97cead4a5">HTTP_RESPONSE</a>
, <a class="el" href="#ab37735642db3ab741e86bf064b2ddbbda404d2d378af4663f27fc14676459b13b">HTTP_BOTH</a>
 }</td></tr>
<tr class="separator:ab37735642db3ab741e86bf064b2ddbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0000b45b0b55789f757f1c3d2461cb" id="r_a7b0000b45b0b55789f757f1c3d2461cb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b0000b45b0b55789f757f1c3d2461cb">flags</a> { <br />
&#160;&#160;<a class="el" href="#a7b0000b45b0b55789f757f1c3d2461cba22ea0cf0d50ecfe6b139d83ecc83d8df">F_CHUNKED</a> = 1 &lt;&lt; 0
, <a class="el" href="#a7b0000b45b0b55789f757f1c3d2461cbaf14c04cd6f0125dbeceaf61b94fb1352">F_CONNECTION_KEEP_ALIVE</a> = 1 &lt;&lt; 1
, <a class="el" href="#a7b0000b45b0b55789f757f1c3d2461cba78a204621316260f385954c3bb0fff0f">F_CONNECTION_CLOSE</a> = 1 &lt;&lt; 2
, <a class="el" href="#a7b0000b45b0b55789f757f1c3d2461cba608843554e95e8438ea48d18e8034043">F_CONNECTION_UPGRADE</a> = 1 &lt;&lt; 3
, <br />
&#160;&#160;<a class="el" href="#a7b0000b45b0b55789f757f1c3d2461cba819c3d4c4621c49323e997ef186e81cb">F_TRAILING</a> = 1 &lt;&lt; 4
, <a class="el" href="#a7b0000b45b0b55789f757f1c3d2461cba91bd0dc716ef59be0726782a89b3fe42">F_UPGRADE</a> = 1 &lt;&lt; 5
, <a class="el" href="#a7b0000b45b0b55789f757f1c3d2461cba0741b53c2752382134a5c1548c4af772">F_SKIPBODY</a> = 1 &lt;&lt; 6
, <a class="el" href="#a7b0000b45b0b55789f757f1c3d2461cba63d30d0cca722219ca11f554a1adf1df">F_CONTENTLENGTH</a> = 1 &lt;&lt; 7
<br />
 }</td></tr>
<tr class="separator:a7b0000b45b0b55789f757f1c3d2461cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e56bd09798339ac4f86d36eb8ecea0b" id="r_a0e56bd09798339ac4f86d36eb8ecea0b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e56bd09798339ac4f86d36eb8ecea0b">http_errno</a> </td></tr>
<tr class="separator:a0e56bd09798339ac4f86d36eb8ecea0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a0b479c88b876facf868f0c7a6b598" id="r_af3a0b479c88b876facf868f0c7a6b598"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3a0b479c88b876facf868f0c7a6b598">http_parser_url_fields</a> { <br />
&#160;&#160;<a class="el" href="#af3a0b479c88b876facf868f0c7a6b598a0fc67d54599dc5b503765fb0792e2a54">UF_SCHEMA</a> = 0
, <a class="el" href="#af3a0b479c88b876facf868f0c7a6b598af8e30e235a6bdffaac9f1945ce205851">UF_HOST</a> = 1
, <a class="el" href="#af3a0b479c88b876facf868f0c7a6b598afb2e77eaed47bcfcfee307b2e1aff53a">UF_PORT</a> = 2
, <a class="el" href="#af3a0b479c88b876facf868f0c7a6b598a45e701521a7ea4616989a7ed22cd0ae1">UF_PATH</a> = 3
, <br />
&#160;&#160;<a class="el" href="#af3a0b479c88b876facf868f0c7a6b598a0e308fa010b3352bb15d9dee67b5b6ff">UF_QUERY</a> = 4
, <a class="el" href="#af3a0b479c88b876facf868f0c7a6b598a8534d7d9e32ee9a877dddc70f7abdefd">UF_FRAGMENT</a> = 5
, <a class="el" href="#af3a0b479c88b876facf868f0c7a6b598ae015b71bf6bfa3cfe09f78f1c9360235">UF_USERINFO</a> = 6
, <a class="el" href="#af3a0b479c88b876facf868f0c7a6b598ac6a7f4a78be5640ed5c926efaf8301c2">UF_MAX</a> = 7
<br />
 }</td></tr>
<tr class="separator:af3a0b479c88b876facf868f0c7a6b598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42370aadfc71d5b56c38275023a08226" id="r_a42370aadfc71d5b56c38275023a08226"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42370aadfc71d5b56c38275023a08226">endianness</a> { <a class="el" href="#a42370aadfc71d5b56c38275023a08226ad861877da56b8b4ceb35c8cbfdf65bb4">big</a>
, <a class="el" href="#a42370aadfc71d5b56c38275023a08226aaae6635e044ac56046b2893a529b5114">little</a>
, <a class="el" href="#a42370aadfc71d5b56c38275023a08226a8e5f3adee38c8fccc13c1f3be0143796">native</a> = little
 }</td></tr>
<tr class="separator:a42370aadfc71d5b56c38275023a08226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00dc51f60e3a7f50eea48b914e9f88a" id="r_ae00dc51f60e3a7f50eea48b914e9f88a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae00dc51f60e3a7f50eea48b914e9f88a">LogLevel</a> { <br />
&#160;&#160;<a class="el" href="#ae00dc51f60e3a7f50eea48b914e9f88aa4eaaa435255d53d8ee1ad804ac2fde9d">WPI_LOG_CRITICAL</a> = 50
, <a class="el" href="#ae00dc51f60e3a7f50eea48b914e9f88aabd6cb7f9e35184593c719b52e3269f2e">WPI_LOG_ERROR</a> = 40
, <a class="el" href="#ae00dc51f60e3a7f50eea48b914e9f88aae6035e37ce53de5e15e2d11ab3aaa8d2">WPI_LOG_WARNING</a> = 30
, <a class="el" href="#ae00dc51f60e3a7f50eea48b914e9f88aafb54895e0b8a35d815e26607f33bc33c">WPI_LOG_INFO</a> = 20
, <br />
&#160;&#160;<a class="el" href="#ae00dc51f60e3a7f50eea48b914e9f88aa82615e27834c547fec2af93cf5d4b4a7">WPI_LOG_DEBUG</a> = 10
, <a class="el" href="#ae00dc51f60e3a7f50eea48b914e9f88aac7f7f9988bf8b7a36185cd7a19faa576">WPI_LOG_DEBUG1</a> = 9
, <a class="el" href="#ae00dc51f60e3a7f50eea48b914e9f88aa749ae7790a80d70497b9b873e51737c4">WPI_LOG_DEBUG2</a> = 8
, <a class="el" href="#ae00dc51f60e3a7f50eea48b914e9f88aaec2f6db5ca268bd387c48d6e06c06ecc">WPI_LOG_DEBUG3</a> = 7
, <br />
&#160;&#160;<a class="el" href="#ae00dc51f60e3a7f50eea48b914e9f88aae12c0145b954247e75447e15f40ba4e9">WPI_LOG_DEBUG4</a> = 6
<br />
 }</td></tr>
<tr class="separator:ae00dc51f60e3a7f50eea48b914e9f88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc73ce1be7e2680fb97374e03368001" id="r_a0cc73ce1be7e2680fb97374e03368001"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cc73ce1be7e2680fb97374e03368001">errc</a> { <br />
&#160;&#160;<a class="el" href="#a0cc73ce1be7e2680fb97374e03368001a1b245b26b5ea3428c050d7f1503d7715">argument_list_too_long</a> = int(std::errc::argument_list_too_long)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001a4b82222a0895b538d0597092b3ceab3e">argument_out_of_domain</a> = int(std::errc::argument_out_of_domain)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001aaf169f73a82794128aa491c4b4f1c071">bad_address</a> = int(std::errc::bad_address)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001a9941c5c8c58ff058b870e94e96ac38e1">bad_file_descriptor</a> = int(std::errc::bad_file_descriptor)
, <br />
&#160;&#160;<a class="el" href="#a0cc73ce1be7e2680fb97374e03368001a2f0338eed54503152be1d31c93c9c2f1">broken_pipe</a> = int(std::errc::broken_pipe)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001ab3ab5338a00f49c4451851cc5442f370">device_or_resource_busy</a> = int(std::errc::device_or_resource_busy)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001a6a336135d33e62f49edc55f29354e12e">directory_not_empty</a> = int(std::errc::directory_not_empty)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001a4dfaf9c996cf045f32d17edc9754fc95">executable_format_error</a> = int(std::errc::executable_format_error)
, <br />
&#160;&#160;<a class="el" href="#a0cc73ce1be7e2680fb97374e03368001a41edf636e3c7b59f797348fc58472258">file_exists</a> = int(std::errc::file_exists)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001aa1e14bfb89b41ddf654b1772c8fd2e74">file_too_large</a> = int(std::errc::file_too_large)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001a6e56e6ed055b9771b8192a4f229fee27">filename_too_long</a> = int(std::errc::filename_too_long)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001aa33c516bbdfb179cef733c8daeb97bed">function_not_supported</a> = int(std::errc::function_not_supported)
, <br />
&#160;&#160;<a class="el" href="#a0cc73ce1be7e2680fb97374e03368001a53a9e57a679708b2d8ff0ccd8ec96b18">illegal_byte_sequence</a> = int(std::errc::illegal_byte_sequence)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001a45fe7da1767194b580aeba752d7b44ae">inappropriate_io_control_operation</a>
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001afadb76763385627e57ec386c9b6038f0">interrupted</a> = int(std::errc::interrupted)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001ae55d43eabeefe5a8271b4a3c898bd18f">invalid_argument</a> = int(std::errc::invalid_argument)
, <br />
&#160;&#160;<a class="el" href="#a0cc73ce1be7e2680fb97374e03368001abd86a2c65caf6a270b916234ab321ce3">invalid_seek</a> = int(std::errc::invalid_seek)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001acccc32f2a5f7dc7b87d2f85daea66789">io_error</a> = int(std::errc::io_error)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001af3c51d7ea75a76f26c0a2bdc00c4e006">is_a_directory</a> = int(std::errc::is_a_directory)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001ad08d4c854a6810cebd2a8ab61876f919">no_child_process</a> = int(std::errc::no_child_process)
, <br />
&#160;&#160;<a class="el" href="#a0cc73ce1be7e2680fb97374e03368001a58688487c3e24313637a76bd29881e64">no_lock_available</a> = int(std::errc::no_lock_available)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001a1a5334dd8d1ca56e33887bd44630641b">no_space_on_device</a> = int(std::errc::no_space_on_device)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001a5c83a012eac17bbf458df5804801e373">no_such_device_or_address</a> = int(std::errc::no_such_device_or_address)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001af42b2e58729e2783b683c8610977fc22">no_such_device</a> = int(std::errc::no_such_device)
, <br />
&#160;&#160;<a class="el" href="#a0cc73ce1be7e2680fb97374e03368001a2e70fc89b08f26fa3fc77694c91e8f7a">no_such_file_or_directory</a> = int(std::errc::no_such_file_or_directory)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001ad91a9b8a734f2bef4b778f89806cbab7">no_such_process</a> = int(std::errc::no_such_process)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001a21e867ca95e1dfecff4701863547dcec">not_a_directory</a> = int(std::errc::not_a_directory)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001aafdb5594dc3e484fc1bfd7c564d550c1">not_enough_memory</a> = int(std::errc::not_enough_memory)
, <br />
&#160;&#160;<a class="el" href="#a0cc73ce1be7e2680fb97374e03368001aa55e82356e9721946aa9ba954733c6f0">not_supported</a> = int(std::errc::not_supported)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001a8344b3d509942f035d5e303022f9b986">operation_not_permitted</a> = int(std::errc::operation_not_permitted)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001ae8ee838822072f02738dbd7d97ea03fc">permission_denied</a> = int(std::errc::permission_denied)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001a06108efce8ef1cd8aa4cc440f8b4317f">read_only_file_system</a> = int(std::errc::read_only_file_system)
, <br />
&#160;&#160;<a class="el" href="#a0cc73ce1be7e2680fb97374e03368001aed65f7649c6f0e365673d65a9d8119d8">resource_deadlock_would_occur</a> = int(std::errc::resource_deadlock_would_occur)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001ae46a97ea2906921c8c626890bde832cf">resource_unavailable_try_again</a>
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001a8e0fafb181567cc468e1ee81983d739d">result_out_of_range</a> = int(std::errc::result_out_of_range)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001a3130d1d4e000cdc1e7c47013e313c10e">too_many_files_open_in_system</a> = int(std::errc::too_many_files_open_in_system)
, <br />
&#160;&#160;<a class="el" href="#a0cc73ce1be7e2680fb97374e03368001aed2c33c8fe874cfeba6f4a7747c62d05">too_many_files_open</a> = int(std::errc::too_many_files_open)
, <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001abfe22fc9b27a8ff13186aba60b6bc5c8">too_many_links</a> = int(std::errc::too_many_links)
<br />
 }</td></tr>
<tr class="separator:a0cc73ce1be7e2680fb97374e03368001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4416775113f6a916bc699ca08308a4" id="r_a5e4416775113f6a916bc699ca08308a4"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e4416775113f6a916bc699ca08308a4">StructFieldType</a> { <br />
&#160;&#160;<a class="el" href="#a5e4416775113f6a916bc699ca08308a4a18268c9f691ba5a5f650049d9d0da8dc">kBool</a>
, <a class="el" href="#a5e4416775113f6a916bc699ca08308a4af5e6c1b4f03d321b82fafadb7a3c2d47">kChar</a>
, <a class="el" href="#a5e4416775113f6a916bc699ca08308a4af112965031ccac10c07073b4e7430107">kInt8</a>
, <a class="el" href="#a5e4416775113f6a916bc699ca08308a4a6698ae5a05a12d36333200ae5e8f4f95">kInt16</a>
, <br />
&#160;&#160;<a class="el" href="#a5e4416775113f6a916bc699ca08308a4a10c09f8bff3c372f21cd8a13e01ae941">kInt32</a>
, <a class="el" href="#a5e4416775113f6a916bc699ca08308a4a22c776007533004e22da8e6bdd888b33">kInt64</a>
, <a class="el" href="#a5e4416775113f6a916bc699ca08308a4a11f076c48d8c2d080d2b9fbf5bf1725c">kUint8</a>
, <a class="el" href="#a5e4416775113f6a916bc699ca08308a4aca94c6052fa35563adffc07eac974ab6">kUint16</a>
, <br />
&#160;&#160;<a class="el" href="#a5e4416775113f6a916bc699ca08308a4af5fca11a36e986e3623193c5cccc4f39">kUint32</a>
, <a class="el" href="#a5e4416775113f6a916bc699ca08308a4a4e5966a6ca84ccd3ed763941df242c68">kUint64</a>
, <a class="el" href="#a5e4416775113f6a916bc699ca08308a4a8425cd882e78bc9251db970b8a1da20e">kFloat</a>
, <a class="el" href="#a5e4416775113f6a916bc699ca08308a4a7fb3efa35444cd88d5a31dc125ca9c28">kDouble</a>
, <br />
&#160;&#160;<a class="el" href="#a5e4416775113f6a916bc699ca08308a4a37d24e1221658f0e0333a512fdbcd2f0">kStruct</a>
<br />
 }</td></tr>
<tr class="memdesc:a5e4416775113f6a916bc699ca08308a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Known data types for raw struct dynamic fields (see StructFieldDescriptor).  <a href="#a5e4416775113f6a916bc699ca08308a4">More...</a><br /></td></tr>
<tr class="separator:a5e4416775113f6a916bc699ca08308a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac792221430e4bf80c1b31493afd90bfe" id="r_ac792221430e4bf80c1b31493afd90bfe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a> { <a class="el" href="#ac792221430e4bf80c1b31493afd90bfeaa1d30cd6c73259c50b7ce68207a7650f">conversionOK</a>
, <a class="el" href="#ac792221430e4bf80c1b31493afd90bfea673cb258ea483b0e6f31d55cf61311d1">sourceExhausted</a>
, <a class="el" href="#ac792221430e4bf80c1b31493afd90bfeac785c0d8e74261d6cbde1d63f8535ed2">targetExhausted</a>
, <a class="el" href="#ac792221430e4bf80c1b31493afd90bfea34299b0f92763294d72a3117752dbbe0">sourceIllegal</a>
 }</td></tr>
<tr class="separator:ac792221430e4bf80c1b31493afd90bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6baba019eee7e75848c7c03db9557b" id="r_aae6baba019eee7e75848c7c03db9557b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a> { <a class="el" href="#aae6baba019eee7e75848c7c03db9557ba32bafada5c584a9590053ed1bf5e7bfb">strictConversion</a> = 0
, <a class="el" href="#aae6baba019eee7e75848c7c03db9557ba26ee89af55088fc0f622de938525ad2a">lenientConversion</a>
 }</td></tr>
<tr class="separator:aae6baba019eee7e75848c7c03db9557b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9a1be75438ab85bc362414f0d60b8d" id="r_adf9a1be75438ab85bc362414f0d60b8d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf9a1be75438ab85bc362414f0d60b8d">nargs_pattern</a> { <a class="el" href="#adf9a1be75438ab85bc362414f0d60b8dad57c24f3fe52d16e7169b912dd647f0d">optional</a>
, <a class="el" href="#adf9a1be75438ab85bc362414f0d60b8da100b8cad7cf2a56f6df78f171f97a1ec">any</a>
, <a class="el" href="#adf9a1be75438ab85bc362414f0d60b8da3fe0284a7cd758589321a05f30353587">at_least_one</a>
 }</td></tr>
<tr class="separator:adf9a1be75438ab85bc362414f0d60b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b741829b477ec608a2534e5e5a22f67" id="r_a2b741829b477ec608a2534e5e5a22f67"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b741829b477ec608a2534e5e5a22f67">default_arguments</a> : unsigned int { <a class="el" href="#a2b741829b477ec608a2534e5e5a22f67a334c4a4c42fdb79d7ebc3e73b517e6f8">none</a> = 0
, <a class="el" href="#a2b741829b477ec608a2534e5e5a22f67a657f8b8da628ef83cf69101b6817150a">help</a> = 1
, <a class="el" href="#a2b741829b477ec608a2534e5e5a22f67a2af72f100c356273d46284f6fd1dfc08">version</a> = 2
, <a class="el" href="#a2b741829b477ec608a2534e5e5a22f67aa181a603769c1f98ad927e7367c7aa51">all</a> = help | version
 }</td></tr>
<tr class="separator:a2b741829b477ec608a2534e5e5a22f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a01feba2e98f9634bb529eac857ffa4fb" id="r_a01feba2e98f9634bb529eac857ffa4fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_compiler_8h.html#acbae7c06e77fa64145cca176963b6863">LLVM_ATTRIBUTE_RETURNS_NONNULL</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01feba2e98f9634bb529eac857ffa4fb">safe_malloc</a> (size_t Sz)</td></tr>
<tr class="separator:a01feba2e98f9634bb529eac857ffa4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3107b50e4fba4c211bc3981f452dfbc" id="r_aa3107b50e4fba4c211bc3981f452dfbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_compiler_8h.html#acbae7c06e77fa64145cca176963b6863">LLVM_ATTRIBUTE_RETURNS_NONNULL</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3107b50e4fba4c211bc3981f452dfbc">safe_calloc</a> (size_t Count, size_t Sz)</td></tr>
<tr class="separator:aa3107b50e4fba4c211bc3981f452dfbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780a79e5410f3c9082aa1ff62d997151" id="r_a780a79e5410f3c9082aa1ff62d997151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_compiler_8h.html#acbae7c06e77fa64145cca176963b6863">LLVM_ATTRIBUTE_RETURNS_NONNULL</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a780a79e5410f3c9082aa1ff62d997151">safe_realloc</a> (void *Ptr, size_t Sz)</td></tr>
<tr class="separator:a780a79e5410f3c9082aa1ff62d997151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17a307d96b6bf9787f0dc6aac310fee" id="r_ac17a307d96b6bf9787f0dc6aac310fee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_compiler_8h.html#acbae7c06e77fa64145cca176963b6863">LLVM_ATTRIBUTE_RETURNS_NONNULL</a> <a class="el" href="_compiler_8h.html#a33bc304d1e6e184f3ffd9fa1620fd14c">LLVM_ATTRIBUTE_RETURNS_NOALIAS</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac17a307d96b6bf9787f0dc6aac310fee">allocate_buffer</a> (size_t Size, size_t Alignment)</td></tr>
<tr class="memdesc:ac17a307d96b6bf9787f0dc6aac310fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a buffer of memory with the given size and alignment.  <br /></td></tr>
<tr class="separator:ac17a307d96b6bf9787f0dc6aac310fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693165287d8a8a5159fd739216188620" id="r_a693165287d8a8a5159fd739216188620"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a693165287d8a8a5159fd739216188620">deallocate_buffer</a> (void *Ptr, size_t Size, size_t Alignment)</td></tr>
<tr class="memdesc:a693165287d8a8a5159fd739216188620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate a buffer of memory with the given size and alignment.  <br /></td></tr>
<tr class="separator:a693165287d8a8a5159fd739216188620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f7388a5c35ee653463418cea51c178" id="r_a30f7388a5c35ee653463418cea51c178"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, typename PointerTy , unsigned IntBits, typename IntType , typename PtrTraits , typename Info &gt; </td></tr>
<tr class="memitem:a30f7388a5c35ee653463418cea51c178"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a30f7388a5c35ee653463418cea51c178">get</a> (const <a class="el" href="classwpi_1_1_pointer_int_pair.html">PointerIntPair</a>&lt; PointerTy, IntBits, IntType, PtrTraits, Info &gt; &amp;Pair)</td></tr>
<tr class="separator:a30f7388a5c35ee653463418cea51c178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964ada559def4cb99c3554f2a7c8ecca" id="r_a964ada559def4cb99c3554f2a7c8ecca"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:a964ada559def4cb99c3554f2a7c8ecca"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a964ada559def4cb99c3554f2a7c8ecca">isa</a> (const From &amp;Val)</td></tr>
<tr class="memdesc:a964ada559def4cb99c3554f2a7c8ecca"><td class="mdescLeft">&#160;</td><td class="mdescRight">isa&lt;X&gt; - Return true if the parameter to the template is an instance of one of the template type arguments.  <br /></td></tr>
<tr class="separator:a964ada559def4cb99c3554f2a7c8ecca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45870e316ed651537ea145e67b3512a" id="r_ad45870e316ed651537ea145e67b3512a"><td class="memTemplParams" colspan="2">template&lt;typename First , typename Second , typename... Rest, typename From &gt; </td></tr>
<tr class="memitem:ad45870e316ed651537ea145e67b3512a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad45870e316ed651537ea145e67b3512a">isa</a> (const From &amp;Val)</td></tr>
<tr class="separator:ad45870e316ed651537ea145e67b3512a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d1ec7b9131213ad5deed2c377eac77" id="r_a07d1ec7b9131213ad5deed2c377eac77"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:a07d1ec7b9131213ad5deed2c377eac77"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a07d1ec7b9131213ad5deed2c377eac77">cast</a> (const From &amp;Val)</td></tr>
<tr class="memdesc:a07d1ec7b9131213ad5deed2c377eac77"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast&lt;X&gt; - Return the argument parameter cast to the specified type.  <br /></td></tr>
<tr class="separator:a07d1ec7b9131213ad5deed2c377eac77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae397c6f6851eec1e8e685786dee62ea4" id="r_ae397c6f6851eec1e8e685786dee62ea4"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:ae397c6f6851eec1e8e685786dee62ea4"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae397c6f6851eec1e8e685786dee62ea4">cast</a> (From &amp;Val)</td></tr>
<tr class="separator:ae397c6f6851eec1e8e685786dee62ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b54fe186a1d407a3f60a259c4c0492" id="r_a53b54fe186a1d407a3f60a259c4c0492"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:a53b54fe186a1d407a3f60a259c4c0492"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a53b54fe186a1d407a3f60a259c4c0492">cast</a> (From *Val)</td></tr>
<tr class="separator:a53b54fe186a1d407a3f60a259c4c0492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260ef7c17feedcb3c516b22f07b0a402" id="r_a260ef7c17feedcb3c516b22f07b0a402"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:a260ef7c17feedcb3c516b22f07b0a402"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a260ef7c17feedcb3c516b22f07b0a402">cast</a> (std::unique_ptr&lt; From &gt; &amp;&amp;Val)</td></tr>
<tr class="separator:a260ef7c17feedcb3c516b22f07b0a402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f54d8682fc12347ac7befe9706e7c1" id="r_aa6f54d8682fc12347ac7befe9706e7c1"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:aa6f54d8682fc12347ac7befe9706e7c1"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa6f54d8682fc12347ac7befe9706e7c1">dyn_cast</a> (const From &amp;Val)</td></tr>
<tr class="memdesc:aa6f54d8682fc12347ac7befe9706e7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">dyn_cast&lt;X&gt; - Return the argument parameter cast to the specified type.  <br /></td></tr>
<tr class="separator:aa6f54d8682fc12347ac7befe9706e7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b3596d6edfbd8dba33b1c9a23022cc" id="r_a80b3596d6edfbd8dba33b1c9a23022cc"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:a80b3596d6edfbd8dba33b1c9a23022cc"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a80b3596d6edfbd8dba33b1c9a23022cc">dyn_cast</a> (From &amp;Val)</td></tr>
<tr class="separator:a80b3596d6edfbd8dba33b1c9a23022cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad473029646c1b0de5aa067c7565e409a" id="r_ad473029646c1b0de5aa067c7565e409a"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:ad473029646c1b0de5aa067c7565e409a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad473029646c1b0de5aa067c7565e409a">dyn_cast</a> (From *Val)</td></tr>
<tr class="separator:ad473029646c1b0de5aa067c7565e409a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe2ef2ae56adc0a57f8b9f942cfc3c8" id="r_a7fe2ef2ae56adc0a57f8b9f942cfc3c8"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:a7fe2ef2ae56adc0a57f8b9f942cfc3c8"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7fe2ef2ae56adc0a57f8b9f942cfc3c8">dyn_cast</a> (std::unique_ptr&lt; From &gt; &amp;Val)</td></tr>
<tr class="separator:a7fe2ef2ae56adc0a57f8b9f942cfc3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cc4026f84f4c754d494b7d3ced2066" id="r_aa7cc4026f84f4c754d494b7d3ced2066"><td class="memTemplParams" colspan="2">template&lt;typename... X, class Y &gt; </td></tr>
<tr class="memitem:aa7cc4026f84f4c754d494b7d3ced2066"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa7cc4026f84f4c754d494b7d3ced2066">isa_and_present</a> (const Y &amp;Val)</td></tr>
<tr class="memdesc:aa7cc4026f84f4c754d494b7d3ced2066"><td class="mdescLeft">&#160;</td><td class="mdescRight">isa_and_present&lt;X&gt; - Functionally identical to isa, except that a null value is accepted.  <br /></td></tr>
<tr class="separator:aa7cc4026f84f4c754d494b7d3ced2066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8475cd52faddca844bb540effa022e" id="r_a5a8475cd52faddca844bb540effa022e"><td class="memTemplParams" colspan="2">template&lt;typename... X, class Y &gt; </td></tr>
<tr class="memitem:a5a8475cd52faddca844bb540effa022e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5a8475cd52faddca844bb540effa022e">isa_and_nonnull</a> (const Y &amp;Val)</td></tr>
<tr class="separator:a5a8475cd52faddca844bb540effa022e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae574e491fd08b2b0dc040da5c1b9e045" id="r_ae574e491fd08b2b0dc040da5c1b9e045"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:ae574e491fd08b2b0dc040da5c1b9e045"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae574e491fd08b2b0dc040da5c1b9e045">cast_if_present</a> (const Y &amp;Val)</td></tr>
<tr class="memdesc:ae574e491fd08b2b0dc040da5c1b9e045"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast_if_present&lt;X&gt; - Functionally identical to cast, except that a null value is accepted.  <br /></td></tr>
<tr class="separator:ae574e491fd08b2b0dc040da5c1b9e045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16c17b52842390c6c6ad910789b9772" id="r_aa16c17b52842390c6c6ad910789b9772"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:aa16c17b52842390c6c6ad910789b9772"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa16c17b52842390c6c6ad910789b9772">cast_if_present</a> (Y &amp;Val)</td></tr>
<tr class="separator:aa16c17b52842390c6c6ad910789b9772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e4021d4285d64972a97040f3c33079" id="r_aa8e4021d4285d64972a97040f3c33079"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:aa8e4021d4285d64972a97040f3c33079"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa8e4021d4285d64972a97040f3c33079">cast_if_present</a> (Y *Val)</td></tr>
<tr class="separator:aa8e4021d4285d64972a97040f3c33079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1533b15a80c0d7e1132b3a8ce4068aef" id="r_a1533b15a80c0d7e1132b3a8ce4068aef"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a1533b15a80c0d7e1132b3a8ce4068aef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1533b15a80c0d7e1132b3a8ce4068aef">cast_if_present</a> (std::unique_ptr&lt; Y &gt; &amp;&amp;Val)</td></tr>
<tr class="separator:a1533b15a80c0d7e1132b3a8ce4068aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5a09d7249f213d2b3dedd3978a5dda" id="r_a1f5a09d7249f213d2b3dedd3978a5dda"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a1f5a09d7249f213d2b3dedd3978a5dda"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1f5a09d7249f213d2b3dedd3978a5dda">cast_or_null</a> (const Y &amp;Val)</td></tr>
<tr class="separator:a1f5a09d7249f213d2b3dedd3978a5dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9b1a139f23ae41fab47e19f42d7b6c" id="r_acf9b1a139f23ae41fab47e19f42d7b6c"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:acf9b1a139f23ae41fab47e19f42d7b6c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acf9b1a139f23ae41fab47e19f42d7b6c">cast_or_null</a> (Y &amp;Val)</td></tr>
<tr class="separator:acf9b1a139f23ae41fab47e19f42d7b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733a794c73228e91c8b9c1995ddd5326" id="r_a733a794c73228e91c8b9c1995ddd5326"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a733a794c73228e91c8b9c1995ddd5326"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a733a794c73228e91c8b9c1995ddd5326">cast_or_null</a> (Y *Val)</td></tr>
<tr class="separator:a733a794c73228e91c8b9c1995ddd5326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d9ded262559ddbd76ee0c76db53c45" id="r_a14d9ded262559ddbd76ee0c76db53c45"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a14d9ded262559ddbd76ee0c76db53c45"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a14d9ded262559ddbd76ee0c76db53c45">cast_or_null</a> (std::unique_ptr&lt; Y &gt; &amp;&amp;Val)</td></tr>
<tr class="separator:a14d9ded262559ddbd76ee0c76db53c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a2172f617bad28f826b306b2c3fd48" id="r_ad7a2172f617bad28f826b306b2c3fd48"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:ad7a2172f617bad28f826b306b2c3fd48"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad7a2172f617bad28f826b306b2c3fd48">dyn_cast_if_present</a> (const Y &amp;Val)</td></tr>
<tr class="memdesc:ad7a2172f617bad28f826b306b2c3fd48"><td class="mdescLeft">&#160;</td><td class="mdescRight">dyn_cast_if_present&lt;X&gt; - Functionally identical to dyn_cast, except that a null (or none in the case of optionals) value is accepted.  <br /></td></tr>
<tr class="separator:ad7a2172f617bad28f826b306b2c3fd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed04fcefb22adfac639093654b30ba8" id="r_a4ed04fcefb22adfac639093654b30ba8"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a4ed04fcefb22adfac639093654b30ba8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4ed04fcefb22adfac639093654b30ba8">dyn_cast_if_present</a> (Y &amp;Val)</td></tr>
<tr class="separator:a4ed04fcefb22adfac639093654b30ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acada0e48faa3c9744961e3f633c34491" id="r_acada0e48faa3c9744961e3f633c34491"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:acada0e48faa3c9744961e3f633c34491"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acada0e48faa3c9744961e3f633c34491">dyn_cast_if_present</a> (Y *Val)</td></tr>
<tr class="separator:acada0e48faa3c9744961e3f633c34491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fd32ebcb102cb3ccb0d8c267b920f3" id="r_ae2fd32ebcb102cb3ccb0d8c267b920f3"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:ae2fd32ebcb102cb3ccb0d8c267b920f3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae2fd32ebcb102cb3ccb0d8c267b920f3">dyn_cast_or_null</a> (const Y &amp;Val)</td></tr>
<tr class="separator:ae2fd32ebcb102cb3ccb0d8c267b920f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a951ab0e01e0c994b76be9f61d56c12" id="r_a5a951ab0e01e0c994b76be9f61d56c12"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a5a951ab0e01e0c994b76be9f61d56c12"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5a951ab0e01e0c994b76be9f61d56c12">dyn_cast_or_null</a> (Y &amp;Val)</td></tr>
<tr class="separator:a5a951ab0e01e0c994b76be9f61d56c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b381976312c54ae970f51b9c5aa2ad" id="r_a48b381976312c54ae970f51b9c5aa2ad"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a48b381976312c54ae970f51b9c5aa2ad"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a48b381976312c54ae970f51b9c5aa2ad">dyn_cast_or_null</a> (Y *Val)</td></tr>
<tr class="separator:a48b381976312c54ae970f51b9c5aa2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad586a56958f612d9abd6e681095f84b" id="r_aad586a56958f612d9abd6e681095f84b"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:aad586a56958f612d9abd6e681095f84b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structwpi_1_1_cast_info.html">CastInfo</a>&lt; X, std::unique_ptr&lt; Y &gt; &gt;::CastResultType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aad586a56958f612d9abd6e681095f84b">unique_dyn_cast</a> (std::unique_ptr&lt; Y &gt; &amp;Val)</td></tr>
<tr class="memdesc:aad586a56958f612d9abd6e681095f84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">unique_dyn_cast&lt;X&gt; - Given a unique_ptr&lt;Y&gt;, try to return a unique_ptr&lt;X&gt;, taking ownership of the input pointer iff isa&lt;X&gt;(Val) is true.  <br /></td></tr>
<tr class="separator:aad586a56958f612d9abd6e681095f84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43b2efdc26b8b018d5854d115e6ff17" id="r_ad43b2efdc26b8b018d5854d115e6ff17"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:ad43b2efdc26b8b018d5854d115e6ff17"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad43b2efdc26b8b018d5854d115e6ff17">unique_dyn_cast</a> (std::unique_ptr&lt; Y &gt; &amp;&amp;Val)</td></tr>
<tr class="separator:ad43b2efdc26b8b018d5854d115e6ff17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5344f9b4191fcd767af5fbd6af5aa2b3" id="r_a5344f9b4191fcd767af5fbd6af5aa2b3"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a5344f9b4191fcd767af5fbd6af5aa2b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structwpi_1_1_cast_info.html">CastInfo</a>&lt; X, std::unique_ptr&lt; Y &gt; &gt;::CastResultType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5344f9b4191fcd767af5fbd6af5aa2b3">unique_dyn_cast_or_null</a> (std::unique_ptr&lt; Y &gt; &amp;Val)</td></tr>
<tr class="separator:a5344f9b4191fcd767af5fbd6af5aa2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19895a7f422ff3246efb74b2e67364d" id="r_ad19895a7f422ff3246efb74b2e67364d"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:ad19895a7f422ff3246efb74b2e67364d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad19895a7f422ff3246efb74b2e67364d">unique_dyn_cast_or_null</a> (std::unique_ptr&lt; Y &gt; &amp;&amp;Val)</td></tr>
<tr class="separator:ad19895a7f422ff3246efb74b2e67364d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7e386e354d5ee78df311f700c7fae0" id="r_a1e7e386e354d5ee78df311f700c7fae0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e7e386e354d5ee78df311f700c7fae0">Demangle</a> (std::string_view mangledSymbol)</td></tr>
<tr class="memdesc:a1e7e386e354d5ee78df311f700c7fae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Demangle a C++ symbol.  <br /></td></tr>
<tr class="separator:a1e7e386e354d5ee78df311f700c7fae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad718ecdfe8fb14771e97a6c2169ddb99" id="r_ad718ecdfe8fb14771e97a6c2169ddb99"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad718ecdfe8fb14771e97a6c2169ddb99"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad718ecdfe8fb14771e97a6c2169ddb99">GetTypeName</a> (const T &amp;type)</td></tr>
<tr class="memdesc:ad718ecdfe8fb14771e97a6c2169ddb99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type name of an object.  <br /></td></tr>
<tr class="separator:ad718ecdfe8fb14771e97a6c2169ddb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af979beb47215754d9f91b67aab2dc4e7" id="r_af979beb47215754d9f91b67aab2dc4e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af979beb47215754d9f91b67aab2dc4e7">SocketErrno</a> ()</td></tr>
<tr class="separator:af979beb47215754d9f91b67aab2dc4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b76c9ad108ae76959df39c1d0b6f03b" id="r_a8b76c9ad108ae76959df39c1d0b6f03b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b76c9ad108ae76959df39c1d0b6f03b">SocketStrerror</a> (int <a class="el" href="_third_party_notices_8txt.html#a84115a3d674a21b7abd56eab103ff848">code</a>)</td></tr>
<tr class="separator:a8b76c9ad108ae76959df39c1d0b6f03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d3b98c9badfe33b94b7c6ec1ad3f9f" id="r_aa4d3b98c9badfe33b94b7c6ec1ad3f9f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4d3b98c9badfe33b94b7c6ec1ad3f9f">SocketStrerror</a> ()</td></tr>
<tr class="separator:aa4d3b98c9badfe33b94b7c6ec1ad3f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337beda02d2dd53b5d020a593c867e6d" id="r_a337beda02d2dd53b5d020a593c867e6d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a337beda02d2dd53b5d020a593c867e6d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a337beda02d2dd53b5d020a593c867e6d">maskTrailingOnes</a> (unsigned N)</td></tr>
<tr class="memdesc:a337beda02d2dd53b5d020a593c867e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a bitmask with the N right-most bits set to 1, and all other bits set to 0.  <br /></td></tr>
<tr class="separator:a337beda02d2dd53b5d020a593c867e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca1a8d567765c25e5c8aaf6f2a3a51a" id="r_a0ca1a8d567765c25e5c8aaf6f2a3a51a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ca1a8d567765c25e5c8aaf6f2a3a51a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ca1a8d567765c25e5c8aaf6f2a3a51a">maskLeadingOnes</a> (unsigned N)</td></tr>
<tr class="memdesc:a0ca1a8d567765c25e5c8aaf6f2a3a51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a bitmask with the N left-most bits set to 1, and all other bits set to 0.  <br /></td></tr>
<tr class="separator:a0ca1a8d567765c25e5c8aaf6f2a3a51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e2df17acd6bc9d36f64037926be88f" id="r_ad6e2df17acd6bc9d36f64037926be88f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad6e2df17acd6bc9d36f64037926be88f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad6e2df17acd6bc9d36f64037926be88f">maskTrailingZeros</a> (unsigned N)</td></tr>
<tr class="memdesc:ad6e2df17acd6bc9d36f64037926be88f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a bitmask with the N right-most bits set to 0, and all other bits set to 1.  <br /></td></tr>
<tr class="separator:ad6e2df17acd6bc9d36f64037926be88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed916b5acc65b9b7f1ff971ffc096030" id="r_aed916b5acc65b9b7f1ff971ffc096030"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed916b5acc65b9b7f1ff971ffc096030"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aed916b5acc65b9b7f1ff971ffc096030">maskLeadingZeros</a> (unsigned N)</td></tr>
<tr class="memdesc:aed916b5acc65b9b7f1ff971ffc096030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a bitmask with the N left-most bits set to 0, and all other bits set to 1.  <br /></td></tr>
<tr class="separator:aed916b5acc65b9b7f1ff971ffc096030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538316af0297b9fa6d65a22c874d4a95" id="r_a538316af0297b9fa6d65a22c874d4a95"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a538316af0297b9fa6d65a22c874d4a95"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a538316af0297b9fa6d65a22c874d4a95">reverseBits</a> (T Val)</td></tr>
<tr class="memdesc:a538316af0297b9fa6d65a22c874d4a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the bits in <code>Val</code>.  <br /></td></tr>
<tr class="separator:a538316af0297b9fa6d65a22c874d4a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3568938669eceec8a2a2e8060cf7550" id="r_af3568938669eceec8a2a2e8060cf7550"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3568938669eceec8a2a2e8060cf7550">Hi_32</a> (uint64_t Value)</td></tr>
<tr class="memdesc:af3568938669eceec8a2a2e8060cf7550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the high 32 bits of a 64 bit value.  <br /></td></tr>
<tr class="separator:af3568938669eceec8a2a2e8060cf7550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cde0598116042ad77cd369e21b95d3" id="r_a30cde0598116042ad77cd369e21b95d3"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30cde0598116042ad77cd369e21b95d3">Lo_32</a> (uint64_t Value)</td></tr>
<tr class="memdesc:a30cde0598116042ad77cd369e21b95d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the low 32 bits of a 64 bit value.  <br /></td></tr>
<tr class="separator:a30cde0598116042ad77cd369e21b95d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6fd03a9b591a2f187f0a44e2b4a356" id="r_acc6fd03a9b591a2f187f0a44e2b4a356"><td class="memItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc6fd03a9b591a2f187f0a44e2b4a356">Make_64</a> (uint32_t High, uint32_t Low)</td></tr>
<tr class="memdesc:acc6fd03a9b591a2f187f0a44e2b4a356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a 64-bit integer from a high / low pair of 32-bit integers.  <br /></td></tr>
<tr class="separator:acc6fd03a9b591a2f187f0a44e2b4a356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793cb5a31f3412455ec43e6030919a42" id="r_a793cb5a31f3412455ec43e6030919a42"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a793cb5a31f3412455ec43e6030919a42"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a793cb5a31f3412455ec43e6030919a42">isInt</a> (int64_t x)</td></tr>
<tr class="memdesc:a793cb5a31f3412455ec43e6030919a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an integer fits into the given bit width.  <br /></td></tr>
<tr class="separator:a793cb5a31f3412455ec43e6030919a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b38a6d85f09021ac8f5a253764011fb" id="r_a3b38a6d85f09021ac8f5a253764011fb"><td class="memTemplParams" colspan="2">template&lt;unsigned N, unsigned S&gt; </td></tr>
<tr class="memitem:a3b38a6d85f09021ac8f5a253764011fb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3b38a6d85f09021ac8f5a253764011fb">isShiftedInt</a> (int64_t x)</td></tr>
<tr class="memdesc:a3b38a6d85f09021ac8f5a253764011fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a signed integer is an N bit number shifted left by S.  <br /></td></tr>
<tr class="separator:a3b38a6d85f09021ac8f5a253764011fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db3174e602eaacc944f1a7fb8fecdc0" id="r_a0db3174e602eaacc944f1a7fb8fecdc0"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:a0db3174e602eaacc944f1a7fb8fecdc0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0db3174e602eaacc944f1a7fb8fecdc0">isUInt</a> (uint64_t x)</td></tr>
<tr class="memdesc:a0db3174e602eaacc944f1a7fb8fecdc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an unsigned integer fits into the given bit width.  <br /></td></tr>
<tr class="separator:a0db3174e602eaacc944f1a7fb8fecdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24c771b8df1d9311b05e5aa01ec09b3" id="r_ae24c771b8df1d9311b05e5aa01ec09b3"><td class="memTemplParams" colspan="2">template&lt;unsigned N, unsigned S&gt; </td></tr>
<tr class="memitem:ae24c771b8df1d9311b05e5aa01ec09b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae24c771b8df1d9311b05e5aa01ec09b3">isShiftedUInt</a> (uint64_t x)</td></tr>
<tr class="memdesc:ae24c771b8df1d9311b05e5aa01ec09b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a unsigned integer is an N bit number shifted left by S.  <br /></td></tr>
<tr class="separator:ae24c771b8df1d9311b05e5aa01ec09b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb968c37d6007862cab0e2e2156d9df9" id="r_adb968c37d6007862cab0e2e2156d9df9"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb968c37d6007862cab0e2e2156d9df9">maxUIntN</a> (uint64_t N)</td></tr>
<tr class="memdesc:adb968c37d6007862cab0e2e2156d9df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum value for a N-bit unsigned integer.  <br /></td></tr>
<tr class="separator:adb968c37d6007862cab0e2e2156d9df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb563f4c667933f0ebf44c6ca54e7ba" id="r_abfb563f4c667933f0ebf44c6ca54e7ba"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfb563f4c667933f0ebf44c6ca54e7ba">minIntN</a> (int64_t N)</td></tr>
<tr class="memdesc:abfb563f4c667933f0ebf44c6ca54e7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the minimum value for a N-bit signed integer.  <br /></td></tr>
<tr class="separator:abfb563f4c667933f0ebf44c6ca54e7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01982bb8b119d94de4200ed371ad5397" id="r_a01982bb8b119d94de4200ed371ad5397"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01982bb8b119d94de4200ed371ad5397">maxIntN</a> (int64_t N)</td></tr>
<tr class="memdesc:a01982bb8b119d94de4200ed371ad5397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum value for a N-bit signed integer.  <br /></td></tr>
<tr class="separator:a01982bb8b119d94de4200ed371ad5397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2ea2c155eeb9a3662912e8c2ff880e" id="r_adc2ea2c155eeb9a3662912e8c2ff880e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc2ea2c155eeb9a3662912e8c2ff880e">isUIntN</a> (unsigned N, uint64_t x)</td></tr>
<tr class="memdesc:adc2ea2c155eeb9a3662912e8c2ff880e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an unsigned integer fits into the given (dynamic) bit width.  <br /></td></tr>
<tr class="separator:adc2ea2c155eeb9a3662912e8c2ff880e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65bc8235c8a7ccfb15d4856909adc45" id="r_ae65bc8235c8a7ccfb15d4856909adc45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae65bc8235c8a7ccfb15d4856909adc45">isIntN</a> (unsigned N, int64_t x)</td></tr>
<tr class="memdesc:ae65bc8235c8a7ccfb15d4856909adc45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an signed integer fits into the given (dynamic) bit width.  <br /></td></tr>
<tr class="separator:ae65bc8235c8a7ccfb15d4856909adc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7868b72f26477d7e06a655a552b8886" id="r_af7868b72f26477d7e06a655a552b8886"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7868b72f26477d7e06a655a552b8886">isMask_32</a> (uint32_t Value)</td></tr>
<tr class="memdesc:af7868b72f26477d7e06a655a552b8886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the argument is a non-empty sequence of ones starting at the least significant bit with the remainder zero (32 bit version).  <br /></td></tr>
<tr class="separator:af7868b72f26477d7e06a655a552b8886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba808be054c9d45a724cc14bf47b45b" id="r_abba808be054c9d45a724cc14bf47b45b"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abba808be054c9d45a724cc14bf47b45b">isMask_64</a> (uint64_t Value)</td></tr>
<tr class="memdesc:abba808be054c9d45a724cc14bf47b45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the argument is a non-empty sequence of ones starting at the least significant bit with the remainder zero (64 bit version).  <br /></td></tr>
<tr class="separator:abba808be054c9d45a724cc14bf47b45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca9c306cc27e6eb5d669b6d41e6dba0" id="r_a3ca9c306cc27e6eb5d669b6d41e6dba0"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ca9c306cc27e6eb5d669b6d41e6dba0">isShiftedMask_32</a> (uint32_t Value)</td></tr>
<tr class="memdesc:a3ca9c306cc27e6eb5d669b6d41e6dba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the argument contains a non-empty sequence of ones with the remainder zero (32 bit version.) Ex.  <br /></td></tr>
<tr class="separator:a3ca9c306cc27e6eb5d669b6d41e6dba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76f4df15ef384517038996decd80631" id="r_ae76f4df15ef384517038996decd80631"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae76f4df15ef384517038996decd80631">isShiftedMask_64</a> (uint64_t Value)</td></tr>
<tr class="memdesc:ae76f4df15ef384517038996decd80631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the argument contains a non-empty sequence of ones with the remainder zero (64 bit version.)  <br /></td></tr>
<tr class="separator:ae76f4df15ef384517038996decd80631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ef6fef4b85937dabc224872f7ff540" id="r_a44ef6fef4b85937dabc224872f7ff540"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44ef6fef4b85937dabc224872f7ff540">isPowerOf2_32</a> (uint32_t Value)</td></tr>
<tr class="memdesc:a44ef6fef4b85937dabc224872f7ff540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the argument is a power of two &gt; 0.  <br /></td></tr>
<tr class="separator:a44ef6fef4b85937dabc224872f7ff540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab337d9f021792437e222ab8de869770c" id="r_ab337d9f021792437e222ab8de869770c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab337d9f021792437e222ab8de869770c">isPowerOf2_64</a> (uint64_t Value)</td></tr>
<tr class="memdesc:ab337d9f021792437e222ab8de869770c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the argument is a power of two &gt; 0 (64 bit edition.)  <br /></td></tr>
<tr class="separator:ab337d9f021792437e222ab8de869770c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5a1ddcd97fd7f07a98a6bc0eb7c204" id="r_adb5a1ddcd97fd7f07a98a6bc0eb7c204"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb5a1ddcd97fd7f07a98a6bc0eb7c204">isShiftedMask_32</a> (uint32_t Value, unsigned &amp;MaskIdx, unsigned &amp;MaskLen)</td></tr>
<tr class="memdesc:adb5a1ddcd97fd7f07a98a6bc0eb7c204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the argument contains a non-empty sequence of ones with the remainder zero (32 bit version.) Ex.  <br /></td></tr>
<tr class="separator:adb5a1ddcd97fd7f07a98a6bc0eb7c204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ce1e370353bc9753bead0ab77727f0" id="r_a24ce1e370353bc9753bead0ab77727f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24ce1e370353bc9753bead0ab77727f0">isShiftedMask_64</a> (uint64_t Value, unsigned &amp;MaskIdx, unsigned &amp;MaskLen)</td></tr>
<tr class="memdesc:a24ce1e370353bc9753bead0ab77727f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the argument contains a non-empty sequence of ones with the remainder zero (64 bit version.) If true, <code>MaskIdx</code> will specify the index of the lowest set bit and <code>MaskLen</code> is updated to specify the length of the mask, else neither are updated.  <br /></td></tr>
<tr class="separator:a24ce1e370353bc9753bead0ab77727f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5847649747d23028195684c90de9cfa1" id="r_a5847649747d23028195684c90de9cfa1"><td class="memTemplParams" colspan="2">template&lt;size_t kValue&gt; </td></tr>
<tr class="memitem:a5847649747d23028195684c90de9cfa1"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5847649747d23028195684c90de9cfa1">CTLog2</a> ()</td></tr>
<tr class="memdesc:a5847649747d23028195684c90de9cfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time Log2.  <br /></td></tr>
<tr class="separator:a5847649747d23028195684c90de9cfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a3d85b513c921ffa14928e047294b6" id="r_a72a3d85b513c921ffa14928e047294b6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a72a3d85b513c921ffa14928e047294b6"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a72a3d85b513c921ffa14928e047294b6">CTLog2&lt; 1 &gt;</a> ()</td></tr>
<tr class="separator:a72a3d85b513c921ffa14928e047294b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fc40611c1ed874ebee9877f3866da8" id="r_a12fc40611c1ed874ebee9877f3866da8"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12fc40611c1ed874ebee9877f3866da8">Log2_32</a> (uint32_t Value)</td></tr>
<tr class="memdesc:a12fc40611c1ed874ebee9877f3866da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floor log base 2 of the specified value, -1 if the value is zero.  <br /></td></tr>
<tr class="separator:a12fc40611c1ed874ebee9877f3866da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab109b30376a3d157344b924e82ccd5ef" id="r_ab109b30376a3d157344b924e82ccd5ef"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab109b30376a3d157344b924e82ccd5ef">Log2_64</a> (uint64_t Value)</td></tr>
<tr class="memdesc:ab109b30376a3d157344b924e82ccd5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floor log base 2 of the specified value, -1 if the value is zero.  <br /></td></tr>
<tr class="separator:ab109b30376a3d157344b924e82ccd5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be06425de1e3346544e3600fda4f352" id="r_a1be06425de1e3346544e3600fda4f352"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1be06425de1e3346544e3600fda4f352">Log2_32_Ceil</a> (uint32_t Value)</td></tr>
<tr class="memdesc:a1be06425de1e3346544e3600fda4f352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ceil log base 2 of the specified value, 32 if the value is zero.  <br /></td></tr>
<tr class="separator:a1be06425de1e3346544e3600fda4f352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b43a321203f7b23732402ef5dc9709" id="r_ae6b43a321203f7b23732402ef5dc9709"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6b43a321203f7b23732402ef5dc9709">Log2_64_Ceil</a> (uint64_t Value)</td></tr>
<tr class="memdesc:ae6b43a321203f7b23732402ef5dc9709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ceil log base 2 of the specified value, 64 if the value is zero.  <br /></td></tr>
<tr class="separator:ae6b43a321203f7b23732402ef5dc9709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2c49962110e8c4bf54b763aac045c8" id="r_aaf2c49962110e8c4bf54b763aac045c8"><td class="memItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf2c49962110e8c4bf54b763aac045c8">MinAlign</a> (uint64_t A, uint64_t B)</td></tr>
<tr class="memdesc:aaf2c49962110e8c4bf54b763aac045c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A and B are either alignments or offsets.  <br /></td></tr>
<tr class="separator:aaf2c49962110e8c4bf54b763aac045c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde254908107ab292ce34e1eaf9f0287" id="r_abde254908107ab292ce34e1eaf9f0287"><td class="memItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abde254908107ab292ce34e1eaf9f0287">NextPowerOf2</a> (uint64_t A)</td></tr>
<tr class="memdesc:abde254908107ab292ce34e1eaf9f0287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next power of two (in 64-bits) that is strictly greater than A.  <br /></td></tr>
<tr class="separator:abde254908107ab292ce34e1eaf9f0287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d2692504baab859a5288de06e96df3" id="r_a22d2692504baab859a5288de06e96df3"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22d2692504baab859a5288de06e96df3">PowerOf2Ceil</a> (uint64_t A)</td></tr>
<tr class="memdesc:a22d2692504baab859a5288de06e96df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the power of two which is greater than or equal to the given value.  <br /></td></tr>
<tr class="separator:a22d2692504baab859a5288de06e96df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0316a8c345ffe467f744e0e9f7d475" id="r_a7b0316a8c345ffe467f744e0e9f7d475"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b0316a8c345ffe467f744e0e9f7d475">alignTo</a> (uint64_t Value, uint64_t Align)</td></tr>
<tr class="memdesc:a7b0316a8c345ffe467f744e0e9f7d475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next integer (mod 2**64) that is greater than or equal to <code>Value</code> and is a multiple of <code>Align</code>.  <br /></td></tr>
<tr class="separator:a7b0316a8c345ffe467f744e0e9f7d475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab167a7e34682d91fc42f5d419d2af941" id="r_ab167a7e34682d91fc42f5d419d2af941"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab167a7e34682d91fc42f5d419d2af941">alignToPowerOf2</a> (uint64_t Value, uint64_t Align)</td></tr>
<tr class="separator:ab167a7e34682d91fc42f5d419d2af941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53cd62626ce308da46540adc1a24250" id="r_ae53cd62626ce308da46540adc1a24250"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae53cd62626ce308da46540adc1a24250">alignTo</a> (uint64_t Value, uint64_t Align, uint64_t Skew)</td></tr>
<tr class="memdesc:ae53cd62626ce308da46540adc1a24250"><td class="mdescLeft">&#160;</td><td class="mdescRight">If non-zero <code>Skew</code> is specified, the return value will be a minimal integer that is greater than or equal to <code>Size</code> and equal to <code>A</code> * N + <code>Skew</code> for some integer N.  <br /></td></tr>
<tr class="separator:ae53cd62626ce308da46540adc1a24250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e89f720bc5d42133b9e1fba299f9e6e" id="r_a2e89f720bc5d42133b9e1fba299f9e6e"><td class="memTemplParams" colspan="2">template&lt;uint64_t Align&gt; </td></tr>
<tr class="memitem:a2e89f720bc5d42133b9e1fba299f9e6e"><td class="memTemplItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2e89f720bc5d42133b9e1fba299f9e6e">alignTo</a> (uint64_t Value)</td></tr>
<tr class="memdesc:a2e89f720bc5d42133b9e1fba299f9e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next integer (mod 2**64) that is greater than or equal to <code>Value</code> and is a multiple of <code>Align</code>.  <br /></td></tr>
<tr class="separator:a2e89f720bc5d42133b9e1fba299f9e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86598beceb2a41ea10f4335f8d5b99e4" id="r_a86598beceb2a41ea10f4335f8d5b99e4"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86598beceb2a41ea10f4335f8d5b99e4">divideCeil</a> (uint64_t Numerator, uint64_t Denominator)</td></tr>
<tr class="memdesc:a86598beceb2a41ea10f4335f8d5b99e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the integer ceil(Numerator / Denominator).  <br /></td></tr>
<tr class="separator:a86598beceb2a41ea10f4335f8d5b99e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75514d8e686b9790882d92c4efc0c8f3" id="r_a75514d8e686b9790882d92c4efc0c8f3"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75514d8e686b9790882d92c4efc0c8f3">divideNearest</a> (uint64_t Numerator, uint64_t Denominator)</td></tr>
<tr class="memdesc:a75514d8e686b9790882d92c4efc0c8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the integer nearest(Numerator / Denominator).  <br /></td></tr>
<tr class="separator:a75514d8e686b9790882d92c4efc0c8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96597787b5255d8569295b2a87d33cf" id="r_af96597787b5255d8569295b2a87d33cf"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af96597787b5255d8569295b2a87d33cf">alignDown</a> (uint64_t Value, uint64_t Align, uint64_t Skew=0)</td></tr>
<tr class="memdesc:af96597787b5255d8569295b2a87d33cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest uint64_t less than or equal to <code>Value</code> and is <code>Skew</code> mod <code>Align</code>.  <br /></td></tr>
<tr class="separator:af96597787b5255d8569295b2a87d33cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae892922c9d93c91d358b554fec2b6505" id="r_ae892922c9d93c91d358b554fec2b6505"><td class="memTemplParams" colspan="2">template&lt;unsigned B&gt; </td></tr>
<tr class="memitem:ae892922c9d93c91d358b554fec2b6505"><td class="memTemplItemLeft" align="right" valign="top">constexpr int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae892922c9d93c91d358b554fec2b6505">SignExtend32</a> (uint32_t X)</td></tr>
<tr class="memdesc:ae892922c9d93c91d358b554fec2b6505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extend the number in the bottom B bits of X to a 32-bit integer.  <br /></td></tr>
<tr class="separator:ae892922c9d93c91d358b554fec2b6505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3d762ed7571ddac4e212f583eb0a12" id="r_a9c3d762ed7571ddac4e212f583eb0a12"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c3d762ed7571ddac4e212f583eb0a12">SignExtend32</a> (uint32_t X, unsigned B)</td></tr>
<tr class="memdesc:a9c3d762ed7571ddac4e212f583eb0a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extend the number in the bottom B bits of X to a 32-bit integer.  <br /></td></tr>
<tr class="separator:a9c3d762ed7571ddac4e212f583eb0a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401f9f01b250b094f790fab7706106d8" id="r_a401f9f01b250b094f790fab7706106d8"><td class="memTemplParams" colspan="2">template&lt;unsigned B&gt; </td></tr>
<tr class="memitem:a401f9f01b250b094f790fab7706106d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a401f9f01b250b094f790fab7706106d8">SignExtend64</a> (uint64_t x)</td></tr>
<tr class="memdesc:a401f9f01b250b094f790fab7706106d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extend the number in the bottom B bits of X to a 64-bit integer.  <br /></td></tr>
<tr class="separator:a401f9f01b250b094f790fab7706106d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2540c26db383c900eae86f2c67c41ce0" id="r_a2540c26db383c900eae86f2c67c41ce0"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2540c26db383c900eae86f2c67c41ce0">SignExtend64</a> (uint64_t X, unsigned B)</td></tr>
<tr class="memdesc:a2540c26db383c900eae86f2c67c41ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extend the number in the bottom B bits of X to a 64-bit integer.  <br /></td></tr>
<tr class="separator:a2540c26db383c900eae86f2c67c41ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92bb1e40972ef1155f70f9a1e341fce" id="r_ab92bb1e40972ef1155f70f9a1e341fce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab92bb1e40972ef1155f70f9a1e341fce"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_unsigned_v&lt; T &gt;, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab92bb1e40972ef1155f70f9a1e341fce">AbsoluteDifference</a> (T X, T Y)</td></tr>
<tr class="memdesc:ab92bb1e40972ef1155f70f9a1e341fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two unsigned integers, X and Y, of type T and return the absolute value of the result.  <br /></td></tr>
<tr class="separator:ab92bb1e40972ef1155f70f9a1e341fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62659b5a787c7e4226be65a87f78687d" id="r_a62659b5a787c7e4226be65a87f78687d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62659b5a787c7e4226be65a87f78687d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_unsigned_v&lt; T &gt;, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a62659b5a787c7e4226be65a87f78687d">SaturatingAdd</a> (T X, T Y, bool *ResultOverflowed=nullptr)</td></tr>
<tr class="memdesc:a62659b5a787c7e4226be65a87f78687d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two unsigned integers, X and Y, of type T.  <br /></td></tr>
<tr class="separator:a62659b5a787c7e4226be65a87f78687d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f5e9a527fc240f35c74bd250f7870a" id="r_a56f5e9a527fc240f35c74bd250f7870a"><td class="memTemplParams" colspan="2">template&lt;class T , class... Ts&gt; </td></tr>
<tr class="memitem:a56f5e9a527fc240f35c74bd250f7870a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_unsigned_v&lt; T &gt;, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a56f5e9a527fc240f35c74bd250f7870a">SaturatingAdd</a> (T X, T Y, T Z, Ts... Args)</td></tr>
<tr class="memdesc:a56f5e9a527fc240f35c74bd250f7870a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add multiple unsigned integers of type T.  <br /></td></tr>
<tr class="separator:a56f5e9a527fc240f35c74bd250f7870a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61cc21f13e1ebeb16606beee7fbdfa86" id="r_a61cc21f13e1ebeb16606beee7fbdfa86"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a61cc21f13e1ebeb16606beee7fbdfa86"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_unsigned_v&lt; T &gt;, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a61cc21f13e1ebeb16606beee7fbdfa86">SaturatingMultiply</a> (T X, T Y, bool *ResultOverflowed=nullptr)</td></tr>
<tr class="memdesc:a61cc21f13e1ebeb16606beee7fbdfa86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two unsigned integers, X and Y, of type T.  <br /></td></tr>
<tr class="separator:a61cc21f13e1ebeb16606beee7fbdfa86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b025ab259067b84fe2ecea8127ee44b" id="r_a8b025ab259067b84fe2ecea8127ee44b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8b025ab259067b84fe2ecea8127ee44b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_unsigned_v&lt; T &gt;, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8b025ab259067b84fe2ecea8127ee44b">SaturatingMultiplyAdd</a> (T X, T Y, T A, bool *ResultOverflowed=nullptr)</td></tr>
<tr class="memdesc:a8b025ab259067b84fe2ecea8127ee44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two unsigned integers, X and Y, and add the unsigned integer, A to the product.  <br /></td></tr>
<tr class="separator:a8b025ab259067b84fe2ecea8127ee44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8aa688a56f891640957f59beef75d82" id="r_ab8aa688a56f891640957f59beef75d82"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab8aa688a56f891640957f59beef75d82"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_signed_v&lt; T &gt;, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab8aa688a56f891640957f59beef75d82">AddOverflow</a> (T X, T Y, T &amp;Result)</td></tr>
<tr class="memdesc:ab8aa688a56f891640957f59beef75d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two signed integers, computing the two's complement truncated result, returning true if overflow occurred.  <br /></td></tr>
<tr class="separator:ab8aa688a56f891640957f59beef75d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05953a04700d3bac512b4f35fabee3d7" id="r_a05953a04700d3bac512b4f35fabee3d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a05953a04700d3bac512b4f35fabee3d7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_signed_v&lt; T &gt;, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a05953a04700d3bac512b4f35fabee3d7">SubOverflow</a> (T X, T Y, T &amp;Result)</td></tr>
<tr class="memdesc:a05953a04700d3bac512b4f35fabee3d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two signed integers, computing the two's complement truncated result, returning true if an overflow ocurred.  <br /></td></tr>
<tr class="separator:a05953a04700d3bac512b4f35fabee3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f0b046a937c5df08ee7e355cd99919" id="r_a54f0b046a937c5df08ee7e355cd99919"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a54f0b046a937c5df08ee7e355cd99919"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_signed_v&lt; T &gt;, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a54f0b046a937c5df08ee7e355cd99919">MulOverflow</a> (T X, T Y, T &amp;Result)</td></tr>
<tr class="memdesc:a54f0b046a937c5df08ee7e355cd99919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two signed integers, computing the two's complement truncated result, returning true if an overflow ocurred.  <br /></td></tr>
<tr class="separator:a54f0b046a937c5df08ee7e355cd99919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dca6ddf9e17f10ec7699c29819b6c18" id="r_a0dca6ddf9e17f10ec7699c29819b6c18"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0dca6ddf9e17f10ec7699c29819b6c18"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0dca6ddf9e17f10ec7699c29819b6c18">sgn</a> (T val)</td></tr>
<tr class="separator:a0dca6ddf9e17f10ec7699c29819b6c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905c54ca4b7fdb1633b425ad9ca5dc48" id="r_a905c54ca4b7fdb1633b425ad9ca5dc48"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a905c54ca4b7fdb1633b425ad9ca5dc48"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a905c54ca4b7fdb1633b425ad9ca5dc48">Lerp</a> (const T &amp;startValue, const T &amp;endValue, double t)</td></tr>
<tr class="memdesc:a905c54ca4b7fdb1633b425ad9ca5dc48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linearly interpolates between two values.  <br /></td></tr>
<tr class="separator:a905c54ca4b7fdb1633b425ad9ca5dc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a591544e2a1812a45a5caa585367c01" id="r_a2a591544e2a1812a45a5caa585367c01"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a2a591544e2a1812a45a5caa585367c01"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::span&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2a591544e2a1812a45a5caa585367c01">drop_front</a> (std::span&lt; T, N &gt; in, typename std::span&lt; T &gt;::size_type n=1)</td></tr>
<tr class="memdesc:a2a591544e2a1812a45a5caa585367c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the first <code>N</code> elements of the array.  <br /></td></tr>
<tr class="separator:a2a591544e2a1812a45a5caa585367c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2640340e4b5c2618417738f45c047509" id="r_a2640340e4b5c2618417738f45c047509"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a2640340e4b5c2618417738f45c047509"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::span&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2640340e4b5c2618417738f45c047509">drop_back</a> (std::span&lt; T, N &gt; in, typename std::span&lt; T &gt;::size_type n=1)</td></tr>
<tr class="memdesc:a2640340e4b5c2618417738f45c047509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the last <code>N</code> elements of the array.  <br /></td></tr>
<tr class="separator:a2640340e4b5c2618417738f45c047509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55070033454b115a776f0896c59e7784" id="r_a55070033454b115a776f0896c59e7784"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a55070033454b115a776f0896c59e7784"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::span&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a55070033454b115a776f0896c59e7784">take_front</a> (std::span&lt; T, N &gt; in, typename std::span&lt; T &gt;::size_type n=1)</td></tr>
<tr class="memdesc:a55070033454b115a776f0896c59e7784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a span equal to <code>in</code> but with only the first <code>n</code> elements remaining.  <br /></td></tr>
<tr class="separator:a55070033454b115a776f0896c59e7784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3f5909dbe701d6f87b8a381047f683" id="r_aab3f5909dbe701d6f87b8a381047f683"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:aab3f5909dbe701d6f87b8a381047f683"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::span&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aab3f5909dbe701d6f87b8a381047f683">take_back</a> (std::span&lt; T, N &gt; in, typename std::span&lt; T &gt;::size_type n=1)</td></tr>
<tr class="memdesc:aab3f5909dbe701d6f87b8a381047f683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a span equal to <code>in</code> but with only the last <code>n</code> elements remaining.  <br /></td></tr>
<tr class="separator:aab3f5909dbe701d6f87b8a381047f683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1285c84e98d61b7f161a2213dd9f7940" id="r_a1285c84e98d61b7f161a2213dd9f7940"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1285c84e98d61b7f161a2213dd9f7940">http_parser_version</a> (void)</td></tr>
<tr class="separator:a1285c84e98d61b7f161a2213dd9f7940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfaa8c347e0e51020430bcd0d45660b4" id="r_adfaa8c347e0e51020430bcd0d45660b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfaa8c347e0e51020430bcd0d45660b4">http_parser_init</a> (<a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *parser, enum <a class="el" href="#ab37735642db3ab741e86bf064b2ddbbd">http_parser_type</a> type)</td></tr>
<tr class="separator:adfaa8c347e0e51020430bcd0d45660b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f661690631e2ba6da370fe0b5bcfc55" id="r_a9f661690631e2ba6da370fe0b5bcfc55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f661690631e2ba6da370fe0b5bcfc55">http_parser_settings_init</a> (<a class="el" href="structwpi_1_1http__parser__settings.html">http_parser_settings</a> *settings)</td></tr>
<tr class="separator:a9f661690631e2ba6da370fe0b5bcfc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cea3956c069ac99ed2e7eeebb5b3cfb" id="r_a9cea3956c069ac99ed2e7eeebb5b3cfb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cea3956c069ac99ed2e7eeebb5b3cfb">http_parser_execute</a> (<a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *parser, const <a class="el" href="structwpi_1_1http__parser__settings.html">http_parser_settings</a> *settings, const char *data, size_t len)</td></tr>
<tr class="separator:a9cea3956c069ac99ed2e7eeebb5b3cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d892e596ff2ee4287ebd021faa63b4" id="r_ad1d892e596ff2ee4287ebd021faa63b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1d892e596ff2ee4287ebd021faa63b4">http_should_keep_alive</a> (const <a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *parser)</td></tr>
<tr class="separator:ad1d892e596ff2ee4287ebd021faa63b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be802a6897b36bbcd4c2dcd23e9e7f3" id="r_a9be802a6897b36bbcd4c2dcd23e9e7f3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9be802a6897b36bbcd4c2dcd23e9e7f3">http_method_str</a> (enum <a class="el" href="#a3458579fc7214ea6b0411bbadf6ffcbc">http_method</a> m)</td></tr>
<tr class="separator:a9be802a6897b36bbcd4c2dcd23e9e7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af568f1219d61f5c74f4de5caac588a90" id="r_af568f1219d61f5c74f4de5caac588a90"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af568f1219d61f5c74f4de5caac588a90">http_status_str</a> (enum <a class="el" href="#ae89a1f90a8603e399f9cc0465b0ce21e">http_status</a> s)</td></tr>
<tr class="separator:af568f1219d61f5c74f4de5caac588a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b4fb11893062b968b86716e84aebae" id="r_ab0b4fb11893062b968b86716e84aebae"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0b4fb11893062b968b86716e84aebae">http_errno_name</a> (enum <a class="el" href="#a0e56bd09798339ac4f86d36eb8ecea0b">http_errno</a> err)</td></tr>
<tr class="separator:ab0b4fb11893062b968b86716e84aebae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534aec91ecbd222189dd61e56e809443" id="r_a534aec91ecbd222189dd61e56e809443"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a534aec91ecbd222189dd61e56e809443">http_errno_description</a> (enum <a class="el" href="#a0e56bd09798339ac4f86d36eb8ecea0b">http_errno</a> err)</td></tr>
<tr class="separator:a534aec91ecbd222189dd61e56e809443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798587facfa5f28d28e137d96c97a0d0" id="r_a798587facfa5f28d28e137d96c97a0d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a798587facfa5f28d28e137d96c97a0d0">http_parser_url_init</a> (struct <a class="el" href="structwpi_1_1http__parser__url.html">http_parser_url</a> *u)</td></tr>
<tr class="separator:a798587facfa5f28d28e137d96c97a0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc17f817835ce41947523e20f3feeb1" id="r_a7fc17f817835ce41947523e20f3feeb1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fc17f817835ce41947523e20f3feeb1">http_parser_parse_url</a> (const char *buf, size_t buflen, int is_connect, struct <a class="el" href="structwpi_1_1http__parser__url.html">http_parser_url</a> *u)</td></tr>
<tr class="separator:a7fc17f817835ce41947523e20f3feeb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc98ce08cafe77beb6171b08d3065181" id="r_afc98ce08cafe77beb6171b08d3065181"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc98ce08cafe77beb6171b08d3065181">http_parser_pause</a> (<a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *parser, int paused)</td></tr>
<tr class="separator:afc98ce08cafe77beb6171b08d3065181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab736f59b1f30b097d559e33acc6bb602" id="r_ab736f59b1f30b097d559e33acc6bb602"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab736f59b1f30b097d559e33acc6bb602">http_body_is_final</a> (const <a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *parser)</td></tr>
<tr class="separator:ab736f59b1f30b097d559e33acc6bb602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3bbec452d79352196b712ee75332681" id="r_ac3bbec452d79352196b712ee75332681"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From , typename  = std::enable_if_t&lt;sizeof(To) == sizeof(From)&gt;, typename  = std::enable_if_t&lt;std::is_trivially_constructible&lt;To&gt;::value&gt;, typename  = std::enable_if_t&lt;std::is_trivially_copyable&lt;To&gt;::value&gt;, typename  = std::enable_if_t&lt;std::is_trivially_copyable&lt;From&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ac3bbec452d79352196b712ee75332681"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac3bbec452d79352196b712ee75332681">bit_cast</a> (const From &amp;<a class="el" href="_third_party_notices_8txt.html#ae1e371287219a11d6a2498f92d3e15d2">from</a>) noexcept</td></tr>
<tr class="separator:ac3bbec452d79352196b712ee75332681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32aa2b0061658aa4b7720efe05f8bcbe" id="r_a32aa2b0061658aa4b7720efe05f8bcbe"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:a32aa2b0061658aa4b7720efe05f8bcbe"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a32aa2b0061658aa4b7720efe05f8bcbe">byteswap</a> (T V) noexcept</td></tr>
<tr class="memdesc:a32aa2b0061658aa4b7720efe05f8bcbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the bytes in the given integer value V.  <br /></td></tr>
<tr class="separator:a32aa2b0061658aa4b7720efe05f8bcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87dbe0fae2ecbfa69d709f615dbf8d01" id="r_a87dbe0fae2ecbfa69d709f615dbf8d01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87dbe0fae2ecbfa69d709f615dbf8d01">vprint</a> (<a class="el" href="classwpi_1_1raw__ostream.html">wpi::raw_ostream</a> &amp;os, fmt::string_view format_str, fmt::format_args args)</td></tr>
<tr class="separator:a87dbe0fae2ecbfa69d709f615dbf8d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0653a25063e16f63b5f9aec814b0afd3" id="r_a0653a25063e16f63b5f9aec814b0afd3"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="wpilibc_2src_2main_2native_2include_2frc_2_errors_8h.html#a82134794782845c50b9a960bb191ba30">S</a> , typename... Args&gt; </td></tr>
<tr class="memitem:a0653a25063e16f63b5f9aec814b0afd3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0653a25063e16f63b5f9aec814b0afd3">print</a> (<a class="el" href="classwpi_1_1raw__ostream.html">wpi::raw_ostream</a> &amp;os, const <a class="el" href="wpilibc_2src_2main_2native_2include_2frc_2_errors_8h.html#a82134794782845c50b9a960bb191ba30">S</a> &amp;format_str, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a0653a25063e16f63b5f9aec814b0afd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints formatted data to the stream <em>os</em>.  <br /></td></tr>
<tr class="separator:a0653a25063e16f63b5f9aec814b0afd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb253c150fd08303e17789f200e2c751" id="r_aeb253c150fd08303e17789f200e2c751"><td class="memTemplParams" colspan="2">template&lt;std::size_t Index, typename ValueTy &gt; </td></tr>
<tr class="memitem:aeb253c150fd08303e17789f200e2c751"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeb253c150fd08303e17789f200e2c751">get</a> (const <a class="el" href="classwpi_1_1_string_map_entry.html">StringMapEntry</a>&lt; ValueTy &gt; &amp;E)</td></tr>
<tr class="separator:aeb253c150fd08303e17789f200e2c751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0def7e7c0176002c2ad197435f25b4b6" id="r_a0def7e7c0176002c2ad197435f25b4b6"><td class="memTemplParams" colspan="2">template&lt;std::size_t Index, typename ValueTy &gt; </td></tr>
<tr class="memitem:a0def7e7c0176002c2ad197435f25b4b6"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0def7e7c0176002c2ad197435f25b4b6">get</a> (<a class="el" href="classwpi_1_1_string_map_entry.html">StringMapEntry</a>&lt; ValueTy &gt; &amp;E)</td></tr>
<tr class="separator:a0def7e7c0176002c2ad197435f25b4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5058f1185c691b80cd2d8a692a7657" id="r_a4f5058f1185c691b80cd2d8a692a7657"><td class="memTemplParams" colspan="2">template&lt;typename T , std::convertible_to&lt; T &gt;... Ts&gt; </td></tr>
<tr class="memitem:a4f5058f1185c691b80cd2d8a692a7657"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4f5058f1185c691b80cd2d8a692a7657">array</a> (T, Ts...) -&gt; array&lt; T, 1+sizeof...(Ts)&gt;</td></tr>
<tr class="separator:a4f5058f1185c691b80cd2d8a692a7657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9258f2870864143e01a09bb5cf806ba6" id="r_a9258f2870864143e01a09bb5cf806ba6"><td class="memTemplParams" colspan="2">template&lt;typename DerivedT , typename KeyT , typename ValueT , typename KeyInfoT , typename BucketT &gt; </td></tr>
<tr class="memitem:a9258f2870864143e01a09bb5cf806ba6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9258f2870864143e01a09bb5cf806ba6">operator==</a> (const <a class="el" href="classwpi_1_1_dense_map_base.html">DenseMapBase</a>&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt; &amp;LHS, const <a class="el" href="classwpi_1_1_dense_map_base.html">DenseMapBase</a>&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt; &amp;RHS)</td></tr>
<tr class="memdesc:a9258f2870864143e01a09bb5cf806ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison for <a class="el" href="classwpi_1_1_dense_map.html">DenseMap</a>.  <br /></td></tr>
<tr class="separator:a9258f2870864143e01a09bb5cf806ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2bd96b09718980689f6278dd7ea224d" id="r_ac2bd96b09718980689f6278dd7ea224d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedT , typename KeyT , typename ValueT , typename KeyInfoT , typename BucketT &gt; </td></tr>
<tr class="memitem:ac2bd96b09718980689f6278dd7ea224d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac2bd96b09718980689f6278dd7ea224d">operator!=</a> (const <a class="el" href="classwpi_1_1_dense_map_base.html">DenseMapBase</a>&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt; &amp;LHS, const <a class="el" href="classwpi_1_1_dense_map_base.html">DenseMapBase</a>&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt; &amp;RHS)</td></tr>
<tr class="memdesc:ac2bd96b09718980689f6278dd7ea224d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison for <a class="el" href="classwpi_1_1_dense_map.html">DenseMap</a>.  <br /></td></tr>
<tr class="separator:ac2bd96b09718980689f6278dd7ea224d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703d958d0d00e12bac5736929f6f1b33" id="r_a703d958d0d00e12bac5736929f6f1b33"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT , typename KeyInfoT &gt; </td></tr>
<tr class="memitem:a703d958d0d00e12bac5736929f6f1b33"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a703d958d0d00e12bac5736929f6f1b33">capacity_in_bytes</a> (const <a class="el" href="classwpi_1_1_dense_map.html">DenseMap</a>&lt; KeyT, ValueT, KeyInfoT &gt; &amp;X)</td></tr>
<tr class="separator:a703d958d0d00e12bac5736929f6f1b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62962dadd010d3e7f1517084802194b" id="r_ad62962dadd010d3e7f1517084802194b"><td class="memTemplParams" colspan="2">template&lt;typename Char , size_t M&gt; </td></tr>
<tr class="memitem:ad62962dadd010d3e7f1517084802194b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad62962dadd010d3e7f1517084802194b">ct_string</a> (Char const (&amp;s)[M]) -&gt; ct_string&lt; Char, std::char_traits&lt; Char &gt;, M - 1 &gt;</td></tr>
<tr class="separator:ad62962dadd010d3e7f1517084802194b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873cf95a88c9f787819ee2c9aacb7c13" id="r_a873cf95a88c9f787819ee2c9aacb7c13"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structwpi_1_1ct__string.html">ct_string</a> S&gt; </td></tr>
<tr class="memitem:a873cf95a88c9f787819ee2c9aacb7c13"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1literals.html#a873cf95a88c9f787819ee2c9aacb7c13">operator&quot;&quot;_ct_string</a> ()</td></tr>
<tr class="separator:a873cf95a88c9f787819ee2c9aacb7c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b884901ae1c2a760ac27c1ced1f2ca0" id="r_a9b884901ae1c2a760ac27c1ced1f2ca0"><td class="memTemplParams" colspan="2">template&lt;typename Char , typename Traits , size_t N1, size_t N2&gt; </td></tr>
<tr class="memitem:a9b884901ae1c2a760ac27c1ced1f2ca0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9b884901ae1c2a760ac27c1ced1f2ca0">operator+</a> (<a class="el" href="structwpi_1_1ct__string.html">ct_string</a>&lt; Char, Traits, N1 &gt; const &amp;s1, <a class="el" href="structwpi_1_1ct__string.html">ct_string</a>&lt; Char, Traits, N2 &gt; const &amp;s2) noexcept</td></tr>
<tr class="separator:a9b884901ae1c2a760ac27c1ced1f2ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ed722bd88bc8cbd56f950b3e0333fb" id="r_a16ed722bd88bc8cbd56f950b3e0333fb"><td class="memTemplParams" colspan="2">template&lt;typename Char , typename Traits , size_t N1, size_t... N&gt; </td></tr>
<tr class="memitem:a16ed722bd88bc8cbd56f950b3e0333fb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a16ed722bd88bc8cbd56f950b3e0333fb">Concat</a> (<a class="el" href="structwpi_1_1ct__string.html">ct_string</a>&lt; Char, Traits, N1 &gt; const &amp;s1, <a class="el" href="structwpi_1_1ct__string.html">ct_string</a>&lt; Char, Traits, N &gt; const &amp;... s)</td></tr>
<tr class="memdesc:a16ed722bd88bc8cbd56f950b3e0333fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple fixed_strings into a larger fixed_string at compile time.  <br /></td></tr>
<tr class="separator:a16ed722bd88bc8cbd56f950b3e0333fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a60cf592ceb77188e17328f0c69791e" id="r_a0a60cf592ceb77188e17328f0c69791e"><td class="memTemplParams" colspan="2">template&lt;intmax_t N, int Base = 10, typename Char  = char, typename Traits  = std::char_traits&lt;Char&gt;&gt; <br />
requires (Base &gt;= 2 &amp;&amp; Base &lt;= 36)</td></tr>
<tr class="memitem:a0a60cf592ceb77188e17328f0c69791e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0a60cf592ceb77188e17328f0c69791e">NumToCtString</a> ()</td></tr>
<tr class="memdesc:a0a60cf592ceb77188e17328f0c69791e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts any integral to a <a class="el" href="structwpi_1_1ct__string.html" title="Fixed length string (array of character) for compile time use.">ct_string</a> at compile-time.  <br /></td></tr>
<tr class="separator:a0a60cf592ceb77188e17328f0c69791e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9630e9cd2902c4dbc7f817a6a84bb9da" id="r_a9630e9cd2902c4dbc7f817a6a84bb9da"><td class="memTemplParams" colspan="2">template&lt;typename RangeT , typename WrappedIteratorT  = decltype(std::begin(std::declval&lt;RangeT&gt;()))&gt; </td></tr>
<tr class="memitem:a9630e9cd2902c4dbc7f817a6a84bb9da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="structwpi_1_1pointee__iterator.html">pointee_iterator</a>&lt; WrappedIteratorT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9630e9cd2902c4dbc7f817a6a84bb9da">make_pointee_range</a> (RangeT &amp;&amp;Range)</td></tr>
<tr class="separator:a9630e9cd2902c4dbc7f817a6a84bb9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa300eeb1def26aef1ca3af133fb26971" id="r_aa300eeb1def26aef1ca3af133fb26971"><td class="memTemplParams" colspan="2">template&lt;typename RangeT , typename WrappedIteratorT  = decltype(std::begin(std::declval&lt;RangeT&gt;()))&gt; </td></tr>
<tr class="memitem:aa300eeb1def26aef1ca3af133fb26971"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classwpi_1_1pointer__iterator.html">pointer_iterator</a>&lt; WrappedIteratorT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa300eeb1def26aef1ca3af133fb26971">make_pointer_range</a> (RangeT &amp;&amp;Range)</td></tr>
<tr class="separator:aa300eeb1def26aef1ca3af133fb26971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af9a7e30ba77940f2ef47d513252866" id="r_a8af9a7e30ba77940f2ef47d513252866"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8af9a7e30ba77940f2ef47d513252866">mapWindowsError</a> (unsigned EV)</td></tr>
<tr class="separator:a8af9a7e30ba77940f2ef47d513252866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84cf72de6e08899df61612e400beff1" id="r_aa84cf72de6e08899df61612e400beff1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa84cf72de6e08899df61612e400beff1">Base64Decode</a> (<a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;os, std::string_view encoded)</td></tr>
<tr class="separator:aa84cf72de6e08899df61612e400beff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2dec1800b8c82d4cb942493afc4a828" id="r_af2dec1800b8c82d4cb942493afc4a828"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2dec1800b8c82d4cb942493afc4a828">Base64Decode</a> (std::string_view encoded, std::string *plain)</td></tr>
<tr class="separator:af2dec1800b8c82d4cb942493afc4a828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac503c8c47490fca90512a88b23b65358" id="r_ac503c8c47490fca90512a88b23b65358"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac503c8c47490fca90512a88b23b65358">Base64Decode</a> (std::string_view encoded, size_t *num_read, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;buf)</td></tr>
<tr class="separator:ac503c8c47490fca90512a88b23b65358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c4d7b36efb76fd101c8cd219c9bdb8" id="r_a46c4d7b36efb76fd101c8cd219c9bdb8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46c4d7b36efb76fd101c8cd219c9bdb8">Base64Decode</a> (std::string_view encoded, std::vector&lt; uint8_t &gt; *plain)</td></tr>
<tr class="separator:a46c4d7b36efb76fd101c8cd219c9bdb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa145997bec65a8d0e2b783c384a6e3e4" id="r_aa145997bec65a8d0e2b783c384a6e3e4"><td class="memItemLeft" align="right" valign="top">std::span&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa145997bec65a8d0e2b783c384a6e3e4">Base64Decode</a> (std::string_view encoded, size_t *num_read, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; uint8_t &gt; &amp;buf)</td></tr>
<tr class="separator:aa145997bec65a8d0e2b783c384a6e3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0cca388f8042851ed82359d23c61e9" id="r_a8f0cca388f8042851ed82359d23c61e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f0cca388f8042851ed82359d23c61e9">Base64Encode</a> (<a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;os, std::string_view plain)</td></tr>
<tr class="separator:a8f0cca388f8042851ed82359d23c61e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4351dc23f99c30ed993190988f3da889" id="r_a4351dc23f99c30ed993190988f3da889"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4351dc23f99c30ed993190988f3da889">Base64Encode</a> (std::string_view plain, std::string *encoded)</td></tr>
<tr class="separator:a4351dc23f99c30ed993190988f3da889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfd836e85f4e66313113339d542ae76" id="r_adbfd836e85f4e66313113339d542ae76"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbfd836e85f4e66313113339d542ae76">Base64Encode</a> (std::string_view plain, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;buf)</td></tr>
<tr class="separator:adbfd836e85f4e66313113339d542ae76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d319e2a72f572e4fbdbb2017fd203e" id="r_ad2d319e2a72f572e4fbdbb2017fd203e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2d319e2a72f572e4fbdbb2017fd203e">Base64Encode</a> (<a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;os, std::span&lt; const uint8_t &gt; plain)</td></tr>
<tr class="separator:ad2d319e2a72f572e4fbdbb2017fd203e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f1eed3c192da2db90b3d0ab15d24c8" id="r_a94f1eed3c192da2db90b3d0ab15d24c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94f1eed3c192da2db90b3d0ab15d24c8">Base64Encode</a> (std::span&lt; const uint8_t &gt; plain, std::string *encoded)</td></tr>
<tr class="separator:a94f1eed3c192da2db90b3d0ab15d24c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c10d4e853c1b2027f22c23c46106f15" id="r_a3c10d4e853c1b2027f22c23c46106f15"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c10d4e853c1b2027f22c23c46106f15">Base64Encode</a> (std::span&lt; const uint8_t &gt; plain, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;buf)</td></tr>
<tr class="separator:a3c10d4e853c1b2027f22c23c46106f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309bc670f1bda6373a69c5a66eb9849a" id="r_a309bc670f1bda6373a69c5a66eb9849a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a309bc670f1bda6373a69c5a66eb9849a">install_fatal_error_handler</a> (<a class="el" href="#aacde1332b72e968317ed516552a07ca8">fatal_error_handler_t</a> handler, void *user_data=nullptr)</td></tr>
<tr class="memdesc:a309bc670f1bda6373a69c5a66eb9849a"><td class="mdescLeft">&#160;</td><td class="mdescRight">install_fatal_error_handler - Installs a new error handler to be used whenever a serious (non-recoverable) error is encountered by LLVM.  <br /></td></tr>
<tr class="separator:a309bc670f1bda6373a69c5a66eb9849a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d89324acbf36872064573065959d20" id="r_a08d89324acbf36872064573065959d20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08d89324acbf36872064573065959d20">remove_fatal_error_handler</a> ()</td></tr>
<tr class="memdesc:a08d89324acbf36872064573065959d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores default error handling behaviour.  <br /></td></tr>
<tr class="separator:a08d89324acbf36872064573065959d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6392584571d4e2bec4247503254d83a3" id="r_a6392584571d4e2bec4247503254d83a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6392584571d4e2bec4247503254d83a3">report_fatal_error</a> (const char *reason, bool gen_crash_diag=true)</td></tr>
<tr class="memdesc:a6392584571d4e2bec4247503254d83a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports a serious error, calling any installed error handler.  <br /></td></tr>
<tr class="separator:a6392584571d4e2bec4247503254d83a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2f5ea71a00431f1def0f2d7daf7af3" id="r_a2a2f5ea71a00431f1def0f2d7daf7af3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a2f5ea71a00431f1def0f2d7daf7af3">report_fatal_error</a> (const std::string &amp;reason, bool gen_crash_diag=true)</td></tr>
<tr class="separator:a2a2f5ea71a00431f1def0f2d7daf7af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5d4610f996de2254ee2eca97aa2da6" id="r_a9c5d4610f996de2254ee2eca97aa2da6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c5d4610f996de2254ee2eca97aa2da6">report_fatal_error</a> (std::string_view reason, bool gen_crash_diag=true)</td></tr>
<tr class="separator:a9c5d4610f996de2254ee2eca97aa2da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5490819a8d9ceedb98494b59ed05917" id="r_ad5490819a8d9ceedb98494b59ed05917"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5490819a8d9ceedb98494b59ed05917">install_bad_alloc_error_handler</a> (<a class="el" href="#aacde1332b72e968317ed516552a07ca8">fatal_error_handler_t</a> handler, void *user_data=nullptr)</td></tr>
<tr class="memdesc:ad5490819a8d9ceedb98494b59ed05917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a new bad alloc error handler that should be used whenever a bad alloc error, e.g.  <br /></td></tr>
<tr class="separator:ad5490819a8d9ceedb98494b59ed05917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69094b92cf05fe59b51ae012a03d9474" id="r_a69094b92cf05fe59b51ae012a03d9474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69094b92cf05fe59b51ae012a03d9474">remove_bad_alloc_error_handler</a> ()</td></tr>
<tr class="memdesc:a69094b92cf05fe59b51ae012a03d9474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores default bad alloc error handling behavior.  <br /></td></tr>
<tr class="separator:a69094b92cf05fe59b51ae012a03d9474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97e6b598cd8e5fe3f4d4e75e83dbb9e" id="r_ad97e6b598cd8e5fe3f4d4e75e83dbb9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad97e6b598cd8e5fe3f4d4e75e83dbb9e">install_out_of_memory_new_handler</a> ()</td></tr>
<tr class="separator:ad97e6b598cd8e5fe3f4d4e75e83dbb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3cd886beda7a2289aa18773f3aa103" id="r_a6e3cd886beda7a2289aa18773f3aa103"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e3cd886beda7a2289aa18773f3aa103">report_bad_alloc_error</a> (const char *Reason, bool GenCrashDiag=true)</td></tr>
<tr class="memdesc:a6e3cd886beda7a2289aa18773f3aa103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports a bad alloc error, calling any user defined bad alloc error handler.  <br /></td></tr>
<tr class="separator:a6e3cd886beda7a2289aa18773f3aa103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a330e37a0f2a3ac6bf2a664ea6d12db" id="r_a0a330e37a0f2a3ac6bf2a664ea6d12db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a330e37a0f2a3ac6bf2a664ea6d12db">wpi_unreachable_internal</a> (const char *msg=nullptr, const char *file=nullptr, unsigned line=0)</td></tr>
<tr class="memdesc:a0a330e37a0f2a3ac6bf2a664ea6d12db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calls abort(), and prints the optional message to stderr.  <br /></td></tr>
<tr class="separator:a0a330e37a0f2a3ac6bf2a664ea6d12db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805c424d8dd8935ad4d89f4e721b74f3" id="r_a805c424d8dd8935ad4d89f4e721b74f3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</td></tr>
<tr class="memitem:a805c424d8dd8935ad4d89f4e721b74f3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a805c424d8dd8935ad4d89f4e721b74f3">UnpackStruct</a> (std::span&lt; const uint8_t &gt; data, const I &amp;... info)</td></tr>
<tr class="memdesc:a805c424d8dd8935ad4d89f4e721b74f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a serialized struct.  <br /></td></tr>
<tr class="separator:a805c424d8dd8935ad4d89f4e721b74f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6b1367b38f8bb562b8a4fbeeeaa27c" id="r_acf6b1367b38f8bb562b8a4fbeeeaa27c"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Offset, typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</td></tr>
<tr class="memitem:acf6b1367b38f8bb562b8a4fbeeeaa27c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acf6b1367b38f8bb562b8a4fbeeeaa27c">UnpackStruct</a> (std::span&lt; const uint8_t &gt; data, const I &amp;... info)</td></tr>
<tr class="memdesc:acf6b1367b38f8bb562b8a4fbeeeaa27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a serialized struct starting at a given offset within the data.  <br /></td></tr>
<tr class="separator:acf6b1367b38f8bb562b8a4fbeeeaa27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81bdf06aca9f2529e7cd001103dffa0" id="r_ac81bdf06aca9f2529e7cd001103dffa0"><td class="memTemplParams" colspan="2">template&lt;StructSerializable T, size_t Offset, size_t N&gt; </td></tr>
<tr class="memitem:ac81bdf06aca9f2529e7cd001103dffa0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac81bdf06aca9f2529e7cd001103dffa0">UnpackStructArray</a> (std::span&lt; const uint8_t &gt; data)</td></tr>
<tr class="memdesc:ac81bdf06aca9f2529e7cd001103dffa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a serialized struct array starting at a given offset within the data.  <br /></td></tr>
<tr class="separator:ac81bdf06aca9f2529e7cd001103dffa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec17a5d90a5682c56cedc791280c3f24" id="r_aec17a5d90a5682c56cedc791280c3f24"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</td></tr>
<tr class="memitem:aec17a5d90a5682c56cedc791280c3f24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aec17a5d90a5682c56cedc791280c3f24">PackStruct</a> (std::span&lt; uint8_t &gt; data, T &amp;&amp;value, const I &amp;... info)</td></tr>
<tr class="memdesc:aec17a5d90a5682c56cedc791280c3f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a serialized struct.  <br /></td></tr>
<tr class="separator:aec17a5d90a5682c56cedc791280c3f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6a6f967162388cd2b16ff89ab37921" id="r_a9f6a6f967162388cd2b16ff89ab37921"><td class="memTemplParams" colspan="2">template&lt;size_t Offset, typename T , typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</td></tr>
<tr class="memitem:a9f6a6f967162388cd2b16ff89ab37921"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9f6a6f967162388cd2b16ff89ab37921">PackStruct</a> (std::span&lt; uint8_t &gt; data, T &amp;&amp;value, const I &amp;... info)</td></tr>
<tr class="memdesc:a9f6a6f967162388cd2b16ff89ab37921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a serialized struct starting at a given offset within the data.  <br /></td></tr>
<tr class="separator:a9f6a6f967162388cd2b16ff89ab37921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9475dc5093a863e98e3d87e80421719f" id="r_a9475dc5093a863e98e3d87e80421719f"><td class="memTemplParams" colspan="2">template&lt;size_t Offset, size_t N, StructSerializable T&gt; </td></tr>
<tr class="memitem:a9475dc5093a863e98e3d87e80421719f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9475dc5093a863e98e3d87e80421719f">PackStructArray</a> (std::span&lt; uint8_t &gt; data, const <a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; T, N &gt; &amp;arr)</td></tr>
<tr class="memdesc:a9475dc5093a863e98e3d87e80421719f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a serialized struct array starting at a given offset within the data.  <br /></td></tr>
<tr class="separator:a9475dc5093a863e98e3d87e80421719f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29496596f0788faf2bfefee4a32fda6f" id="r_a29496596f0788faf2bfefee4a32fda6f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</td></tr>
<tr class="memitem:a29496596f0788faf2bfefee4a32fda6f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a29496596f0788faf2bfefee4a32fda6f">UnpackStructInto</a> (T *out, std::span&lt; const uint8_t &gt; data, const I &amp;... info)</td></tr>
<tr class="memdesc:a29496596f0788faf2bfefee4a32fda6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a serialized struct into an existing object, overwriting its contents.  <br /></td></tr>
<tr class="separator:a29496596f0788faf2bfefee4a32fda6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8787a202964e86ce1d7f549504241fc" id="r_ad8787a202964e86ce1d7f549504241fc"><td class="memTemplParams" colspan="2">template&lt;size_t Offset, typename T , typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</td></tr>
<tr class="memitem:ad8787a202964e86ce1d7f549504241fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad8787a202964e86ce1d7f549504241fc">UnpackStructInto</a> (T *out, std::span&lt; const uint8_t &gt; data, const I &amp;... info)</td></tr>
<tr class="memdesc:ad8787a202964e86ce1d7f549504241fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a serialized struct into an existing object, overwriting its contents, and starting at a given offset within the data.  <br /></td></tr>
<tr class="separator:ad8787a202964e86ce1d7f549504241fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0811bc73046b235809bcc275bb3682" id="r_a9b0811bc73046b235809bcc275bb3682"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</td></tr>
<tr class="memitem:a9b0811bc73046b235809bcc275bb3682"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9b0811bc73046b235809bcc275bb3682">GetStructTypeName</a> (const I &amp;... info)</td></tr>
<tr class="memdesc:a9b0811bc73046b235809bcc275bb3682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type name for a raw struct serializable type.  <br /></td></tr>
<tr class="separator:a9b0811bc73046b235809bcc275bb3682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0249983b0ac0f153c86b6ca79937c1fb" id="r_a0249983b0ac0f153c86b6ca79937c1fb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</td></tr>
<tr class="memitem:a0249983b0ac0f153c86b6ca79937c1fb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0249983b0ac0f153c86b6ca79937c1fb">GetStructTypeString</a> (const I &amp;... info)</td></tr>
<tr class="memdesc:a0249983b0ac0f153c86b6ca79937c1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type string for a raw struct serializable type.  <br /></td></tr>
<tr class="separator:a0249983b0ac0f153c86b6ca79937c1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54cf203a3da0455d74c23f253c13639" id="r_ab54cf203a3da0455d74c23f253c13639"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</td></tr>
<tr class="memitem:ab54cf203a3da0455d74c23f253c13639"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab54cf203a3da0455d74c23f253c13639">GetStructSize</a> (const I &amp;... info)</td></tr>
<tr class="memdesc:ab54cf203a3da0455d74c23f253c13639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size for a raw struct serializable type.  <br /></td></tr>
<tr class="separator:ab54cf203a3da0455d74c23f253c13639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08be78834f39daf48110ff9e98e6e840" id="r_a08be78834f39daf48110ff9e98e6e840"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</td></tr>
<tr class="memitem:a08be78834f39daf48110ff9e98e6e840"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a08be78834f39daf48110ff9e98e6e840">MakeStructArrayTypeName</a> (const I &amp;... info)</td></tr>
<tr class="separator:a08be78834f39daf48110ff9e98e6e840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceec6c891e38c5857a21892f7cd3d94" id="r_a7ceec6c891e38c5857a21892f7cd3d94"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</td></tr>
<tr class="memitem:a7ceec6c891e38c5857a21892f7cd3d94"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7ceec6c891e38c5857a21892f7cd3d94">MakeStructArrayTypeString</a> (const I &amp;... info)</td></tr>
<tr class="separator:a7ceec6c891e38c5857a21892f7cd3d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f627b8aa91ec48125d72a895d54924" id="r_a22f627b8aa91ec48125d72a895d54924"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</td></tr>
<tr class="memitem:a22f627b8aa91ec48125d72a895d54924"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a22f627b8aa91ec48125d72a895d54924">MakeStructArraySchema</a> (const I &amp;... info)</td></tr>
<tr class="separator:a22f627b8aa91ec48125d72a895d54924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975d368152ea01b5199b4040293ce52d" id="r_a975d368152ea01b5199b4040293ce52d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</td></tr>
<tr class="memitem:a975d368152ea01b5199b4040293ce52d"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::string_view&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a975d368152ea01b5199b4040293ce52d">GetStructSchema</a> (const I &amp;... info)</td></tr>
<tr class="separator:a975d368152ea01b5199b4040293ce52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2ad040d89f1db413517d3f8777c3c3" id="r_a8d2ad040d89f1db413517d3f8777c3c3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</td></tr>
<tr class="memitem:a8d2ad040d89f1db413517d3f8777c3c3"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::span&lt; const uint8_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8d2ad040d89f1db413517d3f8777c3c3">GetStructSchemaBytes</a> (const I &amp;... info)</td></tr>
<tr class="separator:a8d2ad040d89f1db413517d3f8777c3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4c7fb7a4c097ca545d416153dc0a9b" id="r_aba4c7fb7a4c097ca545d416153dc0a9b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</td></tr>
<tr class="memitem:aba4c7fb7a4c097ca545d416153dc0a9b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aba4c7fb7a4c097ca545d416153dc0a9b">ForEachStructSchema</a> (std::invocable&lt; std::string_view, std::string_view &gt; auto fn, const I &amp;... info)</td></tr>
<tr class="separator:aba4c7fb7a4c097ca545d416153dc0a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb20671f09fd21f4f52662c86fd6521" id="r_a6bb20671f09fd21f4f52662c86fd6521"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bb20671f09fd21f4f52662c86fd6521">make_error_code</a> (<a class="el" href="#a0cc73ce1be7e2680fb97374e03368001">errc</a> E)</td></tr>
<tr class="separator:a6bb20671f09fd21f4f52662c86fd6521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c6f38176a757997f4548366d10941c" id="r_ac2c6f38176a757997f4548366d10941c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2c6f38176a757997f4548366d10941c">operator&lt;&lt;</a> (<a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;OS, <a class="el" href="namespacewpi_1_1sys.html#abb2f430c92b93a1558fed9d588b7c199">sys::TimePoint</a>&lt;&gt; TP)</td></tr>
<tr class="separator:ac2c6f38176a757997f4548366d10941c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4d33e6dd228017533698524332016c" id="r_a7d4d33e6dd228017533698524332016c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d4d33e6dd228017533698524332016c">operator&lt;&lt;</a> (<a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;OS, <a class="el" href="namespacewpi_1_1sys.html#a79528fc04bbfce5e003543aac3a9a5a1">sys::UtcTime</a>&lt;&gt; TP)</td></tr>
<tr class="separator:a7d4d33e6dd228017533698524332016c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1505100db54c65ffa211cd4f6e49e4e" id="r_ac1505100db54c65ffa211cd4f6e49e4e"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ac1505100db54c65ffa211cd4f6e49e4e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac1505100db54c65ffa211cd4f6e49e4e">print</a> (fmt::format_string&lt; T... &gt; fmt, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac1505100db54c65ffa211cd4f6e49e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around fmt::print() that squelches write failure exceptions.  <br /></td></tr>
<tr class="separator:ac1505100db54c65ffa211cd4f6e49e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3054f74d1db148eb857efc543e6aba99" id="r_a3054f74d1db148eb857efc543e6aba99"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a3054f74d1db148eb857efc543e6aba99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3054f74d1db148eb857efc543e6aba99">print</a> (std::FILE *f, fmt::format_string&lt; T... &gt; fmt, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3054f74d1db148eb857efc543e6aba99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around fmt::print() that squelches write failure exceptions.  <br /></td></tr>
<tr class="separator:a3054f74d1db148eb857efc543e6aba99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6daa0f43b081b200b41744eef996c775" id="r_a6daa0f43b081b200b41744eef996c775"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a6daa0f43b081b200b41744eef996c775"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6daa0f43b081b200b41744eef996c775">println</a> (fmt::format_string&lt; T... &gt; fmt, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6daa0f43b081b200b41744eef996c775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around fmt::println() that squelches write failure exceptions.  <br /></td></tr>
<tr class="separator:a6daa0f43b081b200b41744eef996c775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffbe8b1dd8d4cbc82a26e9e96bfa1e7" id="r_abffbe8b1dd8d4cbc82a26e9e96bfa1e7"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:abffbe8b1dd8d4cbc82a26e9e96bfa1e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abffbe8b1dd8d4cbc82a26e9e96bfa1e7">println</a> (std::FILE *f, fmt::format_string&lt; T... &gt; fmt, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:abffbe8b1dd8d4cbc82a26e9e96bfa1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around fmt::println() that squelches write failure exceptions.  <br /></td></tr>
<tr class="separator:abffbe8b1dd8d4cbc82a26e9e96bfa1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1ac8844d24e58fc06de7d1270f0c7d" id="r_afd1ac8844d24e58fc06de7d1270f0c7d"><td class="memTemplParams" colspan="2">template&lt;typename PtrType &gt; </td></tr>
<tr class="memitem:afd1ac8844d24e58fc06de7d1270f0c7d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afd1ac8844d24e58fc06de7d1270f0c7d">operator==</a> (const <a class="el" href="classwpi_1_1_small_ptr_set_impl.html">SmallPtrSetImpl</a>&lt; PtrType &gt; &amp;LHS, const <a class="el" href="classwpi_1_1_small_ptr_set_impl.html">SmallPtrSetImpl</a>&lt; PtrType &gt; &amp;RHS)</td></tr>
<tr class="memdesc:afd1ac8844d24e58fc06de7d1270f0c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison for <a class="el" href="classwpi_1_1_small_ptr_set.html" title="SmallPtrSet - This class implements a set which is optimized for holding SmallSize or less elements.">SmallPtrSet</a>.  <br /></td></tr>
<tr class="separator:afd1ac8844d24e58fc06de7d1270f0c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3493bed4041adb43e57361d40517a4d4" id="r_a3493bed4041adb43e57361d40517a4d4"><td class="memTemplParams" colspan="2">template&lt;typename PtrType &gt; </td></tr>
<tr class="memitem:a3493bed4041adb43e57361d40517a4d4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3493bed4041adb43e57361d40517a4d4">operator!=</a> (const <a class="el" href="classwpi_1_1_small_ptr_set_impl.html">SmallPtrSetImpl</a>&lt; PtrType &gt; &amp;LHS, const <a class="el" href="classwpi_1_1_small_ptr_set_impl.html">SmallPtrSetImpl</a>&lt; PtrType &gt; &amp;RHS)</td></tr>
<tr class="memdesc:a3493bed4041adb43e57361d40517a4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison for <a class="el" href="classwpi_1_1_small_ptr_set.html" title="SmallPtrSet - This class implements a set which is optimized for holding SmallSize or less elements.">SmallPtrSet</a>.  <br /></td></tr>
<tr class="separator:a3493bed4041adb43e57361d40517a4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86c906a89fdf1dbeb5491c1b2a3dc12" id="r_af86c906a89fdf1dbeb5491c1b2a3dc12"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af86c906a89fdf1dbeb5491c1b2a3dc12">NowDefault</a> ()</td></tr>
<tr class="memdesc:af86c906a89fdf1dbeb5491c1b2a3dc12"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default implementation used for <a class="el" href="#af041f6643f3d0d18e0f8430bf0617dda" title="Return a value representing the current time in microseconds.">Now()</a>.  <br /></td></tr>
<tr class="separator:af86c906a89fdf1dbeb5491c1b2a3dc12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74f2f6f8a5413fcad6121a6f455bab6" id="r_af74f2f6f8a5413fcad6121a6f455bab6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af74f2f6f8a5413fcad6121a6f455bab6">SetNowImpl</a> (uint64_t(*func)())</td></tr>
<tr class="memdesc:af74f2f6f8a5413fcad6121a6f455bab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the implementation used by <a class="el" href="#af041f6643f3d0d18e0f8430bf0617dda" title="Return a value representing the current time in microseconds.">Now()</a>.  <br /></td></tr>
<tr class="separator:af74f2f6f8a5413fcad6121a6f455bab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af041f6643f3d0d18e0f8430bf0617dda" id="r_af041f6643f3d0d18e0f8430bf0617dda"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af041f6643f3d0d18e0f8430bf0617dda">Now</a> ()</td></tr>
<tr class="memdesc:af041f6643f3d0d18e0f8430bf0617dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a value representing the current time in microseconds.  <br /></td></tr>
<tr class="separator:af041f6643f3d0d18e0f8430bf0617dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d28c0c9406326aabe2f414979901b37" id="r_a9d28c0c9406326aabe2f414979901b37"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d28c0c9406326aabe2f414979901b37">GetSystemTime</a> ()</td></tr>
<tr class="memdesc:a9d28c0c9406326aabe2f414979901b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current system time in microseconds since the Unix epoch (January 1st, 1970 00:00 UTC).  <br /></td></tr>
<tr class="separator:a9d28c0c9406326aabe2f414979901b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d4bc587263ead52e3057e41d1bcad8" id="r_a20d4bc587263ead52e3057e41d1bcad8"><td class="memTemplParams" colspan="2">template&lt;typename ValueTy &gt; </td></tr>
<tr class="memitem:a20d4bc587263ead52e3057e41d1bcad8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a20d4bc587263ead52e3057e41d1bcad8">operator==</a> (const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;lhs, const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;rhs)</td></tr>
<tr class="separator:a20d4bc587263ead52e3057e41d1bcad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5de24f32a5e0e34e26400e1d2d019ab" id="r_ae5de24f32a5e0e34e26400e1d2d019ab"><td class="memTemplParams" colspan="2">template&lt;typename ValueTy &gt; </td></tr>
<tr class="memitem:ae5de24f32a5e0e34e26400e1d2d019ab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae5de24f32a5e0e34e26400e1d2d019ab">operator!=</a> (const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;lhs, const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;rhs)</td></tr>
<tr class="separator:ae5de24f32a5e0e34e26400e1d2d019ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0497f3ae3790ae4464ca31a28110983f" id="r_a0497f3ae3790ae4464ca31a28110983f"><td class="memTemplParams" colspan="2">template&lt;typename ValueTy &gt; </td></tr>
<tr class="memitem:a0497f3ae3790ae4464ca31a28110983f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0497f3ae3790ae4464ca31a28110983f">operator&lt;</a> (const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;lhs, const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;rhs)</td></tr>
<tr class="separator:a0497f3ae3790ae4464ca31a28110983f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9955629bd414f4388de1629bbe618d" id="r_afe9955629bd414f4388de1629bbe618d"><td class="memTemplParams" colspan="2">template&lt;typename ValueTy &gt; </td></tr>
<tr class="memitem:afe9955629bd414f4388de1629bbe618d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afe9955629bd414f4388de1629bbe618d">operator&lt;=</a> (const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;lhs, const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;rhs)</td></tr>
<tr class="separator:afe9955629bd414f4388de1629bbe618d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f5d37ffdbdece9dc4a138912d2384d" id="r_af9f5d37ffdbdece9dc4a138912d2384d"><td class="memTemplParams" colspan="2">template&lt;typename ValueTy &gt; </td></tr>
<tr class="memitem:af9f5d37ffdbdece9dc4a138912d2384d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af9f5d37ffdbdece9dc4a138912d2384d">operator&gt;</a> (const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;lhs, const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;rhs)</td></tr>
<tr class="separator:af9f5d37ffdbdece9dc4a138912d2384d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5ef98f7e590a36648bdff48b4dfc57" id="r_a0f5ef98f7e590a36648bdff48b4dfc57"><td class="memTemplParams" colspan="2">template&lt;typename ValueTy &gt; </td></tr>
<tr class="memitem:a0f5ef98f7e590a36648bdff48b4dfc57"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f5ef98f7e590a36648bdff48b4dfc57">operator&gt;=</a> (const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;lhs, const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;rhs)</td></tr>
<tr class="separator:a0f5ef98f7e590a36648bdff48b4dfc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae690f31454289b0d204da17bb50ed283" id="r_ae690f31454289b0d204da17bb50ed283"><td class="memTemplParams" colspan="2">template&lt;typename RangeT &gt; </td></tr>
<tr class="memitem:ae690f31454289b0d204da17bb50ed283"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae690f31454289b0d204da17bb50ed283">adl_begin</a> (RangeT &amp;&amp;range) -&gt; decltype(<a class="el" href="namespacewpi_1_1adl__detail.html#a875442e69c8d0c96baae38beb15d4b53">adl_detail::begin_impl</a>(std::forward&lt; RangeT &gt;(range)))</td></tr>
<tr class="memdesc:ae690f31454289b0d204da17bb50ed283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the begin iterator to <code>range</code> using <code>std::begin</code> and function found through Argument-Dependent Lookup (ADL).  <br /></td></tr>
<tr class="separator:ae690f31454289b0d204da17bb50ed283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711873ab0b6ad59448d62e6390a1ed46" id="r_a711873ab0b6ad59448d62e6390a1ed46"><td class="memTemplParams" colspan="2">template&lt;typename RangeT &gt; </td></tr>
<tr class="memitem:a711873ab0b6ad59448d62e6390a1ed46"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a711873ab0b6ad59448d62e6390a1ed46">adl_end</a> (RangeT &amp;&amp;range) -&gt; decltype(<a class="el" href="namespacewpi_1_1adl__detail.html#aca2bc37a44dcab71d6e8d0a4a1534b23">adl_detail::end_impl</a>(std::forward&lt; RangeT &gt;(range)))</td></tr>
<tr class="memdesc:a711873ab0b6ad59448d62e6390a1ed46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the end iterator to <code>range</code> using <code>std::end</code> and functions found through Argument-Dependent Lookup (ADL).  <br /></td></tr>
<tr class="separator:a711873ab0b6ad59448d62e6390a1ed46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca907320830d0935f09090e656edd87" id="r_a9ca907320830d0935f09090e656edd87"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ca907320830d0935f09090e656edd87"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9ca907320830d0935f09090e656edd87">adl_swap</a> (T &amp;&amp;lhs, T &amp;&amp;rhs) noexcept(noexcept(<a class="el" href="namespacewpi_1_1adl__detail.html#a2f6f95e4ac4e13f0a0881dc6d718bb08">adl_detail::swap_impl</a>(std::declval&lt; T &gt;(), std::declval&lt; T &gt;())))</td></tr>
<tr class="memdesc:a9ca907320830d0935f09090e656edd87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <code>lhs</code> with <code>rhs</code> using <code><a class="el" href="namespacestd.html#ae7bc1bfb88e72f65528fc6cf9f362454" title="exchanges the values of two JSON objects">std::swap</a></code> and functions found through Argument-Dependent Lookup (ADL).  <br /></td></tr>
<tr class="separator:a9ca907320830d0935f09090e656edd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb08412efb94d58af17974d77d38bdd" id="r_a2eb08412efb94d58af17974d77d38bdd"><td class="memTemplParams" colspan="2">template&lt;typename RangeT &gt; </td></tr>
<tr class="memitem:a2eb08412efb94d58af17974d77d38bdd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2eb08412efb94d58af17974d77d38bdd">adl_size</a> (RangeT &amp;&amp;range) -&gt; decltype(<a class="el" href="namespacewpi_1_1adl__detail.html#a9cc52aaa08a8db03cf7e3f78d526a4e3">adl_detail::size_impl</a>(std::forward&lt; RangeT &gt;(range)))</td></tr>
<tr class="memdesc:a2eb08412efb94d58af17974d77d38bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of <code>range</code> using <code>std::size</code> and functions found through Argument-Dependent Lookup (ADL).  <br /></td></tr>
<tr class="separator:a2eb08412efb94d58af17974d77d38bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93b7de1e962f6dbca1b8d2f09402624" id="r_ac93b7de1e962f6dbca1b8d2f09402624"><td class="memTemplParams" colspan="2">template&lt;class Lambda , int  = (Lambda{}(), 0)&gt; </td></tr>
<tr class="memitem:ac93b7de1e962f6dbca1b8d2f09402624"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac93b7de1e962f6dbca1b8d2f09402624">is_constexpr</a> (Lambda)</td></tr>
<tr class="separator:ac93b7de1e962f6dbca1b8d2f09402624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5118b70b1397ab73ebbd7c5d9d7aec29" id="r_a5118b70b1397ab73ebbd7c5d9d7aec29"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5118b70b1397ab73ebbd7c5d9d7aec29">is_constexpr</a> (...)</td></tr>
<tr class="separator:a5118b70b1397ab73ebbd7c5d9d7aec29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ee7f9c4e98f812609c2ab856f31d40" id="r_aa4ee7f9c4e98f812609c2ab856f31d40"><td class="memTemplParams" colspan="2">template&lt;ProtobufSerializable T&gt; </td></tr>
<tr class="memitem:aa4ee7f9c4e98f812609c2ab856f31d40"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa4ee7f9c4e98f812609c2ab856f31d40">UnpackProtobuf</a> (const google::protobuf::Message &amp;msg)</td></tr>
<tr class="memdesc:aa4ee7f9c4e98f812609c2ab856f31d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a serialized protobuf message.  <br /></td></tr>
<tr class="separator:aa4ee7f9c4e98f812609c2ab856f31d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafde714844c14477f295d1ac911b35b" id="r_aaafde714844c14477f295d1ac911b35b"><td class="memTemplParams" colspan="2">template&lt;std::derived_from&lt; google::protobuf::Message &gt; Proto, ProtobufSerializable T, size_t N&gt; </td></tr>
<tr class="memitem:aaafde714844c14477f295d1ac911b35b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaafde714844c14477f295d1ac911b35b">UnpackProtobufArray</a> (const <a class="el" href="classgoogle_1_1protobuf_1_1_repeated_ptr_field.html">google::protobuf::RepeatedPtrField</a>&lt; Proto &gt; &amp;msg)</td></tr>
<tr class="memdesc:aaafde714844c14477f295d1ac911b35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a serialized protobuf array message.  <br /></td></tr>
<tr class="separator:aaafde714844c14477f295d1ac911b35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e94022d22c588092a8d275add89ce6" id="r_a41e94022d22c588092a8d275add89ce6"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a41e94022d22c588092a8d275add89ce6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a41e94022d22c588092a8d275add89ce6">UnpackProtobufArray</a> (const <a class="el" href="classgoogle_1_1protobuf_1_1_repeated_field.html">google::protobuf::RepeatedField</a>&lt; T &gt; &amp;msg)</td></tr>
<tr class="memdesc:a41e94022d22c588092a8d275add89ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a serialized protobuf array message.  <br /></td></tr>
<tr class="separator:a41e94022d22c588092a8d275add89ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a29dc82fea465b35449b563c1ddf99" id="r_a97a29dc82fea465b35449b563c1ddf99"><td class="memTemplParams" colspan="2">template&lt;ProtobufSerializable T&gt; </td></tr>
<tr class="memitem:a97a29dc82fea465b35449b563c1ddf99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a97a29dc82fea465b35449b563c1ddf99">PackProtobuf</a> (google::protobuf::Message *msg, const T &amp;value)</td></tr>
<tr class="memdesc:a97a29dc82fea465b35449b563c1ddf99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a serialized protobuf message.  <br /></td></tr>
<tr class="separator:a97a29dc82fea465b35449b563c1ddf99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6205d9674eca9725b95390234b546578" id="r_a6205d9674eca9725b95390234b546578"><td class="memTemplParams" colspan="2">template&lt;std::derived_from&lt; google::protobuf::Message &gt; Proto, ProtobufSerializable T, size_t N&gt; </td></tr>
<tr class="memitem:a6205d9674eca9725b95390234b546578"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6205d9674eca9725b95390234b546578">PackProtobufArray</a> (<a class="el" href="classgoogle_1_1protobuf_1_1_repeated_ptr_field.html">google::protobuf::RepeatedPtrField</a>&lt; Proto &gt; *msg, const <a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; T, N &gt; &amp;arr)</td></tr>
<tr class="memdesc:a6205d9674eca9725b95390234b546578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a serialized protobuf array message.  <br /></td></tr>
<tr class="separator:a6205d9674eca9725b95390234b546578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ba7696776a7e8d599809fa95f31324" id="r_a52ba7696776a7e8d599809fa95f31324"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a52ba7696776a7e8d599809fa95f31324"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a52ba7696776a7e8d599809fa95f31324">PackProtobufArray</a> (<a class="el" href="classgoogle_1_1protobuf_1_1_repeated_field.html">google::protobuf::RepeatedField</a>&lt; T &gt; *msg, const <a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; T, N &gt; &amp;arr)</td></tr>
<tr class="memdesc:a52ba7696776a7e8d599809fa95f31324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a serialized protobuf array message.  <br /></td></tr>
<tr class="separator:a52ba7696776a7e8d599809fa95f31324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca8a1c440adfd6e059ada60de9e65c3" id="r_aaca8a1c440adfd6e059ada60de9e65c3"><td class="memTemplParams" colspan="2">template&lt;ProtobufSerializable T&gt; </td></tr>
<tr class="memitem:aaca8a1c440adfd6e059ada60de9e65c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaca8a1c440adfd6e059ada60de9e65c3">UnpackProtobufInto</a> (T *out, const google::protobuf::Message &amp;msg)</td></tr>
<tr class="memdesc:aaca8a1c440adfd6e059ada60de9e65c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a serialized struct into an existing object, overwriting its contents.  <br /></td></tr>
<tr class="separator:aaca8a1c440adfd6e059ada60de9e65c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e3119bfa85b395027a18a9260bc886" id="r_a74e3119bfa85b395027a18a9260bc886"><td class="memItemLeft" align="right" valign="top">constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74e3119bfa85b395027a18a9260bc886">to_string_view</a> (const struct <a class="el" href="struct_w_p_i___string.html">WPI_String</a> *str)</td></tr>
<tr class="memdesc:a74e3119bfa85b395027a18a9260bc886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="struct_w_p_i___string.html" title="A const UTF8 string.">WPI_String</a> to a string_view.  <br /></td></tr>
<tr class="separator:a74e3119bfa85b395027a18a9260bc886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5268f68b492ea1c161566db733dfbb" id="r_aba5268f68b492ea1c161566db733dfbb"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_w_p_i___string.html">WPI_String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba5268f68b492ea1c161566db733dfbb">make_string</a> (std::string_view view)</td></tr>
<tr class="memdesc:aba5268f68b492ea1c161566db733dfbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string_view to a <a class="el" href="struct_w_p_i___string.html" title="A const UTF8 string.">WPI_String</a>.  <br /></td></tr>
<tr class="separator:aba5268f68b492ea1c161566db733dfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9adbe1d3698433c32c8b78b84f582a5b" id="r_a9adbe1d3698433c32c8b78b84f582a5b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9adbe1d3698433c32c8b78b84f582a5b">GetHostname</a> ()</td></tr>
<tr class="separator:a9adbe1d3698433c32c8b78b84f582a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c253c393e339cc29a6e8ff9cb648420" id="r_a3c253c393e339cc29a6e8ff9cb648420"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c253c393e339cc29a6e8ff9cb648420">GetHostname</a> (<a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;name)</td></tr>
<tr class="separator:a3c253c393e339cc29a6e8ff9cb648420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f6e4aff6a38bb792fead8152d3f1f9" id="r_ac6f6e4aff6a38bb792fead8152d3f1f9"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ac6f6e4aff6a38bb792fead8152d3f1f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac6f6e4aff6a38bb792fead8152d3f1f9">operator==</a> (const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;lhs, const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;rhs)</td></tr>
<tr class="separator:ac6f6e4aff6a38bb792fead8152d3f1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a8f0c09fa990ccc76d3be676c434ec" id="r_ac7a8f0c09fa990ccc76d3be676c434ec"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ac7a8f0c09fa990ccc76d3be676c434ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac7a8f0c09fa990ccc76d3be676c434ec">operator!=</a> (const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;lhs, const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;rhs)</td></tr>
<tr class="separator:ac7a8f0c09fa990ccc76d3be676c434ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f4db75c03a9da9d2159a1ea1263f83" id="r_a67f4db75c03a9da9d2159a1ea1263f83"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a67f4db75c03a9da9d2159a1ea1263f83"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a67f4db75c03a9da9d2159a1ea1263f83">operator&lt;</a> (const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;lhs, const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;rhs)</td></tr>
<tr class="separator:a67f4db75c03a9da9d2159a1ea1263f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e46980861d4cee757e1205bba80f44a" id="r_a8e46980861d4cee757e1205bba80f44a"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a8e46980861d4cee757e1205bba80f44a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8e46980861d4cee757e1205bba80f44a">operator&lt;=</a> (const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;lhs, const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;rhs)</td></tr>
<tr class="separator:a8e46980861d4cee757e1205bba80f44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f869097cbd300cfeed6e63d2318b04" id="r_a21f869097cbd300cfeed6e63d2318b04"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a21f869097cbd300cfeed6e63d2318b04"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a21f869097cbd300cfeed6e63d2318b04">operator&gt;</a> (const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;lhs, const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;rhs)</td></tr>
<tr class="separator:a21f869097cbd300cfeed6e63d2318b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7557a7ad21a5e7fa2f1be542b4e1d3" id="r_a9f7557a7ad21a5e7fa2f1be542b4e1d3"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a9f7557a7ad21a5e7fa2f1be542b4e1d3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9f7557a7ad21a5e7fa2f1be542b4e1d3">operator&gt;=</a> (const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;lhs, const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;rhs)</td></tr>
<tr class="separator:a9f7557a7ad21a5e7fa2f1be542b4e1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39dedecbcd080adc1e8208e016b5974b" id="r_a39dedecbcd080adc1e8208e016b5974b"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a39dedecbcd080adc1e8208e016b5974b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; typename std::decay&lt; E &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a39dedecbcd080adc1e8208e016b5974b">make_unexpected</a> (E &amp;&amp;e)</td></tr>
<tr class="separator:a39dedecbcd080adc1e8208e016b5974b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18d4042818206dca90b1775d44c0aec" id="r_aa18d4042818206dca90b1775d44c0aec"><td class="memTemplParams" colspan="2">template&lt;class T , class E , class U , class F &gt; </td></tr>
<tr class="memitem:aa18d4042818206dca90b1775d44c0aec"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa18d4042818206dca90b1775d44c0aec">operator==</a> (const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;lhs, const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; U, F &gt; &amp;rhs)</td></tr>
<tr class="separator:aa18d4042818206dca90b1775d44c0aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24823b06d3080f4378d7eb86519c4141" id="r_a24823b06d3080f4378d7eb86519c4141"><td class="memTemplParams" colspan="2">template&lt;class T , class E , class U , class F &gt; </td></tr>
<tr class="memitem:a24823b06d3080f4378d7eb86519c4141"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a24823b06d3080f4378d7eb86519c4141">operator!=</a> (const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;lhs, const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; U, F &gt; &amp;rhs)</td></tr>
<tr class="separator:a24823b06d3080f4378d7eb86519c4141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc620acab606fb0d6e751c7709d4795" id="r_abfc620acab606fb0d6e751c7709d4795"><td class="memTemplParams" colspan="2">template&lt;class E , class F &gt; </td></tr>
<tr class="memitem:abfc620acab606fb0d6e751c7709d4795"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abfc620acab606fb0d6e751c7709d4795">operator==</a> (const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; void, E &gt; &amp;lhs, const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; void, F &gt; &amp;rhs)</td></tr>
<tr class="separator:abfc620acab606fb0d6e751c7709d4795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4888ad0dc554c31bf61fde6aee5d82ee" id="r_a4888ad0dc554c31bf61fde6aee5d82ee"><td class="memTemplParams" colspan="2">template&lt;class E , class F &gt; </td></tr>
<tr class="memitem:a4888ad0dc554c31bf61fde6aee5d82ee"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4888ad0dc554c31bf61fde6aee5d82ee">operator!=</a> (const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; void, E &gt; &amp;lhs, const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; void, F &gt; &amp;rhs)</td></tr>
<tr class="separator:a4888ad0dc554c31bf61fde6aee5d82ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bb76c48fdcecdd9cebe482488fd31f" id="r_ac5bb76c48fdcecdd9cebe482488fd31f"><td class="memTemplParams" colspan="2">template&lt;class T , class E , class U &gt; </td></tr>
<tr class="memitem:ac5bb76c48fdcecdd9cebe482488fd31f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac5bb76c48fdcecdd9cebe482488fd31f">operator==</a> (const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x, const U &amp;v)</td></tr>
<tr class="separator:ac5bb76c48fdcecdd9cebe482488fd31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28e5992a79afeddc6f36986e8f4747c" id="r_ac28e5992a79afeddc6f36986e8f4747c"><td class="memTemplParams" colspan="2">template&lt;class T , class E , class U &gt; </td></tr>
<tr class="memitem:ac28e5992a79afeddc6f36986e8f4747c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac28e5992a79afeddc6f36986e8f4747c">operator==</a> (const U &amp;v, const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x)</td></tr>
<tr class="separator:ac28e5992a79afeddc6f36986e8f4747c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70436e5fc0d405e66d861bd82a41b8aa" id="r_a70436e5fc0d405e66d861bd82a41b8aa"><td class="memTemplParams" colspan="2">template&lt;class T , class E , class U &gt; </td></tr>
<tr class="memitem:a70436e5fc0d405e66d861bd82a41b8aa"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a70436e5fc0d405e66d861bd82a41b8aa">operator!=</a> (const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x, const U &amp;v)</td></tr>
<tr class="separator:a70436e5fc0d405e66d861bd82a41b8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf2ccf060494e397a073e1d790f0965" id="r_abdf2ccf060494e397a073e1d790f0965"><td class="memTemplParams" colspan="2">template&lt;class T , class E , class U &gt; </td></tr>
<tr class="memitem:abdf2ccf060494e397a073e1d790f0965"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abdf2ccf060494e397a073e1d790f0965">operator!=</a> (const U &amp;v, const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x)</td></tr>
<tr class="separator:abdf2ccf060494e397a073e1d790f0965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc5fbe0d0b8dacb813befbc51ab62be" id="r_acdc5fbe0d0b8dacb813befbc51ab62be"><td class="memTemplParams" colspan="2">template&lt;class T , class E &gt; </td></tr>
<tr class="memitem:acdc5fbe0d0b8dacb813befbc51ab62be"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acdc5fbe0d0b8dacb813befbc51ab62be">operator==</a> (const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x, const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;e)</td></tr>
<tr class="separator:acdc5fbe0d0b8dacb813befbc51ab62be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f613143cd18d99120248fe6da7e837" id="r_af3f613143cd18d99120248fe6da7e837"><td class="memTemplParams" colspan="2">template&lt;class T , class E &gt; </td></tr>
<tr class="memitem:af3f613143cd18d99120248fe6da7e837"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af3f613143cd18d99120248fe6da7e837">operator==</a> (const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;e, const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x)</td></tr>
<tr class="separator:af3f613143cd18d99120248fe6da7e837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25324caffea3cc810a10ad48f937036" id="r_ad25324caffea3cc810a10ad48f937036"><td class="memTemplParams" colspan="2">template&lt;class T , class E &gt; </td></tr>
<tr class="memitem:ad25324caffea3cc810a10ad48f937036"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad25324caffea3cc810a10ad48f937036">operator!=</a> (const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x, const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;e)</td></tr>
<tr class="separator:ad25324caffea3cc810a10ad48f937036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3967898dc4d02842e7124a25ff5c06" id="r_afe3967898dc4d02842e7124a25ff5c06"><td class="memTemplParams" colspan="2">template&lt;class T , class E &gt; </td></tr>
<tr class="memitem:afe3967898dc4d02842e7124a25ff5c06"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afe3967898dc4d02842e7124a25ff5c06">operator!=</a> (const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;e, const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x)</td></tr>
<tr class="separator:afe3967898dc4d02842e7124a25ff5c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3084aaf9d059654958af201cad67e70a" id="r_a3084aaf9d059654958af201cad67e70a"><td class="memTemplParams" colspan="2">template&lt;class T , class E , <a class="el" href="namespacewpi_1_1detail__expected.html#ae16eac50d15e3d1edb9c7106933dc891">detail_expected::enable_if_t</a>&lt;(std::is_void&lt; T &gt;::value||std::is_move_constructible&lt; T &gt;::value) &amp;&amp;<a class="el" href="structwpi_1_1detail__expected_1_1is__swappable.html">detail_expected::is_swappable</a>&lt; T &gt;::value &amp;&amp;std::is_move_constructible&lt; E &gt;::value &amp;&amp;<a class="el" href="structwpi_1_1detail__expected_1_1is__swappable.html">detail_expected::is_swappable</a>&lt; E &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3084aaf9d059654958af201cad67e70a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3084aaf9d059654958af201cad67e70a">swap</a> (<a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;lhs, <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;rhs) noexcept(noexcept(lhs.swap(rhs)))</td></tr>
<tr class="separator:a3084aaf9d059654958af201cad67e70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55235b8d8fe2b869b11a04237f1c1b5f" id="r_a55235b8d8fe2b869b11a04237f1c1b5f"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55235b8d8fe2b869b11a04237f1c1b5f">UnescapeURI</a> (std::string_view str, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;buf, bool *error)</td></tr>
<tr class="separator:a55235b8d8fe2b869b11a04237f1c1b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e885a95d4fbe472d78076ecc824194" id="r_ab6e885a95d4fbe472d78076ecc824194"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6e885a95d4fbe472d78076ecc824194">EscapeURI</a> (std::string_view str, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;buf, bool spacePlus=true)</td></tr>
<tr class="separator:ab6e885a95d4fbe472d78076ecc824194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12877798c9e05cae590789ebe25883b7" id="r_a12877798c9e05cae590789ebe25883b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12877798c9e05cae590789ebe25883b7">ParseHttpHeaders</a> (<a class="el" href="classwpi_1_1raw__istream.html">raw_istream</a> &amp;is, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; *contentType, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; *contentLength)</td></tr>
<tr class="separator:a12877798c9e05cae590789ebe25883b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efec7766be35df2a4782f6cb1004058" id="r_a8efec7766be35df2a4782f6cb1004058"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8efec7766be35df2a4782f6cb1004058">FindMultipartBoundary</a> (<a class="el" href="classwpi_1_1raw__istream.html">wpi::raw_istream</a> &amp;is, std::string_view boundary, std::string *saveBuf)</td></tr>
<tr class="separator:a8efec7766be35df2a4782f6cb1004058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bada7642f7a62d2271fd42cd0cb01f3" id="r_a4bada7642f7a62d2271fd42cd0cb01f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bada7642f7a62d2271fd42cd0cb01f3">ConvertUTF8toUTF16</a> (const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **sourceStart, const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *sourceEnd, <a class="el" href="#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> **targetStart, <a class="el" href="#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> *targetEnd, <a class="el" href="#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a> <a class="el" href="#a7b0000b45b0b55789f757f1c3d2461cb">flags</a>)</td></tr>
<tr class="separator:a4bada7642f7a62d2271fd42cd0cb01f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9f39188361bf855a010751dbafbaff" id="r_aac9f39188361bf855a010751dbafbaff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac9f39188361bf855a010751dbafbaff">ConvertUTF8toUTF32Partial</a> (const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **sourceStart, const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *sourceEnd, <a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> **targetStart, <a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *targetEnd, <a class="el" href="#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a> <a class="el" href="#a7b0000b45b0b55789f757f1c3d2461cb">flags</a>)</td></tr>
<tr class="memdesc:aac9f39188361bf855a010751dbafbaff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a partial UTF8 sequence to UTF32.  <br /></td></tr>
<tr class="separator:aac9f39188361bf855a010751dbafbaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c663588a7ff49ab4cb3ffb71e5d5c6" id="r_ab9c663588a7ff49ab4cb3ffb71e5d5c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9c663588a7ff49ab4cb3ffb71e5d5c6">ConvertUTF8toUTF32</a> (const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **sourceStart, const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *sourceEnd, <a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> **targetStart, <a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *targetEnd, <a class="el" href="#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a> <a class="el" href="#a7b0000b45b0b55789f757f1c3d2461cb">flags</a>)</td></tr>
<tr class="memdesc:ab9c663588a7ff49ab4cb3ffb71e5d5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a partial UTF8 sequence to UTF32.  <br /></td></tr>
<tr class="separator:ab9c663588a7ff49ab4cb3ffb71e5d5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54c2f26ecf324df5da9128c77052d31" id="r_ac54c2f26ecf324df5da9128c77052d31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac54c2f26ecf324df5da9128c77052d31">ConvertUTF16toUTF8</a> (const <a class="el" href="#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> **sourceStart, const <a class="el" href="#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> *sourceEnd, <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **targetStart, <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *targetEnd, <a class="el" href="#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a> <a class="el" href="#a7b0000b45b0b55789f757f1c3d2461cb">flags</a>)</td></tr>
<tr class="separator:ac54c2f26ecf324df5da9128c77052d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903ac386cdae4917d7cc20ed662dcee5" id="r_a903ac386cdae4917d7cc20ed662dcee5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a903ac386cdae4917d7cc20ed662dcee5">ConvertUTF32toUTF8</a> (const <a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> **sourceStart, const <a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *sourceEnd, <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **targetStart, <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *targetEnd, <a class="el" href="#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a> <a class="el" href="#a7b0000b45b0b55789f757f1c3d2461cb">flags</a>)</td></tr>
<tr class="separator:a903ac386cdae4917d7cc20ed662dcee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9257f3c46568bac25b1ba2f3fac4678a" id="r_a9257f3c46568bac25b1ba2f3fac4678a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9257f3c46568bac25b1ba2f3fac4678a">ConvertUTF16toUTF32</a> (const <a class="el" href="#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> **sourceStart, const <a class="el" href="#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> *sourceEnd, <a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> **targetStart, <a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *targetEnd, <a class="el" href="#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a> <a class="el" href="#a7b0000b45b0b55789f757f1c3d2461cb">flags</a>)</td></tr>
<tr class="separator:a9257f3c46568bac25b1ba2f3fac4678a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323342b32a2c5cf6e46b217e4843c014" id="r_a323342b32a2c5cf6e46b217e4843c014"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a323342b32a2c5cf6e46b217e4843c014">ConvertUTF32toUTF16</a> (const <a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> **sourceStart, const <a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *sourceEnd, <a class="el" href="#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> **targetStart, <a class="el" href="#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> *targetEnd, <a class="el" href="#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a> <a class="el" href="#a7b0000b45b0b55789f757f1c3d2461cb">flags</a>)</td></tr>
<tr class="separator:a323342b32a2c5cf6e46b217e4843c014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e27444cfe3390c1682575a3ad1860b" id="r_a26e27444cfe3390c1682575a3ad1860b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac9954615e01ad150570a0e1d4548d879">Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26e27444cfe3390c1682575a3ad1860b">isLegalUTF8Sequence</a> (const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *<a class="el" href="_third_party_notices_8txt.html#a7e4b2af6b1063d628370e894227dec10">source</a>, const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *sourceEnd)</td></tr>
<tr class="separator:a26e27444cfe3390c1682575a3ad1860b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c7efa3db3243cb89f4f1c15b2a2c10" id="r_ad8c7efa3db3243cb89f4f1c15b2a2c10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac9954615e01ad150570a0e1d4548d879">Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8c7efa3db3243cb89f4f1c15b2a2c10">isLegalUTF8String</a> (const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **<a class="el" href="_third_party_notices_8txt.html#a7e4b2af6b1063d628370e894227dec10">source</a>, const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *sourceEnd)</td></tr>
<tr class="separator:ad8c7efa3db3243cb89f4f1c15b2a2c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3463b82b9bd307aca59abfafc0fd0b28" id="r_a3463b82b9bd307aca59abfafc0fd0b28"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3463b82b9bd307aca59abfafc0fd0b28">getUTF8SequenceSize</a> (const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *<a class="el" href="_third_party_notices_8txt.html#a7e4b2af6b1063d628370e894227dec10">source</a>, const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *sourceEnd)</td></tr>
<tr class="separator:a3463b82b9bd307aca59abfafc0fd0b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a45aaed6f6214f0a95dc9fd352b628" id="r_a54a45aaed6f6214f0a95dc9fd352b628"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54a45aaed6f6214f0a95dc9fd352b628">getNumBytesForUTF8</a> (<a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> firstByte)</td></tr>
<tr class="separator:a54a45aaed6f6214f0a95dc9fd352b628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f044a5abfa43152b4511fc34f422abd" id="r_a4f044a5abfa43152b4511fc34f422abd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f044a5abfa43152b4511fc34f422abd">ConvertUTF8toWide</a> (unsigned WideCharWidth, std::string_view Source, char *&amp;ResultPtr, const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *&amp;ErrorPtr)</td></tr>
<tr class="memdesc:a4f044a5abfa43152b4511fc34f422abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an UTF8 string_view to UTF8, UTF16, or UTF32 depending on WideCharWidth.  <br /></td></tr>
<tr class="separator:a4f044a5abfa43152b4511fc34f422abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c65f324a518248ea7c9e3dec6abd2e" id="r_ab6c65f324a518248ea7c9e3dec6abd2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6c65f324a518248ea7c9e3dec6abd2e">ConvertUTF8toWide</a> (std::string_view Source, std::wstring &amp;Result)</td></tr>
<tr class="memdesc:ab6c65f324a518248ea7c9e3dec6abd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a UTF-8 string_view to a std::wstring.  <br /></td></tr>
<tr class="separator:ab6c65f324a518248ea7c9e3dec6abd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34dcbda849543386fc00cfa5e9a30b1a" id="r_a34dcbda849543386fc00cfa5e9a30b1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34dcbda849543386fc00cfa5e9a30b1a">ConvertUTF8toWide</a> (const char *Source, std::wstring &amp;Result)</td></tr>
<tr class="memdesc:a34dcbda849543386fc00cfa5e9a30b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a UTF-8 C-string to a std::wstring.  <br /></td></tr>
<tr class="separator:a34dcbda849543386fc00cfa5e9a30b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0d4fcb62d165827231b4132e83e1a7" id="r_a4e0d4fcb62d165827231b4132e83e1a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e0d4fcb62d165827231b4132e83e1a7">convertWideToUTF8</a> (const std::wstring &amp;Source, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;Result)</td></tr>
<tr class="memdesc:a4e0d4fcb62d165827231b4132e83e1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a std::wstring to a UTF-8 encoded std::string.  <br /></td></tr>
<tr class="separator:a4e0d4fcb62d165827231b4132e83e1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2b50e25edd8fc47c0ef3b0929a9aac" id="r_a0b2b50e25edd8fc47c0ef3b0929a9aac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b2b50e25edd8fc47c0ef3b0929a9aac">ConvertCodePointToUTF8</a> (unsigned Source, char *&amp;ResultPtr)</td></tr>
<tr class="memdesc:a0b2b50e25edd8fc47c0ef3b0929a9aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an Unicode code point to UTF8 sequence.  <br /></td></tr>
<tr class="separator:a0b2b50e25edd8fc47c0ef3b0929a9aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349ec073e684b8777cd7e7166dd3b465" id="r_a349ec073e684b8777cd7e7166dd3b465"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a349ec073e684b8777cd7e7166dd3b465">convertUTF8Sequence</a> (const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **<a class="el" href="_third_party_notices_8txt.html#a7e4b2af6b1063d628370e894227dec10">source</a>, const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *sourceEnd, <a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *target, <a class="el" href="#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a> <a class="el" href="#a7b0000b45b0b55789f757f1c3d2461cb">flags</a>)</td></tr>
<tr class="memdesc:a349ec073e684b8777cd7e7166dd3b465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the first UTF8 sequence in the given source buffer to a UTF32 code point.  <br /></td></tr>
<tr class="separator:a349ec073e684b8777cd7e7166dd3b465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328c5e2f088e151affd5ff9d7b398c42" id="r_a328c5e2f088e151affd5ff9d7b398c42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a328c5e2f088e151affd5ff9d7b398c42">hasUTF16ByteOrderMark</a> (std::span&lt; const char &gt; SrcBytes)</td></tr>
<tr class="memdesc:a328c5e2f088e151affd5ff9d7b398c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a blob of text starts with a UTF-16 big or little endian byte order mark.  <br /></td></tr>
<tr class="separator:a328c5e2f088e151affd5ff9d7b398c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96959c1be95aa4d288cc84e11ab6f1b" id="r_ad96959c1be95aa4d288cc84e11ab6f1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad96959c1be95aa4d288cc84e11ab6f1b">convertUTF16ToUTF8String</a> (std::span&lt; const char &gt; SrcBytes, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;Out)</td></tr>
<tr class="memdesc:ad96959c1be95aa4d288cc84e11ab6f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a stream of raw bytes assumed to be UTF16 into a UTF8 std::string.  <br /></td></tr>
<tr class="separator:ad96959c1be95aa4d288cc84e11ab6f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae550217f649fc634dfa84af9795df29" id="r_aae550217f649fc634dfa84af9795df29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae550217f649fc634dfa84af9795df29">convertUTF16ToUTF8String</a> (std::span&lt; const <a class="el" href="#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> &gt; Src, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;Out)</td></tr>
<tr class="memdesc:aae550217f649fc634dfa84af9795df29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a UTF16 string into a UTF8 std::string.  <br /></td></tr>
<tr class="separator:aae550217f649fc634dfa84af9795df29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ebf5e2ffc341ff3f8840f8ad3ed06f" id="r_a60ebf5e2ffc341ff3f8840f8ad3ed06f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60ebf5e2ffc341ff3f8840f8ad3ed06f">convertUTF32ToUTF8String</a> (std::span&lt; const char &gt; SrcBytes, std::string &amp;Out)</td></tr>
<tr class="memdesc:a60ebf5e2ffc341ff3f8840f8ad3ed06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a stream of raw bytes assumed to be UTF32 into a UTF8 std::string.  <br /></td></tr>
<tr class="separator:a60ebf5e2ffc341ff3f8840f8ad3ed06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8249a62e85e46e5ed358c283261fa9" id="r_a9a8249a62e85e46e5ed358c283261fa9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a8249a62e85e46e5ed358c283261fa9">convertUTF32ToUTF8String</a> (std::span&lt; const <a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> &gt; Src, std::string &amp;Out)</td></tr>
<tr class="memdesc:a9a8249a62e85e46e5ed358c283261fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a UTF32 string into a UTF8 std::string.  <br /></td></tr>
<tr class="separator:a9a8249a62e85e46e5ed358c283261fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051a613a70381a8d15a4ed7630bfd942" id="r_a051a613a70381a8d15a4ed7630bfd942"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a051a613a70381a8d15a4ed7630bfd942">convertUTF8ToUTF16String</a> (std::string_view SrcUTF8, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; <a class="el" href="#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> &gt; &amp;DstUTF16)</td></tr>
<tr class="memdesc:a051a613a70381a8d15a4ed7630bfd942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a UTF-8 string into a UTF-16 string with native endianness.  <br /></td></tr>
<tr class="separator:a051a613a70381a8d15a4ed7630bfd942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025d8760b23ac3786c52b2cc7d72f5eb" id="r_a025d8760b23ac3786c52b2cc7d72f5eb"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a025d8760b23ac3786c52b2cc7d72f5eb">hexdigit</a> (unsigned X, bool LowerCase=false) noexcept</td></tr>
<tr class="memdesc:a025d8760b23ac3786c52b2cc7d72f5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">hexdigit - Return the hexadecimal character for the given number <code>X</code> (which should be less than 16).  <br /></td></tr>
<tr class="separator:a025d8760b23ac3786c52b2cc7d72f5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f23b372d35fd43e572bd6310538d3b4" id="r_a3f23b372d35fd43e572bd6310538d3b4"><td class="memItemLeft" align="right" valign="top">constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f23b372d35fd43e572bd6310538d3b4">hexDigitValue</a> (char C) noexcept</td></tr>
<tr class="memdesc:a3f23b372d35fd43e572bd6310538d3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpret the given character <code>C</code> as a hexadecimal digit and return its value.  <br /></td></tr>
<tr class="separator:a3f23b372d35fd43e572bd6310538d3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368b03e8bb2ecfdc34b02b40523055e4" id="r_a368b03e8bb2ecfdc34b02b40523055e4"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a368b03e8bb2ecfdc34b02b40523055e4">isDigit</a> (char C) noexcept</td></tr>
<tr class="memdesc:a368b03e8bb2ecfdc34b02b40523055e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if character <code>C</code> is one of the 10 decimal digits.  <br /></td></tr>
<tr class="separator:a368b03e8bb2ecfdc34b02b40523055e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33822f75a8aa525d240b60e5e79568b6" id="r_a33822f75a8aa525d240b60e5e79568b6"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33822f75a8aa525d240b60e5e79568b6">isHexDigit</a> (char C) noexcept</td></tr>
<tr class="memdesc:a33822f75a8aa525d240b60e5e79568b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if character <code>C</code> is a hexadecimal numeric character.  <br /></td></tr>
<tr class="separator:a33822f75a8aa525d240b60e5e79568b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40bed52c4db6c9d8ac4d6a34f701fca" id="r_ad40bed52c4db6c9d8ac4d6a34f701fca"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad40bed52c4db6c9d8ac4d6a34f701fca">isAlpha</a> (char C) noexcept</td></tr>
<tr class="memdesc:ad40bed52c4db6c9d8ac4d6a34f701fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if character <code>C</code> is a valid letter as classified by "C" locale.  <br /></td></tr>
<tr class="separator:ad40bed52c4db6c9d8ac4d6a34f701fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db9afebe0b9cb8a94691657ad62b71b" id="r_a2db9afebe0b9cb8a94691657ad62b71b"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2db9afebe0b9cb8a94691657ad62b71b">isAlnum</a> (char C) noexcept</td></tr>
<tr class="memdesc:a2db9afebe0b9cb8a94691657ad62b71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether character <code>C</code> is either a decimal digit or an uppercase or lowercase letter as classified by "C" locale.  <br /></td></tr>
<tr class="separator:a2db9afebe0b9cb8a94691657ad62b71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e6acbb1ecc26fc431a01798885b5a1" id="r_ad2e6acbb1ecc26fc431a01798885b5a1"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2e6acbb1ecc26fc431a01798885b5a1">isASCII</a> (char C) noexcept</td></tr>
<tr class="memdesc:ad2e6acbb1ecc26fc431a01798885b5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether character <code>C</code> is valid ASCII (high bit is zero).  <br /></td></tr>
<tr class="separator:ad2e6acbb1ecc26fc431a01798885b5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c8224f526316dbd1d8e8c3e53362db" id="r_a91c8224f526316dbd1d8e8c3e53362db"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91c8224f526316dbd1d8e8c3e53362db">isPrint</a> (char C) noexcept</td></tr>
<tr class="memdesc:a91c8224f526316dbd1d8e8c3e53362db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether character <code>C</code> is printable.  <br /></td></tr>
<tr class="separator:a91c8224f526316dbd1d8e8c3e53362db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d0773c177190213ead75a95fe7fc46" id="r_a47d0773c177190213ead75a95fe7fc46"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47d0773c177190213ead75a95fe7fc46">toLower</a> (char x) noexcept</td></tr>
<tr class="memdesc:a47d0773c177190213ead75a95fe7fc46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the corresponding lowercase character if <code>x</code> is uppercase.  <br /></td></tr>
<tr class="separator:a47d0773c177190213ead75a95fe7fc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe9106b78ee79e9796550968c3ef216" id="r_a4fe9106b78ee79e9796550968c3ef216"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fe9106b78ee79e9796550968c3ef216">toUpper</a> (char x) noexcept</td></tr>
<tr class="memdesc:a4fe9106b78ee79e9796550968c3ef216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the corresponding uppercase character if <code>x</code> is lowercase.  <br /></td></tr>
<tr class="separator:a4fe9106b78ee79e9796550968c3ef216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7da2e15d1e126422095bfbc0e66f1bc" id="r_ae7da2e15d1e126422095bfbc0e66f1bc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7da2e15d1e126422095bfbc0e66f1bc">utohexstr</a> (unsigned long long val, bool lowerCase=false)</td></tr>
<tr class="separator:ae7da2e15d1e126422095bfbc0e66f1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861d18fea3edd7f459017ea02e79d5ea" id="r_a861d18fea3edd7f459017ea02e79d5ea"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a861d18fea3edd7f459017ea02e79d5ea">equals</a> (std::string_view lhs, std::string_view rhs) noexcept</td></tr>
<tr class="memdesc:a861d18fea3edd7f459017ea02e79d5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">equals - Check for string equality, this is more efficient than compare() when the relative ordering of inequal strings isn't needed.  <br /></td></tr>
<tr class="separator:a861d18fea3edd7f459017ea02e79d5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135363b62874f7e1527b3ee317063f28" id="r_a135363b62874f7e1527b3ee317063f28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a135363b62874f7e1527b3ee317063f28">compare_lower</a> (std::string_view lhs, std::string_view rhs) noexcept</td></tr>
<tr class="memdesc:a135363b62874f7e1527b3ee317063f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare_lower - Compare two strings, ignoring case.  <br /></td></tr>
<tr class="separator:a135363b62874f7e1527b3ee317063f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f467e8545fad85176bcf4e64ced7bc7" id="r_a6f467e8545fad85176bcf4e64ced7bc7"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f467e8545fad85176bcf4e64ced7bc7">equals_lower</a> (std::string_view lhs, std::string_view rhs) noexcept</td></tr>
<tr class="memdesc:a6f467e8545fad85176bcf4e64ced7bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">equals_lower - Check for string equality, ignoring case.  <br /></td></tr>
<tr class="separator:a6f467e8545fad85176bcf4e64ced7bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f2207fbd2f0fbd2a85bda3ef353ec5" id="r_a32f2207fbd2f0fbd2a85bda3ef353ec5"><td class="memItemLeft" align="right" valign="top">std::string_view::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32f2207fbd2f0fbd2a85bda3ef353ec5">find_lower</a> (std::string_view str, char ch, std::string_view::size_type <a class="el" href="_third_party_notices_8txt.html#ae1e371287219a11d6a2498f92d3e15d2">from</a>=0) noexcept</td></tr>
<tr class="memdesc:a32f2207fbd2f0fbd2a85bda3ef353ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first character <code>ch</code> in <code>str</code>, ignoring case.  <br /></td></tr>
<tr class="separator:a32f2207fbd2f0fbd2a85bda3ef353ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e73ed8bf4d49b2734570b2c83f9303" id="r_af5e73ed8bf4d49b2734570b2c83f9303"><td class="memItemLeft" align="right" valign="top">std::string_view::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5e73ed8bf4d49b2734570b2c83f9303">find_lower</a> (std::string_view str, std::string_view other, std::string_view::size_type <a class="el" href="_third_party_notices_8txt.html#ae1e371287219a11d6a2498f92d3e15d2">from</a>=0) noexcept</td></tr>
<tr class="memdesc:af5e73ed8bf4d49b2734570b2c83f9303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first string <code>other</code> in <code>str</code>, ignoring case.  <br /></td></tr>
<tr class="separator:af5e73ed8bf4d49b2734570b2c83f9303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f278b2f7c4f0f3d3417390f77979fd5" id="r_a5f278b2f7c4f0f3d3417390f77979fd5"><td class="memItemLeft" align="right" valign="top">std::string_view::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f278b2f7c4f0f3d3417390f77979fd5">find_lower</a> (std::string_view str, const char *other, std::string_view::size_type <a class="el" href="_third_party_notices_8txt.html#ae1e371287219a11d6a2498f92d3e15d2">from</a>=0) noexcept</td></tr>
<tr class="memdesc:a5f278b2f7c4f0f3d3417390f77979fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first string <code>other</code> in <code>str</code>, ignoring case.  <br /></td></tr>
<tr class="separator:a5f278b2f7c4f0f3d3417390f77979fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676758fb3474980129376c4430e5965f" id="r_a676758fb3474980129376c4430e5965f"><td class="memItemLeft" align="right" valign="top">std::string_view::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a676758fb3474980129376c4430e5965f">rfind_lower</a> (std::string_view str, char ch, std::string_view::size_type <a class="el" href="_third_party_notices_8txt.html#ae1e371287219a11d6a2498f92d3e15d2">from</a>=std::string_view::npos) noexcept</td></tr>
<tr class="memdesc:a676758fb3474980129376c4430e5965f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last character <code>ch</code> in <code>str</code>, ignoring case.  <br /></td></tr>
<tr class="separator:a676758fb3474980129376c4430e5965f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88303c617dfdc5eca2edb6fb7b10124b" id="r_a88303c617dfdc5eca2edb6fb7b10124b"><td class="memItemLeft" align="right" valign="top">std::string_view::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88303c617dfdc5eca2edb6fb7b10124b">rfind_lower</a> (std::string_view str, std::string_view other) noexcept</td></tr>
<tr class="memdesc:a88303c617dfdc5eca2edb6fb7b10124b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last string <code>other</code> in <code>str</code>, ignoring case.  <br /></td></tr>
<tr class="separator:a88303c617dfdc5eca2edb6fb7b10124b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6670129d8dd67d55733dacac82fb6354" id="r_a6670129d8dd67d55733dacac82fb6354"><td class="memItemLeft" align="right" valign="top">std::string_view::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6670129d8dd67d55733dacac82fb6354">rfind_lower</a> (std::string_view str, const char *other) noexcept</td></tr>
<tr class="memdesc:a6670129d8dd67d55733dacac82fb6354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last string <code>other</code> in <code>str</code>, ignoring case.  <br /></td></tr>
<tr class="separator:a6670129d8dd67d55733dacac82fb6354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f010ee3e4dec5c5697534c0059aa046" id="r_a7f010ee3e4dec5c5697534c0059aa046"><td class="memItemLeft" align="right" valign="top">constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f010ee3e4dec5c5697534c0059aa046">substr</a> (std::string_view str, std::string_view::size_type start, std::string_view::size_type n=std::string_view::npos) noexcept</td></tr>
<tr class="memdesc:a7f010ee3e4dec5c5697534c0059aa046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the substring of <code>str</code> from [start, start + n).  <br /></td></tr>
<tr class="separator:a7f010ee3e4dec5c5697534c0059aa046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0739f65c4cc2835777cc34e9241c377" id="r_af0739f65c4cc2835777cc34e9241c377"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0739f65c4cc2835777cc34e9241c377">starts_with</a> (std::string_view str, std::string_view prefix) noexcept</td></tr>
<tr class="memdesc:af0739f65c4cc2835777cc34e9241c377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> starts with the given <code>prefix</code>.  <br /></td></tr>
<tr class="separator:af0739f65c4cc2835777cc34e9241c377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ed0964b7b3d671454f67babc4835bf" id="r_a24ed0964b7b3d671454f67babc4835bf"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24ed0964b7b3d671454f67babc4835bf">starts_with</a> (std::string_view str, char prefix) noexcept</td></tr>
<tr class="memdesc:a24ed0964b7b3d671454f67babc4835bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> starts with the given <code>prefix</code>.  <br /></td></tr>
<tr class="separator:a24ed0964b7b3d671454f67babc4835bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5432fef02a3f6f25d649439e5f37b291" id="r_a5432fef02a3f6f25d649439e5f37b291"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5432fef02a3f6f25d649439e5f37b291">starts_with</a> (std::string_view str, const char *prefix) noexcept</td></tr>
<tr class="memdesc:a5432fef02a3f6f25d649439e5f37b291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> starts with the given <code>prefix</code>.  <br /></td></tr>
<tr class="separator:a5432fef02a3f6f25d649439e5f37b291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6880afc62fe88adf620fbf7c0ae29cc6" id="r_a6880afc62fe88adf620fbf7c0ae29cc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6880afc62fe88adf620fbf7c0ae29cc6">starts_with_lower</a> (std::string_view str, std::string_view prefix) noexcept</td></tr>
<tr class="memdesc:a6880afc62fe88adf620fbf7c0ae29cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> starts with the given <code>prefix</code>, ignoring case.  <br /></td></tr>
<tr class="separator:a6880afc62fe88adf620fbf7c0ae29cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bef3b73b83b04242caa60d6327ceb68" id="r_a2bef3b73b83b04242caa60d6327ceb68"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bef3b73b83b04242caa60d6327ceb68">starts_with_lower</a> (std::string_view str, char prefix) noexcept</td></tr>
<tr class="memdesc:a2bef3b73b83b04242caa60d6327ceb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> starts with the given <code>prefix</code>, ignoring case.  <br /></td></tr>
<tr class="separator:a2bef3b73b83b04242caa60d6327ceb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddfda4dce07ee9575513ba636d6f383" id="r_a9ddfda4dce07ee9575513ba636d6f383"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ddfda4dce07ee9575513ba636d6f383">starts_with_lower</a> (std::string_view str, const char *prefix) noexcept</td></tr>
<tr class="memdesc:a9ddfda4dce07ee9575513ba636d6f383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> starts with the given <code>prefix</code>, ignoring case.  <br /></td></tr>
<tr class="separator:a9ddfda4dce07ee9575513ba636d6f383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76aa40d978aab32a3dcfab7f8eb953b" id="r_ae76aa40d978aab32a3dcfab7f8eb953b"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae76aa40d978aab32a3dcfab7f8eb953b">ends_with</a> (std::string_view str, std::string_view suffix) noexcept</td></tr>
<tr class="memdesc:ae76aa40d978aab32a3dcfab7f8eb953b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> ends with the given <code>suffix</code>.  <br /></td></tr>
<tr class="separator:ae76aa40d978aab32a3dcfab7f8eb953b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4df2968e94c4ee3ac050889f633446" id="r_abd4df2968e94c4ee3ac050889f633446"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd4df2968e94c4ee3ac050889f633446">ends_with</a> (std::string_view str, char suffix) noexcept</td></tr>
<tr class="memdesc:abd4df2968e94c4ee3ac050889f633446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> ends with the given <code>suffix</code>.  <br /></td></tr>
<tr class="separator:abd4df2968e94c4ee3ac050889f633446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec868a416c46e73b09990b9accd5531" id="r_a3ec868a416c46e73b09990b9accd5531"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ec868a416c46e73b09990b9accd5531">ends_with</a> (std::string_view str, const char *suffix) noexcept</td></tr>
<tr class="memdesc:a3ec868a416c46e73b09990b9accd5531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> ends with the given <code>suffix</code>.  <br /></td></tr>
<tr class="separator:a3ec868a416c46e73b09990b9accd5531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ce9b37507ebc31753938d388848714" id="r_a63ce9b37507ebc31753938d388848714"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63ce9b37507ebc31753938d388848714">ends_with_lower</a> (std::string_view str, std::string_view suffix) noexcept</td></tr>
<tr class="memdesc:a63ce9b37507ebc31753938d388848714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> ends with the given <code>suffix</code>, ignoring case.  <br /></td></tr>
<tr class="separator:a63ce9b37507ebc31753938d388848714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95519eb02ecc90f51e4157b797a4c306" id="r_a95519eb02ecc90f51e4157b797a4c306"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95519eb02ecc90f51e4157b797a4c306">ends_with_lower</a> (std::string_view str, char suffix) noexcept</td></tr>
<tr class="memdesc:a95519eb02ecc90f51e4157b797a4c306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> ends with the given <code>suffix</code>, ignoring case.  <br /></td></tr>
<tr class="separator:a95519eb02ecc90f51e4157b797a4c306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1334c1afcb5a1b5592e57a78436915b" id="r_ac1334c1afcb5a1b5592e57a78436915b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1334c1afcb5a1b5592e57a78436915b">ends_with_lower</a> (std::string_view str, const char *suffix) noexcept</td></tr>
<tr class="memdesc:ac1334c1afcb5a1b5592e57a78436915b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> ends with the given <code>suffix</code>, ignoring case.  <br /></td></tr>
<tr class="separator:ac1334c1afcb5a1b5592e57a78436915b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c338fbb3b9d95ab22856fb0aaacf94" id="r_a57c338fbb3b9d95ab22856fb0aaacf94"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57c338fbb3b9d95ab22856fb0aaacf94">contains</a> (std::string_view str, std::string_view other) noexcept</td></tr>
<tr class="memdesc:a57c338fbb3b9d95ab22856fb0aaacf94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> contains the substring <code>other</code>.  <br /></td></tr>
<tr class="separator:a57c338fbb3b9d95ab22856fb0aaacf94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c14a6177075406fca400c8f46d0dc5" id="r_ac0c14a6177075406fca400c8f46d0dc5"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0c14a6177075406fca400c8f46d0dc5">contains</a> (std::string_view str, char ch) noexcept</td></tr>
<tr class="memdesc:ac0c14a6177075406fca400c8f46d0dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> contains the substring <code>other</code>.  <br /></td></tr>
<tr class="separator:ac0c14a6177075406fca400c8f46d0dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1426c18248d3c2ba9769800334f2c596" id="r_a1426c18248d3c2ba9769800334f2c596"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1426c18248d3c2ba9769800334f2c596">contains</a> (std::string_view str, const char *other) noexcept</td></tr>
<tr class="memdesc:a1426c18248d3c2ba9769800334f2c596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> contains the substring <code>other</code>.  <br /></td></tr>
<tr class="separator:a1426c18248d3c2ba9769800334f2c596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec927e053502a01b8b57dbc9fe7ceea" id="r_afec927e053502a01b8b57dbc9fe7ceea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afec927e053502a01b8b57dbc9fe7ceea">contains_lower</a> (std::string_view str, std::string_view other) noexcept</td></tr>
<tr class="memdesc:afec927e053502a01b8b57dbc9fe7ceea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> contains the substring <code>other</code>, ignoring case.  <br /></td></tr>
<tr class="separator:afec927e053502a01b8b57dbc9fe7ceea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e058e611f4cf33ce6a9355be266854" id="r_ae7e058e611f4cf33ce6a9355be266854"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7e058e611f4cf33ce6a9355be266854">contains_lower</a> (std::string_view str, char ch) noexcept</td></tr>
<tr class="memdesc:ae7e058e611f4cf33ce6a9355be266854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> contains the substring <code>other</code>, ignoring case.  <br /></td></tr>
<tr class="separator:ae7e058e611f4cf33ce6a9355be266854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93417c92f7c6516d3746b419a5f6ec39" id="r_a93417c92f7c6516d3746b419a5f6ec39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93417c92f7c6516d3746b419a5f6ec39">contains_lower</a> (std::string_view str, const char *other) noexcept</td></tr>
<tr class="memdesc:a93417c92f7c6516d3746b419a5f6ec39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>str</code> contains the substring <code>other</code>, ignoring case.  <br /></td></tr>
<tr class="separator:a93417c92f7c6516d3746b419a5f6ec39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151ee27ef17ccf8d36ef6208ed60d1c3" id="r_a151ee27ef17ccf8d36ef6208ed60d1c3"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a151ee27ef17ccf8d36ef6208ed60d1c3">remove_prefix</a> (std::string_view str, std::string_view prefix) noexcept</td></tr>
<tr class="memdesc:a151ee27ef17ccf8d36ef6208ed60d1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an optional containing <code>str</code> but with <code>prefix</code> removed if the string starts with the prefix.  <br /></td></tr>
<tr class="separator:a151ee27ef17ccf8d36ef6208ed60d1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa2430efceab8b21962368d1db93d61" id="r_a4aa2430efceab8b21962368d1db93d61"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4aa2430efceab8b21962368d1db93d61">remove_suffix</a> (std::string_view str, std::string_view suffix) noexcept</td></tr>
<tr class="memdesc:a4aa2430efceab8b21962368d1db93d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an optional containing <code>str</code> but with <code>suffix</code> removed if the string ends with the suffix.  <br /></td></tr>
<tr class="separator:a4aa2430efceab8b21962368d1db93d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e1eeb77b140b88774935651084a248" id="r_aa5e1eeb77b140b88774935651084a248"><td class="memItemLeft" align="right" valign="top">constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5e1eeb77b140b88774935651084a248">drop_front</a> (std::string_view str, std::string_view::size_type n=1) noexcept</td></tr>
<tr class="memdesc:aa5e1eeb77b140b88774935651084a248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string_view equal to <code>str</code> but with the first <code>n</code> elements dropped.  <br /></td></tr>
<tr class="separator:aa5e1eeb77b140b88774935651084a248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f57db8fe105b74dbfbd5897fa695c14" id="r_a7f57db8fe105b74dbfbd5897fa695c14"><td class="memItemLeft" align="right" valign="top">constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f57db8fe105b74dbfbd5897fa695c14">drop_back</a> (std::string_view str, std::string_view::size_type n=1) noexcept</td></tr>
<tr class="memdesc:a7f57db8fe105b74dbfbd5897fa695c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string_view equal to <code>str</code> but with the last <code>n</code> elements dropped.  <br /></td></tr>
<tr class="separator:a7f57db8fe105b74dbfbd5897fa695c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2f9b2ee4f037743d32eb831bb487c4" id="r_aff2f9b2ee4f037743d32eb831bb487c4"><td class="memItemLeft" align="right" valign="top">constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff2f9b2ee4f037743d32eb831bb487c4">take_front</a> (std::string_view str, std::string_view::size_type n=1) noexcept</td></tr>
<tr class="memdesc:aff2f9b2ee4f037743d32eb831bb487c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a view equal to <code>str</code> but with only the first <code>n</code> elements remaining.  <br /></td></tr>
<tr class="separator:aff2f9b2ee4f037743d32eb831bb487c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a98666f01d85b3920861e2477e7926" id="r_aa8a98666f01d85b3920861e2477e7926"><td class="memItemLeft" align="right" valign="top">constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8a98666f01d85b3920861e2477e7926">take_back</a> (std::string_view str, std::string_view::size_type n=1) noexcept</td></tr>
<tr class="memdesc:aa8a98666f01d85b3920861e2477e7926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a view equal to <code>str</code> but with only the last <code>n</code> elements remaining.  <br /></td></tr>
<tr class="separator:aa8a98666f01d85b3920861e2477e7926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f22fd8158dd46fe207d828ab907c6a9" id="r_a0f22fd8158dd46fe207d828ab907c6a9"><td class="memItemLeft" align="right" valign="top">constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f22fd8158dd46fe207d828ab907c6a9">slice</a> (std::string_view str, std::string_view::size_type start, std::string_view::size_type end) noexcept</td></tr>
<tr class="memdesc:a0f22fd8158dd46fe207d828ab907c6a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the substring of <code>str</code> from [start, end).  <br /></td></tr>
<tr class="separator:a0f22fd8158dd46fe207d828ab907c6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9d3d4eb9461ff65cb2743afa9fd08a" id="r_a0f9d3d4eb9461ff65cb2743afa9fd08a"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; std::string_view, std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f9d3d4eb9461ff65cb2743afa9fd08a">split</a> (std::string_view str, char separator) noexcept</td></tr>
<tr class="memdesc:a0f9d3d4eb9461ff65cb2743afa9fd08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits <code>str</code> into two substrings around the first occurrence of a separator character.  <br /></td></tr>
<tr class="separator:a0f9d3d4eb9461ff65cb2743afa9fd08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b559c84b004c61700aa0724cf658177" id="r_a2b559c84b004c61700aa0724cf658177"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; std::string_view, std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b559c84b004c61700aa0724cf658177">split</a> (std::string_view str, std::string_view separator) noexcept</td></tr>
<tr class="memdesc:a2b559c84b004c61700aa0724cf658177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits <code>str</code> into two substrings around the first occurrence of a separator string.  <br /></td></tr>
<tr class="separator:a2b559c84b004c61700aa0724cf658177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a31eb74242495e03e1745ab82085c81" id="r_a7a31eb74242495e03e1745ab82085c81"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; std::string_view, std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a31eb74242495e03e1745ab82085c81">rsplit</a> (std::string_view str, char separator) noexcept</td></tr>
<tr class="memdesc:a7a31eb74242495e03e1745ab82085c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits <code>str</code> into two substrings around the last occurrence of a separator character.  <br /></td></tr>
<tr class="separator:a7a31eb74242495e03e1745ab82085c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2512b6f3e4faf374ccc818722784597b" id="r_a2512b6f3e4faf374ccc818722784597b"><td class="memItemLeft" align="right" valign="top">constexpr std::pair&lt; std::string_view, std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2512b6f3e4faf374ccc818722784597b">rsplit</a> (std::string_view str, std::string_view separator) noexcept</td></tr>
<tr class="memdesc:a2512b6f3e4faf374ccc818722784597b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits <code>str</code> into two substrings around the last occurrence of a separator string.  <br /></td></tr>
<tr class="separator:a2512b6f3e4faf374ccc818722784597b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd39f69badd5bed05f8020e76e688911" id="r_afd39f69badd5bed05f8020e76e688911"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd39f69badd5bed05f8020e76e688911">split</a> (std::string_view str, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; std::string_view &gt; &amp;arr, std::string_view separator, int maxSplit=-1, bool keepEmpty=true) noexcept</td></tr>
<tr class="memdesc:afd39f69badd5bed05f8020e76e688911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits <code>str</code> into substrings around the occurrences of a separator string.  <br /></td></tr>
<tr class="separator:afd39f69badd5bed05f8020e76e688911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32a7896ab3ee6b24926527703eabade" id="r_ac32a7896ab3ee6b24926527703eabade"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac32a7896ab3ee6b24926527703eabade">split</a> (std::string_view str, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; std::string_view &gt; &amp;arr, char separator, int maxSplit=-1, bool keepEmpty=true) noexcept</td></tr>
<tr class="memdesc:ac32a7896ab3ee6b24926527703eabade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits <code>str</code> into substrings around the occurrences of a separator character.  <br /></td></tr>
<tr class="separator:ac32a7896ab3ee6b24926527703eabade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7c271a14f5c78641600f41d7c32299" id="r_a1b7c271a14f5c78641600f41d7c32299"><td class="memItemLeft" align="right" valign="top">constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b7c271a14f5c78641600f41d7c32299">ltrim</a> (std::string_view str, char ch) noexcept</td></tr>
<tr class="memdesc:a1b7c271a14f5c78641600f41d7c32299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>str</code> with consecutive <code>ch</code> characters starting from the the left removed.  <br /></td></tr>
<tr class="separator:a1b7c271a14f5c78641600f41d7c32299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b05ebace5b75bf9c0d3b9513f2c2d11" id="r_a2b05ebace5b75bf9c0d3b9513f2c2d11"><td class="memItemLeft" align="right" valign="top">constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b05ebace5b75bf9c0d3b9513f2c2d11">ltrim</a> (std::string_view str, std::string_view chars=&quot; \t\n\v\f\r&quot;) noexcept</td></tr>
<tr class="memdesc:a2b05ebace5b75bf9c0d3b9513f2c2d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>str</code> with consecutive characters in <code>chars</code> starting from the left removed.  <br /></td></tr>
<tr class="separator:a2b05ebace5b75bf9c0d3b9513f2c2d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3a6a546687b31a4770178e1036c589" id="r_adb3a6a546687b31a4770178e1036c589"><td class="memItemLeft" align="right" valign="top">constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb3a6a546687b31a4770178e1036c589">rtrim</a> (std::string_view str, char ch) noexcept</td></tr>
<tr class="memdesc:adb3a6a546687b31a4770178e1036c589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>str</code> with consecutive <code>Char</code> characters starting from the right removed.  <br /></td></tr>
<tr class="separator:adb3a6a546687b31a4770178e1036c589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c241695392bec8c5295c438f6e8d35f" id="r_a9c241695392bec8c5295c438f6e8d35f"><td class="memItemLeft" align="right" valign="top">constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c241695392bec8c5295c438f6e8d35f">rtrim</a> (std::string_view str, std::string_view chars=&quot; \t\n\v\f\r&quot;) noexcept</td></tr>
<tr class="memdesc:a9c241695392bec8c5295c438f6e8d35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>str</code> with consecutive characters in <code>chars</code> starting from the right removed.  <br /></td></tr>
<tr class="separator:a9c241695392bec8c5295c438f6e8d35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8e2346d8ddaaaecfd3bc8760d09d9a" id="r_a4c8e2346d8ddaaaecfd3bc8760d09d9a"><td class="memItemLeft" align="right" valign="top">constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c8e2346d8ddaaaecfd3bc8760d09d9a">trim</a> (std::string_view str, char ch) noexcept</td></tr>
<tr class="memdesc:a4c8e2346d8ddaaaecfd3bc8760d09d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>str</code> with consecutive <code>ch</code> characters starting from the left and right removed.  <br /></td></tr>
<tr class="separator:a4c8e2346d8ddaaaecfd3bc8760d09d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddfebd5ca997fb76159b3d79f1a98c9" id="r_a5ddfebd5ca997fb76159b3d79f1a98c9"><td class="memItemLeft" align="right" valign="top">constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ddfebd5ca997fb76159b3d79f1a98c9">trim</a> (std::string_view str, std::string_view chars=&quot; \t\n\v\f\r&quot;) noexcept</td></tr>
<tr class="memdesc:a5ddfebd5ca997fb76159b3d79f1a98c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>str</code> with consecutive characters in <code>chars</code> starting from the left and right removed.  <br /></td></tr>
<tr class="separator:a5ddfebd5ca997fb76159b3d79f1a98c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed163433a5d70554975df8e7ef7f4df" id="r_a3ed163433a5d70554975df8e7ef7f4df"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt; std::numeric_limits&lt; T &gt;::is_signed, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a3ed163433a5d70554975df8e7ef7f4df"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3ed163433a5d70554975df8e7ef7f4df">parse_integer</a> (std::string_view str, unsigned radix) noexcept</td></tr>
<tr class="memdesc:a3ed163433a5d70554975df8e7ef7f4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the string <code>str</code> as an integer of the specified radix.  <br /></td></tr>
<tr class="separator:a3ed163433a5d70554975df8e7ef7f4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd59d01b80175e78c41a25b325fa22b" id="r_a2fd59d01b80175e78c41a25b325fa22b"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt; std::numeric_limits&lt; T &gt;::is_signed, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a2fd59d01b80175e78c41a25b325fa22b"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2fd59d01b80175e78c41a25b325fa22b">consume_integer</a> (std::string_view *str, unsigned radix) noexcept</td></tr>
<tr class="memdesc:a2fd59d01b80175e78c41a25b325fa22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the string <code>str</code> as an integer of the specified radix.  <br /></td></tr>
<tr class="separator:a2fd59d01b80175e78c41a25b325fa22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e2a33d363a34850deae1866c324eb6" id="r_ae3e2a33d363a34850deae1866c324eb6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae3e2a33d363a34850deae1866c324eb6"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae3e2a33d363a34850deae1866c324eb6">parse_float</a> (std::string_view str) noexcept</td></tr>
<tr class="memdesc:ae3e2a33d363a34850deae1866c324eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the string <code>str</code> as a floating point value.  <br /></td></tr>
<tr class="separator:ae3e2a33d363a34850deae1866c324eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3739b1e7e77b69e3ce650907ca69ed" id="r_aea3739b1e7e77b69e3ce650907ca69ed"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aea3739b1e7e77b69e3ce650907ca69ed"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; float &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aea3739b1e7e77b69e3ce650907ca69ed">parse_float&lt; float &gt;</a> (std::string_view str) noexcept</td></tr>
<tr class="separator:aea3739b1e7e77b69e3ce650907ca69ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d19c9cf09501aa0ab358fa74281e96d" id="r_a2d19c9cf09501aa0ab358fa74281e96d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a2d19c9cf09501aa0ab358fa74281e96d"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2d19c9cf09501aa0ab358fa74281e96d">parse_float&lt; double &gt;</a> (std::string_view str) noexcept</td></tr>
<tr class="separator:a2d19c9cf09501aa0ab358fa74281e96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ec79c288a28100e273ac8c3e41b85b" id="r_a77ec79c288a28100e273ac8c3e41b85b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a77ec79c288a28100e273ac8c3e41b85b"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; long double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a77ec79c288a28100e273ac8c3e41b85b">parse_float&lt; long double &gt;</a> (std::string_view str) noexcept</td></tr>
<tr class="separator:a77ec79c288a28100e273ac8c3e41b85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab528fd3e2a3f73f3ac2a6ed2177be0a0" id="r_ab528fd3e2a3f73f3ac2a6ed2177be0a0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string_view, std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab528fd3e2a3f73f3ac2a6ed2177be0a0">UnescapeCString</a> (std::string_view str, <a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;buf)</td></tr>
<tr class="memdesc:ab528fd3e2a3f73f3ac2a6ed2177be0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unescapes a C-style string (reverse operation to <a class="el" href="classwpi_1_1raw__ostream.html#a623db24f216428b1b9f695435ddcaad4" title="Output Str, turning &#39;\&#39;, &#39;\t&#39;, &#39; &#39;, &#39;&quot;&#39;, and anything that doesn&#39;t satisfy wpi::isPrint into an escap...">raw_ostream::write_escaped</a>).  <br /></td></tr>
<tr class="separator:ab528fd3e2a3f73f3ac2a6ed2177be0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7392ab14211b2573e41ddf483a2c7b9" id="r_ab7392ab14211b2573e41ddf483a2c7b9"><td class="memTemplParams" colspan="2">template&lt;class OutputIt , class... Args&gt; </td></tr>
<tr class="memitem:ab7392ab14211b2573e41ddf483a2c7b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab7392ab14211b2573e41ddf483a2c7b9">format_to_n_c_str</a> (OutputIt out, std::iter_difference_t&lt; OutputIt &gt; n, fmt::format_string&lt; Args... &gt; fmt, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab7392ab14211b2573e41ddf483a2c7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like std::format_to_n() in that it writes at most n bytes to the output buffer, but also includes a terminating null byte in n.  <br /></td></tr>
<tr class="separator:ab7392ab14211b2573e41ddf483a2c7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0d8a622e089ad47214934b0c723dee" id="r_ada0d8a622e089ad47214934b0c723dee"><td class="memTemplParams" colspan="2">template&lt;typename OStream , typename T &gt; </td></tr>
<tr class="memitem:ada0d8a622e089ad47214934b0c723dee"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_reference_v&lt; OStream &gt; &amp;&amp;std::is_base_of_v&lt; <a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a>, OStream &gt;, OStream &amp;&amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ada0d8a622e089ad47214934b0c723dee">operator&lt;&lt;</a> (OStream &amp;&amp;OS, const T &amp;Value)</td></tr>
<tr class="memdesc:ada0d8a622e089ad47214934b0c723dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the appropriate insertion operator, given an rvalue reference to a <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> object and return a stream of the same type as the argument.  <br /></td></tr>
<tr class="separator:ada0d8a622e089ad47214934b0c723dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc9cf60e707bfcf728eb04c4e4b8d2e" id="r_a4cc9cf60e707bfcf728eb04c4e4b8d2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1raw__fd__ostream.html">raw_fd_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cc9cf60e707bfcf728eb04c4e4b8d2e">outs</a> ()</td></tr>
<tr class="memdesc:a4cc9cf60e707bfcf728eb04c4e4b8d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a reference to a <a class="el" href="classwpi_1_1raw__fd__ostream.html" title="A raw_ostream that writes to a file descriptor.">raw_fd_ostream</a> for standard output.  <br /></td></tr>
<tr class="separator:a4cc9cf60e707bfcf728eb04c4e4b8d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca972941e2effcb07cfc0e14b7c783f6" id="r_aca972941e2effcb07cfc0e14b7c783f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1raw__fd__ostream.html">raw_fd_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca972941e2effcb07cfc0e14b7c783f6">errs</a> ()</td></tr>
<tr class="memdesc:aca972941e2effcb07cfc0e14b7c783f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a reference to a <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> for standard error.  <br /></td></tr>
<tr class="separator:aca972941e2effcb07cfc0e14b7c783f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40031774febe762423c2bf6bb4e0094b" id="r_a40031774febe762423c2bf6bb4e0094b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40031774febe762423c2bf6bb4e0094b">nulls</a> ()</td></tr>
<tr class="memdesc:a40031774febe762423c2bf6bb4e0094b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a reference to a <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> which simply discards output.  <br /></td></tr>
<tr class="separator:a40031774febe762423c2bf6bb4e0094b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b125df3c2eaae6f9b8cd09ccd9da98d" id="r_a4b125df3c2eaae6f9b8cd09ccd9da98d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b125df3c2eaae6f9b8cd09ccd9da98d">GetStackTrace</a> (int offset)</td></tr>
<tr class="memdesc:a4b125df3c2eaae6f9b8cd09ccd9da98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a stack trace, ignoring the first "offset" symbols.  <br /></td></tr>
<tr class="separator:a4b125df3c2eaae6f9b8cd09ccd9da98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c7ea157a96be60befa9ba11407f839" id="r_a17c7ea157a96be60befa9ba11407f839"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17c7ea157a96be60befa9ba11407f839">GetStackTraceDefault</a> (int offset)</td></tr>
<tr class="memdesc:a17c7ea157a96be60befa9ba11407f839"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default implementation used for <a class="el" href="#a4b125df3c2eaae6f9b8cd09ccd9da98d" title="Get a stack trace, ignoring the first &quot;offset&quot; symbols.">GetStackTrace()</a>.  <br /></td></tr>
<tr class="separator:a17c7ea157a96be60befa9ba11407f839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3776b907dc530ce3556e36bcb5a68462" id="r_a3776b907dc530ce3556e36bcb5a68462"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3776b907dc530ce3556e36bcb5a68462">SetGetStackTraceImpl</a> (std::string(*func)(int offset))</td></tr>
<tr class="memdesc:a3776b907dc530ce3556e36bcb5a68462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the implementation used by <a class="el" href="#a4b125df3c2eaae6f9b8cd09ccd9da98d" title="Get a stack trace, ignoring the first &quot;offset&quot; symbols.">GetStackTrace()</a>.  <br /></td></tr>
<tr class="separator:a3776b907dc530ce3556e36bcb5a68462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ea49dcab711bb9a5e64a569c32241b" id="r_a36ea49dcab711bb9a5e64a569c32241b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36ea49dcab711bb9a5e64a569c32241b">SizeUleb128</a> (uint64_t val)</td></tr>
<tr class="memdesc:a36ea49dcab711bb9a5e64a569c32241b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of unsigned LEB128 data.  <br /></td></tr>
<tr class="separator:a36ea49dcab711bb9a5e64a569c32241b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3dac2f55476ec2190adf33d5a123cf4" id="r_ab3dac2f55476ec2190adf33d5a123cf4"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3dac2f55476ec2190adf33d5a123cf4">WriteUleb128</a> (<a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;dest, uint64_t val)</td></tr>
<tr class="memdesc:ab3dac2f55476ec2190adf33d5a123cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write unsigned LEB128 data.  <br /></td></tr>
<tr class="separator:ab3dac2f55476ec2190adf33d5a123cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d290fcc6f4ff08f10afc9eb18d5af16" id="r_a1d290fcc6f4ff08f10afc9eb18d5af16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d290fcc6f4ff08f10afc9eb18d5af16">WriteUleb128</a> (<a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;os, uint64_t val)</td></tr>
<tr class="memdesc:a1d290fcc6f4ff08f10afc9eb18d5af16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write unsigned LEB128 data.  <br /></td></tr>
<tr class="separator:a1d290fcc6f4ff08f10afc9eb18d5af16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486cee9c105ed0e242f6c00183c682f3" id="r_a486cee9c105ed0e242f6c00183c682f3"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a486cee9c105ed0e242f6c00183c682f3">ReadUleb128</a> (const char *addr, uint64_t *ret)</td></tr>
<tr class="memdesc:a486cee9c105ed0e242f6c00183c682f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read unsigned LEB128 data.  <br /></td></tr>
<tr class="separator:a486cee9c105ed0e242f6c00183c682f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4e972587009901ad40bc390e4bb8db" id="r_ade4e972587009901ad40bc390e4bb8db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade4e972587009901ad40bc390e4bb8db">ReadUleb128</a> (<a class="el" href="classwpi_1_1raw__istream.html">raw_istream</a> &amp;is, uint64_t *ret)</td></tr>
<tr class="memdesc:ade4e972587009901ad40bc390e4bb8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read unsigned LEB128 data from a stream.  <br /></td></tr>
<tr class="separator:ade4e972587009901ad40bc390e4bb8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e35647cd9f9f0d2c097ea72e6d9f608" id="r_a0e35647cd9f9f0d2c097ea72e6d9f608"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned N&gt; </td></tr>
<tr class="memitem:a0e35647cd9f9f0d2c097ea72e6d9f608"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0e35647cd9f9f0d2c097ea72e6d9f608">capacity_in_bytes</a> (const <a class="el" href="classwpi_1_1_small_vector.html">SmallVector</a>&lt; T, N &gt; &amp;X)</td></tr>
<tr class="separator:a0e35647cd9f9f0d2c097ea72e6d9f608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5602e08ef8bfc0486d71717a291a06b4" id="r_a5602e08ef8bfc0486d71717a291a06b4"><td class="memTemplParams" colspan="2">template&lt;unsigned Size, typename R &gt; </td></tr>
<tr class="memitem:a5602e08ef8bfc0486d71717a291a06b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1_small_vector.html">SmallVector</a>&lt; <a class="el" href="#a5ba14c6ed82a2230ba7b7f9152d1e6af">ValueTypeFromRangeType</a>&lt; R &gt;, Size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5602e08ef8bfc0486d71717a291a06b4">to_vector</a> (R &amp;&amp;Range)</td></tr>
<tr class="memdesc:a5602e08ef8bfc0486d71717a291a06b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a range of type R, iterate the entire range and return a <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> with elements of the vector.  <br /></td></tr>
<tr class="separator:a5602e08ef8bfc0486d71717a291a06b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6769bd8fc499c71e913a1b6af19b9232" id="r_a6769bd8fc499c71e913a1b6af19b9232"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a6769bd8fc499c71e913a1b6af19b9232"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1_small_vector.html">SmallVector</a>&lt; <a class="el" href="#a5ba14c6ed82a2230ba7b7f9152d1e6af">ValueTypeFromRangeType</a>&lt; R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6769bd8fc499c71e913a1b6af19b9232">to_vector</a> (R &amp;&amp;Range)</td></tr>
<tr class="separator:a6769bd8fc499c71e913a1b6af19b9232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77699b09ddc46df66382aa0a658d5da5" id="r_a77699b09ddc46df66382aa0a658d5da5"><td class="memTemplParams" colspan="2">template&lt;typename Out , unsigned Size, typename R &gt; </td></tr>
<tr class="memitem:a77699b09ddc46df66382aa0a658d5da5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1_small_vector.html">SmallVector</a>&lt; Out, Size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a77699b09ddc46df66382aa0a658d5da5">to_vector_of</a> (R &amp;&amp;Range)</td></tr>
<tr class="separator:a77699b09ddc46df66382aa0a658d5da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1687abd77cebc784b25364d696c46fee" id="r_a1687abd77cebc784b25364d696c46fee"><td class="memTemplParams" colspan="2">template&lt;typename Out , typename R &gt; </td></tr>
<tr class="memitem:a1687abd77cebc784b25364d696c46fee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1_small_vector.html">SmallVector</a>&lt; Out &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1687abd77cebc784b25364d696c46fee">to_vector_of</a> (R &amp;&amp;Range)</td></tr>
<tr class="separator:a1687abd77cebc784b25364d696c46fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7c7026236c3b3756c7ade99aa716cc" id="r_a9f7c7026236c3b3756c7ade99aa716cc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:a9f7c7026236c3b3756c7ade99aa716cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; T &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9f7c7026236c3b3756c7ade99aa716cc">erase_if</a> (<a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; T &gt; &amp;c, Pred pred)</td></tr>
<tr class="separator:a9f7c7026236c3b3756c7ade99aa716cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e2b9c52f4cd86842aa577863b93c2a" id="r_ab9e2b9c52f4cd86842aa577863b93c2a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab9e2b9c52f4cd86842aa577863b93c2a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab9e2b9c52f4cd86842aa577863b93c2a">insert_sorted</a> (std::vector&lt; T &gt; &amp;vec, T const &amp;item)</td></tr>
<tr class="separator:ab9e2b9c52f4cd86842aa577863b93c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7928a642def980fb692b5d321ed63529" id="r_a7928a642def980fb692b5d321ed63529"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Ts&gt; </td></tr>
<tr class="memitem:a7928a642def980fb692b5d321ed63529"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7928a642def980fb692b5d321ed63529">for_each</a> (F &amp;&amp;f, Ts &amp;&amp;... elems)</td></tr>
<tr class="memdesc:a7928a642def980fb692b5d321ed63529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls f(i, elem) for each element of elems where i is the index of the element in elems and elem is the element.  <br /></td></tr>
<tr class="separator:a7928a642def980fb692b5d321ed63529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abdfb1cf85cbf947a6de5c34b0ed078" id="r_a2abdfb1cf85cbf947a6de5c34b0ed078"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Function &gt; </td></tr>
<tr class="memitem:a2abdfb1cf85cbf947a6de5c34b0ed078"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2abdfb1cf85cbf947a6de5c34b0ed078">transformOptional</a> (const std::optional&lt; T &gt; &amp;O, const Function &amp;F) -&gt; std::optional&lt; decltype(F(*O))&gt;</td></tr>
<tr class="separator:a2abdfb1cf85cbf947a6de5c34b0ed078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d3870ae294caf2d9463229be0c67bc" id="r_a50d3870ae294caf2d9463229be0c67bc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Function &gt; </td></tr>
<tr class="memitem:a50d3870ae294caf2d9463229be0c67bc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a50d3870ae294caf2d9463229be0c67bc">transformOptional</a> (std::optional&lt; T &gt; &amp;&amp;O, const Function &amp;F) -&gt; std::optional&lt; decltype(F(*std::move(O)))&gt;</td></tr>
<tr class="separator:a50d3870ae294caf2d9463229be0c67bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac420770a69a1f2159f02480b797fccc1" id="r_ac420770a69a1f2159f02480b797fccc1"><td class="memTemplParams" colspan="2">template&lt;typename Enum &gt; </td></tr>
<tr class="memitem:ac420770a69a1f2159f02480b797fccc1"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::underlying_type_t&lt; Enum &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac420770a69a1f2159f02480b797fccc1">to_underlying</a> (Enum E)</td></tr>
<tr class="memdesc:ac420770a69a1f2159f02480b797fccc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns underlying integer value of an enum.  <br /></td></tr>
<tr class="separator:ac420770a69a1f2159f02480b797fccc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f52673d7bfdffd89e1d383abf131410" id="r_a0f52673d7bfdffd89e1d383abf131410"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f52673d7bfdffd89e1d383abf131410"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f52673d7bfdffd89e1d383abf131410">CreateMessage</a> (google::protobuf::Arena *arena)</td></tr>
<tr class="separator:a0f52673d7bfdffd89e1d383abf131410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64cc2a8bb25b3e692e7aacd722fdd29" id="r_ac64cc2a8bb25b3e692e7aacd722fdd29"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned LN, unsigned RN, typename C &gt; </td></tr>
<tr class="memitem:ac64cc2a8bb25b3e692e7aacd722fdd29"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac64cc2a8bb25b3e692e7aacd722fdd29">operator==</a> (const <a class="el" href="classwpi_1_1_small_set.html">SmallSet</a>&lt; T, LN, C &gt; &amp;LHS, const <a class="el" href="classwpi_1_1_small_set.html">SmallSet</a>&lt; T, RN, C &gt; &amp;RHS)</td></tr>
<tr class="memdesc:ac64cc2a8bb25b3e692e7aacd722fdd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison for <a class="el" href="classwpi_1_1_small_set.html" title="SmallSet - This maintains a set of unique values, optimizing for the case when the set is small (less...">SmallSet</a>.  <br /></td></tr>
<tr class="separator:ac64cc2a8bb25b3e692e7aacd722fdd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad032764915283409382ba49638651b69" id="r_ad032764915283409382ba49638651b69"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned LN, unsigned RN, typename C &gt; </td></tr>
<tr class="memitem:ad032764915283409382ba49638651b69"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad032764915283409382ba49638651b69">operator!=</a> (const <a class="el" href="classwpi_1_1_small_set.html">SmallSet</a>&lt; T, LN, C &gt; &amp;LHS, const <a class="el" href="classwpi_1_1_small_set.html">SmallSet</a>&lt; T, RN, C &gt; &amp;RHS)</td></tr>
<tr class="memdesc:ad032764915283409382ba49638651b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison for <a class="el" href="classwpi_1_1_small_set.html" title="SmallSet - This maintains a set of unique values, optimizing for the case when the set is small (less...">SmallSet</a>.  <br /></td></tr>
<tr class="separator:ad032764915283409382ba49638651b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3287d2b8e67eaf00c1f275eb1d2b1fd8" id="r_a3287d2b8e67eaf00c1f275eb1d2b1fd8"><td class="memTemplParams" colspan="2">template&lt;typename ... PTs&gt; </td></tr>
<tr class="memitem:a3287d2b8e67eaf00c1f275eb1d2b1fd8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3287d2b8e67eaf00c1f275eb1d2b1fd8">operator==</a> (<a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt; lhs, <a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt; rhs)</td></tr>
<tr class="separator:a3287d2b8e67eaf00c1f275eb1d2b1fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088be308371a5cee44b52aedf5a619e7" id="r_a088be308371a5cee44b52aedf5a619e7"><td class="memTemplParams" colspan="2">template&lt;typename ... PTs&gt; </td></tr>
<tr class="memitem:a088be308371a5cee44b52aedf5a619e7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a088be308371a5cee44b52aedf5a619e7">operator!=</a> (<a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt; lhs, <a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt; rhs)</td></tr>
<tr class="separator:a088be308371a5cee44b52aedf5a619e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e03174a92e237c3b5544c57d3dee498" id="r_a4e03174a92e237c3b5544c57d3dee498"><td class="memTemplParams" colspan="2">template&lt;typename ... PTs&gt; </td></tr>
<tr class="memitem:a4e03174a92e237c3b5544c57d3dee498"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4e03174a92e237c3b5544c57d3dee498">operator&lt;</a> (<a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt; lhs, <a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt; rhs)</td></tr>
<tr class="separator:a4e03174a92e237c3b5544c57d3dee498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf26bf198ea436f545bf8205670ff7a" id="r_afbf26bf198ea436f545bf8205670ff7a"><td class="memTemplParams" colspan="2">template&lt;class T  = void *&gt; </td></tr>
<tr class="memitem:afbf26bf198ea436f545bf8205670ff7a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afbf26bf198ea436f545bf8205670ff7a">shouldReverseIterate</a> ()</td></tr>
<tr class="separator:afbf26bf198ea436f545bf8205670ff7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95acb3c2c107b75867a237c1701577c" id="r_aa95acb3c2c107b75867a237c1701577c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa95acb3c2c107b75867a237c1701577c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="classwpi_1_1is__integral__or__enum.html">is_integral_or_enum</a>&lt; T &gt;::value, <a class="el" href="classwpi_1_1hash__code.html">hash_code</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa95acb3c2c107b75867a237c1701577c">hash_value</a> (T value)</td></tr>
<tr class="memdesc:aa95acb3c2c107b75867a237c1701577c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for any integer value.  <br /></td></tr>
<tr class="separator:aa95acb3c2c107b75867a237c1701577c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb96f94c028542a238feaf8cabb44dc" id="r_a8eb96f94c028542a238feaf8cabb44dc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8eb96f94c028542a238feaf8cabb44dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8eb96f94c028542a238feaf8cabb44dc">hash_value</a> (const T *<a class="el" href="format_8h.html#adb6e274f8eb0b74b2865215e1b49c535">ptr</a>)</td></tr>
<tr class="memdesc:a8eb96f94c028542a238feaf8cabb44dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a pointer's address.  <br /></td></tr>
<tr class="separator:a8eb96f94c028542a238feaf8cabb44dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9238bfb621b5c47abfc9480889408e" id="r_a6b9238bfb621b5c47abfc9480889408e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a6b9238bfb621b5c47abfc9480889408e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6b9238bfb621b5c47abfc9480889408e">hash_value</a> (const std::pair&lt; T, U &gt; &amp;<a class="el" href="wpiutil_2src_2main_2native_2thirdparty_2fmtlib_2include_2fmt_2base_8h.html#a2c8e80c1b1c8b7747e99b8e9a24a0429">arg</a>)</td></tr>
<tr class="memdesc:a6b9238bfb621b5c47abfc9480889408e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a pair of objects.  <br /></td></tr>
<tr class="separator:a6b9238bfb621b5c47abfc9480889408e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09058a5e42b0bee35ae7f6d7bf0822a0" id="r_a09058a5e42b0bee35ae7f6d7bf0822a0"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a09058a5e42b0bee35ae7f6d7bf0822a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a09058a5e42b0bee35ae7f6d7bf0822a0">hash_value</a> (const std::tuple&lt; Ts... &gt; &amp;<a class="el" href="wpiutil_2src_2main_2native_2thirdparty_2fmtlib_2include_2fmt_2base_8h.html#a2c8e80c1b1c8b7747e99b8e9a24a0429">arg</a>)</td></tr>
<tr class="memdesc:a09058a5e42b0bee35ae7f6d7bf0822a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a tuple.  <br /></td></tr>
<tr class="separator:a09058a5e42b0bee35ae7f6d7bf0822a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2f8fc1e0870f5b219a8bc1d3654ecc" id="r_a8e2f8fc1e0870f5b219a8bc1d3654ecc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8e2f8fc1e0870f5b219a8bc1d3654ecc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8e2f8fc1e0870f5b219a8bc1d3654ecc">hash_value</a> (const std::basic_string&lt; T &gt; &amp;<a class="el" href="wpiutil_2src_2main_2native_2thirdparty_2fmtlib_2include_2fmt_2base_8h.html#a2c8e80c1b1c8b7747e99b8e9a24a0429">arg</a>)</td></tr>
<tr class="memdesc:a8e2f8fc1e0870f5b219a8bc1d3654ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a standard string.  <br /></td></tr>
<tr class="separator:a8e2f8fc1e0870f5b219a8bc1d3654ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d22556bedb2cce56fa864ccb308f5d" id="r_a97d22556bedb2cce56fa864ccb308f5d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a97d22556bedb2cce56fa864ccb308f5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a97d22556bedb2cce56fa864ccb308f5d">hash_value</a> (const std::optional&lt; T &gt; &amp;<a class="el" href="wpiutil_2src_2main_2native_2thirdparty_2fmtlib_2include_2fmt_2base_8h.html#a2c8e80c1b1c8b7747e99b8e9a24a0429">arg</a>)</td></tr>
<tr class="memdesc:a97d22556bedb2cce56fa864ccb308f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a standard string.  <br /></td></tr>
<tr class="separator:a97d22556bedb2cce56fa864ccb308f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9199d95a0d0ca4ba23a42b8c9cd4763" id="r_ab9199d95a0d0ca4ba23a42b8c9cd4763"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9199d95a0d0ca4ba23a42b8c9cd4763">set_fixed_execution_hash_seed</a> (uint64_t fixed_value)</td></tr>
<tr class="memdesc:ab9199d95a0d0ca4ba23a42b8c9cd4763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override the execution seed with a fixed value.  <br /></td></tr>
<tr class="separator:ab9199d95a0d0ca4ba23a42b8c9cd4763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583ca8bbb8e3ee49e8f65df91a6ecaaf" id="r_a583ca8bbb8e3ee49e8f65df91a6ecaaf"><td class="memTemplParams" colspan="2">template&lt;typename InputIteratorT &gt; </td></tr>
<tr class="memitem:a583ca8bbb8e3ee49e8f65df91a6ecaaf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a583ca8bbb8e3ee49e8f65df91a6ecaaf">hash_combine_range</a> (InputIteratorT first, InputIteratorT last)</td></tr>
<tr class="memdesc:a583ca8bbb8e3ee49e8f65df91a6ecaaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a sequence of values.  <br /></td></tr>
<tr class="separator:a583ca8bbb8e3ee49e8f65df91a6ecaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a8888fe7cb03223848f14e95e42764" id="r_a70a8888fe7cb03223848f14e95e42764"><td class="memTemplParams" colspan="2">template&lt;typename ... Ts&gt; </td></tr>
<tr class="memitem:a70a8888fe7cb03223848f14e95e42764"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a70a8888fe7cb03223848f14e95e42764">hash_combine</a> (const Ts &amp;...args)</td></tr>
<tr class="memdesc:a70a8888fe7cb03223848f14e95e42764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine values into a single <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a>.  <br /></td></tr>
<tr class="separator:a70a8888fe7cb03223848f14e95e42764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2b51e8a094e47441a1f8a17b129255" id="r_a5e2b51e8a094e47441a1f8a17b129255"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_synchronization_8h.html#a4e842b28ce72a1d1dc778397b5f81b87">WPI_EventHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e2b51e8a094e47441a1f8a17b129255">CreateEvent</a> (bool manualReset=false, bool initialState=false)</td></tr>
<tr class="memdesc:a5e2b51e8a094e47441a1f8a17b129255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an event.  <br /></td></tr>
<tr class="separator:a5e2b51e8a094e47441a1f8a17b129255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9e09379b6fd369678065777492fa13" id="r_acc9e09379b6fd369678065777492fa13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc9e09379b6fd369678065777492fa13">DestroyEvent</a> (<a class="el" href="_synchronization_8h.html#a4e842b28ce72a1d1dc778397b5f81b87">WPI_EventHandle</a> handle)</td></tr>
<tr class="memdesc:acc9e09379b6fd369678065777492fa13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an event.  <br /></td></tr>
<tr class="separator:acc9e09379b6fd369678065777492fa13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397be4df815a23d76e43a6713bc2c8b6" id="r_a397be4df815a23d76e43a6713bc2c8b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a397be4df815a23d76e43a6713bc2c8b6">SetEvent</a> (<a class="el" href="_synchronization_8h.html#a4e842b28ce72a1d1dc778397b5f81b87">WPI_EventHandle</a> handle)</td></tr>
<tr class="memdesc:a397be4df815a23d76e43a6713bc2c8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an event to signaled state.  <br /></td></tr>
<tr class="separator:a397be4df815a23d76e43a6713bc2c8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601a2e82b14588ebbce04bd58f47de35" id="r_a601a2e82b14588ebbce04bd58f47de35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a601a2e82b14588ebbce04bd58f47de35">ResetEvent</a> (<a class="el" href="_synchronization_8h.html#a4e842b28ce72a1d1dc778397b5f81b87">WPI_EventHandle</a> handle)</td></tr>
<tr class="memdesc:a601a2e82b14588ebbce04bd58f47de35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an event to non-signaled state.  <br /></td></tr>
<tr class="separator:a601a2e82b14588ebbce04bd58f47de35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cf2d5389f07b5a0b98d4b26be8c766" id="r_ae9cf2d5389f07b5a0b98d4b26be8c766"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_synchronization_8h.html#a35ca8808aba014f82899e1bca7c7372b">WPI_SemaphoreHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9cf2d5389f07b5a0b98d4b26be8c766">CreateSemaphore</a> (int initialCount=0, int maximumCount=INT_MAX)</td></tr>
<tr class="memdesc:ae9cf2d5389f07b5a0b98d4b26be8c766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a semaphore.  <br /></td></tr>
<tr class="separator:ae9cf2d5389f07b5a0b98d4b26be8c766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c260de651e61ba3109bdab5ce72c6fc" id="r_a0c260de651e61ba3109bdab5ce72c6fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c260de651e61ba3109bdab5ce72c6fc">DestroySemaphore</a> (<a class="el" href="_synchronization_8h.html#a35ca8808aba014f82899e1bca7c7372b">WPI_SemaphoreHandle</a> handle)</td></tr>
<tr class="memdesc:a0c260de651e61ba3109bdab5ce72c6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a semaphore.  <br /></td></tr>
<tr class="separator:a0c260de651e61ba3109bdab5ce72c6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6962747bba62185bf15ef5484bee3e2" id="r_ac6962747bba62185bf15ef5484bee3e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6962747bba62185bf15ef5484bee3e2">ReleaseSemaphore</a> (<a class="el" href="_synchronization_8h.html#a35ca8808aba014f82899e1bca7c7372b">WPI_SemaphoreHandle</a> handle, int releaseCount=1, int *prevCount=nullptr)</td></tr>
<tr class="memdesc:ac6962747bba62185bf15ef5484bee3e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases N counts of a semaphore.  <br /></td></tr>
<tr class="separator:ac6962747bba62185bf15ef5484bee3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878b699be631007b8e6eeb2c95e4bc83" id="r_a878b699be631007b8e6eeb2c95e4bc83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a878b699be631007b8e6eeb2c95e4bc83">WaitForObject</a> (<a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> handle)</td></tr>
<tr class="memdesc:a878b699be631007b8e6eeb2c95e4bc83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for an handle to be signaled.  <br /></td></tr>
<tr class="separator:a878b699be631007b8e6eeb2c95e4bc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10992d66a2e0bc348c37c2bbca2ce718" id="r_a10992d66a2e0bc348c37c2bbca2ce718"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10992d66a2e0bc348c37c2bbca2ce718">WaitForObject</a> (<a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> handle, double timeout, bool *timedOut)</td></tr>
<tr class="memdesc:a10992d66a2e0bc348c37c2bbca2ce718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for an handle to be signaled, with timeout.  <br /></td></tr>
<tr class="separator:a10992d66a2e0bc348c37c2bbca2ce718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a293cc66ff9b6f047b81e41cb697d9" id="r_af8a293cc66ff9b6f047b81e41cb697d9"><td class="memItemLeft" align="right" valign="top">std::span&lt; <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8a293cc66ff9b6f047b81e41cb697d9">WaitForObjects</a> (std::span&lt; const <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt; handles, std::span&lt; <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt; signaled)</td></tr>
<tr class="memdesc:af8a293cc66ff9b6f047b81e41cb697d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for one or more handles to be signaled.  <br /></td></tr>
<tr class="separator:af8a293cc66ff9b6f047b81e41cb697d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad9633f9184e5be60f5f35700af7dba" id="r_acad9633f9184e5be60f5f35700af7dba"><td class="memItemLeft" align="right" valign="top">std::span&lt; <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acad9633f9184e5be60f5f35700af7dba">WaitForObjects</a> (std::initializer_list&lt; <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt; handles, std::span&lt; <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt; signaled)</td></tr>
<tr class="memdesc:acad9633f9184e5be60f5f35700af7dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for one or more handles to be signaled.  <br /></td></tr>
<tr class="separator:acad9633f9184e5be60f5f35700af7dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393fa6e883232d7af1d57d96218fd2f8" id="r_a393fa6e883232d7af1d57d96218fd2f8"><td class="memItemLeft" align="right" valign="top">std::span&lt; <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a393fa6e883232d7af1d57d96218fd2f8">WaitForObjects</a> (std::span&lt; const <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt; handles, std::span&lt; <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt; signaled, double timeout, bool *timedOut)</td></tr>
<tr class="memdesc:a393fa6e883232d7af1d57d96218fd2f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for one or more handles to be signaled, with timeout.  <br /></td></tr>
<tr class="separator:a393fa6e883232d7af1d57d96218fd2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4471d272e72369b5c5c12da6bc222d2" id="r_ae4471d272e72369b5c5c12da6bc222d2"><td class="memItemLeft" align="right" valign="top">std::span&lt; <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4471d272e72369b5c5c12da6bc222d2">WaitForObjects</a> (std::initializer_list&lt; <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt; handles, std::span&lt; <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt; signaled, double timeout, bool *timedOut)</td></tr>
<tr class="memdesc:ae4471d272e72369b5c5c12da6bc222d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for one or more handles to be signaled, with timeout.  <br /></td></tr>
<tr class="separator:ae4471d272e72369b5c5c12da6bc222d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd6181788d9d2b6ca9df2e9120e6bc1" id="r_a1dd6181788d9d2b6ca9df2e9120e6bc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1dd6181788d9d2b6ca9df2e9120e6bc1">CreateSignalObject</a> (<a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> handle, bool manualReset=false, bool initialState=false)</td></tr>
<tr class="memdesc:a1dd6181788d9d2b6ca9df2e9120e6bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up signaling for an arbitrary handle.  <br /></td></tr>
<tr class="separator:a1dd6181788d9d2b6ca9df2e9120e6bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5461711574b8a35edcde80d9ecaf9ff" id="r_ab5461711574b8a35edcde80d9ecaf9ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5461711574b8a35edcde80d9ecaf9ff">SetSignalObject</a> (<a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> handle)</td></tr>
<tr class="memdesc:ab5461711574b8a35edcde80d9ecaf9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a handle to signaled state.  <br /></td></tr>
<tr class="separator:ab5461711574b8a35edcde80d9ecaf9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591297d9bc21d366707c09d9ebb9e1b2" id="r_a591297d9bc21d366707c09d9ebb9e1b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a591297d9bc21d366707c09d9ebb9e1b2">ResetSignalObject</a> (<a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> handle)</td></tr>
<tr class="memdesc:a591297d9bc21d366707c09d9ebb9e1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a handle to non-signaled state.  <br /></td></tr>
<tr class="separator:a591297d9bc21d366707c09d9ebb9e1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbea963e58a5375de8945e77262bb05" id="r_aacbea963e58a5375de8945e77262bb05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacbea963e58a5375de8945e77262bb05">DestroySignalObject</a> (<a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> handle)</td></tr>
<tr class="memdesc:aacbea963e58a5375de8945e77262bb05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up signaling for a handle.  <br /></td></tr>
<tr class="separator:aacbea963e58a5375de8945e77262bb05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed245bfb118e5dfe475bf2044a4985d8" id="r_aed245bfb118e5dfe475bf2044a4985d8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed245bfb118e5dfe475bf2044a4985d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1future.html">future</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aed245bfb118e5dfe475bf2044a4985d8">make_ready_future</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:aed245bfb118e5dfe475bf2044a4985d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a valid future with the value set.  <br /></td></tr>
<tr class="separator:aed245bfb118e5dfe475bf2044a4985d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a0d64a50babc1c46b2ede08a2cf13d" id="r_a21a0d64a50babc1c46b2ede08a2cf13d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1future.html">future</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21a0d64a50babc1c46b2ede08a2cf13d">make_ready_future</a> ()</td></tr>
<tr class="memdesc:a21a0d64a50babc1c46b2ede08a2cf13d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a valid future with the value set.  <br /></td></tr>
<tr class="separator:a21a0d64a50babc1c46b2ede08a2cf13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863f7dccbe48e628d0674d0957238fe6" id="r_a863f7dccbe48e628d0674d0957238fe6"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a863f7dccbe48e628d0674d0957238fe6">MimeTypeFromPath</a> (std::string_view path)</td></tr>
<tr class="separator:a863f7dccbe48e628d0674d0957238fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5219583a8d061de60505c1ca0327f1c6" id="r_a5219583a8d061de60505c1ca0327f1c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2b741829b477ec608a2534e5e5a22f67">default_arguments</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5219583a8d061de60505c1ca0327f1c6">operator&amp;</a> (const <a class="el" href="#a2b741829b477ec608a2534e5e5a22f67">default_arguments</a> &amp;a, const <a class="el" href="#a2b741829b477ec608a2534e5e5a22f67">default_arguments</a> &amp;b)</td></tr>
<tr class="separator:a5219583a8d061de60505c1ca0327f1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3690db2358c9141bfa7dc816cb91436a" id="r_a3690db2358c9141bfa7dc816cb91436a"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t ArrayExtent&gt; </td></tr>
<tr class="memitem:a3690db2358c9141bfa7dc816cb91436a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3690db2358c9141bfa7dc816cb91436a">rotated_span</a> (Type(&amp;)[ArrayExtent]) -&gt; rotated_span&lt; Type, ArrayExtent &gt;</td></tr>
<tr class="separator:a3690db2358c9141bfa7dc816cb91436a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4748932455907f51f9f495d41c8b437" id="r_ab4748932455907f51f9f495d41c8b437"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t ArrayExtent&gt; </td></tr>
<tr class="memitem:ab4748932455907f51f9f495d41c8b437"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab4748932455907f51f9f495d41c8b437">rotated_span</a> (std::array&lt; Type, ArrayExtent &gt; &amp;) -&gt; rotated_span&lt; Type, ArrayExtent &gt;</td></tr>
<tr class="separator:ab4748932455907f51f9f495d41c8b437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8401d71223335daab845683d6d786af" id="r_ad8401d71223335daab845683d6d786af"><td class="memTemplParams" colspan="2">template&lt;std::contiguous_iterator It, typename End &gt; </td></tr>
<tr class="memitem:ad8401d71223335daab845683d6d786af"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad8401d71223335daab845683d6d786af">rotated_span</a> (It, End) -&gt; rotated_span&lt; std::remove_reference_t&lt; std::iter_reference_t&lt; It &gt; &gt; &gt;</td></tr>
<tr class="separator:ad8401d71223335daab845683d6d786af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7f0ad943e1786cd6c0a13a763880f8" id="r_a3f7f0ad943e1786cd6c0a13a763880f8"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t Extent&gt; </td></tr>
<tr class="memitem:a3f7f0ad943e1786cd6c0a13a763880f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1rotated__span.html">rotated_span</a>&lt; const std::byte, Extent==std::dynamic_extent ? std::dynamic_extent :Extent *sizeof(Type)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3f7f0ad943e1786cd6c0a13a763880f8">as_bytes</a> (<a class="el" href="classwpi_1_1rotated__span.html">rotated_span</a>&lt; Type, Extent &gt; sp) noexcept</td></tr>
<tr class="separator:a3f7f0ad943e1786cd6c0a13a763880f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e3f0e3cb64b1422a2866adbce6da8c" id="r_ad6e3f0e3cb64b1422a2866adbce6da8c"><td class="memTemplParams" colspan="2">template&lt;typename Type , size_t Extent&gt; <br />
requires (!std::is_const_v&lt;Type&gt;)</td></tr>
<tr class="memitem:ad6e3f0e3cb64b1422a2866adbce6da8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1rotated__span.html">rotated_span</a>&lt; std::byte, Extent==std::dynamic_extent ? std::dynamic_extent :Extent *sizeof(Type)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad6e3f0e3cb64b1422a2866adbce6da8c">as_writable_bytes</a> (<a class="el" href="classwpi_1_1rotated__span.html">rotated_span</a>&lt; Type, Extent &gt; sp) noexcept</td></tr>
<tr class="separator:ad6e3f0e3cb64b1422a2866adbce6da8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd1bef2e08248159bc8fae9290ac160" id="r_a3fd1bef2e08248159bc8fae9290ac160"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fd1bef2e08248159bc8fae9290ac160">xxHash64</a> (std::string_view Data)</td></tr>
<tr class="separator:a3fd1bef2e08248159bc8fae9290ac160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa897f74e19d0de9754ab270fe2fdbd89" id="r_aa897f74e19d0de9754ab270fe2fdbd89"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa897f74e19d0de9754ab270fe2fdbd89">xxHash64</a> (std::span&lt; const uint8_t &gt; Data)</td></tr>
<tr class="separator:aa897f74e19d0de9754ab270fe2fdbd89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7bbf91a7aa1adadf235c7388ec0663" id="r_aaa7bbf91a7aa1adadf235c7388ec0663"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa7bbf91a7aa1adadf235c7388ec0663">xxh3_64bits</a> (std::span&lt; const uint8_t &gt; data)</td></tr>
<tr class="separator:aaa7bbf91a7aa1adadf235c7388ec0663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776a14294ad0f23f615b831d908eb34d" id="r_a776a14294ad0f23f615b831d908eb34d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a776a14294ad0f23f615b831d908eb34d">xxh3_64bits</a> (std::string_view data)</td></tr>
<tr class="separator:a776a14294ad0f23f615b831d908eb34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcb05e6bcaec6ab65a71d55d6586366" id="r_a1bcb05e6bcaec6ab65a71d55d6586366"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a1bcb05e6bcaec6ab65a71d55d6586366"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1bcb05e6bcaec6ab65a71d55d6586366">iterator_range</a> (Container &amp;&amp;) -&gt; iterator_range&lt; <a class="el" href="namespacewpi_1_1detail.html#a5097c6ebef74fe403b5012c6d7e7f61b">detail::IterOfRange</a>&lt; Container &gt; &gt;</td></tr>
<tr class="separator:a1bcb05e6bcaec6ab65a71d55d6586366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc327c9a551f61642d9a6ef107c4593" id="r_aacc327c9a551f61642d9a6ef107c4593"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aacc327c9a551f61642d9a6ef107c4593"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1iterator__range.html">iterator_range</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aacc327c9a551f61642d9a6ef107c4593">make_range</a> (T x, T y)</td></tr>
<tr class="memdesc:aacc327c9a551f61642d9a6ef107c4593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for iterating over sub-ranges.  <br /></td></tr>
<tr class="separator:aacc327c9a551f61642d9a6ef107c4593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b2b7a19d614a944822ce6f577be33a" id="r_ad1b2b7a19d614a944822ce6f577be33a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad1b2b7a19d614a944822ce6f577be33a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1iterator__range.html">iterator_range</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad1b2b7a19d614a944822ce6f577be33a">make_range</a> (std::pair&lt; T, T &gt; p)</td></tr>
<tr class="separator:ad1b2b7a19d614a944822ce6f577be33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a0f1727b9890d66f5ef4750af330b072c" id="r_a0f1727b9890d66f5ef4750af330b072c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f1727b9890d66f5ef4750af330b072c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f1727b9890d66f5ef4750af330b072c">IsNullable</a></td></tr>
<tr class="separator:a0f1727b9890d66f5ef4750af330b072c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096e48bf0264a255eb2ff954146cc85b" id="r_a096e48bf0264a255eb2ff954146cc85b"><td class="memItemLeft" align="right" valign="top">static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a096e48bf0264a255eb2ff954146cc85b">BitReverseTable256</a> [256]</td></tr>
<tr class="memdesc:a096e48bf0264a255eb2ff954146cc85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro compressed bit reversal table for 256 bits.  <br /></td></tr>
<tr class="separator:a096e48bf0264a255eb2ff954146cc85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68147e630fcf898faec5b0f4cacd7214" id="r_a68147e630fcf898faec5b0f4cacd7214"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68147e630fcf898faec5b0f4cacd7214">huge_valf</a></td></tr>
<tr class="memdesc:a68147e630fcf898faec5b0f4cacd7214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this rather than HUGE_VALF; the latter causes warnings on MSVC.  <br /></td></tr>
<tr class="separator:a68147e630fcf898faec5b0f4cacd7214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cecb2351a66db7a659706908ff8764" id="r_ab3cecb2351a66db7a659706908ff8764"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structwpi_1_1empty__array__t.html">empty_array_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3cecb2351a66db7a659706908ff8764">empty_array</a></td></tr>
<tr class="separator:ab3cecb2351a66db7a659706908ff8764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e441a1bfb8b548adcb3fd7e08eb3be0" id="r_a9e441a1bfb8b548adcb3fd7e08eb3be0"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="structwpi_1_1in__place__t.html">in_place_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e441a1bfb8b548adcb3fd7e08eb3be0">in_place</a> {}</td></tr>
<tr class="separator:a9e441a1bfb8b548adcb3fd7e08eb3be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec1d1c5281afa1fc4e4333abc544b45" id="r_a8ec1d1c5281afa1fc4e4333abc544b45"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="structwpi_1_1unexpect__t.html">unexpect_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ec1d1c5281afa1fc4e4333abc544b45">unexpect</a> {}</td></tr>
<tr class="separator:a8ec1d1c5281afa1fc4e4333abc544b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ddf62331eda674218d045fb5376c13" id="r_a74ddf62331eda674218d045fb5376c13"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned N&gt; </td></tr>
<tr class="memitem:a74ddf62331eda674218d045fb5376c13"><td class="memTemplItemLeft" align="right" valign="top">class <a class="el" href="_compiler_8h.html#a61e566d072949de225fa6912528beaf5">LLVM_GSL_OWNER</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a74ddf62331eda674218d045fb5376c13">SmallVector</a></td></tr>
<tr class="memdesc:a74ddf62331eda674218d045fb5376c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration of <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> so that calculateSmallVectorDefaultInlinedElements can reference <code>sizeof(<a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a>&lt;T, 0&gt;)</code>.  <br /></td></tr>
<tr class="separator:a74ddf62331eda674218d045fb5376c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd67a84f9a70d9cfcee1d5deb9f909cf" id="r_afd67a84f9a70d9cfcee1d5deb9f909cf"><td class="memItemLeft" align="right" valign="top">constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd67a84f9a70d9cfcee1d5deb9f909cf">kInvalidHandle</a> = 0</td></tr>
<tr class="memdesc:afd67a84f9a70d9cfcee1d5deb9f909cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant representing an invalid handle.  <br /></td></tr>
<tr class="separator:afd67a84f9a70d9cfcee1d5deb9f909cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab51794df83caf0d2ee4dcd959aef6600" id="r_ab51794df83caf0d2ee4dcd959aef6600"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab51794df83caf0d2ee4dcd959aef6600">kHandleTypeEvent</a> = 1</td></tr>
<tr class="memdesc:ab51794df83caf0d2ee4dcd959aef6600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard types for handles.  <br /></td></tr>
<tr class="separator:ab51794df83caf0d2ee4dcd959aef6600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da225411044fa616099a3373dbe6730" id="r_a5da225411044fa616099a3373dbe6730"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5da225411044fa616099a3373dbe6730">kHandleTypeSemaphore</a> = 2</td></tr>
<tr class="separator:a5da225411044fa616099a3373dbe6730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de0a4446fe8d9ed31724a8b930aee57" id="r_a8de0a4446fe8d9ed31724a8b930aee57"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8de0a4446fe8d9ed31724a8b930aee57">kHandleTypeCSBase</a> = 3</td></tr>
<tr class="separator:a8de0a4446fe8d9ed31724a8b930aee57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99480131b4acc3346e92488fa6ef11c3" id="r_a99480131b4acc3346e92488fa6ef11c3"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99480131b4acc3346e92488fa6ef11c3">kHandleTypeNTBase</a> = 16</td></tr>
<tr class="separator:a99480131b4acc3346e92488fa6ef11c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b0fdd08ea9c5d05545f34d61daa6b3" id="r_ae6b0fdd08ea9c5d05545f34d61daa6b3"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6b0fdd08ea9c5d05545f34d61daa6b3">kHandleTypeHALBase</a> = 48</td></tr>
<tr class="separator:ae6b0fdd08ea9c5d05545f34d61daa6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d975e6f2e33e12e3ba9f88f3abbcae" id="r_ac0d975e6f2e33e12e3ba9f88f3abbcae"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0d975e6f2e33e12e3ba9f88f3abbcae">kHandleTypeUserBase</a> = 80</td></tr>
<tr class="separator:ac0d975e6f2e33e12e3ba9f88f3abbcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Foonathan namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ac9954615e01ad150570a0e1d4548d879" name="ac9954615e01ad150570a0e1d4548d879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9954615e01ad150570a0e1d4548d879">&#9670;&#160;</a></span>Boolean</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool <a class="el" href="#ac9954615e01ad150570a0e1d4548d879">wpi::Boolean</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34e586095a24baa7bbd27dcc50251c47" name="a34e586095a24baa7bbd27dcc50251c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e586095a24baa7bbd27dcc50251c47">&#9670;&#160;</a></span>condition_variable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a34e586095a24baa7bbd27dcc50251c47">wpi::condition_variable</a> = ::std::condition_variable</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f37036e786223b476f02676130eaf20" name="a7f37036e786223b476f02676130eaf20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f37036e786223b476f02676130eaf20">&#9670;&#160;</a></span>EnableIfConvertibleToInputIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7f37036e786223b476f02676130eaf20">wpi::EnableIfConvertibleToInputIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::enable_if_t&lt;std::is_convertible&lt;</div>
<div class="line">    <span class="keyword">typename</span> std::iterator_traits&lt;Iterator&gt;::iterator_category,</div>
<div class="line">    std::input_iterator_tag&gt;::value&gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="aacde1332b72e968317ed516552a07ca8" name="aacde1332b72e968317ed516552a07ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacde1332b72e968317ed516552a07ca8">&#9670;&#160;</a></span>fatal_error_handler_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* wpi::fatal_error_handler_t) (void *user_data, const char *reason, bool gen_crash_diag)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An error handler callback. </p>

</div>
</div>
<a id="a15767624048ad142d04bc6b1eab0d646" name="a15767624048ad142d04bc6b1eab0d646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15767624048ad142d04bc6b1eab0d646">&#9670;&#160;</a></span>http_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* wpi::http_cb) (<a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af30c1ffd4dedd4ff88adccac000e4c18" name="af30c1ffd4dedd4ff88adccac000e4c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30c1ffd4dedd4ff88adccac000e4c18">&#9670;&#160;</a></span>http_data_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* wpi::http_data_cb) (<a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *, const char *at, size_t length)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2f449b8813b6175c38218ad8b8996ea" name="ad2f449b8813b6175c38218ad8b8996ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f449b8813b6175c38218ad8b8996ea">&#9670;&#160;</a></span>mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ad2f449b8813b6175c38218ad8b8996ea">wpi::mutex</a> = ::std::mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6cccdd003c725c1d8558b97727563972" name="a6cccdd003c725c1d8558b97727563972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cccdd003c725c1d8558b97727563972">&#9670;&#160;</a></span>raw_pointer_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename WrappedIteratorT , typename T1  = std::remove_reference_t&lt;decltype(              **std::declval&lt;WrappedIteratorT&gt;())&gt;, typename T2  = std::add_pointer_t&lt;T1&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a6cccdd003c725c1d8558b97727563972">wpi::raw_pointer_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    pointer_iterator&lt;pointee_iterator&lt;WrappedIteratorT, T1&gt;, T2&gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="acfebff14457dadb6a3abf2edf9d4d8b5" name="acfebff14457dadb6a3abf2edf9d4d8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfebff14457dadb6a3abf2edf9d4d8b5">&#9670;&#160;</a></span>recursive_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#acfebff14457dadb6a3abf2edf9d4d8b5">wpi::recursive_mutex</a> = ::std::recursive_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab63bc458144009d9a09693c274d6001e" name="ab63bc458144009d9a09693c274d6001e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63bc458144009d9a09693c274d6001e">&#9670;&#160;</a></span>recursive_spinlock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab63bc458144009d9a09693c274d6001e">wpi::recursive_spinlock</a> = <a class="el" href="classwpi_1_1recursive__spinlock1.html">recursive_spinlock1</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a32ebe279c9afb4e51ea32f9d690c9561" name="a32ebe279c9afb4e51ea32f9d690c9561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ebe279c9afb4e51ea32f9d690c9561">&#9670;&#160;</a></span>TypeAtIndex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a32ebe279c9afb4e51ea32f9d690c9561">wpi::TypeAtIndex</a> = std::tuple_element_t&lt;I, std::tuple&lt;Ts...&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the type at a given index in a list of types. </p>
<p>TypeAtIndex&lt;I, Ts...&gt; is the type at index I in Ts. </p>

</div>
</div>
<a id="a45f45c50238ed154108c2d79c37d19ab" name="a45f45c50238ed154108c2d79c37d19ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f45c50238ed154108c2d79c37d19ab">&#9670;&#160;</a></span>UTF16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned short <a class="el" href="#a45f45c50238ed154108c2d79c37d19ab">wpi::UTF16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab31f8b5d3b4b5750e308b9486c8063cf" name="ab31f8b5d3b4b5750e308b9486c8063cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31f8b5d3b4b5750e308b9486c8063cf">&#9670;&#160;</a></span>UTF32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">wpi::UTF32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37bbc3b1e95b6409a042b8089d3d8c00" name="a37bbc3b1e95b6409a042b8089d3d8c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37bbc3b1e95b6409a042b8089d3d8c00">&#9670;&#160;</a></span>UTF8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned char <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">wpi::UTF8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ba14c6ed82a2230ba7b7f9152d1e6af" name="a5ba14c6ed82a2230ba7b7f9152d1e6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba14c6ed82a2230ba7b7f9152d1e6af">&#9670;&#160;</a></span>ValueTypeFromRangeType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5ba14c6ed82a2230ba7b7f9152d1e6af">wpi::ValueTypeFromRangeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::remove_const_t&lt;std::remove_reference_t&lt;<span class="keyword">decltype</span>(*std::begin(</div>
<div class="line">        std::declval&lt;RangeType &amp;&gt;()))&gt;&gt;</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aae6baba019eee7e75848c7c03db9557b" name="aae6baba019eee7e75848c7c03db9557b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae6baba019eee7e75848c7c03db9557b">&#9670;&#160;</a></span>ConversionFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#aae6baba019eee7e75848c7c03db9557b">wpi::ConversionFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aae6baba019eee7e75848c7c03db9557ba32bafada5c584a9590053ed1bf5e7bfb" name="aae6baba019eee7e75848c7c03db9557ba32bafada5c584a9590053ed1bf5e7bfb"></a>strictConversion&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aae6baba019eee7e75848c7c03db9557ba26ee89af55088fc0f622de938525ad2a" name="aae6baba019eee7e75848c7c03db9557ba26ee89af55088fc0f622de938525ad2a"></a>lenientConversion&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ac792221430e4bf80c1b31493afd90bfe" name="ac792221430e4bf80c1b31493afd90bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac792221430e4bf80c1b31493afd90bfe">&#9670;&#160;</a></span>ConversionResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ac792221430e4bf80c1b31493afd90bfe">wpi::ConversionResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac792221430e4bf80c1b31493afd90bfeaa1d30cd6c73259c50b7ce68207a7650f" name="ac792221430e4bf80c1b31493afd90bfeaa1d30cd6c73259c50b7ce68207a7650f"></a>conversionOK&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac792221430e4bf80c1b31493afd90bfea673cb258ea483b0e6f31d55cf61311d1" name="ac792221430e4bf80c1b31493afd90bfea673cb258ea483b0e6f31d55cf61311d1"></a>sourceExhausted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac792221430e4bf80c1b31493afd90bfeac785c0d8e74261d6cbde1d63f8535ed2" name="ac792221430e4bf80c1b31493afd90bfeac785c0d8e74261d6cbde1d63f8535ed2"></a>targetExhausted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac792221430e4bf80c1b31493afd90bfea34299b0f92763294d72a3117752dbbe0" name="ac792221430e4bf80c1b31493afd90bfea34299b0f92763294d72a3117752dbbe0"></a>sourceIllegal&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a2b741829b477ec608a2534e5e5a22f67" name="a2b741829b477ec608a2534e5e5a22f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b741829b477ec608a2534e5e5a22f67">&#9670;&#160;</a></span>default_arguments</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a2b741829b477ec608a2534e5e5a22f67">wpi::default_arguments</a> : unsigned int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2b741829b477ec608a2534e5e5a22f67a334c4a4c42fdb79d7ebc3e73b517e6f8" name="a2b741829b477ec608a2534e5e5a22f67a334c4a4c42fdb79d7ebc3e73b517e6f8"></a>none&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2b741829b477ec608a2534e5e5a22f67a657f8b8da628ef83cf69101b6817150a" name="a2b741829b477ec608a2534e5e5a22f67a657f8b8da628ef83cf69101b6817150a"></a>help&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2b741829b477ec608a2534e5e5a22f67a2af72f100c356273d46284f6fd1dfc08" name="a2b741829b477ec608a2534e5e5a22f67a2af72f100c356273d46284f6fd1dfc08"></a>version&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2b741829b477ec608a2534e5e5a22f67aa181a603769c1f98ad927e7367c7aa51" name="a2b741829b477ec608a2534e5e5a22f67aa181a603769c1f98ad927e7367c7aa51"></a>all&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a42370aadfc71d5b56c38275023a08226" name="a42370aadfc71d5b56c38275023a08226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42370aadfc71d5b56c38275023a08226">&#9670;&#160;</a></span>endianness</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a42370aadfc71d5b56c38275023a08226">wpi::endianness</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a42370aadfc71d5b56c38275023a08226ad861877da56b8b4ceb35c8cbfdf65bb4" name="a42370aadfc71d5b56c38275023a08226ad861877da56b8b4ceb35c8cbfdf65bb4"></a>big&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a42370aadfc71d5b56c38275023a08226aaae6635e044ac56046b2893a529b5114" name="a42370aadfc71d5b56c38275023a08226aaae6635e044ac56046b2893a529b5114"></a>little&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a42370aadfc71d5b56c38275023a08226a8e5f3adee38c8fccc13c1f3be0143796" name="a42370aadfc71d5b56c38275023a08226a8e5f3adee38c8fccc13c1f3be0143796"></a>native&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a0cc73ce1be7e2680fb97374e03368001" name="a0cc73ce1be7e2680fb97374e03368001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc73ce1be7e2680fb97374e03368001">&#9670;&#160;</a></span>errc</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a0cc73ce1be7e2680fb97374e03368001">wpi::errc</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a1b245b26b5ea3428c050d7f1503d7715" name="a0cc73ce1be7e2680fb97374e03368001a1b245b26b5ea3428c050d7f1503d7715"></a>argument_list_too_long&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a4b82222a0895b538d0597092b3ceab3e" name="a0cc73ce1be7e2680fb97374e03368001a4b82222a0895b538d0597092b3ceab3e"></a>argument_out_of_domain&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001aaf169f73a82794128aa491c4b4f1c071" name="a0cc73ce1be7e2680fb97374e03368001aaf169f73a82794128aa491c4b4f1c071"></a>bad_address&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a9941c5c8c58ff058b870e94e96ac38e1" name="a0cc73ce1be7e2680fb97374e03368001a9941c5c8c58ff058b870e94e96ac38e1"></a>bad_file_descriptor&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a2f0338eed54503152be1d31c93c9c2f1" name="a0cc73ce1be7e2680fb97374e03368001a2f0338eed54503152be1d31c93c9c2f1"></a>broken_pipe&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001ab3ab5338a00f49c4451851cc5442f370" name="a0cc73ce1be7e2680fb97374e03368001ab3ab5338a00f49c4451851cc5442f370"></a>device_or_resource_busy&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a6a336135d33e62f49edc55f29354e12e" name="a0cc73ce1be7e2680fb97374e03368001a6a336135d33e62f49edc55f29354e12e"></a>directory_not_empty&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a4dfaf9c996cf045f32d17edc9754fc95" name="a0cc73ce1be7e2680fb97374e03368001a4dfaf9c996cf045f32d17edc9754fc95"></a>executable_format_error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a41edf636e3c7b59f797348fc58472258" name="a0cc73ce1be7e2680fb97374e03368001a41edf636e3c7b59f797348fc58472258"></a>file_exists&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001aa1e14bfb89b41ddf654b1772c8fd2e74" name="a0cc73ce1be7e2680fb97374e03368001aa1e14bfb89b41ddf654b1772c8fd2e74"></a>file_too_large&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a6e56e6ed055b9771b8192a4f229fee27" name="a0cc73ce1be7e2680fb97374e03368001a6e56e6ed055b9771b8192a4f229fee27"></a>filename_too_long&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001aa33c516bbdfb179cef733c8daeb97bed" name="a0cc73ce1be7e2680fb97374e03368001aa33c516bbdfb179cef733c8daeb97bed"></a>function_not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a53a9e57a679708b2d8ff0ccd8ec96b18" name="a0cc73ce1be7e2680fb97374e03368001a53a9e57a679708b2d8ff0ccd8ec96b18"></a>illegal_byte_sequence&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a45fe7da1767194b580aeba752d7b44ae" name="a0cc73ce1be7e2680fb97374e03368001a45fe7da1767194b580aeba752d7b44ae"></a>inappropriate_io_control_operation&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001afadb76763385627e57ec386c9b6038f0" name="a0cc73ce1be7e2680fb97374e03368001afadb76763385627e57ec386c9b6038f0"></a>interrupted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001ae55d43eabeefe5a8271b4a3c898bd18f" name="a0cc73ce1be7e2680fb97374e03368001ae55d43eabeefe5a8271b4a3c898bd18f"></a>invalid_argument&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001abd86a2c65caf6a270b916234ab321ce3" name="a0cc73ce1be7e2680fb97374e03368001abd86a2c65caf6a270b916234ab321ce3"></a>invalid_seek&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001acccc32f2a5f7dc7b87d2f85daea66789" name="a0cc73ce1be7e2680fb97374e03368001acccc32f2a5f7dc7b87d2f85daea66789"></a>io_error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001af3c51d7ea75a76f26c0a2bdc00c4e006" name="a0cc73ce1be7e2680fb97374e03368001af3c51d7ea75a76f26c0a2bdc00c4e006"></a>is_a_directory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001ad08d4c854a6810cebd2a8ab61876f919" name="a0cc73ce1be7e2680fb97374e03368001ad08d4c854a6810cebd2a8ab61876f919"></a>no_child_process&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a58688487c3e24313637a76bd29881e64" name="a0cc73ce1be7e2680fb97374e03368001a58688487c3e24313637a76bd29881e64"></a>no_lock_available&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a1a5334dd8d1ca56e33887bd44630641b" name="a0cc73ce1be7e2680fb97374e03368001a1a5334dd8d1ca56e33887bd44630641b"></a>no_space_on_device&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a5c83a012eac17bbf458df5804801e373" name="a0cc73ce1be7e2680fb97374e03368001a5c83a012eac17bbf458df5804801e373"></a>no_such_device_or_address&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001af42b2e58729e2783b683c8610977fc22" name="a0cc73ce1be7e2680fb97374e03368001af42b2e58729e2783b683c8610977fc22"></a>no_such_device&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a2e70fc89b08f26fa3fc77694c91e8f7a" name="a0cc73ce1be7e2680fb97374e03368001a2e70fc89b08f26fa3fc77694c91e8f7a"></a>no_such_file_or_directory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001ad91a9b8a734f2bef4b778f89806cbab7" name="a0cc73ce1be7e2680fb97374e03368001ad91a9b8a734f2bef4b778f89806cbab7"></a>no_such_process&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a21e867ca95e1dfecff4701863547dcec" name="a0cc73ce1be7e2680fb97374e03368001a21e867ca95e1dfecff4701863547dcec"></a>not_a_directory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001aafdb5594dc3e484fc1bfd7c564d550c1" name="a0cc73ce1be7e2680fb97374e03368001aafdb5594dc3e484fc1bfd7c564d550c1"></a>not_enough_memory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001aa55e82356e9721946aa9ba954733c6f0" name="a0cc73ce1be7e2680fb97374e03368001aa55e82356e9721946aa9ba954733c6f0"></a>not_supported&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a8344b3d509942f035d5e303022f9b986" name="a0cc73ce1be7e2680fb97374e03368001a8344b3d509942f035d5e303022f9b986"></a>operation_not_permitted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001ae8ee838822072f02738dbd7d97ea03fc" name="a0cc73ce1be7e2680fb97374e03368001ae8ee838822072f02738dbd7d97ea03fc"></a>permission_denied&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a06108efce8ef1cd8aa4cc440f8b4317f" name="a0cc73ce1be7e2680fb97374e03368001a06108efce8ef1cd8aa4cc440f8b4317f"></a>read_only_file_system&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001aed65f7649c6f0e365673d65a9d8119d8" name="a0cc73ce1be7e2680fb97374e03368001aed65f7649c6f0e365673d65a9d8119d8"></a>resource_deadlock_would_occur&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001ae46a97ea2906921c8c626890bde832cf" name="a0cc73ce1be7e2680fb97374e03368001ae46a97ea2906921c8c626890bde832cf"></a>resource_unavailable_try_again&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a8e0fafb181567cc468e1ee81983d739d" name="a0cc73ce1be7e2680fb97374e03368001a8e0fafb181567cc468e1ee81983d739d"></a>result_out_of_range&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001a3130d1d4e000cdc1e7c47013e313c10e" name="a0cc73ce1be7e2680fb97374e03368001a3130d1d4e000cdc1e7c47013e313c10e"></a>too_many_files_open_in_system&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001aed2c33c8fe874cfeba6f4a7747c62d05" name="a0cc73ce1be7e2680fb97374e03368001aed2c33c8fe874cfeba6f4a7747c62d05"></a>too_many_files_open&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0cc73ce1be7e2680fb97374e03368001abfe22fc9b27a8ff13186aba60b6bc5c8" name="a0cc73ce1be7e2680fb97374e03368001abfe22fc9b27a8ff13186aba60b6bc5c8"></a>too_many_links&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a7b0000b45b0b55789f757f1c3d2461cb" name="a7b0000b45b0b55789f757f1c3d2461cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b0000b45b0b55789f757f1c3d2461cb">&#9670;&#160;</a></span>flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a7b0000b45b0b55789f757f1c3d2461cb">wpi::flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7b0000b45b0b55789f757f1c3d2461cba22ea0cf0d50ecfe6b139d83ecc83d8df" name="a7b0000b45b0b55789f757f1c3d2461cba22ea0cf0d50ecfe6b139d83ecc83d8df"></a>F_CHUNKED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b0000b45b0b55789f757f1c3d2461cbaf14c04cd6f0125dbeceaf61b94fb1352" name="a7b0000b45b0b55789f757f1c3d2461cbaf14c04cd6f0125dbeceaf61b94fb1352"></a>F_CONNECTION_KEEP_ALIVE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b0000b45b0b55789f757f1c3d2461cba78a204621316260f385954c3bb0fff0f" name="a7b0000b45b0b55789f757f1c3d2461cba78a204621316260f385954c3bb0fff0f"></a>F_CONNECTION_CLOSE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b0000b45b0b55789f757f1c3d2461cba608843554e95e8438ea48d18e8034043" name="a7b0000b45b0b55789f757f1c3d2461cba608843554e95e8438ea48d18e8034043"></a>F_CONNECTION_UPGRADE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b0000b45b0b55789f757f1c3d2461cba819c3d4c4621c49323e997ef186e81cb" name="a7b0000b45b0b55789f757f1c3d2461cba819c3d4c4621c49323e997ef186e81cb"></a>F_TRAILING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b0000b45b0b55789f757f1c3d2461cba91bd0dc716ef59be0726782a89b3fe42" name="a7b0000b45b0b55789f757f1c3d2461cba91bd0dc716ef59be0726782a89b3fe42"></a>F_UPGRADE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b0000b45b0b55789f757f1c3d2461cba0741b53c2752382134a5c1548c4af772" name="a7b0000b45b0b55789f757f1c3d2461cba0741b53c2752382134a5c1548c4af772"></a>F_SKIPBODY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7b0000b45b0b55789f757f1c3d2461cba63d30d0cca722219ca11f554a1adf1df" name="a7b0000b45b0b55789f757f1c3d2461cba63d30d0cca722219ca11f554a1adf1df"></a>F_CONTENTLENGTH&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a0e56bd09798339ac4f86d36eb8ecea0b" name="a0e56bd09798339ac4f86d36eb8ecea0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e56bd09798339ac4f86d36eb8ecea0b">&#9670;&#160;</a></span>http_errno</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a0e56bd09798339ac4f86d36eb8ecea0b">wpi::http_errno</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3458579fc7214ea6b0411bbadf6ffcbc" name="a3458579fc7214ea6b0411bbadf6ffcbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3458579fc7214ea6b0411bbadf6ffcbc">&#9670;&#160;</a></span>http_method</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a3458579fc7214ea6b0411bbadf6ffcbc">wpi::http_method</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab37735642db3ab741e86bf064b2ddbbd" name="ab37735642db3ab741e86bf064b2ddbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37735642db3ab741e86bf064b2ddbbd">&#9670;&#160;</a></span>http_parser_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ab37735642db3ab741e86bf064b2ddbbd">wpi::http_parser_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab37735642db3ab741e86bf064b2ddbbda83022e72aaa06928c047700a88837608" name="ab37735642db3ab741e86bf064b2ddbbda83022e72aaa06928c047700a88837608"></a>HTTP_REQUEST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab37735642db3ab741e86bf064b2ddbbdaa131b28da3205e7a497320d97cead4a5" name="ab37735642db3ab741e86bf064b2ddbbdaa131b28da3205e7a497320d97cead4a5"></a>HTTP_RESPONSE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab37735642db3ab741e86bf064b2ddbbda404d2d378af4663f27fc14676459b13b" name="ab37735642db3ab741e86bf064b2ddbbda404d2d378af4663f27fc14676459b13b"></a>HTTP_BOTH&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="af3a0b479c88b876facf868f0c7a6b598" name="af3a0b479c88b876facf868f0c7a6b598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a0b479c88b876facf868f0c7a6b598">&#9670;&#160;</a></span>http_parser_url_fields</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#af3a0b479c88b876facf868f0c7a6b598">wpi::http_parser_url_fields</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af3a0b479c88b876facf868f0c7a6b598a0fc67d54599dc5b503765fb0792e2a54" name="af3a0b479c88b876facf868f0c7a6b598a0fc67d54599dc5b503765fb0792e2a54"></a>UF_SCHEMA&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af3a0b479c88b876facf868f0c7a6b598af8e30e235a6bdffaac9f1945ce205851" name="af3a0b479c88b876facf868f0c7a6b598af8e30e235a6bdffaac9f1945ce205851"></a>UF_HOST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af3a0b479c88b876facf868f0c7a6b598afb2e77eaed47bcfcfee307b2e1aff53a" name="af3a0b479c88b876facf868f0c7a6b598afb2e77eaed47bcfcfee307b2e1aff53a"></a>UF_PORT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af3a0b479c88b876facf868f0c7a6b598a45e701521a7ea4616989a7ed22cd0ae1" name="af3a0b479c88b876facf868f0c7a6b598a45e701521a7ea4616989a7ed22cd0ae1"></a>UF_PATH&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af3a0b479c88b876facf868f0c7a6b598a0e308fa010b3352bb15d9dee67b5b6ff" name="af3a0b479c88b876facf868f0c7a6b598a0e308fa010b3352bb15d9dee67b5b6ff"></a>UF_QUERY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af3a0b479c88b876facf868f0c7a6b598a8534d7d9e32ee9a877dddc70f7abdefd" name="af3a0b479c88b876facf868f0c7a6b598a8534d7d9e32ee9a877dddc70f7abdefd"></a>UF_FRAGMENT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af3a0b479c88b876facf868f0c7a6b598ae015b71bf6bfa3cfe09f78f1c9360235" name="af3a0b479c88b876facf868f0c7a6b598ae015b71bf6bfa3cfe09f78f1c9360235"></a>UF_USERINFO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af3a0b479c88b876facf868f0c7a6b598ac6a7f4a78be5640ed5c926efaf8301c2" name="af3a0b479c88b876facf868f0c7a6b598ac6a7f4a78be5640ed5c926efaf8301c2"></a>UF_MAX&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ae89a1f90a8603e399f9cc0465b0ce21e" name="ae89a1f90a8603e399f9cc0465b0ce21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89a1f90a8603e399f9cc0465b0ce21e">&#9670;&#160;</a></span>http_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ae89a1f90a8603e399f9cc0465b0ce21e">wpi::http_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae00dc51f60e3a7f50eea48b914e9f88a" name="ae00dc51f60e3a7f50eea48b914e9f88a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00dc51f60e3a7f50eea48b914e9f88a">&#9670;&#160;</a></span>LogLevel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ae00dc51f60e3a7f50eea48b914e9f88a">wpi::LogLevel</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae00dc51f60e3a7f50eea48b914e9f88aa4eaaa435255d53d8ee1ad804ac2fde9d" name="ae00dc51f60e3a7f50eea48b914e9f88aa4eaaa435255d53d8ee1ad804ac2fde9d"></a>WPI_LOG_CRITICAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae00dc51f60e3a7f50eea48b914e9f88aabd6cb7f9e35184593c719b52e3269f2e" name="ae00dc51f60e3a7f50eea48b914e9f88aabd6cb7f9e35184593c719b52e3269f2e"></a>WPI_LOG_ERROR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae00dc51f60e3a7f50eea48b914e9f88aae6035e37ce53de5e15e2d11ab3aaa8d2" name="ae00dc51f60e3a7f50eea48b914e9f88aae6035e37ce53de5e15e2d11ab3aaa8d2"></a>WPI_LOG_WARNING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae00dc51f60e3a7f50eea48b914e9f88aafb54895e0b8a35d815e26607f33bc33c" name="ae00dc51f60e3a7f50eea48b914e9f88aafb54895e0b8a35d815e26607f33bc33c"></a>WPI_LOG_INFO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae00dc51f60e3a7f50eea48b914e9f88aa82615e27834c547fec2af93cf5d4b4a7" name="ae00dc51f60e3a7f50eea48b914e9f88aa82615e27834c547fec2af93cf5d4b4a7"></a>WPI_LOG_DEBUG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae00dc51f60e3a7f50eea48b914e9f88aac7f7f9988bf8b7a36185cd7a19faa576" name="ae00dc51f60e3a7f50eea48b914e9f88aac7f7f9988bf8b7a36185cd7a19faa576"></a>WPI_LOG_DEBUG1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae00dc51f60e3a7f50eea48b914e9f88aa749ae7790a80d70497b9b873e51737c4" name="ae00dc51f60e3a7f50eea48b914e9f88aa749ae7790a80d70497b9b873e51737c4"></a>WPI_LOG_DEBUG2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae00dc51f60e3a7f50eea48b914e9f88aaec2f6db5ca268bd387c48d6e06c06ecc" name="ae00dc51f60e3a7f50eea48b914e9f88aaec2f6db5ca268bd387c48d6e06c06ecc"></a>WPI_LOG_DEBUG3&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae00dc51f60e3a7f50eea48b914e9f88aae12c0145b954247e75447e15f40ba4e9" name="ae00dc51f60e3a7f50eea48b914e9f88aae12c0145b954247e75447e15f40ba4e9"></a>WPI_LOG_DEBUG4&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="adf9a1be75438ab85bc362414f0d60b8d" name="adf9a1be75438ab85bc362414f0d60b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9a1be75438ab85bc362414f0d60b8d">&#9670;&#160;</a></span>nargs_pattern</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#adf9a1be75438ab85bc362414f0d60b8d">wpi::nargs_pattern</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adf9a1be75438ab85bc362414f0d60b8dad57c24f3fe52d16e7169b912dd647f0d" name="adf9a1be75438ab85bc362414f0d60b8dad57c24f3fe52d16e7169b912dd647f0d"></a>optional&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="adf9a1be75438ab85bc362414f0d60b8da100b8cad7cf2a56f6df78f171f97a1ec" name="adf9a1be75438ab85bc362414f0d60b8da100b8cad7cf2a56f6df78f171f97a1ec"></a>any&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="adf9a1be75438ab85bc362414f0d60b8da3fe0284a7cd758589321a05f30353587" name="adf9a1be75438ab85bc362414f0d60b8da3fe0284a7cd758589321a05f30353587"></a>at_least_one&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a5e4416775113f6a916bc699ca08308a4" name="a5e4416775113f6a916bc699ca08308a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4416775113f6a916bc699ca08308a4">&#9670;&#160;</a></span>StructFieldType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a5e4416775113f6a916bc699ca08308a4">wpi::StructFieldType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Known data types for raw struct dynamic fields (see <a class="el" href="classwpi_1_1_struct_field_descriptor.html" title="Raw struct dynamic field descriptor.">StructFieldDescriptor</a>). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5e4416775113f6a916bc699ca08308a4a18268c9f691ba5a5f650049d9d0da8dc" name="a5e4416775113f6a916bc699ca08308a4a18268c9f691ba5a5f650049d9d0da8dc"></a>kBool&#160;</td><td class="fielddoc"><p>bool. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e4416775113f6a916bc699ca08308a4af5e6c1b4f03d321b82fafadb7a3c2d47" name="a5e4416775113f6a916bc699ca08308a4af5e6c1b4f03d321b82fafadb7a3c2d47"></a>kChar&#160;</td><td class="fielddoc"><p>char. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e4416775113f6a916bc699ca08308a4af112965031ccac10c07073b4e7430107" name="a5e4416775113f6a916bc699ca08308a4af112965031ccac10c07073b4e7430107"></a>kInt8&#160;</td><td class="fielddoc"><p>int8. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e4416775113f6a916bc699ca08308a4a6698ae5a05a12d36333200ae5e8f4f95" name="a5e4416775113f6a916bc699ca08308a4a6698ae5a05a12d36333200ae5e8f4f95"></a>kInt16&#160;</td><td class="fielddoc"><p>int16. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e4416775113f6a916bc699ca08308a4a10c09f8bff3c372f21cd8a13e01ae941" name="a5e4416775113f6a916bc699ca08308a4a10c09f8bff3c372f21cd8a13e01ae941"></a>kInt32&#160;</td><td class="fielddoc"><p>int32. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e4416775113f6a916bc699ca08308a4a22c776007533004e22da8e6bdd888b33" name="a5e4416775113f6a916bc699ca08308a4a22c776007533004e22da8e6bdd888b33"></a>kInt64&#160;</td><td class="fielddoc"><p>int64. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e4416775113f6a916bc699ca08308a4a11f076c48d8c2d080d2b9fbf5bf1725c" name="a5e4416775113f6a916bc699ca08308a4a11f076c48d8c2d080d2b9fbf5bf1725c"></a>kUint8&#160;</td><td class="fielddoc"><p>uint8. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e4416775113f6a916bc699ca08308a4aca94c6052fa35563adffc07eac974ab6" name="a5e4416775113f6a916bc699ca08308a4aca94c6052fa35563adffc07eac974ab6"></a>kUint16&#160;</td><td class="fielddoc"><p>uint16. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e4416775113f6a916bc699ca08308a4af5fca11a36e986e3623193c5cccc4f39" name="a5e4416775113f6a916bc699ca08308a4af5fca11a36e986e3623193c5cccc4f39"></a>kUint32&#160;</td><td class="fielddoc"><p>uint32. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e4416775113f6a916bc699ca08308a4a4e5966a6ca84ccd3ed763941df242c68" name="a5e4416775113f6a916bc699ca08308a4a4e5966a6ca84ccd3ed763941df242c68"></a>kUint64&#160;</td><td class="fielddoc"><p>uint64. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e4416775113f6a916bc699ca08308a4a8425cd882e78bc9251db970b8a1da20e" name="a5e4416775113f6a916bc699ca08308a4a8425cd882e78bc9251db970b8a1da20e"></a>kFloat&#160;</td><td class="fielddoc"><p>float. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e4416775113f6a916bc699ca08308a4a7fb3efa35444cd88d5a31dc125ca9c28" name="a5e4416775113f6a916bc699ca08308a4a7fb3efa35444cd88d5a31dc125ca9c28"></a>kDouble&#160;</td><td class="fielddoc"><p>double. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e4416775113f6a916bc699ca08308a4a37d24e1221658f0e0333a512fdbcd2f0" name="a5e4416775113f6a916bc699ca08308a4a37d24e1221658f0e0333a512fdbcd2f0"></a>kStruct&#160;</td><td class="fielddoc"><p>struct. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab92bb1e40972ef1155f70f9a1e341fce" name="ab92bb1e40972ef1155f70f9a1e341fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92bb1e40972ef1155f70f9a1e341fce">&#9670;&#160;</a></span>AbsoluteDifference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_unsigned_v&lt; T &gt;, T &gt; wpi::AbsoluteDifference </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract two unsigned integers, X and Y, of type T and return the absolute value of the result. </p>

</div>
</div>
<a id="ab8aa688a56f891640957f59beef75d82" name="ab8aa688a56f891640957f59beef75d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8aa688a56f891640957f59beef75d82">&#9670;&#160;</a></span>AddOverflow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_signed_v&lt; T &gt;, T &gt; wpi::AddOverflow </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>Result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add two signed integers, computing the two's complement truncated result, returning true if overflow occurred. </p>

</div>
</div>
<a id="ae690f31454289b0d204da17bb50ed283" name="ae690f31454289b0d204da17bb50ed283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae690f31454289b0d204da17bb50ed283">&#9670;&#160;</a></span>adl_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::adl_begin </td>
          <td>(</td>
          <td class="paramtype">RangeT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespacewpi_1_1adl__detail.html#a875442e69c8d0c96baae38beb15d4b53">adl_detail::begin_impl</a>(std::forward&lt;RangeT&gt;(range))) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the begin iterator to <code>range</code> using <code>std::begin</code> and function found through Argument-Dependent Lookup (ADL). </p>

</div>
</div>
<a id="a711873ab0b6ad59448d62e6390a1ed46" name="a711873ab0b6ad59448d62e6390a1ed46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711873ab0b6ad59448d62e6390a1ed46">&#9670;&#160;</a></span>adl_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::adl_end </td>
          <td>(</td>
          <td class="paramtype">RangeT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespacewpi_1_1adl__detail.html#aca2bc37a44dcab71d6e8d0a4a1534b23">adl_detail::end_impl</a>(std::forward&lt;RangeT&gt;(range))) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the end iterator to <code>range</code> using <code>std::end</code> and functions found through Argument-Dependent Lookup (ADL). </p>

</div>
</div>
<a id="a2eb08412efb94d58af17974d77d38bdd" name="a2eb08412efb94d58af17974d77d38bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb08412efb94d58af17974d77d38bdd">&#9670;&#160;</a></span>adl_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::adl_size </td>
          <td>(</td>
          <td class="paramtype">RangeT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespacewpi_1_1adl__detail.html#a9cc52aaa08a8db03cf7e3f78d526a4e3">adl_detail::size_impl</a>(std::forward&lt;RangeT&gt;(range))) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of <code>range</code> using <code>std::size</code> and functions found through Argument-Dependent Lookup (ADL). </p>

</div>
</div>
<a id="a9ca907320830d0935f09090e656edd87" name="a9ca907320830d0935f09090e656edd87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca907320830d0935f09090e656edd87">&#9670;&#160;</a></span>adl_swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::adl_swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps <code>lhs</code> with <code>rhs</code> using <code><a class="el" href="namespacestd.html#ae7bc1bfb88e72f65528fc6cf9f362454" title="exchanges the values of two JSON objects">std::swap</a></code> and functions found through Argument-Dependent Lookup (ADL). </p>

</div>
</div>
<a id="af96597787b5255d8569295b2a87d33cf" name="af96597787b5255d8569295b2a87d33cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96597787b5255d8569295b2a87d33cf">&#9670;&#160;</a></span>alignDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::alignDown </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Align</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Skew</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the largest uint64_t less than or equal to <code>Value</code> and is <code>Skew</code> mod <code>Align</code>. </p>
<p><code>Align</code> must be non-zero </p>

</div>
</div>
<a id="a2e89f720bc5d42133b9e1fba299f9e6e" name="a2e89f720bc5d42133b9e1fba299f9e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e89f720bc5d42133b9e1fba299f9e6e">&#9670;&#160;</a></span>alignTo() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint64_t Align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::alignTo </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next integer (mod 2**64) that is greater than or equal to <code>Value</code> and is a multiple of <code>Align</code>. </p>
<p><code>Align</code> must be non-zero. </p>

</div>
</div>
<a id="a7b0316a8c345ffe467f744e0e9f7d475" name="a7b0316a8c345ffe467f744e0e9f7d475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b0316a8c345ffe467f744e0e9f7d475">&#9670;&#160;</a></span>alignTo() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::alignTo </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Align</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next integer (mod 2**64) that is greater than or equal to <code>Value</code> and is a multiple of <code>Align</code>. </p>
<p><code>Align</code> must be non-zero.</p>
<p>Examples: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a7b0316a8c345ffe467f744e0e9f7d475">alignTo</a>(5, 8) = 8</div>
<div class="line"><a class="code hl_function" href="#a7b0316a8c345ffe467f744e0e9f7d475">alignTo</a>(17, 8) = 24</div>
<div class="line"><a class="code hl_function" href="#a7b0316a8c345ffe467f744e0e9f7d475">alignTo</a>(~0LL, 8) = 0</div>
<div class="line"><a class="code hl_function" href="#a7b0316a8c345ffe467f744e0e9f7d475">alignTo</a>(321, 255) = 510</div>
<div class="ttc" id="anamespacewpi_html_a7b0316a8c345ffe467f744e0e9f7d475"><div class="ttname"><a href="#a7b0316a8c345ffe467f744e0e9f7d475">wpi::alignTo</a></div><div class="ttdeci">uint64_t alignTo(uint64_t Value, uint64_t Align)</div><div class="ttdoc">Returns the next integer (mod 2**64) that is greater than or equal to Value and is a multiple of Alig...</div><div class="ttdef"><b>Definition</b> MathExtras.h:351</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae53cd62626ce308da46540adc1a24250" name="ae53cd62626ce308da46540adc1a24250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53cd62626ce308da46540adc1a24250">&#9670;&#160;</a></span>alignTo() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::alignTo </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Align</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Skew</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If non-zero <code>Skew</code> is specified, the return value will be a minimal integer that is greater than or equal to <code>Size</code> and equal to <code>A</code> * N + <code>Skew</code> for some integer N. </p>
<p>If <code>Skew</code> is larger than <code>A</code>, its value is adjusted to '<code>Skew</code> mod <code>A'</code>. <code>Align</code> must be non-zero.</p>
<p>Examples: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a7b0316a8c345ffe467f744e0e9f7d475">alignTo</a>(5, 8, 7) = 7</div>
<div class="line"><a class="code hl_function" href="#a7b0316a8c345ffe467f744e0e9f7d475">alignTo</a>(17, 8, 1) = 17</div>
<div class="line"><a class="code hl_function" href="#a7b0316a8c345ffe467f744e0e9f7d475">alignTo</a>(~0LL, 8, 3) = 3</div>
<div class="line"><a class="code hl_function" href="#a7b0316a8c345ffe467f744e0e9f7d475">alignTo</a>(321, 255, 42) = 552</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab167a7e34682d91fc42f5d419d2af941" name="ab167a7e34682d91fc42f5d419d2af941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab167a7e34682d91fc42f5d419d2af941">&#9670;&#160;</a></span>alignToPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::alignToPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Align</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac17a307d96b6bf9787f0dc6aac310fee" name="ac17a307d96b6bf9787f0dc6aac310fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17a307d96b6bf9787f0dc6aac310fee">&#9670;&#160;</a></span>allocate_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_compiler_8h.html#acbae7c06e77fa64145cca176963b6863">LLVM_ATTRIBUTE_RETURNS_NONNULL</a> <a class="el" href="_compiler_8h.html#a33bc304d1e6e184f3ffd9fa1620fd14c">LLVM_ATTRIBUTE_RETURNS_NOALIAS</a> void * wpi::allocate_buffer </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>Size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>Alignment</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a buffer of memory with the given size and alignment. </p>
<p>When the compiler supports aligned operator new, this will use it to handle even over-aligned allocations.</p>
<p>However, this doesn't make any attempt to leverage the fancier techniques like posix_memalign due to portability. It is mostly intended to allow compatibility with platforms that, after aligned allocation was added, use reduced default alignment. </p>

</div>
</div>
<a id="a4f5058f1185c691b80cd2d8a692a7657" name="a4f5058f1185c691b80cd2d8a692a7657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5058f1185c691b80cd2d8a692a7657">&#9670;&#160;</a></span>array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::convertible_to&lt; T &gt;... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::array </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts...</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  array&lt; T, 1+sizeof...(Ts)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f7f0ad943e1786cd6c0a13a763880f8" name="a3f7f0ad943e1786cd6c0a13a763880f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7f0ad943e1786cd6c0a13a763880f8">&#9670;&#160;</a></span>as_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t Extent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1rotated__span.html">rotated_span</a>&lt; const std::byte, Extent==std::dynamic_extent ? std::dynamic_extent :Extent *sizeof(Type)&gt; wpi::as_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1rotated__span.html">rotated_span</a>&lt; Type, Extent &gt;</td>          <td class="paramname"><span class="paramname"><em>sp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6e3f0e3cb64b1422a2866adbce6da8c" name="ad6e3f0e3cb64b1422a2866adbce6da8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e3f0e3cb64b1422a2866adbce6da8c">&#9670;&#160;</a></span>as_writable_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t Extent&gt; <br />
requires (!std::is_const_v&lt;Type&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1rotated__span.html">rotated_span</a>&lt; std::byte, Extent==std::dynamic_extent ? std::dynamic_extent :Extent *sizeof(Type)&gt; wpi::as_writable_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1rotated__span.html">rotated_span</a>&lt; Type, Extent &gt;</td>          <td class="paramname"><span class="paramname"><em>sp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa84cf72de6e08899df61612e400beff1" name="aa84cf72de6e08899df61612e400beff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84cf72de6e08899df61612e400beff1">&#9670;&#160;</a></span>Base64Decode() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t wpi::Base64Decode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>encoded</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac503c8c47490fca90512a88b23b65358" name="ac503c8c47490fca90512a88b23b65358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac503c8c47490fca90512a88b23b65358">&#9670;&#160;</a></span>Base64Decode() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view wpi::Base64Decode </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>encoded</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>num_read</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa145997bec65a8d0e2b783c384a6e3e4" name="aa145997bec65a8d0e2b783c384a6e3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa145997bec65a8d0e2b783c384a6e3e4">&#9670;&#160;</a></span>Base64Decode() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; uint8_t &gt; wpi::Base64Decode </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>encoded</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>num_read</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; uint8_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2dec1800b8c82d4cb942493afc4a828" name="af2dec1800b8c82d4cb942493afc4a828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2dec1800b8c82d4cb942493afc4a828">&#9670;&#160;</a></span>Base64Decode() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t wpi::Base64Decode </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>encoded</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>plain</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a46c4d7b36efb76fd101c8cd219c9bdb8" name="a46c4d7b36efb76fd101c8cd219c9bdb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c4d7b36efb76fd101c8cd219c9bdb8">&#9670;&#160;</a></span>Base64Decode() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t wpi::Base64Decode </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>encoded</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; *</td>          <td class="paramname"><span class="paramname"><em>plain</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2d319e2a72f572e4fbdbb2017fd203e" name="ad2d319e2a72f572e4fbdbb2017fd203e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d319e2a72f572e4fbdbb2017fd203e">&#9670;&#160;</a></span>Base64Encode() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::Base64Encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const uint8_t &gt;</td>          <td class="paramname"><span class="paramname"><em>plain</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f0cca388f8042851ed82359d23c61e9" name="a8f0cca388f8042851ed82359d23c61e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0cca388f8042851ed82359d23c61e9">&#9670;&#160;</a></span>Base64Encode() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::Base64Encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>plain</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c10d4e853c1b2027f22c23c46106f15" name="a3c10d4e853c1b2027f22c23c46106f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c10d4e853c1b2027f22c23c46106f15">&#9670;&#160;</a></span>Base64Encode() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view wpi::Base64Encode </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const uint8_t &gt;</td>          <td class="paramname"><span class="paramname"><em>plain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a94f1eed3c192da2db90b3d0ab15d24c8" name="a94f1eed3c192da2db90b3d0ab15d24c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f1eed3c192da2db90b3d0ab15d24c8">&#9670;&#160;</a></span>Base64Encode() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::Base64Encode </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const uint8_t &gt;</td>          <td class="paramname"><span class="paramname"><em>plain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>encoded</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adbfd836e85f4e66313113339d542ae76" name="adbfd836e85f4e66313113339d542ae76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbfd836e85f4e66313113339d542ae76">&#9670;&#160;</a></span>Base64Encode() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view wpi::Base64Encode </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>plain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4351dc23f99c30ed993190988f3da889" name="a4351dc23f99c30ed993190988f3da889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4351dc23f99c30ed993190988f3da889">&#9670;&#160;</a></span>Base64Encode() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::Base64Encode </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>plain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>encoded</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3bbec452d79352196b712ee75332681" name="ac3bbec452d79352196b712ee75332681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3bbec452d79352196b712ee75332681">&#9670;&#160;</a></span>bit_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From , typename  = std::enable_if_t&lt;sizeof(To) == sizeof(From)&gt;, typename  = std::enable_if_t&lt;std::is_trivially_constructible&lt;To&gt;::value&gt;, typename  = std::enable_if_t&lt;std::is_trivially_copyable&lt;To&gt;::value&gt;, typename  = std::enable_if_t&lt;std::is_trivially_copyable&lt;From&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To wpi::bit_cast </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32aa2b0061658aa4b7720efe05f8bcbe" name="a32aa2b0061658aa4b7720efe05f8bcbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32aa2b0061658aa4b7720efe05f8bcbe">&#9670;&#160;</a></span>byteswap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T wpi::byteswap </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>V</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the bytes in the given integer value V. </p>

</div>
</div>
<a id="a703d958d0d00e12bac5736929f6f1b33" name="a703d958d0d00e12bac5736929f6f1b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703d958d0d00e12bac5736929f6f1b33">&#9670;&#160;</a></span>capacity_in_bytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT , typename KeyInfoT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t wpi::capacity_in_bytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_dense_map.html">DenseMap</a>&lt; KeyT, ValueT, KeyInfoT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e35647cd9f9f0d2c097ea72e6d9f608" name="a0e35647cd9f9f0d2c097ea72e6d9f608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e35647cd9f9f0d2c097ea72e6d9f608">&#9670;&#160;</a></span>capacity_in_bytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t wpi::capacity_in_bytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_small_vector.html">SmallVector</a>&lt; T, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07d1ec7b9131213ad5deed2c377eac77" name="a07d1ec7b9131213ad5deed2c377eac77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d1ec7b9131213ad5deed2c377eac77">&#9670;&#160;</a></span>cast() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) wpi::cast </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cast&lt;X&gt; - Return the argument parameter cast to the specified type. </p>
<p>This casting operator asserts that the type is correct, so it does not return null on failure. It does not allow a null argument (use cast_if_present for that). It is typically used like this:</p>
<p>cast&lt;Instruction&gt;(myVal)-&gt;getParent() </p>

</div>
</div>
<a id="ae397c6f6851eec1e8e685786dee62ea4" name="ae397c6f6851eec1e8e685786dee62ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae397c6f6851eec1e8e685786dee62ea4">&#9670;&#160;</a></span>cast() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) wpi::cast </td>
          <td>(</td>
          <td class="paramtype">From &amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a53b54fe186a1d407a3f60a259c4c0492" name="a53b54fe186a1d407a3f60a259c4c0492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b54fe186a1d407a3f60a259c4c0492">&#9670;&#160;</a></span>cast() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) wpi::cast </td>
          <td>(</td>
          <td class="paramtype">From *</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a260ef7c17feedcb3c516b22f07b0a402" name="a260ef7c17feedcb3c516b22f07b0a402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260ef7c17feedcb3c516b22f07b0a402">&#9670;&#160;</a></span>cast() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) wpi::cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; From &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae574e491fd08b2b0dc040da5c1b9e045" name="ae574e491fd08b2b0dc040da5c1b9e045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae574e491fd08b2b0dc040da5c1b9e045">&#9670;&#160;</a></span>cast_if_present() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::cast_if_present </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cast_if_present&lt;X&gt; - Functionally identical to cast, except that a null value is accepted. </p>

</div>
</div>
<a id="a1533b15a80c0d7e1132b3a8ce4068aef" name="a1533b15a80c0d7e1132b3a8ce4068aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1533b15a80c0d7e1132b3a8ce4068aef">&#9670;&#160;</a></span>cast_if_present() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::cast_if_present </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; Y &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa16c17b52842390c6c6ad910789b9772" name="aa16c17b52842390c6c6ad910789b9772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16c17b52842390c6c6ad910789b9772">&#9670;&#160;</a></span>cast_if_present() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::cast_if_present </td>
          <td>(</td>
          <td class="paramtype">Y &amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8e4021d4285d64972a97040f3c33079" name="aa8e4021d4285d64972a97040f3c33079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e4021d4285d64972a97040f3c33079">&#9670;&#160;</a></span>cast_if_present() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::cast_if_present </td>
          <td>(</td>
          <td class="paramtype">Y *</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f5a09d7249f213d2b3dedd3978a5dda" name="a1f5a09d7249f213d2b3dedd3978a5dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f5a09d7249f213d2b3dedd3978a5dda">&#9670;&#160;</a></span>cast_or_null() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::cast_or_null </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a14d9ded262559ddbd76ee0c76db53c45" name="a14d9ded262559ddbd76ee0c76db53c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d9ded262559ddbd76ee0c76db53c45">&#9670;&#160;</a></span>cast_or_null() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::cast_or_null </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; Y &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf9b1a139f23ae41fab47e19f42d7b6c" name="acf9b1a139f23ae41fab47e19f42d7b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9b1a139f23ae41fab47e19f42d7b6c">&#9670;&#160;</a></span>cast_or_null() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::cast_or_null </td>
          <td>(</td>
          <td class="paramtype">Y &amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a733a794c73228e91c8b9c1995ddd5326" name="a733a794c73228e91c8b9c1995ddd5326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733a794c73228e91c8b9c1995ddd5326">&#9670;&#160;</a></span>cast_or_null() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::cast_or_null </td>
          <td>(</td>
          <td class="paramtype">Y *</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a135363b62874f7e1527b3ee317063f28" name="a135363b62874f7e1527b3ee317063f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135363b62874f7e1527b3ee317063f28">&#9670;&#160;</a></span>compare_lower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int wpi::compare_lower </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compare_lower - Compare two strings, ignoring case. </p>

</div>
</div>
<a id="a16ed722bd88bc8cbd56f950b3e0333fb" name="a16ed722bd88bc8cbd56f950b3e0333fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ed722bd88bc8cbd56f950b3e0333fb">&#9670;&#160;</a></span>Concat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char , typename Traits , size_t N1, size_t... N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::Concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwpi_1_1ct__string.html">ct_string</a>&lt; Char, Traits, N1 &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>s1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwpi_1_1ct__string.html">ct_string</a>&lt; Char, Traits, N &gt; const &amp;...</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates multiple fixed_strings into a larger fixed_string at compile time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>first string </td></tr>
    <tr><td class="paramname">s</td><td>second and later strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>concatenated string </dd></dl>

</div>
</div>
<a id="a2fd59d01b80175e78c41a25b325fa22b" name="a2fd59d01b80175e78c41a25b325fa22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd59d01b80175e78c41a25b325fa22b">&#9670;&#160;</a></span>consume_integer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::enable_if_t&lt; std::numeric_limits&lt; T &gt;::is_signed, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; T &gt; wpi::consume_integer </td>
          <td>(</td>
          <td class="paramtype">std::string_view *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>radix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses the string <code>str</code> as an integer of the specified radix. </p>
<p>If <code>radix</code> is specified as zero, this does radix autosensing using extended C rules: 0 is octal, 0x is hex, 0b is binary.</p>
<p>If the string does not begin with a number of the specified radix, this returns nullopt to signify the error. The string is considered erroneous if empty or if it overflows T. The portion of the string representing the discovered numeric value is removed from the beginning of the string. </p>

</div>
</div>
<a id="ac0c14a6177075406fca400c8f46d0dc5" name="ac0c14a6177075406fca400c8f46d0dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c14a6177075406fca400c8f46d0dc5">&#9670;&#160;</a></span>contains() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::contains </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> contains the substring <code>other</code>. </p>

</div>
</div>
<a id="a1426c18248d3c2ba9769800334f2c596" name="a1426c18248d3c2ba9769800334f2c596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1426c18248d3c2ba9769800334f2c596">&#9670;&#160;</a></span>contains() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::contains </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> contains the substring <code>other</code>. </p>

</div>
</div>
<a id="a57c338fbb3b9d95ab22856fb0aaacf94" name="a57c338fbb3b9d95ab22856fb0aaacf94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c338fbb3b9d95ab22856fb0aaacf94">&#9670;&#160;</a></span>contains() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::contains </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> contains the substring <code>other</code>. </p>

</div>
</div>
<a id="ae7e058e611f4cf33ce6a9355be266854" name="ae7e058e611f4cf33ce6a9355be266854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e058e611f4cf33ce6a9355be266854">&#9670;&#160;</a></span>contains_lower() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::contains_lower </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> contains the substring <code>other</code>, ignoring case. </p>

</div>
</div>
<a id="a93417c92f7c6516d3746b419a5f6ec39" name="a93417c92f7c6516d3746b419a5f6ec39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93417c92f7c6516d3746b419a5f6ec39">&#9670;&#160;</a></span>contains_lower() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::contains_lower </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> contains the substring <code>other</code>, ignoring case. </p>

</div>
</div>
<a id="afec927e053502a01b8b57dbc9fe7ceea" name="afec927e053502a01b8b57dbc9fe7ceea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec927e053502a01b8b57dbc9fe7ceea">&#9670;&#160;</a></span>contains_lower() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::contains_lower </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> contains the substring <code>other</code>, ignoring case. </p>

</div>
</div>
<a id="a0b2b50e25edd8fc47c0ef3b0929a9aac" name="a0b2b50e25edd8fc47c0ef3b0929a9aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2b50e25edd8fc47c0ef3b0929a9aac">&#9670;&#160;</a></span>ConvertCodePointToUTF8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::ConvertCodePointToUTF8 </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>Source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;</td>          <td class="paramname"><span class="paramname"><em>ResultPtr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an Unicode code point to UTF8 sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">Source</td><td>a Unicode code point. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ResultPtr</td><td>pointer to the output buffer, needs to be at least <code>UNI_MAX_UTF8_BYTES_PER_CODE_POINT</code> bytes. On success <code>ResultPtr</code> is updated one past end of the converted sequence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>true on success. </dd></dl>

</div>
</div>
<a id="a9257f3c46568bac25b1ba2f3fac4678a" name="a9257f3c46568bac25b1ba2f3fac4678a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9257f3c46568bac25b1ba2f3fac4678a">&#9670;&#160;</a></span>ConvertUTF16toUTF32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a> wpi::ConvertUTF16toUTF32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> **</td>          <td class="paramname"><span class="paramname"><em>sourceStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> *</td>          <td class="paramname"><span class="paramname"><em>sourceEnd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> **</td>          <td class="paramname"><span class="paramname"><em>targetStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *</td>          <td class="paramname"><span class="paramname"><em>targetEnd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac54c2f26ecf324df5da9128c77052d31" name="ac54c2f26ecf324df5da9128c77052d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54c2f26ecf324df5da9128c77052d31">&#9670;&#160;</a></span>ConvertUTF16toUTF8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a> wpi::ConvertUTF16toUTF8 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> **</td>          <td class="paramname"><span class="paramname"><em>sourceStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> *</td>          <td class="paramname"><span class="paramname"><em>sourceEnd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **</td>          <td class="paramname"><span class="paramname"><em>targetStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *</td>          <td class="paramname"><span class="paramname"><em>targetEnd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad96959c1be95aa4d288cc84e11ab6f1b" name="ad96959c1be95aa4d288cc84e11ab6f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96959c1be95aa4d288cc84e11ab6f1b">&#9670;&#160;</a></span>convertUTF16ToUTF8String() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::convertUTF16ToUTF8String </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const char &gt;</td>          <td class="paramname"><span class="paramname"><em>SrcBytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a stream of raw bytes assumed to be UTF16 into a UTF8 std::string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SrcBytes</td><td>A buffer of what is assumed to be UTF-16 encoded text. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Out</td><td>Converted UTF-8 is stored here on success. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>true on success </dd></dl>

</div>
</div>
<a id="aae550217f649fc634dfa84af9795df29" name="aae550217f649fc634dfa84af9795df29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae550217f649fc634dfa84af9795df29">&#9670;&#160;</a></span>convertUTF16ToUTF8String() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::convertUTF16ToUTF8String </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const <a class="el" href="#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a UTF16 string into a UTF8 std::string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Src</td><td>A buffer of UTF-16 encoded text. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Out</td><td>Converted UTF-8 is stored here on success. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>true on success </dd></dl>

</div>
</div>
<a id="a323342b32a2c5cf6e46b217e4843c014" name="a323342b32a2c5cf6e46b217e4843c014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323342b32a2c5cf6e46b217e4843c014">&#9670;&#160;</a></span>ConvertUTF32toUTF16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a> wpi::ConvertUTF32toUTF16 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> **</td>          <td class="paramname"><span class="paramname"><em>sourceStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *</td>          <td class="paramname"><span class="paramname"><em>sourceEnd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> **</td>          <td class="paramname"><span class="paramname"><em>targetStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> *</td>          <td class="paramname"><span class="paramname"><em>targetEnd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a903ac386cdae4917d7cc20ed662dcee5" name="a903ac386cdae4917d7cc20ed662dcee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903ac386cdae4917d7cc20ed662dcee5">&#9670;&#160;</a></span>ConvertUTF32toUTF8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a> wpi::ConvertUTF32toUTF8 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> **</td>          <td class="paramname"><span class="paramname"><em>sourceStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *</td>          <td class="paramname"><span class="paramname"><em>sourceEnd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **</td>          <td class="paramname"><span class="paramname"><em>targetStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *</td>          <td class="paramname"><span class="paramname"><em>targetEnd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a60ebf5e2ffc341ff3f8840f8ad3ed06f" name="a60ebf5e2ffc341ff3f8840f8ad3ed06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ebf5e2ffc341ff3f8840f8ad3ed06f">&#9670;&#160;</a></span>convertUTF32ToUTF8String() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::convertUTF32ToUTF8String </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const char &gt;</td>          <td class="paramname"><span class="paramname"><em>SrcBytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>Out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a stream of raw bytes assumed to be UTF32 into a UTF8 std::string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SrcBytes</td><td>A buffer of what is assumed to be UTF-32 encoded text. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Out</td><td>Converted UTF-8 is stored here on success. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>true on success </dd></dl>

</div>
</div>
<a id="a9a8249a62e85e46e5ed358c283261fa9" name="a9a8249a62e85e46e5ed358c283261fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8249a62e85e46e5ed358c283261fa9">&#9670;&#160;</a></span>convertUTF32ToUTF8String() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::convertUTF32ToUTF8String </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const <a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>Src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>Out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a UTF32 string into a UTF8 std::string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Src</td><td>A buffer of UTF-32 encoded text. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Out</td><td>Converted UTF-8 is stored here on success. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>true on success </dd></dl>

</div>
</div>
<a id="a349ec073e684b8777cd7e7166dd3b465" name="a349ec073e684b8777cd7e7166dd3b465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a349ec073e684b8777cd7e7166dd3b465">&#9670;&#160;</a></span>convertUTF8Sequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a> wpi::convertUTF8Sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *</td>          <td class="paramname"><span class="paramname"><em>sourceEnd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the first UTF8 sequence in the given source buffer to a UTF32 code point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">source</td><td>A pointer to the source buffer. If the conversion succeeds, this pointer will be updated to point to the byte just past the end of the converted sequence. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sourceEnd</td><td>A pointer just past the end of the source buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">target</td><td>The converted code </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">flags</td><td>Whether the conversion is strict or lenient.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>conversionOK on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab9c663588a7ff49ab4cb3ffb71e5d5c6" title="Convert a partial UTF8 sequence to UTF32.">ConvertUTF8toUTF32</a> </dd></dl>

</div>
</div>
<a id="a4bada7642f7a62d2271fd42cd0cb01f3" name="a4bada7642f7a62d2271fd42cd0cb01f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bada7642f7a62d2271fd42cd0cb01f3">&#9670;&#160;</a></span>ConvertUTF8toUTF16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a> wpi::ConvertUTF8toUTF16 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **</td>          <td class="paramname"><span class="paramname"><em>sourceStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *</td>          <td class="paramname"><span class="paramname"><em>sourceEnd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> **</td>          <td class="paramname"><span class="paramname"><em>targetStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> *</td>          <td class="paramname"><span class="paramname"><em>targetEnd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a051a613a70381a8d15a4ed7630bfd942" name="a051a613a70381a8d15a4ed7630bfd942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051a613a70381a8d15a4ed7630bfd942">&#9670;&#160;</a></span>convertUTF8ToUTF16String()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::convertUTF8ToUTF16String </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>SrcUTF8</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; <a class="el" href="#a45f45c50238ed154108c2d79c37d19ab">UTF16</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>DstUTF16</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a UTF-8 string into a UTF-16 string with native endianness. </p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>true on success </dd></dl>

</div>
</div>
<a id="ab9c663588a7ff49ab4cb3ffb71e5d5c6" name="ab9c663588a7ff49ab4cb3ffb71e5d5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c663588a7ff49ab4cb3ffb71e5d5c6">&#9670;&#160;</a></span>ConvertUTF8toUTF32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a> wpi::ConvertUTF8toUTF32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **</td>          <td class="paramname"><span class="paramname"><em>sourceStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *</td>          <td class="paramname"><span class="paramname"><em>sourceEnd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> **</td>          <td class="paramname"><span class="paramname"><em>targetStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *</td>          <td class="paramname"><span class="paramname"><em>targetEnd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a partial UTF8 sequence to UTF32. </p>
<p>If the sequence ends in an incomplete code unit sequence, returns <code>sourceIllegal</code>. </p>

</div>
</div>
<a id="aac9f39188361bf855a010751dbafbaff" name="aac9f39188361bf855a010751dbafbaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9f39188361bf855a010751dbafbaff">&#9670;&#160;</a></span>ConvertUTF8toUTF32Partial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac792221430e4bf80c1b31493afd90bfe">ConversionResult</a> wpi::ConvertUTF8toUTF32Partial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **</td>          <td class="paramname"><span class="paramname"><em>sourceStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *</td>          <td class="paramname"><span class="paramname"><em>sourceEnd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> **</td>          <td class="paramname"><span class="paramname"><em>targetStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab31f8b5d3b4b5750e308b9486c8063cf">UTF32</a> *</td>          <td class="paramname"><span class="paramname"><em>targetEnd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aae6baba019eee7e75848c7c03db9557b">ConversionFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a partial UTF8 sequence to UTF32. </p>
<p>If the sequence ends in an incomplete code unit sequence, returns <code>sourceExhausted</code>. </p>

</div>
</div>
<a id="a34dcbda849543386fc00cfa5e9a30b1a" name="a34dcbda849543386fc00cfa5e9a30b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34dcbda849543386fc00cfa5e9a30b1a">&#9670;&#160;</a></span>ConvertUTF8toWide() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::ConvertUTF8toWide </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>Source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::wstring &amp;</td>          <td class="paramname"><span class="paramname"><em>Result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a UTF-8 C-string to a std::wstring. </p>
<dl class="section return"><dt>Returns</dt><dd>true on success. </dd></dl>

</div>
</div>
<a id="ab6c65f324a518248ea7c9e3dec6abd2e" name="ab6c65f324a518248ea7c9e3dec6abd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c65f324a518248ea7c9e3dec6abd2e">&#9670;&#160;</a></span>ConvertUTF8toWide() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::ConvertUTF8toWide </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>Source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::wstring &amp;</td>          <td class="paramname"><span class="paramname"><em>Result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a UTF-8 string_view to a std::wstring. </p>
<dl class="section return"><dt>Returns</dt><dd>true on success. </dd></dl>

</div>
</div>
<a id="a4f044a5abfa43152b4511fc34f422abd" name="a4f044a5abfa43152b4511fc34f422abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f044a5abfa43152b4511fc34f422abd">&#9670;&#160;</a></span>ConvertUTF8toWide() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::ConvertUTF8toWide </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>WideCharWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>Source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;</td>          <td class="paramname"><span class="paramname"><em>ResultPtr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>ErrorPtr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an UTF8 string_view to UTF8, UTF16, or UTF32 depending on WideCharWidth. </p>
<p>The converted data is written to ResultPtr, which needs to point to at least WideCharWidth * (Source.Size() + 1) bytes. On success, ResultPtr will point one after the end of the copied string. On failure, ResultPtr will not be changed, and ErrorPtr will be set to the location of the first character which could not be converted. </p><dl class="section return"><dt>Returns</dt><dd>true on success. </dd></dl>

</div>
</div>
<a id="a4e0d4fcb62d165827231b4132e83e1a7" name="a4e0d4fcb62d165827231b4132e83e1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0d4fcb62d165827231b4132e83e1a7">&#9670;&#160;</a></span>convertWideToUTF8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::convertWideToUTF8 </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;</td>          <td class="paramname"><span class="paramname"><em>Source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a std::wstring to a UTF-8 encoded std::string. </p>
<dl class="section return"><dt>Returns</dt><dd>true on success. </dd></dl>

</div>
</div>
<a id="a5e2b51e8a094e47441a1f8a17b129255" name="a5e2b51e8a094e47441a1f8a17b129255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2b51e8a094e47441a1f8a17b129255">&#9670;&#160;</a></span>CreateEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_synchronization_8h.html#a4e842b28ce72a1d1dc778397b5f81b87">WPI_EventHandle</a> wpi::CreateEvent </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>manualReset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>initialState</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an event. </p>
<p>Events have binary state (signaled or not signaled) and may be either automatically reset or manually reset. Automatic-reset events go to non-signaled state when a WaitForObject is woken up by the event; manual-reset events require <a class="el" href="#a601a2e82b14588ebbce04bd58f47de35" title="Sets an event to non-signaled state.">ResetEvent()</a> to be called to set the event to non-signaled state; if <a class="el" href="#a601a2e82b14588ebbce04bd58f47de35" title="Sets an event to non-signaled state.">ResetEvent()</a> is not called, any waiter on that event will immediately wake when called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manualReset</td><td>true for manual reset, false for automatic reset </td></tr>
    <tr><td class="paramname">initialState</td><td>true to make the event initially in signaled state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classwpi_1_1_event.html" title="An atomic signaling event for synchronization.">Event</a> handle </dd></dl>

</div>
</div>
<a id="a0f52673d7bfdffd89e1d383abf131410" name="a0f52673d7bfdffd89e1d383abf131410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f52673d7bfdffd89e1d383abf131410">&#9670;&#160;</a></span>CreateMessage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * wpi::CreateMessage </td>
          <td>(</td>
          <td class="paramtype">google::protobuf::Arena *</td>          <td class="paramname"><span class="paramname"><em>arena</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9cf2d5389f07b5a0b98d4b26be8c766" name="ae9cf2d5389f07b5a0b98d4b26be8c766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9cf2d5389f07b5a0b98d4b26be8c766">&#9670;&#160;</a></span>CreateSemaphore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_synchronization_8h.html#a35ca8808aba014f82899e1bca7c7372b">WPI_SemaphoreHandle</a> wpi::CreateSemaphore </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>initialCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maximumCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">INT_MAX</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a semaphore. </p>
<p>Semaphores keep an internal counter. Releasing the semaphore increases the count. A semaphore with a non-zero count is considered signaled. When a waiter wakes up it atomically decrements the count by 1. This is generally useful in a single-supplier, multiple-consumer scenario.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initialCount</td><td>initial value for the semaphore's internal counter </td></tr>
    <tr><td class="paramname">maximumCount</td><td>maximum value for the semaphore's internal counter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classwpi_1_1_semaphore.html" title="A semaphore for synchronization.">Semaphore</a> handle </dd></dl>

</div>
</div>
<a id="a1dd6181788d9d2b6ca9df2e9120e6bc1" name="a1dd6181788d9d2b6ca9df2e9120e6bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd6181788d9d2b6ca9df2e9120e6bc1">&#9670;&#160;</a></span>CreateSignalObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::CreateSignalObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>manualReset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>initialState</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up signaling for an arbitrary handle. </p>
<p>With this function, any handle can operate like an event handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="classwpi_1_1_event.html" title="An atomic signaling event for synchronization.">Event</a> handle </td></tr>
    <tr><td class="paramname">manualReset</td><td>true for manual reset, false for automatic reset </td></tr>
    <tr><td class="paramname">initialState</td><td>true to make the handle initially in signaled state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad62962dadd010d3e7f1517084802194b" name="ad62962dadd010d3e7f1517084802194b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62962dadd010d3e7f1517084802194b">&#9670;&#160;</a></span>ct_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char , size_t M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::ct_string </td>
          <td>(</td>
          <td class="paramtype">Char const (&amp;)</td>          <td class="paramname"><span class="paramname"><em>s</em></span>[M]</td><td>)</td>
          <td> -&gt;  ct_string&lt; Char, std::char_traits&lt; Char &gt;, M - 1 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5847649747d23028195684c90de9cfa1" name="a5847649747d23028195684c90de9cfa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5847649747d23028195684c90de9cfa1">&#9670;&#160;</a></span>CTLog2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t kValue&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t wpi::CTLog2 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time Log2. </p>
<p>Valid only for positive powers of two. </p>

</div>
</div>
<a id="a72a3d85b513c921ffa14928e047294b6" name="a72a3d85b513c921ffa14928e047294b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a3d85b513c921ffa14928e047294b6">&#9670;&#160;</a></span>CTLog2&lt; 1 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="#a5847649747d23028195684c90de9cfa1">wpi::CTLog2</a>&lt; 1 &gt; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a693165287d8a8a5159fd739216188620" name="a693165287d8a8a5159fd739216188620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693165287d8a8a5159fd739216188620">&#9670;&#160;</a></span>deallocate_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::deallocate_buffer </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>Ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>Size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>Alignment</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate a buffer of memory with the given size and alignment. </p>
<p>If supported, this will used the sized delete operator. Also if supported, this will pass the alignment to the delete operator.</p>
<p>The pointer must have been allocated with the corresponding new operator, most likely using the above helper. </p>

</div>
</div>
<a id="a1e7e386e354d5ee78df311f700c7fae0" name="a1e7e386e354d5ee78df311f700c7fae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7e386e354d5ee78df311f700c7fae0">&#9670;&#160;</a></span>Demangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string wpi::Demangle </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>mangledSymbol</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Demangle a C++ symbol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mangledSymbol</td><td>the mangled symbol. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The demangled symbol, or mangledSymbol if demangling fails. </dd></dl>

</div>
</div>
<a id="acc9e09379b6fd369678065777492fa13" name="acc9e09379b6fd369678065777492fa13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9e09379b6fd369678065777492fa13">&#9670;&#160;</a></span>DestroyEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::DestroyEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_synchronization_8h.html#a4e842b28ce72a1d1dc778397b5f81b87">WPI_EventHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys an event. </p>
<p>Destruction wakes up any waiters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>event handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c260de651e61ba3109bdab5ce72c6fc" name="a0c260de651e61ba3109bdab5ce72c6fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c260de651e61ba3109bdab5ce72c6fc">&#9670;&#160;</a></span>DestroySemaphore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::DestroySemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_synchronization_8h.html#a35ca8808aba014f82899e1bca7c7372b">WPI_SemaphoreHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a semaphore. </p>
<p>Destruction wakes up any waiters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>semaphore handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacbea963e58a5375de8945e77262bb05" name="aacbea963e58a5375de8945e77262bb05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacbea963e58a5375de8945e77262bb05">&#9670;&#160;</a></span>DestroySignalObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::DestroySignalObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleans up signaling for a handle. </p>
<p>Destruction wakes up any waiters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86598beceb2a41ea10f4335f8d5b99e4" name="a86598beceb2a41ea10f4335f8d5b99e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86598beceb2a41ea10f4335f8d5b99e4">&#9670;&#160;</a></span>divideCeil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::divideCeil </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Numerator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Denominator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the integer ceil(Numerator / Denominator). </p>

</div>
</div>
<a id="a75514d8e686b9790882d92c4efc0c8f3" name="a75514d8e686b9790882d92c4efc0c8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75514d8e686b9790882d92c4efc0c8f3">&#9670;&#160;</a></span>divideNearest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::divideNearest </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Numerator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Denominator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the integer nearest(Numerator / Denominator). </p>

</div>
</div>
<a id="a2640340e4b5c2618417738f45c047509" name="a2640340e4b5c2618417738f45c047509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2640340e4b5c2618417738f45c047509">&#9670;&#160;</a></span>drop_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; T &gt; wpi::drop_back </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T, N &gt;</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::span&lt; T &gt;::size_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop the last <code>N</code> elements of the array. </p>

</div>
</div>
<a id="a7f57db8fe105b74dbfbd5897fa695c14" name="a7f57db8fe105b74dbfbd5897fa695c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f57db8fe105b74dbfbd5897fa695c14">&#9670;&#160;</a></span>drop_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view wpi::drop_back </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a string_view equal to <code>str</code> but with the last <code>n</code> elements dropped. </p>

</div>
</div>
<a id="a2a591544e2a1812a45a5caa585367c01" name="a2a591544e2a1812a45a5caa585367c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a591544e2a1812a45a5caa585367c01">&#9670;&#160;</a></span>drop_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; T &gt; wpi::drop_front </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T, N &gt;</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::span&lt; T &gt;::size_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop the first <code>N</code> elements of the array. </p>

</div>
</div>
<a id="aa5e1eeb77b140b88774935651084a248" name="aa5e1eeb77b140b88774935651084a248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e1eeb77b140b88774935651084a248">&#9670;&#160;</a></span>drop_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view wpi::drop_front </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a string_view equal to <code>str</code> but with the first <code>n</code> elements dropped. </p>

</div>
</div>
<a id="aa6f54d8682fc12347ac7befe9706e7c1" name="aa6f54d8682fc12347ac7befe9706e7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f54d8682fc12347ac7befe9706e7c1">&#9670;&#160;</a></span>dyn_cast() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) wpi::dyn_cast </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dyn_cast&lt;X&gt; - Return the argument parameter cast to the specified type. </p>
<p>This casting operator returns null if the argument is of the wrong type, so it can be used to test for a type as well as cast if successful. The value passed in must be present, if not, use dyn_cast_if_present. This should be used in the context of an if statement like this:</p>
<p>if (const Instruction *I = dyn_cast&lt;Instruction&gt;(myVal)) { ... } </p>

</div>
</div>
<a id="a80b3596d6edfbd8dba33b1c9a23022cc" name="a80b3596d6edfbd8dba33b1c9a23022cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b3596d6edfbd8dba33b1c9a23022cc">&#9670;&#160;</a></span>dyn_cast() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) wpi::dyn_cast </td>
          <td>(</td>
          <td class="paramtype">From &amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad473029646c1b0de5aa067c7565e409a" name="ad473029646c1b0de5aa067c7565e409a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad473029646c1b0de5aa067c7565e409a">&#9670;&#160;</a></span>dyn_cast() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) wpi::dyn_cast </td>
          <td>(</td>
          <td class="paramtype">From *</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7fe2ef2ae56adc0a57f8b9f942cfc3c8" name="a7fe2ef2ae56adc0a57f8b9f942cfc3c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe2ef2ae56adc0a57f8b9f942cfc3c8">&#9670;&#160;</a></span>dyn_cast() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) wpi::dyn_cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; From &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7a2172f617bad28f826b306b2c3fd48" name="ad7a2172f617bad28f826b306b2c3fd48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a2172f617bad28f826b306b2c3fd48">&#9670;&#160;</a></span>dyn_cast_if_present() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::dyn_cast_if_present </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>dyn_cast_if_present&lt;X&gt; - Functionally identical to dyn_cast, except that a null (or none in the case of optionals) value is accepted. </p>

</div>
</div>
<a id="a4ed04fcefb22adfac639093654b30ba8" name="a4ed04fcefb22adfac639093654b30ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed04fcefb22adfac639093654b30ba8">&#9670;&#160;</a></span>dyn_cast_if_present() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::dyn_cast_if_present </td>
          <td>(</td>
          <td class="paramtype">Y &amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acada0e48faa3c9744961e3f633c34491" name="acada0e48faa3c9744961e3f633c34491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acada0e48faa3c9744961e3f633c34491">&#9670;&#160;</a></span>dyn_cast_if_present() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::dyn_cast_if_present </td>
          <td>(</td>
          <td class="paramtype">Y *</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2fd32ebcb102cb3ccb0d8c267b920f3" name="ae2fd32ebcb102cb3ccb0d8c267b920f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2fd32ebcb102cb3ccb0d8c267b920f3">&#9670;&#160;</a></span>dyn_cast_or_null() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::dyn_cast_or_null </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a951ab0e01e0c994b76be9f61d56c12" name="a5a951ab0e01e0c994b76be9f61d56c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a951ab0e01e0c994b76be9f61d56c12">&#9670;&#160;</a></span>dyn_cast_or_null() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::dyn_cast_or_null </td>
          <td>(</td>
          <td class="paramtype">Y &amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48b381976312c54ae970f51b9c5aa2ad" name="a48b381976312c54ae970f51b9c5aa2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b381976312c54ae970f51b9c5aa2ad">&#9670;&#160;</a></span>dyn_cast_or_null() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::dyn_cast_or_null </td>
          <td>(</td>
          <td class="paramtype">Y *</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd4df2968e94c4ee3ac050889f633446" name="abd4df2968e94c4ee3ac050889f633446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4df2968e94c4ee3ac050889f633446">&#9670;&#160;</a></span>ends_with() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::ends_with </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> ends with the given <code>suffix</code>. </p>

</div>
</div>
<a id="a3ec868a416c46e73b09990b9accd5531" name="a3ec868a416c46e73b09990b9accd5531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec868a416c46e73b09990b9accd5531">&#9670;&#160;</a></span>ends_with() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::ends_with </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> ends with the given <code>suffix</code>. </p>

</div>
</div>
<a id="ae76aa40d978aab32a3dcfab7f8eb953b" name="ae76aa40d978aab32a3dcfab7f8eb953b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76aa40d978aab32a3dcfab7f8eb953b">&#9670;&#160;</a></span>ends_with() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::ends_with </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> ends with the given <code>suffix</code>. </p>

</div>
</div>
<a id="a95519eb02ecc90f51e4157b797a4c306" name="a95519eb02ecc90f51e4157b797a4c306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95519eb02ecc90f51e4157b797a4c306">&#9670;&#160;</a></span>ends_with_lower() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::ends_with_lower </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> ends with the given <code>suffix</code>, ignoring case. </p>

</div>
</div>
<a id="ac1334c1afcb5a1b5592e57a78436915b" name="ac1334c1afcb5a1b5592e57a78436915b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1334c1afcb5a1b5592e57a78436915b">&#9670;&#160;</a></span>ends_with_lower() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::ends_with_lower </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> ends with the given <code>suffix</code>, ignoring case. </p>

</div>
</div>
<a id="a63ce9b37507ebc31753938d388848714" name="a63ce9b37507ebc31753938d388848714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ce9b37507ebc31753938d388848714">&#9670;&#160;</a></span>ends_with_lower() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::ends_with_lower </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> ends with the given <code>suffix</code>, ignoring case. </p>

</div>
</div>
<a id="a861d18fea3edd7f459017ea02e79d5ea" name="a861d18fea3edd7f459017ea02e79d5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861d18fea3edd7f459017ea02e79d5ea">&#9670;&#160;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::equals </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>equals - Check for string equality, this is more efficient than compare() when the relative ordering of inequal strings isn't needed. </p>

</div>
</div>
<a id="a6f467e8545fad85176bcf4e64ced7bc7" name="a6f467e8545fad85176bcf4e64ced7bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f467e8545fad85176bcf4e64ced7bc7">&#9670;&#160;</a></span>equals_lower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::equals_lower </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>equals_lower - Check for string equality, ignoring case. </p>

</div>
</div>
<a id="a9f7c7026236c3b3756c7ade99aa716cc" name="a9f7c7026236c3b3756c7ade99aa716cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7c7026236c3b3756c7ade99aa716cc">&#9670;&#160;</a></span>erase_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; T &gt;::size_type wpi::erase_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca972941e2effcb07cfc0e14b7c783f6" name="aca972941e2effcb07cfc0e14b7c783f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca972941e2effcb07cfc0e14b7c783f6">&#9670;&#160;</a></span>errs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1raw__fd__ostream.html">raw_fd_ostream</a> &amp; wpi::errs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns a reference to a <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> for standard error. </p>
<p>Use it like: <a class="el" href="#aca972941e2effcb07cfc0e14b7c783f6" title="This returns a reference to a raw_ostream for standard error.">errs()</a> &lt;&lt; "foo" &lt;&lt; "bar"; By default, the stream is tied to stdout to ensure stdout is flushed before stderr is written, to ensure the error messages are written in their expected place. </p>

</div>
</div>
<a id="ab6e885a95d4fbe472d78076ecc824194" name="ab6e885a95d4fbe472d78076ecc824194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e885a95d4fbe472d78076ecc824194">&#9670;&#160;</a></span>EscapeURI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view wpi::EscapeURI </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>spacePlus</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a32f2207fbd2f0fbd2a85bda3ef353ec5" name="a32f2207fbd2f0fbd2a85bda3ef353ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f2207fbd2f0fbd2a85bda3ef353ec5">&#9670;&#160;</a></span>find_lower() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view::size_type wpi::find_lower </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type</td>          <td class="paramname"><span class="paramname"><em>from</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the first character <code>ch</code> in <code>str</code>, ignoring case. </p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The index of the first occurrence of <code>ch</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="a5f278b2f7c4f0f3d3417390f77979fd5" name="a5f278b2f7c4f0f3d3417390f77979fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f278b2f7c4f0f3d3417390f77979fd5">&#9670;&#160;</a></span>find_lower() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view::size_type wpi::find_lower </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type</td>          <td class="paramname"><span class="paramname"><em>from</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the first string <code>other</code> in <code>str</code>, ignoring case. </p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The index of the first occurrence of <code>other</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="af5e73ed8bf4d49b2734570b2c83f9303" name="af5e73ed8bf4d49b2734570b2c83f9303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e73ed8bf4d49b2734570b2c83f9303">&#9670;&#160;</a></span>find_lower() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view::size_type wpi::find_lower </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type</td>          <td class="paramname"><span class="paramname"><em>from</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the first string <code>other</code> in <code>str</code>, ignoring case. </p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The index of the first occurrence of <code>other</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="a8efec7766be35df2a4782f6cb1004058" name="a8efec7766be35df2a4782f6cb1004058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8efec7766be35df2a4782f6cb1004058">&#9670;&#160;</a></span>FindMultipartBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::FindMultipartBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1raw__istream.html">wpi::raw_istream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>boundary</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>saveBuf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7928a642def980fb692b5d321ed63529" name="a7928a642def980fb692b5d321ed63529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7928a642def980fb692b5d321ed63529">&#9670;&#160;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::for_each </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>elems</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls f(i, elem) for each element of elems where i is the index of the element in elems and elem is the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The callback. </td></tr>
    <tr><td class="paramname">elems</td><td>The elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba4c7fb7a4c097ca545d416153dc0a9b" name="aba4c7fb7a4c097ca545d416153dc0a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4c7fb7a4c097ca545d416153dc0a9b">&#9670;&#160;</a></span>ForEachStructSchema()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">void wpi::ForEachStructSchema </td>
          <td>(</td>
          <td class="paramtype">std::invocable&lt; std::string_view, std::string_view &gt; auto</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I &amp;...</td>          <td class="paramname"><span class="paramname"><em>info</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7392ab14211b2573e41ddf483a2c7b9" name="ab7392ab14211b2573e41ddf483a2c7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7392ab14211b2573e41ddf483a2c7b9">&#9670;&#160;</a></span>format_to_n_c_str()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OutputIt , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::format_to_n_c_str </td>
          <td>(</td>
          <td class="paramtype">OutputIt</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::iter_difference_t&lt; OutputIt &gt;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmt::format_string&lt; Args... &gt;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like std::format_to_n() in that it writes at most n bytes to the output buffer, but also includes a terminating null byte in n. </p>
<p>This is essentially a more performant replacement for std::snprintf().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output buffer. </td></tr>
    <tr><td class="paramname">n</td><td>The size of the output buffer. </td></tr>
    <tr><td class="paramname">fmt</td><td>The format string. </td></tr>
    <tr><td class="paramname">args</td><td>The format string arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30f7388a5c35ee653463418cea51c178" name="a30f7388a5c35ee653463418cea51c178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f7388a5c35ee653463418cea51c178">&#9670;&#160;</a></span>get() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, typename PointerTy , unsigned IntBits, typename IntType , typename PtrTraits , typename Info &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) wpi::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_pointer_int_pair.html">PointerIntPair</a>&lt; PointerTy, IntBits, IntType, PtrTraits, Info &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Pair</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb253c150fd08303e17789f200e2c751" name="aeb253c150fd08303e17789f200e2c751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb253c150fd08303e17789f200e2c751">&#9670;&#160;</a></span>get() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Index, typename ValueTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) wpi::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map_entry.html">StringMapEntry</a>&lt; ValueTy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>E</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0def7e7c0176002c2ad197435f25b4b6" name="a0def7e7c0176002c2ad197435f25b4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0def7e7c0176002c2ad197435f25b4b6">&#9670;&#160;</a></span>get() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Index, typename ValueTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) wpi::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_string_map_entry.html">StringMapEntry</a>&lt; ValueTy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>E</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9adbe1d3698433c32c8b78b84f582a5b" name="a9adbe1d3698433c32c8b78b84f582a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9adbe1d3698433c32c8b78b84f582a5b">&#9670;&#160;</a></span>GetHostname() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string wpi::GetHostname </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c253c393e339cc29a6e8ff9cb648420" name="a3c253c393e339cc29a6e8ff9cb648420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c253c393e339cc29a6e8ff9cb648420">&#9670;&#160;</a></span>GetHostname() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view wpi::GetHostname </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54a45aaed6f6214f0a95dc9fd352b628" name="a54a45aaed6f6214f0a95dc9fd352b628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a45aaed6f6214f0a95dc9fd352b628">&#9670;&#160;</a></span>getNumBytesForUTF8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned wpi::getNumBytesForUTF8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a></td>          <td class="paramname"><span class="paramname"><em>firstByte</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b125df3c2eaae6f9b8cd09ccd9da98d" name="a4b125df3c2eaae6f9b8cd09ccd9da98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b125df3c2eaae6f9b8cd09ccd9da98d">&#9670;&#160;</a></span>GetStackTrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string wpi::GetStackTrace </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a stack trace, ignoring the first "offset" symbols. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The number of symbols at the top of the stack to ignore </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17c7ea157a96be60befa9ba11407f839" name="a17c7ea157a96be60befa9ba11407f839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c7ea157a96be60befa9ba11407f839">&#9670;&#160;</a></span>GetStackTraceDefault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string wpi::GetStackTraceDefault </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offset</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default implementation used for <a class="el" href="#a4b125df3c2eaae6f9b8cd09ccd9da98d" title="Get a stack trace, ignoring the first &quot;offset&quot; symbols.">GetStackTrace()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The number of symbols at the top of the stack to ignore </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a975d368152ea01b5199b4040293ce52d" name="a975d368152ea01b5199b4040293ce52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975d368152ea01b5199b4040293ce52d">&#9670;&#160;</a></span>GetStructSchema()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view wpi::GetStructSchema </td>
          <td>(</td>
          <td class="paramtype">const I &amp;...</td>          <td class="paramname"><span class="paramname"><em>info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d2ad040d89f1db413517d3f8777c3c3" name="a8d2ad040d89f1db413517d3f8777c3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2ad040d89f1db413517d3f8777c3c3">&#9670;&#160;</a></span>GetStructSchemaBytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; const uint8_t &gt; wpi::GetStructSchemaBytes </td>
          <td>(</td>
          <td class="paramtype">const I &amp;...</td>          <td class="paramname"><span class="paramname"><em>info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab54cf203a3da0455d74c23f253c13639" name="ab54cf203a3da0455d74c23f253c13639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54cf203a3da0455d74c23f253c13639">&#9670;&#160;</a></span>GetStructSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t wpi::GetStructSize </td>
          <td>(</td>
          <td class="paramtype">const I &amp;...</td>          <td class="paramname"><span class="paramname"><em>info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size for a raw struct serializable type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>serializable type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>optional struct type info </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size </dd></dl>

</div>
</div>
<a id="a9b0811bc73046b235809bcc275bb3682" name="a9b0811bc73046b235809bcc275bb3682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0811bc73046b235809bcc275bb3682">&#9670;&#160;</a></span>GetStructTypeName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::GetStructTypeName </td>
          <td>(</td>
          <td class="paramtype">const I &amp;...</td>          <td class="paramname"><span class="paramname"><em>info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type name for a raw struct serializable type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>serializable type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>optional struct type info </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>type name </dd></dl>

</div>
</div>
<a id="a0249983b0ac0f153c86b6ca79937c1fb" name="a0249983b0ac0f153c86b6ca79937c1fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0249983b0ac0f153c86b6ca79937c1fb">&#9670;&#160;</a></span>GetStructTypeString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::GetStructTypeString </td>
          <td>(</td>
          <td class="paramtype">const I &amp;...</td>          <td class="paramname"><span class="paramname"><em>info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type string for a raw struct serializable type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>serializable type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>optional struct type info </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>type string (struct: followed by type name) </dd></dl>

</div>
</div>
<a id="a9d28c0c9406326aabe2f414979901b37" name="a9d28c0c9406326aabe2f414979901b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d28c0c9406326aabe2f414979901b37">&#9670;&#160;</a></span>GetSystemTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::GetSystemTime </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current system time in microseconds since the Unix epoch (January 1st, 1970 00:00 UTC). </p>
<dl class="section return"><dt>Returns</dt><dd>Time in microseconds. </dd></dl>

</div>
</div>
<a id="ad718ecdfe8fb14771e97a6c2169ddb99" name="ad718ecdfe8fb14771e97a6c2169ddb99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad718ecdfe8fb14771e97a6c2169ddb99">&#9670;&#160;</a></span>GetTypeName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string wpi::GetTypeName </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the type name of an object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3463b82b9bd307aca59abfafc0fd0b28" name="a3463b82b9bd307aca59abfafc0fd0b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3463b82b9bd307aca59abfafc0fd0b28">&#9670;&#160;</a></span>getUTF8SequenceSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned wpi::getUTF8SequenceSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *</td>          <td class="paramname"><span class="paramname"><em>sourceEnd</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70a8888fe7cb03223848f14e95e42764" name="a70a8888fe7cb03223848f14e95e42764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a8888fe7cb03223848f14e95e42764">&#9670;&#160;</a></span>hash_combine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a> wpi::hash_combine </td>
          <td>(</td>
          <td class="paramtype">const Ts &amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine values into a single <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a>. </p>
<p>This routine accepts a varying number of arguments of any type. It will attempt to combine them into a single <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a>. For user-defined types it attempts to call a </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa95acb3c2c107b75867a237c1701577c" title="Compute a hash_code for any integer value.">hash_value</a> overload (via ADL) for the type. For integer and <a class="el" href="wpiutil_2src_2main_2native_2thirdparty_2fmtlib_2include_2fmt_2base_8h.html#adfa139c9a1902753b3696794759b2c48accac8a66d468e2522611be86933cc0d9">pointer</a> types it directly combines their data into the resulting <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a>.</dd></dl>
<p>The result is suitable for returning from a user's hash_value <em>implementation</em> for their user-defined type. Consumers of a type should <em>not</em> call this routine, they should instead call 'hash_value'. </p>

</div>
</div>
<a id="a583ca8bbb8e3ee49e8f65df91a6ecaaf" name="a583ca8bbb8e3ee49e8f65df91a6ecaaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583ca8bbb8e3ee49e8f65df91a6ecaaf">&#9670;&#160;</a></span>hash_combine_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIteratorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a> wpi::hash_combine_range </td>
          <td>(</td>
          <td class="paramtype">InputIteratorT</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIteratorT</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a sequence of values. </p>
<p>This hashes a sequence of values. It produces the same <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> as 'hash_combine(a, b, c, ...)', but can run over arbitrary sized sequences and is significantly faster given pointers and types which can be hashed as a sequence of bytes. </p>

</div>
</div>
<a id="a8e2f8fc1e0870f5b219a8bc1d3654ecc" name="a8e2f8fc1e0870f5b219a8bc1d3654ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2f8fc1e0870f5b219a8bc1d3654ecc">&#9670;&#160;</a></span>hash_value() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a> wpi::hash_value </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a standard string. </p>

</div>
</div>
<a id="a97d22556bedb2cce56fa864ccb308f5d" name="a97d22556bedb2cce56fa864ccb308f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d22556bedb2cce56fa864ccb308f5d">&#9670;&#160;</a></span>hash_value() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a> wpi::hash_value </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a standard string. </p>

</div>
</div>
<a id="a6b9238bfb621b5c47abfc9480889408e" name="a6b9238bfb621b5c47abfc9480889408e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9238bfb621b5c47abfc9480889408e">&#9670;&#160;</a></span>hash_value() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a> wpi::hash_value </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a pair of objects. </p>

</div>
</div>
<a id="a09058a5e42b0bee35ae7f6d7bf0822a0" name="a09058a5e42b0bee35ae7f6d7bf0822a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09058a5e42b0bee35ae7f6d7bf0822a0">&#9670;&#160;</a></span>hash_value() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a> wpi::hash_value </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; Ts... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a tuple. </p>

</div>
</div>
<a id="a8eb96f94c028542a238feaf8cabb44dc" name="a8eb96f94c028542a238feaf8cabb44dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb96f94c028542a238feaf8cabb44dc">&#9670;&#160;</a></span>hash_value() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1hash__code.html">hash_code</a> wpi::hash_value </td>
          <td>(</td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a pointer's address. </p>
<p>N.B.: This hashes the <em>address</em>. Not the value and not the type. </p>

</div>
</div>
<a id="aa95acb3c2c107b75867a237c1701577c" name="aa95acb3c2c107b75867a237c1701577c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa95acb3c2c107b75867a237c1701577c">&#9670;&#160;</a></span>hash_value() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="classwpi_1_1is__integral__or__enum.html">is_integral_or_enum</a>&lt; T &gt;::value, <a class="el" href="classwpi_1_1hash__code.html">hash_code</a> &gt; wpi::hash_value </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for any integer value. </p>
<p>Note that this function is intended to compute the same <a class="el" href="classwpi_1_1hash__code.html" title="An opaque object representing a hash code.">hash_code</a> for a particular value without regard to the pre-promotion type. This is in contrast to hash_combine which may produce different hash_codes for differing argument types even if they would implicit promote to a common type without changing the value. </p>

</div>
</div>
<a id="a328c5e2f088e151affd5ff9d7b398c42" name="a328c5e2f088e151affd5ff9d7b398c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328c5e2f088e151affd5ff9d7b398c42">&#9670;&#160;</a></span>hasUTF16ByteOrderMark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::hasUTF16ByteOrderMark </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const char &gt;</td>          <td class="paramname"><span class="paramname"><em>SrcBytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if a blob of text starts with a UTF-16 big or little endian byte order mark. </p>

</div>
</div>
<a id="a025d8760b23ac3786c52b2cc7d72f5eb" name="a025d8760b23ac3786c52b2cc7d72f5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a025d8760b23ac3786c52b2cc7d72f5eb">&#9670;&#160;</a></span>hexdigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char wpi::hexdigit </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>LowerCase</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>hexdigit - Return the hexadecimal character for the given number <code>X</code> (which should be less than 16). </p>

</div>
</div>
<a id="a3f23b372d35fd43e572bd6310538d3b4" name="a3f23b372d35fd43e572bd6310538d3b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f23b372d35fd43e572bd6310538d3b4">&#9670;&#160;</a></span>hexDigitValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned wpi::hexDigitValue </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>C</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpret the given character <code>C</code> as a hexadecimal digit and return its value. </p>
<p>If <code>C</code> is not a valid hex digit, -1U is returned. </p>

</div>
</div>
<a id="af3568938669eceec8a2a2e8060cf7550" name="af3568938669eceec8a2a2e8060cf7550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3568938669eceec8a2a2e8060cf7550">&#9670;&#160;</a></span>Hi_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t wpi::Hi_32 </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the high 32 bits of a 64 bit value. </p>

</div>
</div>
<a id="ab736f59b1f30b097d559e33acc6bb602" name="ab736f59b1f30b097d559e33acc6bb602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab736f59b1f30b097d559e33acc6bb602">&#9670;&#160;</a></span>http_body_is_final()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wpi::http_body_is_final </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a534aec91ecbd222189dd61e56e809443" name="a534aec91ecbd222189dd61e56e809443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534aec91ecbd222189dd61e56e809443">&#9670;&#160;</a></span>http_errno_description()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * wpi::http_errno_description </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="#a0e56bd09798339ac4f86d36eb8ecea0b">http_errno</a></td>          <td class="paramname"><span class="paramname"><em>err</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0b4fb11893062b968b86716e84aebae" name="ab0b4fb11893062b968b86716e84aebae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b4fb11893062b968b86716e84aebae">&#9670;&#160;</a></span>http_errno_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * wpi::http_errno_name </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="#a0e56bd09798339ac4f86d36eb8ecea0b">http_errno</a></td>          <td class="paramname"><span class="paramname"><em>err</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9be802a6897b36bbcd4c2dcd23e9e7f3" name="a9be802a6897b36bbcd4c2dcd23e9e7f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be802a6897b36bbcd4c2dcd23e9e7f3">&#9670;&#160;</a></span>http_method_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * wpi::http_method_str </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="#a3458579fc7214ea6b0411bbadf6ffcbc">http_method</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9cea3956c069ac99ed2e7eeebb5b3cfb" name="a9cea3956c069ac99ed2e7eeebb5b3cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cea3956c069ac99ed2e7eeebb5b3cfb">&#9670;&#160;</a></span>http_parser_execute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t wpi::http_parser_execute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structwpi_1_1http__parser__settings.html">http_parser_settings</a> *</td>          <td class="paramname"><span class="paramname"><em>settings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfaa8c347e0e51020430bcd0d45660b4" name="adfaa8c347e0e51020430bcd0d45660b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfaa8c347e0e51020430bcd0d45660b4">&#9670;&#160;</a></span>http_parser_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::http_parser_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#ab37735642db3ab741e86bf064b2ddbbd">http_parser_type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7fc17f817835ce41947523e20f3feeb1" name="a7fc17f817835ce41947523e20f3feeb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc17f817835ce41947523e20f3feeb1">&#9670;&#160;</a></span>http_parser_parse_url()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wpi::http_parser_parse_url </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>buflen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>is_connect</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwpi_1_1http__parser__url.html">http_parser_url</a> *</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc98ce08cafe77beb6171b08d3065181" name="afc98ce08cafe77beb6171b08d3065181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc98ce08cafe77beb6171b08d3065181">&#9670;&#160;</a></span>http_parser_pause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::http_parser_pause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>paused</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f661690631e2ba6da370fe0b5bcfc55" name="a9f661690631e2ba6da370fe0b5bcfc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f661690631e2ba6da370fe0b5bcfc55">&#9670;&#160;</a></span>http_parser_settings_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::http_parser_settings_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwpi_1_1http__parser__settings.html">http_parser_settings</a> *</td>          <td class="paramname"><span class="paramname"><em>settings</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a798587facfa5f28d28e137d96c97a0d0" name="a798587facfa5f28d28e137d96c97a0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798587facfa5f28d28e137d96c97a0d0">&#9670;&#160;</a></span>http_parser_url_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::http_parser_url_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwpi_1_1http__parser__url.html">http_parser_url</a> *</td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1285c84e98d61b7f161a2213dd9f7940" name="a1285c84e98d61b7f161a2213dd9f7940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1285c84e98d61b7f161a2213dd9f7940">&#9670;&#160;</a></span>http_parser_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long wpi::http_parser_version </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1d892e596ff2ee4287ebd021faa63b4" name="ad1d892e596ff2ee4287ebd021faa63b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d892e596ff2ee4287ebd021faa63b4">&#9670;&#160;</a></span>http_should_keep_alive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wpi::http_should_keep_alive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwpi_1_1http__parser.html">http_parser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af568f1219d61f5c74f4de5caac588a90" name="af568f1219d61f5c74f4de5caac588a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af568f1219d61f5c74f4de5caac588a90">&#9670;&#160;</a></span>http_status_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * wpi::http_status_str </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="#ae89a1f90a8603e399f9cc0465b0ce21e">http_status</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9e2b9c52f4cd86842aa577863b93c2a" name="ab9e2b9c52f4cd86842aa577863b93c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e2b9c52f4cd86842aa577863b93c2a">&#9670;&#160;</a></span>insert_sorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;::iterator wpi::insert_sorted </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5490819a8d9ceedb98494b59ed05917" name="ad5490819a8d9ceedb98494b59ed05917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5490819a8d9ceedb98494b59ed05917">&#9670;&#160;</a></span>install_bad_alloc_error_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::install_bad_alloc_error_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aacde1332b72e968317ed516552a07ca8">fatal_error_handler_t</a></td>          <td class="paramname"><span class="paramname"><em>handler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_data</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs a new bad alloc error handler that should be used whenever a bad alloc error, e.g. </p>
<p>failing malloc/calloc, is encountered by LLVM.</p>
<p>The user can install a bad alloc handler, in order to define the behavior in case of failing allocations, e.g. throwing an exception. Note that this handler must not trigger any additional allocations itself.</p>
<p>If no error handler is installed the default is to print the error message to stderr, and call exit(1). If an error handler is installed then it is the handler's responsibility to log the message, it will no longer be printed to stderr. If the error handler returns, then exit(1) will be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_data</td><td>- An argument which will be passed to the installed error handler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a309bc670f1bda6373a69c5a66eb9849a" name="a309bc670f1bda6373a69c5a66eb9849a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309bc670f1bda6373a69c5a66eb9849a">&#9670;&#160;</a></span>install_fatal_error_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::install_fatal_error_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aacde1332b72e968317ed516552a07ca8">fatal_error_handler_t</a></td>          <td class="paramname"><span class="paramname"><em>handler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_data</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>install_fatal_error_handler - Installs a new error handler to be used whenever a serious (non-recoverable) error is encountered by LLVM. </p>
<p>If no error handler is installed the default is to print the error message to stderr, and call exit(1). If an error handler is installed then it is the handler's responsibility to log the message, it will no longer be printed to stderr. If the error handler returns, then exit(1) will be called.</p>
<p>It is dangerous to naively use an error handler which throws an exception. Even though some applications desire to gracefully recover from arbitrary faults, blindly throwing exceptions through unfamiliar code isn't a way to achieve this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_data</td><td>- An argument which will be passed to the install error handler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad97e6b598cd8e5fe3f4d4e75e83dbb9e" name="ad97e6b598cd8e5fe3f4d4e75e83dbb9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97e6b598cd8e5fe3f4d4e75e83dbb9e">&#9670;&#160;</a></span>install_out_of_memory_new_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::install_out_of_memory_new_handler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5118b70b1397ab73ebbd7c5d9d7aec29" name="a5118b70b1397ab73ebbd7c5d9d7aec29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5118b70b1397ab73ebbd7c5d9d7aec29">&#9670;&#160;</a></span>is_constexpr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::is_constexpr </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac93b7de1e962f6dbca1b8d2f09402624" name="ac93b7de1e962f6dbca1b8d2f09402624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93b7de1e962f6dbca1b8d2f09402624">&#9670;&#160;</a></span>is_constexpr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Lambda , int  = (Lambda{}(), 0)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::is_constexpr </td>
          <td>(</td>
          <td class="paramtype">Lambda</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a964ada559def4cb99c3554f2a7c8ecca" name="a964ada559def4cb99c3554f2a7c8ecca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964ada559def4cb99c3554f2a7c8ecca">&#9670;&#160;</a></span>isa() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isa </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>isa&lt;X&gt; - Return true if the parameter to the template is an instance of one of the template type arguments. </p>
<p>Used like this:</p>
<p>if (isa&lt;Type&gt;(myVal)) { ... } if (isa&lt;Type0, Type1, Type2&gt;(myVal)) { ... } </p>

</div>
</div>
<a id="ad45870e316ed651537ea145e67b3512a" name="ad45870e316ed651537ea145e67b3512a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45870e316ed651537ea145e67b3512a">&#9670;&#160;</a></span>isa() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename Second , typename... Rest, typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isa </td>
          <td>(</td>
          <td class="paramtype">const From &amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a8475cd52faddca844bb540effa022e" name="a5a8475cd52faddca844bb540effa022e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a8475cd52faddca844bb540effa022e">&#9670;&#160;</a></span>isa_and_nonnull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... X, class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isa_and_nonnull </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7cc4026f84f4c754d494b7d3ced2066" name="aa7cc4026f84f4c754d494b7d3ced2066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7cc4026f84f4c754d494b7d3ced2066">&#9670;&#160;</a></span>isa_and_present()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... X, class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isa_and_present </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>isa_and_present&lt;X&gt; - Functionally identical to isa, except that a null value is accepted. </p>

</div>
</div>
<a id="a2db9afebe0b9cb8a94691657ad62b71b" name="a2db9afebe0b9cb8a94691657ad62b71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db9afebe0b9cb8a94691657ad62b71b">&#9670;&#160;</a></span>isAlnum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isAlnum </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>C</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether character <code>C</code> is either a decimal digit or an uppercase or lowercase letter as classified by "C" locale. </p>

</div>
</div>
<a id="ad40bed52c4db6c9d8ac4d6a34f701fca" name="ad40bed52c4db6c9d8ac4d6a34f701fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40bed52c4db6c9d8ac4d6a34f701fca">&#9670;&#160;</a></span>isAlpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isAlpha </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>C</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if character <code>C</code> is a valid letter as classified by "C" locale. </p>

</div>
</div>
<a id="ad2e6acbb1ecc26fc431a01798885b5a1" name="ad2e6acbb1ecc26fc431a01798885b5a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e6acbb1ecc26fc431a01798885b5a1">&#9670;&#160;</a></span>isASCII()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isASCII </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>C</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether character <code>C</code> is valid ASCII (high bit is zero). </p>

</div>
</div>
<a id="a368b03e8bb2ecfdc34b02b40523055e4" name="a368b03e8bb2ecfdc34b02b40523055e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368b03e8bb2ecfdc34b02b40523055e4">&#9670;&#160;</a></span>isDigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isDigit </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>C</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if character <code>C</code> is one of the 10 decimal digits. </p>

</div>
</div>
<a id="a33822f75a8aa525d240b60e5e79568b6" name="a33822f75a8aa525d240b60e5e79568b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33822f75a8aa525d240b60e5e79568b6">&#9670;&#160;</a></span>isHexDigit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isHexDigit </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>C</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if character <code>C</code> is a hexadecimal numeric character. </p>

</div>
</div>
<a id="a793cb5a31f3412455ec43e6030919a42" name="a793cb5a31f3412455ec43e6030919a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793cb5a31f3412455ec43e6030919a42">&#9670;&#160;</a></span>isInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isInt </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an integer fits into the given bit width. </p>

</div>
</div>
<a id="ae65bc8235c8a7ccfb15d4856909adc45" name="ae65bc8235c8a7ccfb15d4856909adc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae65bc8235c8a7ccfb15d4856909adc45">&#9670;&#160;</a></span>isIntN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isIntN </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an signed integer fits into the given (dynamic) bit width. </p>

</div>
</div>
<a id="a26e27444cfe3390c1682575a3ad1860b" name="a26e27444cfe3390c1682575a3ad1860b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e27444cfe3390c1682575a3ad1860b">&#9670;&#160;</a></span>isLegalUTF8Sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac9954615e01ad150570a0e1d4548d879">Boolean</a> wpi::isLegalUTF8Sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *</td>          <td class="paramname"><span class="paramname"><em>sourceEnd</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8c7efa3db3243cb89f4f1c15b2a2c10" name="ad8c7efa3db3243cb89f4f1c15b2a2c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c7efa3db3243cb89f4f1c15b2a2c10">&#9670;&#160;</a></span>isLegalUTF8String()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac9954615e01ad150570a0e1d4548d879">Boolean</a> wpi::isLegalUTF8String </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> **</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a37bbc3b1e95b6409a042b8089d3d8c00">UTF8</a> *</td>          <td class="paramname"><span class="paramname"><em>sourceEnd</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7868b72f26477d7e06a655a552b8886" name="af7868b72f26477d7e06a655a552b8886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7868b72f26477d7e06a655a552b8886">&#9670;&#160;</a></span>isMask_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isMask_32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>Value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the argument is a non-empty sequence of ones starting at the least significant bit with the remainder zero (32 bit version). </p>
<p>Ex. isMask_32(0x0000FFFFU) == true. </p>

</div>
</div>
<a id="abba808be054c9d45a724cc14bf47b45b" name="abba808be054c9d45a724cc14bf47b45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba808be054c9d45a724cc14bf47b45b">&#9670;&#160;</a></span>isMask_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isMask_64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the argument is a non-empty sequence of ones starting at the least significant bit with the remainder zero (64 bit version). </p>

</div>
</div>
<a id="a44ef6fef4b85937dabc224872f7ff540" name="a44ef6fef4b85937dabc224872f7ff540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ef6fef4b85937dabc224872f7ff540">&#9670;&#160;</a></span>isPowerOf2_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isPowerOf2_32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>Value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the argument is a power of two &gt; 0. </p>
<p>Ex. isPowerOf2_32(0x00100000U) == true (32 bit edition.) </p>

</div>
</div>
<a id="ab337d9f021792437e222ab8de869770c" name="ab337d9f021792437e222ab8de869770c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab337d9f021792437e222ab8de869770c">&#9670;&#160;</a></span>isPowerOf2_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isPowerOf2_64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the argument is a power of two &gt; 0 (64 bit edition.) </p>

</div>
</div>
<a id="a91c8224f526316dbd1d8e8c3e53362db" name="a91c8224f526316dbd1d8e8c3e53362db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c8224f526316dbd1d8e8c3e53362db">&#9670;&#160;</a></span>isPrint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isPrint </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>C</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether character <code>C</code> is printable. </p>
<p>Locale-independent version of the C standard library isprint whose results may differ on different platforms. </p>

</div>
</div>
<a id="a3b38a6d85f09021ac8f5a253764011fb" name="a3b38a6d85f09021ac8f5a253764011fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b38a6d85f09021ac8f5a253764011fb">&#9670;&#160;</a></span>isShiftedInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, unsigned S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isShiftedInt </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a signed integer is an N bit number shifted left by S. </p>

</div>
</div>
<a id="a3ca9c306cc27e6eb5d669b6d41e6dba0" name="a3ca9c306cc27e6eb5d669b6d41e6dba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca9c306cc27e6eb5d669b6d41e6dba0">&#9670;&#160;</a></span>isShiftedMask_32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isShiftedMask_32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>Value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the argument contains a non-empty sequence of ones with the remainder zero (32 bit version.) Ex. </p>
<p>isShiftedMask_32(0x0000FF00U) == true. </p>

</div>
</div>
<a id="adb5a1ddcd97fd7f07a98a6bc0eb7c204" name="adb5a1ddcd97fd7f07a98a6bc0eb7c204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb5a1ddcd97fd7f07a98a6bc0eb7c204">&#9670;&#160;</a></span>isShiftedMask_32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isShiftedMask_32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>Value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;</td>          <td class="paramname"><span class="paramname"><em>MaskIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;</td>          <td class="paramname"><span class="paramname"><em>MaskLen</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the argument contains a non-empty sequence of ones with the remainder zero (32 bit version.) Ex. </p>
<p>isShiftedMask_32(0x0000FF00U) == true. If true, <code>MaskIdx</code> will specify the index of the lowest set bit and <code>MaskLen</code> is updated to specify the length of the mask, else neither are updated. </p>

</div>
</div>
<a id="ae76f4df15ef384517038996decd80631" name="ae76f4df15ef384517038996decd80631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76f4df15ef384517038996decd80631">&#9670;&#160;</a></span>isShiftedMask_64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isShiftedMask_64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the argument contains a non-empty sequence of ones with the remainder zero (64 bit version.) </p>

</div>
</div>
<a id="a24ce1e370353bc9753bead0ab77727f0" name="a24ce1e370353bc9753bead0ab77727f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ce1e370353bc9753bead0ab77727f0">&#9670;&#160;</a></span>isShiftedMask_64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isShiftedMask_64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;</td>          <td class="paramname"><span class="paramname"><em>MaskIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;</td>          <td class="paramname"><span class="paramname"><em>MaskLen</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the argument contains a non-empty sequence of ones with the remainder zero (64 bit version.) If true, <code>MaskIdx</code> will specify the index of the lowest set bit and <code>MaskLen</code> is updated to specify the length of the mask, else neither are updated. </p>

</div>
</div>
<a id="ae24c771b8df1d9311b05e5aa01ec09b3" name="ae24c771b8df1d9311b05e5aa01ec09b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24c771b8df1d9311b05e5aa01ec09b3">&#9670;&#160;</a></span>isShiftedUInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N, unsigned S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isShiftedUInt </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a unsigned integer is an N bit number shifted left by S. </p>

</div>
</div>
<a id="a0db3174e602eaacc944f1a7fb8fecdc0" name="a0db3174e602eaacc944f1a7fb8fecdc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db3174e602eaacc944f1a7fb8fecdc0">&#9670;&#160;</a></span>isUInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isUInt </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an unsigned integer fits into the given bit width. </p>

</div>
</div>
<a id="adc2ea2c155eeb9a3662912e8c2ff880e" name="adc2ea2c155eeb9a3662912e8c2ff880e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2ea2c155eeb9a3662912e8c2ff880e">&#9670;&#160;</a></span>isUIntN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::isUIntN </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an unsigned integer fits into the given (dynamic) bit width. </p>

</div>
</div>
<a id="a1bcb05e6bcaec6ab65a71d55d6586366" name="a1bcb05e6bcaec6ab65a71d55d6586366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bcb05e6bcaec6ab65a71d55d6586366">&#9670;&#160;</a></span>iterator_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::iterator_range </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  iterator_range&lt; <a class="el" href="namespacewpi_1_1detail.html#a5097c6ebef74fe403b5012c6d7e7f61b">detail::IterOfRange</a>&lt; Container &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a905c54ca4b7fdb1633b425ad9ca5dc48" name="a905c54ca4b7fdb1633b425ad9ca5dc48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905c54ca4b7fdb1633b425ad9ca5dc48">&#9670;&#160;</a></span>Lerp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T wpi::Lerp </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>startValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>endValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linearly interpolates between two values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startValue</td><td>The start value. </td></tr>
    <tr><td class="paramname">endValue</td><td>The end value. </td></tr>
    <tr><td class="paramname">t</td><td>The fraction for interpolation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated value. </dd></dl>

</div>
</div>
<a id="a30cde0598116042ad77cd369e21b95d3" name="a30cde0598116042ad77cd369e21b95d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30cde0598116042ad77cd369e21b95d3">&#9670;&#160;</a></span>Lo_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t wpi::Lo_32 </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the low 32 bits of a 64 bit value. </p>

</div>
</div>
<a id="a12fc40611c1ed874ebee9877f3866da8" name="a12fc40611c1ed874ebee9877f3866da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12fc40611c1ed874ebee9877f3866da8">&#9670;&#160;</a></span>Log2_32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned wpi::Log2_32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>Value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the floor log base 2 of the specified value, -1 if the value is zero. </p>
<p>(32 bit edition.) Ex. Log2_32(32) == 5, Log2_32(1) == 0, Log2_32(0) == -1, Log2_32(6) == 2 </p>

</div>
</div>
<a id="a1be06425de1e3346544e3600fda4f352" name="a1be06425de1e3346544e3600fda4f352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be06425de1e3346544e3600fda4f352">&#9670;&#160;</a></span>Log2_32_Ceil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned wpi::Log2_32_Ceil </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>Value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the ceil log base 2 of the specified value, 32 if the value is zero. </p>
<p>(32 bit edition). Ex. Log2_32_Ceil(32) == 5, Log2_32_Ceil(1) == 0, Log2_32_Ceil(6) == 3 </p>

</div>
</div>
<a id="ab109b30376a3d157344b924e82ccd5ef" name="ab109b30376a3d157344b924e82ccd5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab109b30376a3d157344b924e82ccd5ef">&#9670;&#160;</a></span>Log2_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned wpi::Log2_64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the floor log base 2 of the specified value, -1 if the value is zero. </p>
<p>(64 bit edition.) </p>

</div>
</div>
<a id="ae6b43a321203f7b23732402ef5dc9709" name="ae6b43a321203f7b23732402ef5dc9709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b43a321203f7b23732402ef5dc9709">&#9670;&#160;</a></span>Log2_64_Ceil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned wpi::Log2_64_Ceil </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the ceil log base 2 of the specified value, 64 if the value is zero. </p>
<p>(64 bit edition.) </p>

</div>
</div>
<a id="a1b7c271a14f5c78641600f41d7c32299" name="a1b7c271a14f5c78641600f41d7c32299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7c271a14f5c78641600f41d7c32299">&#9670;&#160;</a></span>ltrim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view wpi::ltrim </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>str</code> with consecutive <code>ch</code> characters starting from the the left removed. </p>

</div>
</div>
<a id="a2b05ebace5b75bf9c0d3b9513f2c2d11" name="a2b05ebace5b75bf9c0d3b9513f2c2d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b05ebace5b75bf9c0d3b9513f2c2d11">&#9670;&#160;</a></span>ltrim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view wpi::ltrim </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>chars</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&#160;\t\n\v\f\r&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>str</code> with consecutive characters in <code>chars</code> starting from the left removed. </p>

</div>
</div>
<a id="acc6fd03a9b591a2f187f0a44e2b4a356" name="acc6fd03a9b591a2f187f0a44e2b4a356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6fd03a9b591a2f187f0a44e2b4a356">&#9670;&#160;</a></span>Make_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::Make_64 </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>High</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>Low</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a 64-bit integer from a high / low pair of 32-bit integers. </p>

</div>
</div>
<a id="a6bb20671f09fd21f4f52662c86fd6521" name="a6bb20671f09fd21f4f52662c86fd6521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb20671f09fd21f4f52662c86fd6521">&#9670;&#160;</a></span>make_error_code()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code wpi::make_error_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0cc73ce1be7e2680fb97374e03368001">errc</a></td>          <td class="paramname"><span class="paramname"><em>E</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9630e9cd2902c4dbc7f817a6a84bb9da" name="a9630e9cd2902c4dbc7f817a6a84bb9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9630e9cd2902c4dbc7f817a6a84bb9da">&#9670;&#160;</a></span>make_pointee_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT , typename WrappedIteratorT  = decltype(std::begin(std::declval&lt;RangeT&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="structwpi_1_1pointee__iterator.html">pointee_iterator</a>&lt; WrappedIteratorT &gt; &gt; wpi::make_pointee_range </td>
          <td>(</td>
          <td class="paramtype">RangeT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>Range</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa300eeb1def26aef1ca3af133fb26971" name="aa300eeb1def26aef1ca3af133fb26971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa300eeb1def26aef1ca3af133fb26971">&#9670;&#160;</a></span>make_pointer_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT , typename WrappedIteratorT  = decltype(std::begin(std::declval&lt;RangeT&gt;()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classwpi_1_1pointer__iterator.html">pointer_iterator</a>&lt; WrappedIteratorT &gt; &gt; wpi::make_pointer_range </td>
          <td>(</td>
          <td class="paramtype">RangeT &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>Range</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1b2b7a19d614a944822ce6f577be33a" name="ad1b2b7a19d614a944822ce6f577be33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b2b7a19d614a944822ce6f577be33a">&#9670;&#160;</a></span>make_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1iterator__range.html">iterator_range</a>&lt; T &gt; wpi::make_range </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; T, T &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aacc327c9a551f61642d9a6ef107c4593" name="aacc327c9a551f61642d9a6ef107c4593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc327c9a551f61642d9a6ef107c4593">&#9670;&#160;</a></span>make_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1iterator__range.html">iterator_range</a>&lt; T &gt; wpi::make_range </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for iterating over sub-ranges. </p>
<p>This provides a bit of syntactic sugar to make using sub-ranges in for loops a bit easier. Analogous to std::make_pair(). </p>

</div>
</div>
<a id="a21a0d64a50babc1c46b2ede08a2cf13d" name="a21a0d64a50babc1c46b2ede08a2cf13d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a0d64a50babc1c46b2ede08a2cf13d">&#9670;&#160;</a></span>make_ready_future() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1future.html">future</a>&lt; void &gt; wpi::make_ready_future </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a valid future with the value set. </p>

</div>
</div>
<a id="aed245bfb118e5dfe475bf2044a4985d8" name="aed245bfb118e5dfe475bf2044a4985d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed245bfb118e5dfe475bf2044a4985d8">&#9670;&#160;</a></span>make_ready_future() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1future.html">future</a>&lt; T &gt; wpi::make_ready_future </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a valid future with the value set. </p>

</div>
</div>
<a id="aba5268f68b492ea1c161566db733dfbb" name="aba5268f68b492ea1c161566db733dfbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5268f68b492ea1c161566db733dfbb">&#9670;&#160;</a></span>make_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_w_p_i___string.html">WPI_String</a> wpi::make_string </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>view</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a string_view to a <a class="el" href="struct_w_p_i___string.html" title="A const UTF8 string.">WPI_String</a>. </p>

</div>
</div>
<a id="a39dedecbcd080adc1e8208e016b5974b" name="a39dedecbcd080adc1e8208e016b5974b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39dedecbcd080adc1e8208e016b5974b">&#9670;&#160;</a></span>make_unexpected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; typename std::decay&lt; E &gt;::type &gt; wpi::make_unexpected </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a22f627b8aa91ec48125d72a895d54924" name="a22f627b8aa91ec48125d72a895d54924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f627b8aa91ec48125d72a895d54924">&#9670;&#160;</a></span>MakeStructArraySchema()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::MakeStructArraySchema </td>
          <td>(</td>
          <td class="paramtype">const I &amp;...</td>          <td class="paramname"><span class="paramname"><em>info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08be78834f39daf48110ff9e98e6e840" name="a08be78834f39daf48110ff9e98e6e840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08be78834f39daf48110ff9e98e6e840">&#9670;&#160;</a></span>MakeStructArrayTypeName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::MakeStructArrayTypeName </td>
          <td>(</td>
          <td class="paramtype">const I &amp;...</td>          <td class="paramname"><span class="paramname"><em>info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ceec6c891e38c5857a21892f7cd3d94" name="a7ceec6c891e38c5857a21892f7cd3d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ceec6c891e38c5857a21892f7cd3d94">&#9670;&#160;</a></span>MakeStructArrayTypeString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::MakeStructArrayTypeString </td>
          <td>(</td>
          <td class="paramtype">const I &amp;...</td>          <td class="paramname"><span class="paramname"><em>info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8af9a7e30ba77940f2ef47d513252866" name="a8af9a7e30ba77940f2ef47d513252866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af9a7e30ba77940f2ef47d513252866">&#9670;&#160;</a></span>mapWindowsError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code wpi::mapWindowsError </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>EV</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ca1a8d567765c25e5c8aaf6f2a3a51a" name="a0ca1a8d567765c25e5c8aaf6f2a3a51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca1a8d567765c25e5c8aaf6f2a3a51a">&#9670;&#160;</a></span>maskLeadingOnes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T wpi::maskLeadingOnes </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a bitmask with the N left-most bits set to 1, and all other bits set to 0. </p>
<p>Only unsigned types are allowed. </p>

</div>
</div>
<a id="aed916b5acc65b9b7f1ff971ffc096030" name="aed916b5acc65b9b7f1ff971ffc096030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed916b5acc65b9b7f1ff971ffc096030">&#9670;&#160;</a></span>maskLeadingZeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T wpi::maskLeadingZeros </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a bitmask with the N left-most bits set to 0, and all other bits set to 1. </p>
<p>Only unsigned types are allowed. </p>

</div>
</div>
<a id="a337beda02d2dd53b5d020a593c867e6d" name="a337beda02d2dd53b5d020a593c867e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337beda02d2dd53b5d020a593c867e6d">&#9670;&#160;</a></span>maskTrailingOnes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T wpi::maskTrailingOnes </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a bitmask with the N right-most bits set to 1, and all other bits set to 0. </p>
<p>Only unsigned types are allowed. </p>

</div>
</div>
<a id="ad6e2df17acd6bc9d36f64037926be88f" name="ad6e2df17acd6bc9d36f64037926be88f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e2df17acd6bc9d36f64037926be88f">&#9670;&#160;</a></span>maskTrailingZeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T wpi::maskTrailingZeros </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a bitmask with the N right-most bits set to 0, and all other bits set to 1. </p>
<p>Only unsigned types are allowed. </p>

</div>
</div>
<a id="a01982bb8b119d94de4200ed371ad5397" name="a01982bb8b119d94de4200ed371ad5397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01982bb8b119d94de4200ed371ad5397">&#9670;&#160;</a></span>maxIntN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t wpi::maxIntN </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum value for a N-bit signed integer. </p>

</div>
</div>
<a id="adb968c37d6007862cab0e2e2156d9df9" name="adb968c37d6007862cab0e2e2156d9df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb968c37d6007862cab0e2e2156d9df9">&#9670;&#160;</a></span>maxUIntN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::maxUIntN </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum value for a N-bit unsigned integer. </p>

</div>
</div>
<a id="a863f7dccbe48e628d0674d0957238fe6" name="a863f7dccbe48e628d0674d0957238fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863f7dccbe48e628d0674d0957238fe6">&#9670;&#160;</a></span>MimeTypeFromPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view wpi::MimeTypeFromPath </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf2c49962110e8c4bf54b763aac045c8" name="aaf2c49962110e8c4bf54b763aac045c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2c49962110e8c4bf54b763aac045c8">&#9670;&#160;</a></span>MinAlign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::MinAlign </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>B</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A and B are either alignments or offsets. </p>
<p>Return the minimum alignment that may be assumed after adding the two together. </p>

</div>
</div>
<a id="abfb563f4c667933f0ebf44c6ca54e7ba" name="abfb563f4c667933f0ebf44c6ca54e7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb563f4c667933f0ebf44c6ca54e7ba">&#9670;&#160;</a></span>minIntN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t wpi::minIntN </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the minimum value for a N-bit signed integer. </p>

</div>
</div>
<a id="a54f0b046a937c5df08ee7e355cd99919" name="a54f0b046a937c5df08ee7e355cd99919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f0b046a937c5df08ee7e355cd99919">&#9670;&#160;</a></span>MulOverflow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_signed_v&lt; T &gt;, T &gt; wpi::MulOverflow </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>Result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two signed integers, computing the two's complement truncated result, returning true if an overflow ocurred. </p>

</div>
</div>
<a id="abde254908107ab292ce34e1eaf9f0287" name="abde254908107ab292ce34e1eaf9f0287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde254908107ab292ce34e1eaf9f0287">&#9670;&#160;</a></span>NextPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::NextPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next power of two (in 64-bits) that is strictly greater than A. </p>
<p>Returns zero on overflow. </p>

</div>
</div>
<a id="af041f6643f3d0d18e0f8430bf0617dda" name="af041f6643f3d0d18e0f8430bf0617dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af041f6643f3d0d18e0f8430bf0617dda">&#9670;&#160;</a></span>Now()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::Now </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a value representing the current time in microseconds. </p>
<p>This is a monotonic clock with an undefined epoch. </p><dl class="section return"><dt>Returns</dt><dd>Time in microseconds. </dd></dl>

</div>
</div>
<a id="af86c906a89fdf1dbeb5491c1b2a3dc12" name="af86c906a89fdf1dbeb5491c1b2a3dc12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86c906a89fdf1dbeb5491c1b2a3dc12">&#9670;&#160;</a></span>NowDefault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::NowDefault </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default implementation used for <a class="el" href="#af041f6643f3d0d18e0f8430bf0617dda" title="Return a value representing the current time in microseconds.">Now()</a>. </p>
<p>In general this is the time returned by the operating system. </p><dl class="section return"><dt>Returns</dt><dd>Time in microseconds. </dd></dl>

</div>
</div>
<a id="a40031774febe762423c2bf6bb4e0094b" name="a40031774febe762423c2bf6bb4e0094b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40031774febe762423c2bf6bb4e0094b">&#9670;&#160;</a></span>nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp; wpi::nulls </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns a reference to a <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> which simply discards output. </p>

</div>
</div>
<a id="a0a60cf592ceb77188e17328f0c69791e" name="a0a60cf592ceb77188e17328f0c69791e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a60cf592ceb77188e17328f0c69791e">&#9670;&#160;</a></span>NumToCtString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;intmax_t N, int Base = 10, typename Char  = char, typename Traits  = std::char_traits&lt;Char&gt;&gt; <br />
requires (Base &gt;= 2 &amp;&amp; Base &lt;= 36)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::NumToCtString </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts any integral to a <a class="el" href="structwpi_1_1ct__string.html" title="Fixed length string (array of character) for compile time use.">ct_string</a> at compile-time. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>number to convert </td></tr>
    <tr><td class="paramname">Base</td><td>desired base, can be from 2 to 36 </td></tr>
    <tr><td class="paramname">Char</td><td>character type </td></tr>
    <tr><td class="paramname">Traits</td><td>character traits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2bd96b09718980689f6278dd7ea224d" name="ac2bd96b09718980689f6278dd7ea224d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2bd96b09718980689f6278dd7ea224d">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedT , typename KeyT , typename ValueT , typename KeyInfoT , typename BucketT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_dense_map_base.html">DenseMapBase</a>&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LHS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_dense_map_base.html">DenseMapBase</a>&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>RHS</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inequality comparison for <a class="el" href="classwpi_1_1_dense_map.html">DenseMap</a>. </p>
<p>Equivalent to !(LHS == RHS). See operator== for performance notes. </p>

</div>
</div>
<a id="a24823b06d3080f4378d7eb86519c4141" name="a24823b06d3080f4378d7eb86519c4141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24823b06d3080f4378d7eb86519c4141">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class E , class U , class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; U, F &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a70436e5fc0d405e66d861bd82a41b8aa" name="a70436e5fc0d405e66d861bd82a41b8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70436e5fc0d405e66d861bd82a41b8aa">&#9670;&#160;</a></span>operator!=() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class E , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad25324caffea3cc810a10ad48f937036" name="ad25324caffea3cc810a10ad48f937036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25324caffea3cc810a10ad48f937036">&#9670;&#160;</a></span>operator!=() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4888ad0dc554c31bf61fde6aee5d82ee" name="a4888ad0dc554c31bf61fde6aee5d82ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4888ad0dc554c31bf61fde6aee5d82ee">&#9670;&#160;</a></span>operator!=() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E , class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; void, E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; void, F &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3493bed4041adb43e57361d40517a4d4" name="a3493bed4041adb43e57361d40517a4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3493bed4041adb43e57361d40517a4d4">&#9670;&#160;</a></span>operator!=() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PtrType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_small_ptr_set_impl.html">SmallPtrSetImpl</a>&lt; PtrType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LHS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_small_ptr_set_impl.html">SmallPtrSetImpl</a>&lt; PtrType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>RHS</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inequality comparison for <a class="el" href="classwpi_1_1_small_ptr_set.html" title="SmallPtrSet - This class implements a set which is optimized for holding SmallSize or less elements.">SmallPtrSet</a>. </p>
<p>Equivalent to !(LHS == RHS). </p>

</div>
</div>
<a id="ad032764915283409382ba49638651b69" name="ad032764915283409382ba49638651b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad032764915283409382ba49638651b69">&#9670;&#160;</a></span>operator!=() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned LN, unsigned RN, typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_small_set.html">SmallSet</a>&lt; T, LN, C &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LHS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_small_set.html">SmallSet</a>&lt; T, RN, C &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>RHS</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inequality comparison for <a class="el" href="classwpi_1_1_small_set.html" title="SmallSet - This maintains a set of unique values, optimizing for the case when the set is small (less...">SmallSet</a>. </p>
<p>Equivalent to !(LHS == RHS). See operator== for performance notes. </p>

</div>
</div>
<a id="ae5de24f32a5e0e34e26400e1d2d019ab" name="ae5de24f32a5e0e34e26400e1d2d019ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5de24f32a5e0e34e26400e1d2d019ab">&#9670;&#160;</a></span>operator!=() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abdf2ccf060494e397a073e1d790f0965" name="abdf2ccf060494e397a073e1d790f0965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf2ccf060494e397a073e1d790f0965">&#9670;&#160;</a></span>operator!=() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class E , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator!= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afe3967898dc4d02842e7124a25ff5c06" name="afe3967898dc4d02842e7124a25ff5c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3967898dc4d02842e7124a25ff5c06">&#9670;&#160;</a></span>operator!=() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7a8f0c09fa990ccc76d3be676c434ec" name="ac7a8f0c09fa990ccc76d3be676c434ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a8f0c09fa990ccc76d3be676c434ec">&#9670;&#160;</a></span>operator!=() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a088be308371a5cee44b52aedf5a619e7" name="a088be308371a5cee44b52aedf5a619e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088be308371a5cee44b52aedf5a619e7">&#9670;&#160;</a></span>operator!=() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... PTs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5219583a8d061de60505c1ca0327f1c6" name="a5219583a8d061de60505c1ca0327f1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5219583a8d061de60505c1ca0327f1c6">&#9670;&#160;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2b741829b477ec608a2534e5e5a22f67">default_arguments</a> wpi::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2b741829b477ec608a2534e5e5a22f67">default_arguments</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a2b741829b477ec608a2534e5e5a22f67">default_arguments</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b884901ae1c2a760ac27c1ced1f2ca0" name="a9b884901ae1c2a760ac27c1ced1f2ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b884901ae1c2a760ac27c1ced1f2ca0">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Char , typename Traits , size_t N1, size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwpi_1_1ct__string.html">ct_string</a>&lt; Char, Traits, N1 &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>s1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwpi_1_1ct__string.html">ct_string</a>&lt; Char, Traits, N2 &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>s2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0497f3ae3790ae4464ca31a28110983f" name="a0497f3ae3790ae4464ca31a28110983f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0497f3ae3790ae4464ca31a28110983f">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67f4db75c03a9da9d2159a1ea1263f83" name="a67f4db75c03a9da9d2159a1ea1263f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f4db75c03a9da9d2159a1ea1263f83">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e03174a92e237c3b5544c57d3dee498" name="a4e03174a92e237c3b5544c57d3dee498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e03174a92e237c3b5544c57d3dee498">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... PTs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada0d8a622e089ad47214934b0c723dee" name="ada0d8a622e089ad47214934b0c723dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0d8a622e089ad47214934b0c723dee">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OStream , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!std::is_reference_v&lt; OStream &gt; &amp;&amp; std::is_base_of_v&lt; <a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a>, OStream &gt;, OStream &amp;&amp; &gt; wpi::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">OStream &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>OS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>Value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the appropriate insertion operator, given an rvalue reference to a <a class="el" href="classwpi_1_1raw__ostream.html" title="This class implements an extremely fast bulk output stream that can only output to a stream.">raw_ostream</a> object and return a stream of the same type as the argument. </p>

</div>
</div>
<a id="ac2c6f38176a757997f4548366d10941c" name="ac2c6f38176a757997f4548366d10941c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c6f38176a757997f4548366d10941c">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp; wpi::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>OS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi_1_1sys.html#abb2f430c92b93a1558fed9d588b7c199">sys::TimePoint</a>&lt;&gt;</td>          <td class="paramname"><span class="paramname"><em>TP</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d4d33e6dd228017533698524332016c" name="a7d4d33e6dd228017533698524332016c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4d33e6dd228017533698524332016c">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp; wpi::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>OS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewpi_1_1sys.html#a79528fc04bbfce5e003543aac3a9a5a1">sys::UtcTime</a>&lt;&gt;</td>          <td class="paramname"><span class="paramname"><em>TP</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe9955629bd414f4388de1629bbe618d" name="afe9955629bd414f4388de1629bbe618d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9955629bd414f4388de1629bbe618d">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e46980861d4cee757e1205bba80f44a" name="a8e46980861d4cee757e1205bba80f44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e46980861d4cee757e1205bba80f44a">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9258f2870864143e01a09bb5cf806ba6" name="a9258f2870864143e01a09bb5cf806ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9258f2870864143e01a09bb5cf806ba6">&#9670;&#160;</a></span>operator==() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedT , typename KeyT , typename ValueT , typename KeyInfoT , typename BucketT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_dense_map_base.html">DenseMapBase</a>&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LHS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_dense_map_base.html">DenseMapBase</a>&lt; DerivedT, KeyT, ValueT, KeyInfoT, BucketT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>RHS</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality comparison for <a class="el" href="classwpi_1_1_dense_map.html">DenseMap</a>. </p>
<p>Iterates over elements of LHS confirming that each (key, value) pair in LHS is also in RHS, and that no additional pairs are in RHS. Equivalent to N calls to RHS.find and N value comparisons. Amortized complexity is linear, worst case is O(N^2) (if every hash collides). </p>

</div>
</div>
<a id="aa18d4042818206dca90b1775d44c0aec" name="aa18d4042818206dca90b1775d44c0aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18d4042818206dca90b1775d44c0aec">&#9670;&#160;</a></span>operator==() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class E , class U , class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; U, F &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5bb76c48fdcecdd9cebe482488fd31f" name="ac5bb76c48fdcecdd9cebe482488fd31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5bb76c48fdcecdd9cebe482488fd31f">&#9670;&#160;</a></span>operator==() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class E , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acdc5fbe0d0b8dacb813befbc51ab62be" name="acdc5fbe0d0b8dacb813befbc51ab62be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc5fbe0d0b8dacb813befbc51ab62be">&#9670;&#160;</a></span>operator==() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abfc620acab606fb0d6e751c7709d4795" name="abfc620acab606fb0d6e751c7709d4795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc620acab606fb0d6e751c7709d4795">&#9670;&#160;</a></span>operator==() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E , class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; void, E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; void, F &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd1ac8844d24e58fc06de7d1270f0c7d" name="afd1ac8844d24e58fc06de7d1270f0c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd1ac8844d24e58fc06de7d1270f0c7d">&#9670;&#160;</a></span>operator==() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PtrType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_small_ptr_set_impl.html">SmallPtrSetImpl</a>&lt; PtrType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LHS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_small_ptr_set_impl.html">SmallPtrSetImpl</a>&lt; PtrType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>RHS</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality comparison for <a class="el" href="classwpi_1_1_small_ptr_set.html" title="SmallPtrSet - This class implements a set which is optimized for holding SmallSize or less elements.">SmallPtrSet</a>. </p>
<p>Iterates over elements of LHS confirming that each value from LHS is also in RHS, and that no additional values are in RHS. </p>

</div>
</div>
<a id="ac64cc2a8bb25b3e692e7aacd722fdd29" name="ac64cc2a8bb25b3e692e7aacd722fdd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64cc2a8bb25b3e692e7aacd722fdd29">&#9670;&#160;</a></span>operator==() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned LN, unsigned RN, typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_small_set.html">SmallSet</a>&lt; T, LN, C &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LHS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_small_set.html">SmallSet</a>&lt; T, RN, C &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>RHS</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality comparison for <a class="el" href="classwpi_1_1_small_set.html" title="SmallSet - This maintains a set of unique values, optimizing for the case when the set is small (less...">SmallSet</a>. </p>
<p>Iterates over elements of LHS confirming that each element is also a member of RHS, and that RHS contains no additional values. Equivalent to N calls to RHS.count. For small-set mode amortized complexity is O(N^2) For large-set mode amortized complexity is linear, worst case is O(N^2) (if every hash collides). </p>

</div>
</div>
<a id="a20d4bc587263ead52e3057e41d1bcad8" name="a20d4bc587263ead52e3057e41d1bcad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d4bc587263ead52e3057e41d1bcad8">&#9670;&#160;</a></span>operator==() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac28e5992a79afeddc6f36986e8f4747c" name="ac28e5992a79afeddc6f36986e8f4747c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28e5992a79afeddc6f36986e8f4747c">&#9670;&#160;</a></span>operator==() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class E , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator== </td>
          <td>(</td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af3f613143cd18d99120248fe6da7e837" name="af3f613143cd18d99120248fe6da7e837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f613143cd18d99120248fe6da7e837">&#9670;&#160;</a></span>operator==() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6f6e4aff6a38bb792fead8152d3f1f9" name="ac6f6e4aff6a38bb792fead8152d3f1f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f6e4aff6a38bb792fead8152d3f1f9">&#9670;&#160;</a></span>operator==() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3287d2b8e67eaf00c1f275eb1d2b1fd8" name="a3287d2b8e67eaf00c1f275eb1d2b1fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3287d2b8e67eaf00c1f275eb1d2b1fd8">&#9670;&#160;</a></span>operator==() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... PTs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_pointer_union.html">PointerUnion</a>&lt; PTs... &gt;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af9f5d37ffdbdece9dc4a138912d2384d" name="af9f5d37ffdbdece9dc4a138912d2384d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f5d37ffdbdece9dc4a138912d2384d">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a21f869097cbd300cfeed6e63d2318b04" name="a21f869097cbd300cfeed6e63d2318b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f869097cbd300cfeed6e63d2318b04">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f5ef98f7e590a36648bdff48b4dfc57" name="a0f5ef98f7e590a36648bdff48b4dfc57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5ef98f7e590a36648bdff48b4dfc57">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; ValueTy &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f7557a7ad21a5e7fa2f1be542b4e1d3" name="a9f7557a7ad21a5e7fa2f1be542b4e1d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7557a7ad21a5e7fa2f1be542b4e1d3">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1unexpected.html">unexpected</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4cc9cf60e707bfcf728eb04c4e4b8d2e" name="a4cc9cf60e707bfcf728eb04c4e4b8d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc9cf60e707bfcf728eb04c4e4b8d2e">&#9670;&#160;</a></span>outs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1raw__fd__ostream.html">raw_fd_ostream</a> &amp; wpi::outs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns a reference to a <a class="el" href="classwpi_1_1raw__fd__ostream.html" title="A raw_ostream that writes to a file descriptor.">raw_fd_ostream</a> for standard output. </p>
<p>Use it like: <a class="el" href="#a4cc9cf60e707bfcf728eb04c4e4b8d2e" title="This returns a reference to a raw_fd_ostream for standard output.">outs()</a> &lt;&lt; "foo" &lt;&lt; "bar"; </p>

</div>
</div>
<a id="a97a29dc82fea465b35449b563c1ddf99" name="a97a29dc82fea465b35449b563c1ddf99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a29dc82fea465b35449b563c1ddf99">&#9670;&#160;</a></span>PackProtobuf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ProtobufSerializable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::PackProtobuf </td>
          <td>(</td>
          <td class="paramtype">google::protobuf::Message *</td>          <td class="paramname"><span class="paramname"><em>msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack a serialized protobuf message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>protobuf message (mutable, output) </td></tr>
    <tr><td class="paramname">value</td><td>object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52ba7696776a7e8d599809fa95f31324" name="a52ba7696776a7e8d599809fa95f31324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ba7696776a7e8d599809fa95f31324">&#9670;&#160;</a></span>PackProtobufArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void wpi::PackProtobufArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1protobuf_1_1_repeated_field.html">google::protobuf::RepeatedField</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; T, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack a serialized protobuf array message. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>object type </td></tr>
    <tr><td class="paramname">N</td><td>number of objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>protobuf message (mutable, output) </td></tr>
    <tr><td class="paramname">arr</td><td>array of objects </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6205d9674eca9725b95390234b546578" name="a6205d9674eca9725b95390234b546578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6205d9674eca9725b95390234b546578">&#9670;&#160;</a></span>PackProtobufArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::derived_from&lt; google::protobuf::Message &gt; Proto, ProtobufSerializable T, size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void wpi::PackProtobufArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgoogle_1_1protobuf_1_1_repeated_ptr_field.html">google::protobuf::RepeatedPtrField</a>&lt; Proto &gt; *</td>          <td class="paramname"><span class="paramname"><em>msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; T, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack a serialized protobuf array message. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Proto</td><td>element type of the protobuf array </td></tr>
    <tr><td class="paramname">T</td><td>object type </td></tr>
    <tr><td class="paramname">N</td><td>number of objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>protobuf message (mutable, output) </td></tr>
    <tr><td class="paramname">arr</td><td>array of objects </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec17a5d90a5682c56cedc791280c3f24" name="aec17a5d90a5682c56cedc791280c3f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec17a5d90a5682c56cedc791280c3f24">&#9670;&#160;</a></span>PackStruct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::PackStruct </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; uint8_t &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I &amp;...</td>          <td class="paramname"><span class="paramname"><em>info</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack a serialized struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>struct storage (mutable, output) </td></tr>
    <tr><td class="paramname">value</td><td>object </td></tr>
    <tr><td class="paramname">info</td><td>optional struct type info </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f6a6f967162388cd2b16ff89ab37921" name="a9f6a6f967162388cd2b16ff89ab37921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6a6f967162388cd2b16ff89ab37921">&#9670;&#160;</a></span>PackStruct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Offset, typename T , typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::PackStruct </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; uint8_t &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I &amp;...</td>          <td class="paramname"><span class="paramname"><em>info</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack a serialized struct starting at a given offset within the data. </p>
<p>This is primarily useful in pack implementations to pack nested structs.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Offset</td><td>starting offset </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>struct storage (mutable, output) </td></tr>
    <tr><td class="paramname">value</td><td>object </td></tr>
    <tr><td class="paramname">info</td><td>optional struct type info </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9475dc5093a863e98e3d87e80421719f" name="a9475dc5093a863e98e3d87e80421719f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9475dc5093a863e98e3d87e80421719f">&#9670;&#160;</a></span>PackStructArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Offset, size_t N, StructSerializable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::PackStructArray </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; uint8_t &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; T, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack a serialized struct array starting at a given offset within the data. </p>
<p>This is primarily useful in pack implementations to pack nested struct arrays.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Offset</td><td>starting offset </td></tr>
    <tr><td class="paramname">N</td><td>number of objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>struct storage (mutable, output) </td></tr>
    <tr><td class="paramname">arr</td><td>array of object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3e2a33d363a34850deae1866c324eb6" name="ae3e2a33d363a34850deae1866c324eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e2a33d363a34850deae1866c324eb6">&#9670;&#160;</a></span>parse_float()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; T &gt; wpi::parse_float </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses the string <code>str</code> as a floating point value. </p>
<p>If the string is invalid or if only a subset of the string is valid, this returns nullopt to signify the error. The string is considered erroneous if empty or if it overflows T. </p>

</div>
</div>
<a id="a2d19c9cf09501aa0ab358fa74281e96d" name="a2d19c9cf09501aa0ab358fa74281e96d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d19c9cf09501aa0ab358fa74281e96d">&#9670;&#160;</a></span>parse_float&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; double &gt; <a class="el" href="#ae3e2a33d363a34850deae1866c324eb6">wpi::parse_float</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aea3739b1e7e77b69e3ce650907ca69ed" name="aea3739b1e7e77b69e3ce650907ca69ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3739b1e7e77b69e3ce650907ca69ed">&#9670;&#160;</a></span>parse_float&lt; float &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; float &gt; <a class="el" href="#ae3e2a33d363a34850deae1866c324eb6">wpi::parse_float</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a77ec79c288a28100e273ac8c3e41b85b" name="a77ec79c288a28100e273ac8c3e41b85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ec79c288a28100e273ac8c3e41b85b">&#9670;&#160;</a></span>parse_float&lt; long double &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; long double &gt; <a class="el" href="#ae3e2a33d363a34850deae1866c324eb6">wpi::parse_float</a>&lt; long double &gt; </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ed163433a5d70554975df8e7ef7f4df" name="a3ed163433a5d70554975df8e7ef7f4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed163433a5d70554975df8e7ef7f4df">&#9670;&#160;</a></span>parse_integer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::enable_if_t&lt; std::numeric_limits&lt; T &gt;::is_signed, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; T &gt; wpi::parse_integer </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>radix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses the string <code>str</code> as an integer of the specified radix. </p>
<p>If <code>radix</code> is specified as zero, this does radix autosensing using extended C rules: 0 is octal, 0x is hex, 0b is binary.</p>
<p>If the string is invalid or if only a subset of the string is valid, this returns nullopt to signify the error. The string is considered erroneous if empty or if it overflows T. </p>

</div>
</div>
<a id="a12877798c9e05cae590789ebe25883b7" name="a12877798c9e05cae590789ebe25883b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12877798c9e05cae590789ebe25883b7">&#9670;&#160;</a></span>ParseHttpHeaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::ParseHttpHeaders </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1raw__istream.html">raw_istream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; *</td>          <td class="paramname"><span class="paramname"><em>contentType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; *</td>          <td class="paramname"><span class="paramname"><em>contentLength</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a22d2692504baab859a5288de06e96df3" name="a22d2692504baab859a5288de06e96df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d2692504baab859a5288de06e96df3">&#9670;&#160;</a></span>PowerOf2Ceil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::PowerOf2Ceil </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the power of two which is greater than or equal to the given value. </p>
<p>Essentially, it is a ceil operation across the domain of powers of two. </p>

</div>
</div>
<a id="ac1505100db54c65ffa211cd4f6e49e4e" name="ac1505100db54c65ffa211cd4f6e49e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1505100db54c65ffa211cd4f6e49e4e">&#9670;&#160;</a></span>print() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::print </td>
          <td>(</td>
          <td class="paramtype">fmt::format_string&lt; T... &gt;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around fmt::print() that squelches write failure exceptions. </p>

</div>
</div>
<a id="a3054f74d1db148eb857efc543e6aba99" name="a3054f74d1db148eb857efc543e6aba99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3054f74d1db148eb857efc543e6aba99">&#9670;&#160;</a></span>print() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::print </td>
          <td>(</td>
          <td class="paramtype">std::FILE *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmt::format_string&lt; T... &gt;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around fmt::print() that squelches write failure exceptions. </p>

</div>
</div>
<a id="a0653a25063e16f63b5f9aec814b0afd3" name="a0653a25063e16f63b5f9aec814b0afd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0653a25063e16f63b5f9aec814b0afd3">&#9670;&#160;</a></span>print() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="wpilibc_2src_2main_2native_2include_2frc_2_errors_8h.html#a82134794782845c50b9a960bb191ba30">S</a> , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void wpi::print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1raw__ostream.html">wpi::raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="wpilibc_2src_2main_2native_2include_2frc_2_errors_8h.html#a82134794782845c50b9a960bb191ba30">S</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>format_str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints formatted data to the stream <em>os</em>. </p>

</div>
</div>
<a id="a6daa0f43b081b200b41744eef996c775" name="a6daa0f43b081b200b41744eef996c775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6daa0f43b081b200b41744eef996c775">&#9670;&#160;</a></span>println() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::println </td>
          <td>(</td>
          <td class="paramtype">fmt::format_string&lt; T... &gt;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around fmt::println() that squelches write failure exceptions. </p>

</div>
</div>
<a id="abffbe8b1dd8d4cbc82a26e9e96bfa1e7" name="abffbe8b1dd8d4cbc82a26e9e96bfa1e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abffbe8b1dd8d4cbc82a26e9e96bfa1e7">&#9670;&#160;</a></span>println() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::println </td>
          <td>(</td>
          <td class="paramtype">std::FILE *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmt::format_string&lt; T... &gt;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around fmt::println() that squelches write failure exceptions. </p>

</div>
</div>
<a id="a486cee9c105ed0e242f6c00183c682f3" name="a486cee9c105ed0e242f6c00183c682f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486cee9c105ed0e242f6c00183c682f3">&#9670;&#160;</a></span>ReadUleb128() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::ReadUleb128 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *</td>          <td class="paramname"><span class="paramname"><em>ret</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read unsigned LEB128 data. </p>
<p>Decode an unsigned LEB128 encoded datum. The algorithm is taken from Appendix C of the DWARF 3 spec. For information on the encodings refer to section "7.6 - Variable Length Data". Return the number of bytes read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The address where the ULEB128 data is stored. </td></tr>
    <tr><td class="paramname">ret</td><td>Address to store the result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade4e972587009901ad40bc390e4bb8db" name="ade4e972587009901ad40bc390e4bb8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4e972587009901ad40bc390e4bb8db">&#9670;&#160;</a></span>ReadUleb128() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::ReadUleb128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1raw__istream.html">raw_istream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *</td>          <td class="paramname"><span class="paramname"><em>ret</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read unsigned LEB128 data from a stream. </p>
<p>Decode an unsigned LEB128 encoded datum. The algorithm is taken from Appendix C of the DWARF 3 spec. For information on the encodings refer to section "7.6 - Variable Length Data". Return false on stream error, true on success.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The input stream where the ULEB128 data is to be read from. </td></tr>
    <tr><td class="paramname">ret</td><td>Address to store the result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6962747bba62185bf15ef5484bee3e2" name="ac6962747bba62185bf15ef5484bee3e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6962747bba62185bf15ef5484bee3e2">&#9670;&#160;</a></span>ReleaseSemaphore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::ReleaseSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_synchronization_8h.html#a35ca8808aba014f82899e1bca7c7372b">WPI_SemaphoreHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>releaseCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>prevCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases N counts of a semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>semaphore handle </td></tr>
    <tr><td class="paramname">releaseCount</td><td>amount to add to semaphore's internal counter; must be positive </td></tr>
    <tr><td class="paramname">prevCount</td><td>if non-null, previous count (output parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on successful release, false on failure (e.g. release count would exceed maximum value, or handle invalid) </dd></dl>

</div>
</div>
<a id="a69094b92cf05fe59b51ae012a03d9474" name="a69094b92cf05fe59b51ae012a03d9474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69094b92cf05fe59b51ae012a03d9474">&#9670;&#160;</a></span>remove_bad_alloc_error_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::remove_bad_alloc_error_handler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restores default bad alloc error handling behavior. </p>

</div>
</div>
<a id="a08d89324acbf36872064573065959d20" name="a08d89324acbf36872064573065959d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d89324acbf36872064573065959d20">&#9670;&#160;</a></span>remove_fatal_error_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::remove_fatal_error_handler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restores default error handling behaviour. </p>

</div>
</div>
<a id="a151ee27ef17ccf8d36ef6208ed60d1c3" name="a151ee27ef17ccf8d36ef6208ed60d1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151ee27ef17ccf8d36ef6208ed60d1c3">&#9670;&#160;</a></span>remove_prefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::string_view &gt; wpi::remove_prefix </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an optional containing <code>str</code> but with <code>prefix</code> removed if the string starts with the prefix. </p>
<p>If the string does not start with the prefix, return an empty optional. </p>

</div>
</div>
<a id="a4aa2430efceab8b21962368d1db93d61" name="a4aa2430efceab8b21962368d1db93d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa2430efceab8b21962368d1db93d61">&#9670;&#160;</a></span>remove_suffix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::string_view &gt; wpi::remove_suffix </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>suffix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an optional containing <code>str</code> but with <code>suffix</code> removed if the string ends with the suffix. </p>
<p>If the string does not end with the suffix, return an empty optional. </p>

</div>
</div>
<a id="a6e3cd886beda7a2289aa18773f3aa103" name="a6e3cd886beda7a2289aa18773f3aa103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3cd886beda7a2289aa18773f3aa103">&#9670;&#160;</a></span>report_bad_alloc_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::report_bad_alloc_error </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>Reason</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>GenCrashDiag</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports a bad alloc error, calling any user defined bad alloc error handler. </p>
<p>In contrast to the generic 'report_fatal_error' functions, this function might not terminate, e.g. the user defined error handler throws an exception, but it won't return.</p>
<p>Note: When throwing an exception in the bad alloc handler, make sure that the following unwind succeeds, e.g. do not trigger additional allocations in the unwind chain.</p>
<p>If no error handler is installed (default), throws a bad_alloc exception if LLVM is compiled with exception support. Otherwise prints the error to standard error and calls abort(). </p>

</div>
</div>
<a id="a6392584571d4e2bec4247503254d83a3" name="a6392584571d4e2bec4247503254d83a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6392584571d4e2bec4247503254d83a3">&#9670;&#160;</a></span>report_fatal_error() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::report_fatal_error </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>reason</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>gen_crash_diag</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports a serious error, calling any installed error handler. </p>
<p>These functions are intended to be used for error conditions which are outside the control of the compiler (I/O errors, invalid user input, etc.)</p>
<p>If no error handler is installed the default is to print the message to standard error, followed by a newline. After the error handler is called this function will call abort(), it does not return. </p>

</div>
</div>
<a id="a2a2f5ea71a00431f1def0f2d7daf7af3" name="a2a2f5ea71a00431f1def0f2d7daf7af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2f5ea71a00431f1def0f2d7daf7af3">&#9670;&#160;</a></span>report_fatal_error() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::report_fatal_error </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>reason</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>gen_crash_diag</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c5d4610f996de2254ee2eca97aa2da6" name="a9c5d4610f996de2254ee2eca97aa2da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5d4610f996de2254ee2eca97aa2da6">&#9670;&#160;</a></span>report_fatal_error() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::report_fatal_error </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>reason</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>gen_crash_diag</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a601a2e82b14588ebbce04bd58f47de35" name="a601a2e82b14588ebbce04bd58f47de35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601a2e82b14588ebbce04bd58f47de35">&#9670;&#160;</a></span>ResetEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::ResetEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_synchronization_8h.html#a4e842b28ce72a1d1dc778397b5f81b87">WPI_EventHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an event to non-signaled state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>event handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a591297d9bc21d366707c09d9ebb9e1b2" name="a591297d9bc21d366707c09d9ebb9e1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591297d9bc21d366707c09d9ebb9e1b2">&#9670;&#160;</a></span>ResetSignalObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::ResetSignalObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a handle to non-signaled state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a538316af0297b9fa6d65a22c874d4a95" name="a538316af0297b9fa6d65a22c874d4a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538316af0297b9fa6d65a22c874d4a95">&#9670;&#160;</a></span>reverseBits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T wpi::reverseBits </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse the bits in <code>Val</code>. </p>

</div>
</div>
<a id="a676758fb3474980129376c4430e5965f" name="a676758fb3474980129376c4430e5965f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676758fb3474980129376c4430e5965f">&#9670;&#160;</a></span>rfind_lower() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view::size_type wpi::rfind_lower </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type</td>          <td class="paramname"><span class="paramname"><em>from</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::string_view::npos</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the last character <code>ch</code> in <code>str</code>, ignoring case. </p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The index of the last occurrence of <code>ch</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="a6670129d8dd67d55733dacac82fb6354" name="a6670129d8dd67d55733dacac82fb6354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6670129d8dd67d55733dacac82fb6354">&#9670;&#160;</a></span>rfind_lower() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view::size_type wpi::rfind_lower </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the last string <code>other</code> in <code>str</code>, ignoring case. </p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The index of the last occurrence of <code>other</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="a88303c617dfdc5eca2edb6fb7b10124b" name="a88303c617dfdc5eca2edb6fb7b10124b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88303c617dfdc5eca2edb6fb7b10124b">&#9670;&#160;</a></span>rfind_lower() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view::size_type wpi::rfind_lower </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>other</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the last string <code>other</code> in <code>str</code>, ignoring case. </p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The index of the last occurrence of <code>other</code>, or npos if not found. </dd></dl>

</div>
</div>
<a id="ad8401d71223335daab845683d6d786af" name="ad8401d71223335daab845683d6d786af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8401d71223335daab845683d6d786af">&#9670;&#160;</a></span>rotated_span() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::contiguous_iterator It, typename End &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::rotated_span </td>
          <td>(</td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">End</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  rotated_span&lt; std::remove_reference_t&lt; std::iter_reference_t&lt; It &gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4748932455907f51f9f495d41c8b437" name="ab4748932455907f51f9f495d41c8b437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4748932455907f51f9f495d41c8b437">&#9670;&#160;</a></span>rotated_span() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t ArrayExtent&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::rotated_span </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; Type, ArrayExtent &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  rotated_span&lt; Type, ArrayExtent &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3690db2358c9141bfa7dc816cb91436a" name="a3690db2358c9141bfa7dc816cb91436a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3690db2358c9141bfa7dc816cb91436a">&#9670;&#160;</a></span>rotated_span() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t ArrayExtent&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wpi::rotated_span </td>
          <td>(</td>
          <td class="paramtype">Type(&amp;)</td>          <td class="paramname"><span class="paramname"><em></em></span>[ArrayExtent]</td><td>)</td>
          <td> -&gt;  rotated_span&lt; Type, ArrayExtent &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a31eb74242495e03e1745ab82085c81" name="a7a31eb74242495e03e1745ab82085c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a31eb74242495e03e1745ab82085c81">&#9670;&#160;</a></span>rsplit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string_view, std::string_view &gt; wpi::rsplit </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>separator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits <code>str</code> into two substrings around the last occurrence of a separator character. </p>
<p>If <code>separator</code> is in the string, then the result is a pair (LHS, RHS) such that (str == LHS + separator + RHS) is true and RHS is minimal. If <code>separator</code> is not in the string, then the result is a pair (LHS, RHS) where (str == LHS) and (RHS == "").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>The string to split on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The split substrings. </dd></dl>

</div>
</div>
<a id="a2512b6f3e4faf374ccc818722784597b" name="a2512b6f3e4faf374ccc818722784597b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2512b6f3e4faf374ccc818722784597b">&#9670;&#160;</a></span>rsplit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string_view, std::string_view &gt; wpi::rsplit </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>separator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits <code>str</code> into two substrings around the last occurrence of a separator string. </p>
<p>If <code>separator</code> is in the string, then the result is a pair (LHS, RHS) such that (str == LHS + separator + RHS) is true and RHS is minimal. If <code>separator</code> is not in the string, then the result is a pair (LHS, RHS) where (str == LHS) and (RHS == "").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>The string to split on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The split substrings. </dd></dl>

</div>
</div>
<a id="adb3a6a546687b31a4770178e1036c589" name="adb3a6a546687b31a4770178e1036c589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3a6a546687b31a4770178e1036c589">&#9670;&#160;</a></span>rtrim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view wpi::rtrim </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>str</code> with consecutive <code>Char</code> characters starting from the right removed. </p>

</div>
</div>
<a id="a9c241695392bec8c5295c438f6e8d35f" name="a9c241695392bec8c5295c438f6e8d35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c241695392bec8c5295c438f6e8d35f">&#9670;&#160;</a></span>rtrim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view wpi::rtrim </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>chars</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&#160;\t\n\v\f\r&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>str</code> with consecutive characters in <code>chars</code> starting from the right removed. </p>

</div>
</div>
<a id="aa3107b50e4fba4c211bc3981f452dfbc" name="aa3107b50e4fba4c211bc3981f452dfbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3107b50e4fba4c211bc3981f452dfbc">&#9670;&#160;</a></span>safe_calloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_compiler_8h.html#acbae7c06e77fa64145cca176963b6863">LLVM_ATTRIBUTE_RETURNS_NONNULL</a> void * wpi::safe_calloc </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>Count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>Sz</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a01feba2e98f9634bb529eac857ffa4fb" name="a01feba2e98f9634bb529eac857ffa4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01feba2e98f9634bb529eac857ffa4fb">&#9670;&#160;</a></span>safe_malloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_compiler_8h.html#acbae7c06e77fa64145cca176963b6863">LLVM_ATTRIBUTE_RETURNS_NONNULL</a> void * wpi::safe_malloc </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>Sz</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a780a79e5410f3c9082aa1ff62d997151" name="a780a79e5410f3c9082aa1ff62d997151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780a79e5410f3c9082aa1ff62d997151">&#9670;&#160;</a></span>safe_realloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_compiler_8h.html#acbae7c06e77fa64145cca176963b6863">LLVM_ATTRIBUTE_RETURNS_NONNULL</a> void * wpi::safe_realloc </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>Ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>Sz</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a62659b5a787c7e4226be65a87f78687d" name="a62659b5a787c7e4226be65a87f78687d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62659b5a787c7e4226be65a87f78687d">&#9670;&#160;</a></span>SaturatingAdd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_unsigned_v&lt; T &gt;, T &gt; wpi::SaturatingAdd </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>ResultOverflowed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add two unsigned integers, X and Y, of type T. </p>
<p>Clamp the result to the maximum representable value of T on overflow. ResultOverflowed indicates if the result is larger than the maximum representable value of type T. </p>

</div>
</div>
<a id="a56f5e9a527fc240f35c74bd250f7870a" name="a56f5e9a527fc240f35c74bd250f7870a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56f5e9a527fc240f35c74bd250f7870a">&#9670;&#160;</a></span>SaturatingAdd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_unsigned_v&lt; T &gt;, T &gt; wpi::SaturatingAdd </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>Z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts...</td>          <td class="paramname"><span class="paramname"><em>Args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add multiple unsigned integers of type T. </p>
<p>Clamp the result to the maximum representable value of T on overflow. </p>

</div>
</div>
<a id="a61cc21f13e1ebeb16606beee7fbdfa86" name="a61cc21f13e1ebeb16606beee7fbdfa86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61cc21f13e1ebeb16606beee7fbdfa86">&#9670;&#160;</a></span>SaturatingMultiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_unsigned_v&lt; T &gt;, T &gt; wpi::SaturatingMultiply </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>ResultOverflowed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two unsigned integers, X and Y, of type T. </p>
<p>Clamp the result to the maximum representable value of T on overflow. ResultOverflowed indicates if the result is larger than the maximum representable value of type T. </p>

</div>
</div>
<a id="a8b025ab259067b84fe2ecea8127ee44b" name="a8b025ab259067b84fe2ecea8127ee44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b025ab259067b84fe2ecea8127ee44b">&#9670;&#160;</a></span>SaturatingMultiplyAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_unsigned_v&lt; T &gt;, T &gt; wpi::SaturatingMultiplyAdd </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>ResultOverflowed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two unsigned integers, X and Y, and add the unsigned integer, A to the product. </p>
<p>Clamp the result to the maximum representable value of T on overflow. ResultOverflowed indicates if the result is larger than the maximum representable value of type T. </p>

</div>
</div>
<a id="ab9199d95a0d0ca4ba23a42b8c9cd4763" name="ab9199d95a0d0ca4ba23a42b8c9cd4763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9199d95a0d0ca4ba23a42b8c9cd4763">&#9670;&#160;</a></span>set_fixed_execution_hash_seed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::set_fixed_execution_hash_seed </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>fixed_value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override the execution seed with a fixed value. </p>
<p>This hashing library uses a per-execution seed designed to change on each run with high probability in order to ensure that the hash codes are not attackable and to ensure that output which is intended to be stable does not rely on the particulars of the hash codes produced.</p>
<p>That said, there are use cases where it is important to be able to reproduce <em>exactly</em> a specific behavior. To that end, we provide a function which will forcibly set the seed to a fixed value. This must be done at the start of the program, before any hashes are computed. Also, it cannot be undone. This makes it thread-hostile and very hard to use outside of immediately on start of a simple program designed for reproducible behavior. </p>

</div>
</div>
<a id="a397be4df815a23d76e43a6713bc2c8b6" name="a397be4df815a23d76e43a6713bc2c8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397be4df815a23d76e43a6713bc2c8b6">&#9670;&#160;</a></span>SetEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::SetEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_synchronization_8h.html#a4e842b28ce72a1d1dc778397b5f81b87">WPI_EventHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an event to signaled state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>event handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3776b907dc530ce3556e36bcb5a68462" name="a3776b907dc530ce3556e36bcb5a68462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3776b907dc530ce3556e36bcb5a68462">&#9670;&#160;</a></span>SetGetStackTraceImpl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::SetGetStackTraceImpl </td>
          <td>(</td>
          <td class="paramtype">std::string(*</td>          <td class="paramname"><span class="paramname"><em>func&#160;</em></span>)(int offset)</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the implementation used by <a class="el" href="#a4b125df3c2eaae6f9b8cd09ccd9da98d" title="Get a stack trace, ignoring the first &quot;offset&quot; symbols.">GetStackTrace()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function called by <a class="el" href="#a4b125df3c2eaae6f9b8cd09ccd9da98d" title="Get a stack trace, ignoring the first &quot;offset&quot; symbols.">GetStackTrace()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af74f2f6f8a5413fcad6121a6f455bab6" name="af74f2f6f8a5413fcad6121a6f455bab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74f2f6f8a5413fcad6121a6f455bab6">&#9670;&#160;</a></span>SetNowImpl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::SetNowImpl </td>
          <td>(</td>
          <td class="paramtype">uint64_t(*</td>          <td class="paramname"><span class="paramname"><em>func&#160;</em></span>)()</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the implementation used by <a class="el" href="#af041f6643f3d0d18e0f8430bf0617dda" title="Return a value representing the current time in microseconds.">Now()</a>. </p>
<p>The implementation must return monotonic time in microseconds to maintain the contract of <a class="el" href="#af041f6643f3d0d18e0f8430bf0617dda" title="Return a value representing the current time in microseconds.">Now()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function called by <a class="el" href="#af041f6643f3d0d18e0f8430bf0617dda" title="Return a value representing the current time in microseconds.">Now()</a> to return the time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5461711574b8a35edcde80d9ecaf9ff" name="ab5461711574b8a35edcde80d9ecaf9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5461711574b8a35edcde80d9ecaf9ff">&#9670;&#160;</a></span>SetSignalObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::SetSignalObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a handle to signaled state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0dca6ddf9e17f10ec7699c29819b6c18" name="a0dca6ddf9e17f10ec7699c29819b6c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dca6ddf9e17f10ec7699c29819b6c18">&#9670;&#160;</a></span>sgn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int wpi::sgn </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afbf26bf198ea436f545bf8205670ff7a" name="afbf26bf198ea436f545bf8205670ff7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf26bf198ea436f545bf8205670ff7a">&#9670;&#160;</a></span>shouldReverseIterate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T  = void *&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::shouldReverseIterate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae892922c9d93c91d358b554fec2b6505" name="ae892922c9d93c91d358b554fec2b6505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae892922c9d93c91d358b554fec2b6505">&#9670;&#160;</a></span>SignExtend32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t wpi::SignExtend32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign-extend the number in the bottom B bits of X to a 32-bit integer. </p>
<p>Requires 0 &lt; B &lt;= 32. </p>

</div>
</div>
<a id="a9c3d762ed7571ddac4e212f583eb0a12" name="a9c3d762ed7571ddac4e212f583eb0a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3d762ed7571ddac4e212f583eb0a12">&#9670;&#160;</a></span>SignExtend32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t wpi::SignExtend32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>B</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign-extend the number in the bottom B bits of X to a 32-bit integer. </p>
<p>Requires 0 &lt; B &lt;= 32. </p>

</div>
</div>
<a id="a401f9f01b250b094f790fab7706106d8" name="a401f9f01b250b094f790fab7706106d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a401f9f01b250b094f790fab7706106d8">&#9670;&#160;</a></span>SignExtend64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned B&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t wpi::SignExtend64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign-extend the number in the bottom B bits of X to a 64-bit integer. </p>
<p>Requires 0 &lt; B &lt;= 64. </p>

</div>
</div>
<a id="a2540c26db383c900eae86f2c67c41ce0" name="a2540c26db383c900eae86f2c67c41ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2540c26db383c900eae86f2c67c41ce0">&#9670;&#160;</a></span>SignExtend64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t wpi::SignExtend64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>B</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign-extend the number in the bottom B bits of X to a 64-bit integer. </p>
<p>Requires 0 &lt; B &lt;= 64. </p>

</div>
</div>
<a id="a36ea49dcab711bb9a5e64a569c32241b" name="a36ea49dcab711bb9a5e64a569c32241b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ea49dcab711bb9a5e64a569c32241b">&#9670;&#160;</a></span>SizeUleb128()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::SizeUleb128 </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get size of unsigned LEB128 data. </p>
<p>Determine the number of bytes required to encode an unsigned LEB128 datum. The algorithm is taken from Appendix C of the DWARF 3 spec. For information on the encodings refer to section "7.6 - Variable Length Data". Return the number of bytes required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>LEB128 data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f22fd8158dd46fe207d828ab907c6a9" name="a0f22fd8158dd46fe207d828ab907c6a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f22fd8158dd46fe207d828ab907c6a9">&#9670;&#160;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view wpi::slice </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the substring of <code>str</code> from [start, end). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The index of the starting character in the substring; if the index is npos or greater than the length of the string then the empty substring will be returned.</td></tr>
    <tr><td class="paramname">end</td><td>The index following the last character to include in the substring. If this is npos or exceeds the number of characters remaining in the string, the string suffix (starting with <code>start</code>) will be returned. If this is less than <code>start</code>, an empty string will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af979beb47215754d9f91b67aab2dc4e7" name="af979beb47215754d9f91b67aab2dc4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af979beb47215754d9f91b67aab2dc4e7">&#9670;&#160;</a></span>SocketErrno()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wpi::SocketErrno </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4d3b98c9badfe33b94b7c6ec1ad3f9f" name="aa4d3b98c9badfe33b94b7c6ec1ad3f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d3b98c9badfe33b94b7c6ec1ad3f9f">&#9670;&#160;</a></span>SocketStrerror() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string wpi::SocketStrerror </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b76c9ad108ae76959df39c1d0b6f03b" name="a8b76c9ad108ae76959df39c1d0b6f03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b76c9ad108ae76959df39c1d0b6f03b">&#9670;&#160;</a></span>SocketStrerror() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string wpi::SocketStrerror </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>code</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f9d3d4eb9461ff65cb2743afa9fd08a" name="a0f9d3d4eb9461ff65cb2743afa9fd08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9d3d4eb9461ff65cb2743afa9fd08a">&#9670;&#160;</a></span>split() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string_view, std::string_view &gt; wpi::split </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>separator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits <code>str</code> into two substrings around the first occurrence of a separator character. </p>
<p>If <code>separator</code> is in the string, then the result is a pair (LHS, RHS) such that (str == LHS + separator + RHS) is true and RHS is maximal. If <code>separator</code> is not in the string, then the result is a pair (LHS, RHS) where (str == LHS) and (RHS == "").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>The character to split on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The split substrings. </dd></dl>

</div>
</div>
<a id="ac32a7896ab3ee6b24926527703eabade" name="ac32a7896ab3ee6b24926527703eabade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32a7896ab3ee6b24926527703eabade">&#9670;&#160;</a></span>split() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::split </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; std::string_view &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>separator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxSplit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>keepEmpty</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits <code>str</code> into substrings around the occurrences of a separator character. </p>
<p>Each substring is stored in <code>arr</code>. If <code>maxSplit</code> is &gt;= 0, at most <code>maxSplit</code> splits are done and consequently &lt;= <code>maxSplit</code> + 1 elements are added to arr. If <code>keepEmpty</code> is false, empty strings are not added to <code>arr</code>. They still count when considering <code>maxSplit</code> An useful invariant is that separator.join(arr) == str if maxSplit == -1 and keepEmpty == true</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Where to put the substrings. </td></tr>
    <tr><td class="paramname">separator</td><td>The character to split on. </td></tr>
    <tr><td class="paramname">maxSplit</td><td>The maximum number of times the string is split. </td></tr>
    <tr><td class="paramname">keepEmpty</td><td>True if empty substring should be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd39f69badd5bed05f8020e76e688911" name="afd39f69badd5bed05f8020e76e688911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd39f69badd5bed05f8020e76e688911">&#9670;&#160;</a></span>split() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::split </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; std::string_view &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>separator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxSplit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>keepEmpty</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits <code>str</code> into substrings around the occurrences of a separator string. </p>
<p>Each substring is stored in <code>arr</code>. If <code>maxSplit</code> is &gt;= 0, at most <code>maxSplit</code> splits are done and consequently &lt;= <code>maxSplit</code> + 1 elements are added to arr. If <code>keepEmpty</code> is false, empty strings are not added to <code>arr</code>. They still count when considering <code>maxSplit</code> An useful invariant is that separator.join(arr) == str if maxSplit == -1 and keepEmpty == true</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Where to put the substrings. </td></tr>
    <tr><td class="paramname">separator</td><td>The string to split on. </td></tr>
    <tr><td class="paramname">maxSplit</td><td>The maximum number of times the string is split. </td></tr>
    <tr><td class="paramname">keepEmpty</td><td>True if empty substring should be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b559c84b004c61700aa0724cf658177" name="a2b559c84b004c61700aa0724cf658177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b559c84b004c61700aa0724cf658177">&#9670;&#160;</a></span>split() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string_view, std::string_view &gt; wpi::split </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>separator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits <code>str</code> into two substrings around the first occurrence of a separator string. </p>
<p>If <code>separator</code> is in the string, then the result is a pair (LHS, RHS) such that (str == LHS + separator + RHS) is true and RHS is maximal. If <code>separator</code> is not in the string, then the result is a pair (LHS, RHS) where (str == LHS) and (RHS == "").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>The string to split on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The split substrings. </dd></dl>

</div>
</div>
<a id="a24ed0964b7b3d671454f67babc4835bf" name="a24ed0964b7b3d671454f67babc4835bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ed0964b7b3d671454f67babc4835bf">&#9670;&#160;</a></span>starts_with() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::starts_with </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> starts with the given <code>prefix</code>. </p>

</div>
</div>
<a id="a5432fef02a3f6f25d649439e5f37b291" name="a5432fef02a3f6f25d649439e5f37b291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5432fef02a3f6f25d649439e5f37b291">&#9670;&#160;</a></span>starts_with() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::starts_with </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> starts with the given <code>prefix</code>. </p>

</div>
</div>
<a id="af0739f65c4cc2835777cc34e9241c377" name="af0739f65c4cc2835777cc34e9241c377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0739f65c4cc2835777cc34e9241c377">&#9670;&#160;</a></span>starts_with() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::starts_with </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> starts with the given <code>prefix</code>. </p>

</div>
</div>
<a id="a2bef3b73b83b04242caa60d6327ceb68" name="a2bef3b73b83b04242caa60d6327ceb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bef3b73b83b04242caa60d6327ceb68">&#9670;&#160;</a></span>starts_with_lower() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::starts_with_lower </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> starts with the given <code>prefix</code>, ignoring case. </p>

</div>
</div>
<a id="a9ddfda4dce07ee9575513ba636d6f383" name="a9ddfda4dce07ee9575513ba636d6f383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ddfda4dce07ee9575513ba636d6f383">&#9670;&#160;</a></span>starts_with_lower() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::starts_with_lower </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> starts with the given <code>prefix</code>, ignoring case. </p>

</div>
</div>
<a id="a6880afc62fe88adf620fbf7c0ae29cc6" name="a6880afc62fe88adf620fbf7c0ae29cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6880afc62fe88adf620fbf7c0ae29cc6">&#9670;&#160;</a></span>starts_with_lower() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::starts_with_lower </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if <code>str</code> starts with the given <code>prefix</code>, ignoring case. </p>

</div>
</div>
<a id="a05953a04700d3bac512b4f35fabee3d7" name="a05953a04700d3bac512b4f35fabee3d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05953a04700d3bac512b4f35fabee3d7">&#9670;&#160;</a></span>SubOverflow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_signed_v&lt; T &gt;, T &gt; wpi::SubOverflow </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>Result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract two signed integers, computing the two's complement truncated result, returning true if an overflow ocurred. </p>

</div>
</div>
<a id="a7f010ee3e4dec5c5697534c0059aa046" name="a7f010ee3e4dec5c5697534c0059aa046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f010ee3e4dec5c5697534c0059aa046">&#9670;&#160;</a></span>substr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view wpi::substr </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::string_view::npos</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the substring of <code>str</code> from [start, start + n). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The index of the starting character in the substring; if the index is npos or greater than the length of the string then the empty substring will be returned.</td></tr>
    <tr><td class="paramname">n</td><td>The number of characters to included in the substring. If n exceeds the number of characters remaining in the string, the string suffix (starting with <code>start</code>) will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3084aaf9d059654958af201cad67e70a" name="a3084aaf9d059654958af201cad67e70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3084aaf9d059654958af201cad67e70a">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class E , <a class="el" href="namespacewpi_1_1detail__expected.html#ae16eac50d15e3d1edb9c7106933dc891">detail_expected::enable_if_t</a>&lt;(std::is_void&lt; T &gt;::value||std::is_move_constructible&lt; T &gt;::value) &amp;&amp;<a class="el" href="structwpi_1_1detail__expected_1_1is__swappable.html">detail_expected::is_swappable</a>&lt; T &gt;::value &amp;&amp;std::is_move_constructible&lt; E &gt;::value &amp;&amp;<a class="el" href="structwpi_1_1detail__expected_1_1is__swappable.html">detail_expected::is_swappable</a>&lt; E &gt;::value &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1expected.html">expected</a>&lt; T, E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aab3f5909dbe701d6f87b8a381047f683" name="aab3f5909dbe701d6f87b8a381047f683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3f5909dbe701d6f87b8a381047f683">&#9670;&#160;</a></span>take_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; T &gt; wpi::take_back </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T, N &gt;</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::span&lt; T &gt;::size_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a span equal to <code>in</code> but with only the last <code>n</code> elements remaining. </p>
<p>If <code>n</code> is greater than the length of the span, the entire span is returned. </p>

</div>
</div>
<a id="aa8a98666f01d85b3920861e2477e7926" name="aa8a98666f01d85b3920861e2477e7926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a98666f01d85b3920861e2477e7926">&#9670;&#160;</a></span>take_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view wpi::take_back </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a view equal to <code>str</code> but with only the last <code>n</code> elements remaining. </p>
<p>If <code>n</code> is greater than the length of the string, the entire string is returned. </p>

</div>
</div>
<a id="a55070033454b115a776f0896c59e7784" name="a55070033454b115a776f0896c59e7784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55070033454b115a776f0896c59e7784">&#9670;&#160;</a></span>take_front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; T &gt; wpi::take_front </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; T, N &gt;</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::span&lt; T &gt;::size_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a span equal to <code>in</code> but with only the first <code>n</code> elements remaining. </p>
<p>If <code>n</code> is greater than the length of the span, the entire span is returned. </p>

</div>
</div>
<a id="aff2f9b2ee4f037743d32eb831bb487c4" name="aff2f9b2ee4f037743d32eb831bb487c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2f9b2ee4f037743d32eb831bb487c4">&#9670;&#160;</a></span>take_front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view wpi::take_front </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view::size_type</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a view equal to <code>str</code> but with only the first <code>n</code> elements remaining. </p>
<p>If <code>n</code> is greater than the length of the string, the entire string is returned. </p>

</div>
</div>
<a id="a74e3119bfa85b395027a18a9260bc886" name="a74e3119bfa85b395027a18a9260bc886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e3119bfa85b395027a18a9260bc886">&#9670;&#160;</a></span>to_string_view()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view wpi::to_string_view </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_w_p_i___string.html">WPI_String</a> *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="struct_w_p_i___string.html" title="A const UTF8 string.">WPI_String</a> to a string_view. </p>

</div>
</div>
<a id="ac420770a69a1f2159f02480b797fccc1" name="ac420770a69a1f2159f02480b797fccc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac420770a69a1f2159f02480b797fccc1">&#9670;&#160;</a></span>to_underlying()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Enum &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::underlying_type_t&lt; Enum &gt; wpi::to_underlying </td>
          <td>(</td>
          <td class="paramtype">Enum</td>          <td class="paramname"><span class="paramname"><em>E</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns underlying integer value of an enum. </p>
<p>Backport of C++23 std::to_underlying. </p>

</div>
</div>
<a id="a5602e08ef8bfc0486d71717a291a06b4" name="a5602e08ef8bfc0486d71717a291a06b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5602e08ef8bfc0486d71717a291a06b4">&#9670;&#160;</a></span>to_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned Size, typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1_small_vector.html">SmallVector</a>&lt; <a class="el" href="#a5ba14c6ed82a2230ba7b7f9152d1e6af">ValueTypeFromRangeType</a>&lt; R &gt;, Size &gt; wpi::to_vector </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>Range</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a range of type R, iterate the entire range and return a <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> with elements of the vector. </p>
<p>This is useful, for example, when you want to iterate a range and then sort the results. </p>

</div>
</div>
<a id="a6769bd8fc499c71e913a1b6af19b9232" name="a6769bd8fc499c71e913a1b6af19b9232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6769bd8fc499c71e913a1b6af19b9232">&#9670;&#160;</a></span>to_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1_small_vector.html">SmallVector</a>&lt; <a class="el" href="#a5ba14c6ed82a2230ba7b7f9152d1e6af">ValueTypeFromRangeType</a>&lt; R &gt; &gt; wpi::to_vector </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>Range</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77699b09ddc46df66382aa0a658d5da5" name="a77699b09ddc46df66382aa0a658d5da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77699b09ddc46df66382aa0a658d5da5">&#9670;&#160;</a></span>to_vector_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Out , unsigned Size, typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1_small_vector.html">SmallVector</a>&lt; Out, Size &gt; wpi::to_vector_of </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>Range</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1687abd77cebc784b25364d696c46fee" name="a1687abd77cebc784b25364d696c46fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1687abd77cebc784b25364d696c46fee">&#9670;&#160;</a></span>to_vector_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Out , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1_small_vector.html">SmallVector</a>&lt; Out &gt; wpi::to_vector_of </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>Range</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a47d0773c177190213ead75a95fe7fc46" name="a47d0773c177190213ead75a95fe7fc46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d0773c177190213ead75a95fe7fc46">&#9670;&#160;</a></span>toLower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char wpi::toLower </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the corresponding lowercase character if <code>x</code> is uppercase. </p>

</div>
</div>
<a id="a4fe9106b78ee79e9796550968c3ef216" name="a4fe9106b78ee79e9796550968c3ef216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe9106b78ee79e9796550968c3ef216">&#9670;&#160;</a></span>toUpper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char wpi::toUpper </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the corresponding uppercase character if <code>x</code> is lowercase. </p>

</div>
</div>
<a id="a2abdfb1cf85cbf947a6de5c34b0ed078" name="a2abdfb1cf85cbf947a6de5c34b0ed078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2abdfb1cf85cbf947a6de5c34b0ed078">&#9670;&#160;</a></span>transformOptional() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::transformOptional </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>O</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Function &amp;</td>          <td class="paramname"><span class="paramname"><em>F</em></span>&#160;) -&gt; std::optional&lt;decltype(F(*O))&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a50d3870ae294caf2d9463229be0c67bc" name="a50d3870ae294caf2d9463229be0c67bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d3870ae294caf2d9463229be0c67bc">&#9670;&#160;</a></span>transformOptional() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::transformOptional </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>O</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Function &amp;</td>          <td class="paramname"><span class="paramname"><em>F</em></span>&#160;) -&gt; std::optional&lt;decltype(F(*std::move(O)))&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c8e2346d8ddaaaecfd3bc8760d09d9a" name="a4c8e2346d8ddaaaecfd3bc8760d09d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8e2346d8ddaaaecfd3bc8760d09d9a">&#9670;&#160;</a></span>trim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view wpi::trim </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>ch</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>str</code> with consecutive <code>ch</code> characters starting from the left and right removed. </p>

</div>
</div>
<a id="a5ddfebd5ca997fb76159b3d79f1a98c9" name="a5ddfebd5ca997fb76159b3d79f1a98c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ddfebd5ca997fb76159b3d79f1a98c9">&#9670;&#160;</a></span>trim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view wpi::trim </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>chars</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&#160;\t\n\v\f\r&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>str</code> with consecutive characters in <code>chars</code> starting from the left and right removed. </p>

</div>
</div>
<a id="ab528fd3e2a3f73f3ac2a6ed2177be0a0" name="ab528fd3e2a3f73f3ac2a6ed2177be0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab528fd3e2a3f73f3ac2a6ed2177be0a0">&#9670;&#160;</a></span>UnescapeCString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string_view, std::string_view &gt; wpi::UnescapeCString </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unescapes a C-style string (reverse operation to <a class="el" href="classwpi_1_1raw__ostream.html#a623db24f216428b1b9f695435ddcaad4" title="Output Str, turning &#39;\&#39;, &#39;\t&#39;, &#39; &#39;, &#39;&quot;&#39;, and anything that doesn&#39;t satisfy wpi::isPrint into an escap...">raw_ostream::write_escaped</a>). </p>
<p>Scans through <code>str</code> until either the end is reached or an unescaped double quote character is found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>input string </td></tr>
    <tr><td class="paramname">buf</td><td>buffer for unescaped characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of the unescaped string and any remaining input </dd></dl>

</div>
</div>
<a id="a55235b8d8fe2b869b11a04237f1c1b5f" name="a55235b8d8fe2b869b11a04237f1c1b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55235b8d8fe2b869b11a04237f1c1b5f">&#9670;&#160;</a></span>UnescapeURI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view wpi::UnescapeURI </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>error</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad43b2efdc26b8b018d5854d115e6ff17" name="ad43b2efdc26b8b018d5854d115e6ff17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43b2efdc26b8b018d5854d115e6ff17">&#9670;&#160;</a></span>unique_dyn_cast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::unique_dyn_cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; Y &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad586a56958f612d9abd6e681095f84b" name="aad586a56958f612d9abd6e681095f84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad586a56958f612d9abd6e681095f84b">&#9670;&#160;</a></span>unique_dyn_cast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structwpi_1_1_cast_info.html">CastInfo</a>&lt; X, std::unique_ptr&lt; Y &gt; &gt;::CastResultType wpi::unique_dyn_cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; Y &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>unique_dyn_cast&lt;X&gt; - Given a unique_ptr&lt;Y&gt;, try to return a unique_ptr&lt;X&gt;, taking ownership of the input pointer iff isa&lt;X&gt;(Val) is true. </p>
<p>If the cast is successful, From refers to nullptr on exit and the casted value is returned. If the cast is unsuccessful, the function returns nullptr and From is unchanged. </p>

</div>
</div>
<a id="ad19895a7f422ff3246efb74b2e67364d" name="ad19895a7f422ff3246efb74b2e67364d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19895a7f422ff3246efb74b2e67364d">&#9670;&#160;</a></span>unique_dyn_cast_or_null() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::unique_dyn_cast_or_null </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; Y &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5344f9b4191fcd767af5fbd6af5aa2b3" name="a5344f9b4191fcd767af5fbd6af5aa2b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5344f9b4191fcd767af5fbd6af5aa2b3">&#9670;&#160;</a></span>unique_dyn_cast_or_null() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structwpi_1_1_cast_info.html">CastInfo</a>&lt; X, std::unique_ptr&lt; Y &gt; &gt;::CastResultType wpi::unique_dyn_cast_or_null </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; Y &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4ee7f9c4e98f812609c2ab856f31d40" name="aa4ee7f9c4e98f812609c2ab856f31d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ee7f9c4e98f812609c2ab856f31d40">&#9670;&#160;</a></span>UnpackProtobuf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ProtobufSerializable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T wpi::UnpackProtobuf </td>
          <td>(</td>
          <td class="paramtype">const google::protobuf::Message &amp;</td>          <td class="paramname"><span class="paramname"><em>msg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a serialized protobuf message. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>object type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>protobuf message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Deserialized object </dd></dl>

</div>
</div>
<a id="a41e94022d22c588092a8d275add89ce6" name="a41e94022d22c588092a8d275add89ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e94022d22c588092a8d275add89ce6">&#9670;&#160;</a></span>UnpackProtobufArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; T, N &gt; wpi::UnpackProtobufArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoogle_1_1protobuf_1_1_repeated_field.html">google::protobuf::RepeatedField</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>msg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpack a serialized protobuf array message. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>element type of the protobuf array </td></tr>
    <tr><td class="paramname">N</td><td>number of objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>protobuf array message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Deserialized array </dd></dl>

</div>
</div>
<a id="aaafde714844c14477f295d1ac911b35b" name="aaafde714844c14477f295d1ac911b35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaafde714844c14477f295d1ac911b35b">&#9670;&#160;</a></span>UnpackProtobufArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::derived_from&lt; google::protobuf::Message &gt; Proto, ProtobufSerializable T, size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; T, N &gt; wpi::UnpackProtobufArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgoogle_1_1protobuf_1_1_repeated_ptr_field.html">google::protobuf::RepeatedPtrField</a>&lt; Proto &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>msg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpack a serialized protobuf array message. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Proto</td><td>element type of the protobuf array </td></tr>
    <tr><td class="paramname">T</td><td>object type </td></tr>
    <tr><td class="paramname">N</td><td>number of objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>protobuf array message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Deserialized array </dd></dl>

</div>
</div>
<a id="aaca8a1c440adfd6e059ada60de9e65c3" name="aaca8a1c440adfd6e059ada60de9e65c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca8a1c440adfd6e059ada60de9e65c3">&#9670;&#160;</a></span>UnpackProtobufInto()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ProtobufSerializable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::UnpackProtobufInto </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const google::protobuf::Message &amp;</td>          <td class="paramname"><span class="paramname"><em>msg</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a serialized struct into an existing object, overwriting its contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>object (output) </td></tr>
    <tr><td class="paramname">msg</td><td>protobuf message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a805c424d8dd8935ad4d89f4e721b74f3" name="a805c424d8dd8935ad4d89f4e721b74f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805c424d8dd8935ad4d89f4e721b74f3">&#9670;&#160;</a></span>UnpackStruct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T wpi::UnpackStruct </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const uint8_t &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I &amp;...</td>          <td class="paramname"><span class="paramname"><em>info</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a serialized struct. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>object type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>raw struct data </td></tr>
    <tr><td class="paramname">info</td><td>optional struct type info </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Deserialized object </dd></dl>

</div>
</div>
<a id="acf6b1367b38f8bb562b8a4fbeeeaa27c" name="acf6b1367b38f8bb562b8a4fbeeeaa27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6b1367b38f8bb562b8a4fbeeeaa27c">&#9670;&#160;</a></span>UnpackStruct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Offset, typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T wpi::UnpackStruct </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const uint8_t &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I &amp;...</td>          <td class="paramname"><span class="paramname"><em>info</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a serialized struct starting at a given offset within the data. </p>
<p>This is primarily useful in unpack implementations to unpack nested structs.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>object type </td></tr>
    <tr><td class="paramname">Offset</td><td>starting offset </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>raw struct data </td></tr>
    <tr><td class="paramname">info</td><td>optional struct type info </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Deserialized object </dd></dl>

</div>
</div>
<a id="ac81bdf06aca9f2529e7cd001103dffa0" name="ac81bdf06aca9f2529e7cd001103dffa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81bdf06aca9f2529e7cd001103dffa0">&#9670;&#160;</a></span>UnpackStructArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StructSerializable T, size_t Offset, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; T, N &gt; wpi::UnpackStructArray </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const uint8_t &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a serialized struct array starting at a given offset within the data. </p>
<p>This is primarily useful in unpack implementations to unpack nested struct arrays.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>object type </td></tr>
    <tr><td class="paramname">Offset</td><td>starting offset </td></tr>
    <tr><td class="paramname">N</td><td>number of objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>raw struct data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Deserialized array </dd></dl>

</div>
</div>
<a id="a29496596f0788faf2bfefee4a32fda6f" name="a29496596f0788faf2bfefee4a32fda6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29496596f0788faf2bfefee4a32fda6f">&#9670;&#160;</a></span>UnpackStructInto() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::UnpackStructInto </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const uint8_t &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I &amp;...</td>          <td class="paramname"><span class="paramname"><em>info</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a serialized struct into an existing object, overwriting its contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>object (output) </td></tr>
    <tr><td class="paramname">data</td><td>raw struct data </td></tr>
    <tr><td class="paramname">info</td><td>optional struct type info </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8787a202964e86ce1d7f549504241fc" name="ad8787a202964e86ce1d7f549504241fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8787a202964e86ce1d7f549504241fc">&#9670;&#160;</a></span>UnpackStructInto() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Offset, typename T , typename... I&gt; <br />
requires StructSerializable&lt;T, I...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::UnpackStructInto </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const uint8_t &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I &amp;...</td>          <td class="paramname"><span class="paramname"><em>info</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a serialized struct into an existing object, overwriting its contents, and starting at a given offset within the data. </p>
<p>This is primarily useful in unpack implementations to unpack nested structs.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Offset</td><td>starting offset </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>object (output) </td></tr>
    <tr><td class="paramname">data</td><td>raw struct data </td></tr>
    <tr><td class="paramname">info</td><td>optional struct type info </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7da2e15d1e126422095bfbc0e66f1bc" name="ae7da2e15d1e126422095bfbc0e66f1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7da2e15d1e126422095bfbc0e66f1bc">&#9670;&#160;</a></span>utohexstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string wpi::utohexstr </td>
          <td>(</td>
          <td class="paramtype">unsigned long long</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>lowerCase</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a87dbe0fae2ecbfa69d709f615dbf8d01" name="a87dbe0fae2ecbfa69d709f615dbf8d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87dbe0fae2ecbfa69d709f615dbf8d01">&#9670;&#160;</a></span>vprint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::vprint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1raw__ostream.html">wpi::raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmt::string_view</td>          <td class="paramname"><span class="paramname"><em>format_str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmt::format_args</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a878b699be631007b8e6eeb2c95e4bc83" name="a878b699be631007b8e6eeb2c95e4bc83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878b699be631007b8e6eeb2c95e4bc83">&#9670;&#160;</a></span>WaitForObject() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::WaitForObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for an handle to be signaled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>handle to wait on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if handle was signaled, false otherwise (e.g. object was destroyed) </dd></dl>

</div>
</div>
<a id="a10992d66a2e0bc348c37c2bbca2ce718" name="a10992d66a2e0bc348c37c2bbca2ce718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10992d66a2e0bc348c37c2bbca2ce718">&#9670;&#160;</a></span>WaitForObject() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::WaitForObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>timedOut</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for an handle to be signaled, with timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>handle to wait on </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout in seconds </td></tr>
    <tr><td class="paramname">timedOut</td><td>if non-null, set to true if timeout reached without handle being signaled; set to false otherwise (output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if handle was signaled, false otherwise (e.g. object was destroyed or timed out) </dd></dl>

</div>
</div>
<a id="acad9633f9184e5be60f5f35700af7dba" name="acad9633f9184e5be60f5f35700af7dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad9633f9184e5be60f5f35700af7dba">&#9670;&#160;</a></span>WaitForObjects() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt; wpi::WaitForObjects </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>handles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>signaled</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for one or more handles to be signaled. </p>
<p>Invalid handles are treated as signaled; the returned array will have the handle error bit set for any invalid handles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handles</td><td>array of handles to wait on </td></tr>
    <tr><td class="paramname">signaled</td><td>output array for storage of signaled handles; must be at least the size of the handles input array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of signaled handles (points into signaled array) </dd></dl>

</div>
</div>
<a id="ae4471d272e72369b5c5c12da6bc222d2" name="ae4471d272e72369b5c5c12da6bc222d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4471d272e72369b5c5c12da6bc222d2">&#9670;&#160;</a></span>WaitForObjects() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt; wpi::WaitForObjects </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>handles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>signaled</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>timedOut</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for one or more handles to be signaled, with timeout. </p>
<p>Invalid handles are treated as signaled; the returned array will have the handle error bit set for any invalid handles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handles</td><td>array of handles to wait on </td></tr>
    <tr><td class="paramname">signaled</td><td>output array for storage of signaled handles; must be at least the size of the handles input array </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout in seconds </td></tr>
    <tr><td class="paramname">timedOut</td><td>if non-null, set to true if timeout reached without any handle being signaled; set to false otherwise (output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of signaled handles (points into signaled array) </dd></dl>

</div>
</div>
<a id="af8a293cc66ff9b6f047b81e41cb697d9" name="af8a293cc66ff9b6f047b81e41cb697d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a293cc66ff9b6f047b81e41cb697d9">&#9670;&#160;</a></span>WaitForObjects() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt; wpi::WaitForObjects </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>handles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>signaled</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for one or more handles to be signaled. </p>
<p>Invalid handles are treated as signaled; the returned array will have the handle error bit set for any invalid handles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handles</td><td>array of handles to wait on </td></tr>
    <tr><td class="paramname">signaled</td><td>output array for storage of signaled handles; must be at least the size of the handles input array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of signaled handles (points into signaled array) </dd></dl>

</div>
</div>
<a id="a393fa6e883232d7af1d57d96218fd2f8" name="a393fa6e883232d7af1d57d96218fd2f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393fa6e883232d7af1d57d96218fd2f8">&#9670;&#160;</a></span>WaitForObjects() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt; wpi::WaitForObjects </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>handles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; <a class="el" href="_synchronization_8h.html#a395db0088ef39bbc22a576f62bfbdf07">WPI_Handle</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>signaled</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>timedOut</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for one or more handles to be signaled, with timeout. </p>
<p>Invalid handles are treated as signaled; the returned array will have the handle error bit set for any invalid handles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handles</td><td>array of handles to wait on </td></tr>
    <tr><td class="paramname">signaled</td><td>output array for storage of signaled handles; must be at least the size of the handles input array </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout in seconds </td></tr>
    <tr><td class="paramname">timedOut</td><td>if non-null, set to true if timeout reached without any handle being signaled; set to false otherwise (output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of signaled handles (points into signaled array) </dd></dl>

</div>
</div>
<a id="a0a330e37a0f2a3ac6bf2a664ea6d12db" name="a0a330e37a0f2a3ac6bf2a664ea6d12db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a330e37a0f2a3ac6bf2a664ea6d12db">&#9670;&#160;</a></span>wpi_unreachable_internal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::wpi_unreachable_internal </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>msg</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>line</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calls abort(), and prints the optional message to stderr. </p>
<p>Use the wpi_unreachable macro (that adds location info), instead of calling this function directly. </p>

</div>
</div>
<a id="a1d290fcc6f4ff08f10afc9eb18d5af16" name="a1d290fcc6f4ff08f10afc9eb18d5af16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d290fcc6f4ff08f10afc9eb18d5af16">&#9670;&#160;</a></span>WriteUleb128() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wpi::WriteUleb128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1raw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write unsigned LEB128 data. </p>
<p>Encode an unsigned LEB128 encoded datum. The algorithm is taken from Appendix C of the DWARF 3 spec. For information on the encodings refer to section "7.6 - Variable Length Data".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3dac2f55476ec2190adf33d5a123cf4" name="ab3dac2f55476ec2190adf33d5a123cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3dac2f55476ec2190adf33d5a123cf4">&#9670;&#160;</a></span>WriteUleb128() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::WriteUleb128 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_small_vector_impl.html">SmallVectorImpl</a>&lt; char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write unsigned LEB128 data. </p>
<p>Encode an unsigned LEB128 encoded datum. The algorithm is taken from Appendix C of the DWARF 3 spec. For information on the encodings refer to section "7.6 - Variable Length Data". Return the number of bytes written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The address where the ULEB128 data is to be stored. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa7bbf91a7aa1adadf235c7388ec0663" name="aaa7bbf91a7aa1adadf235c7388ec0663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7bbf91a7aa1adadf235c7388ec0663">&#9670;&#160;</a></span>xxh3_64bits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::xxh3_64bits </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const uint8_t &gt;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a776a14294ad0f23f615b831d908eb34d" name="a776a14294ad0f23f615b831d908eb34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776a14294ad0f23f615b831d908eb34d">&#9670;&#160;</a></span>xxh3_64bits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::xxh3_64bits </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa897f74e19d0de9754ab270fe2fdbd89" name="aa897f74e19d0de9754ab270fe2fdbd89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa897f74e19d0de9754ab270fe2fdbd89">&#9670;&#160;</a></span>xxHash64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::xxHash64 </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const uint8_t &gt;</td>          <td class="paramname"><span class="paramname"><em>Data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fd1bef2e08248159bc8fae9290ac160" name="a3fd1bef2e08248159bc8fae9290ac160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd1bef2e08248159bc8fae9290ac160">&#9670;&#160;</a></span>xxHash64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t wpi::xxHash64 </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>Data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a096e48bf0264a255eb2ff954146cc85b" name="a096e48bf0264a255eb2ff954146cc85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096e48bf0264a255eb2ff954146cc85b">&#9670;&#160;</a></span>BitReverseTable256</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char wpi::BitReverseTable256[256]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line"><span class="preprocessor">#define R2(n)                                      </span></div>
<div class="line"><span class="preprocessor">#define R4(n)                                                      </span></div>
<div class="line"><span class="preprocessor">#define R6(n)                                                   </span></div>
<div class="line">  <a class="code hl_define" href="_math_extras_8h.html#ace331bebb5bd2780b8dfb7e6e97db7dd">R6</a>(0), <a class="code hl_define" href="_math_extras_8h.html#ace331bebb5bd2780b8dfb7e6e97db7dd">R6</a>(2), <a class="code hl_define" href="_math_extras_8h.html#ace331bebb5bd2780b8dfb7e6e97db7dd">R6</a>(1), <a class="code hl_define" href="_math_extras_8h.html#ace331bebb5bd2780b8dfb7e6e97db7dd">R6</a>(3)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="a_math_extras_8h_html_ace331bebb5bd2780b8dfb7e6e97db7dd"><div class="ttname"><a href="_math_extras_8h.html#ace331bebb5bd2780b8dfb7e6e97db7dd">R6</a></div><div class="ttdeci">#define R6(n)</div></div>
</div><!-- fragment -->
<p>Macro compressed bit reversal table for 256 bits. </p>
<p><a href="http://graphics.stanford.edu/~seander/bithacks.html#BitReverseTable">http://graphics.stanford.edu/~seander/bithacks.html#BitReverseTable</a> </p>

</div>
</div>
<a id="ab3cecb2351a66db7a659706908ff8764" name="ab3cecb2351a66db7a659706908ff8764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3cecb2351a66db7a659706908ff8764">&#9670;&#160;</a></span>empty_array</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structwpi_1_1empty__array__t.html">empty_array_t</a> wpi::empty_array</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68147e630fcf898faec5b0f4cacd7214" name="a68147e630fcf898faec5b0f4cacd7214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68147e630fcf898faec5b0f4cacd7214">&#9670;&#160;</a></span>huge_valf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const float wpi::huge_valf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use this rather than HUGE_VALF; the latter causes warnings on MSVC. </p>

</div>
</div>
<a id="a9e441a1bfb8b548adcb3fd7e08eb3be0" name="a9e441a1bfb8b548adcb3fd7e08eb3be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e441a1bfb8b548adcb3fd7e08eb3be0">&#9670;&#160;</a></span>in_place</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structwpi_1_1in__place__t.html">in_place_t</a> wpi::in_place {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f1727b9890d66f5ef4750af330b072c" name="a0f1727b9890d66f5ef4750af330b072c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1727b9890d66f5ef4750af330b072c">&#9670;&#160;</a></span>IsNullable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::IsNullable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    std::is_pointer_v&lt;T&gt; || std::is_constructible_v&lt;T, std::nullptr_t&gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8de0a4446fe8d9ed31724a8b930aee57" name="a8de0a4446fe8d9ed31724a8b930aee57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de0a4446fe8d9ed31724a8b930aee57">&#9670;&#160;</a></span>kHandleTypeCSBase</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int wpi::kHandleTypeCSBase = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab51794df83caf0d2ee4dcd959aef6600" name="ab51794df83caf0d2ee4dcd959aef6600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab51794df83caf0d2ee4dcd959aef6600">&#9670;&#160;</a></span>kHandleTypeEvent</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int wpi::kHandleTypeEvent = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard types for handles. </p>

</div>
</div>
<a id="ae6b0fdd08ea9c5d05545f34d61daa6b3" name="ae6b0fdd08ea9c5d05545f34d61daa6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b0fdd08ea9c5d05545f34d61daa6b3">&#9670;&#160;</a></span>kHandleTypeHALBase</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int wpi::kHandleTypeHALBase = 48</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a99480131b4acc3346e92488fa6ef11c3" name="a99480131b4acc3346e92488fa6ef11c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99480131b4acc3346e92488fa6ef11c3">&#9670;&#160;</a></span>kHandleTypeNTBase</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int wpi::kHandleTypeNTBase = 16</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5da225411044fa616099a3373dbe6730" name="a5da225411044fa616099a3373dbe6730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da225411044fa616099a3373dbe6730">&#9670;&#160;</a></span>kHandleTypeSemaphore</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int wpi::kHandleTypeSemaphore = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0d975e6f2e33e12e3ba9f88f3abbcae" name="ac0d975e6f2e33e12e3ba9f88f3abbcae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d975e6f2e33e12e3ba9f88f3abbcae">&#9670;&#160;</a></span>kHandleTypeUserBase</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int wpi::kHandleTypeUserBase = 80</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd67a84f9a70d9cfcee1d5deb9f909cf" name="afd67a84f9a70d9cfcee1d5deb9f909cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd67a84f9a70d9cfcee1d5deb9f909cf">&#9670;&#160;</a></span>kInvalidHandle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int wpi::kInvalidHandle = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant representing an invalid handle. </p>

</div>
</div>
<a id="a74ddf62331eda674218d045fb5376c13" name="a74ddf62331eda674218d045fb5376c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ddf62331eda674218d045fb5376c13">&#9670;&#160;</a></span>SmallVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="_compiler_8h.html#a61e566d072949de225fa6912528beaf5">LLVM_GSL_OWNER</a> wpi::SmallVector</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forward declaration of <a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a> so that calculateSmallVectorDefaultInlinedElements can reference <code>sizeof(<a class="el" href="classwpi_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small.">SmallVector</a>&lt;T, 0&gt;)</code>. </p>

</div>
</div>
<a id="a8ec1d1c5281afa1fc4e4333abc544b45" name="a8ec1d1c5281afa1fc4e4333abc544b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec1d1c5281afa1fc4e4333abc544b45">&#9670;&#160;</a></span>unexpect</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structwpi_1_1unexpect__t.html">unexpect_t</a> wpi::unexpect {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacewpi.html">wpi</a></li>
    <li class="footer">Generated on Sun Oct 13 2024 07:19:01 for WPILibC++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
