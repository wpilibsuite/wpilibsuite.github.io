<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: /home/runner/work/allwpilib/allwpilib/apriltag/src/main/native/thirdparty/apriltag/include/common/matd.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="wpilib-128.png"/></td>
  <td id="projectalign">
   <div id="projectname">WPILibC++<span id="projectnumber">&#160;2025.1.1-beta-1-35-g9a5f73d</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('matd_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">matd.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;<a class="el" href="string_8h_source.html">string.h</a>&gt;</code><br />
</div>
<p><a href="matd_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmatd__t.html">matd_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a matrix structure for holding double-precision values with data in row-major order (i.e.  <a href="structmatd__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmatd__svd__t.html">matd_svd_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmatd__plu__t.html">matd_plu_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmatd__chol__t.html">matd_chol_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a double matrix with the Cholesky lower triangular matrix of A.  <a href="structmatd__chol__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a42779663d035cc0fc7aac90c20c12561" id="r_a42779663d035cc0fc7aac90c20c12561"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42779663d035cc0fc7aac90c20c12561">MATD_ALLOC</a>(name,  nrows,  ncols)</td></tr>
<tr class="separator:a42779663d035cc0fc7aac90c20c12561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26200dbba81e189f8137778652569c87" id="r_a26200dbba81e189f8137778652569c87"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26200dbba81e189f8137778652569c87">MATD_EPS</a>&#160;&#160;&#160;1e-8</td></tr>
<tr class="memdesc:a26200dbba81e189f8137778652569c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a small value which can be used in place of zero for approximating calculations which are singular at zero values (i.e.  <br /></td></tr>
<tr class="separator:a26200dbba81e189f8137778652569c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91b10b7048284897e819ed44410b875" id="r_ab91b10b7048284897e819ed44410b875"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab91b10b7048284897e819ed44410b875">MATD_EL</a>(m,  row,  col)</td></tr>
<tr class="memdesc:ab91b10b7048284897e819ed44410b875"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro to reference a specific <a class="el" href="structmatd__t.html" title="Defines a matrix structure for holding double-precision values with data in row-major order (i....">matd_t</a> data element given it's zero-based row and column indexes.  <br /></td></tr>
<tr class="separator:ab91b10b7048284897e819ed44410b875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55207d152a7d0341aa6850481f090374" id="r_a55207d152a7d0341aa6850481f090374"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55207d152a7d0341aa6850481f090374">MATD_SVD_NO_WARNINGS</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a55207d152a7d0341aa6850481f090374"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a13d34d28514d2bf76228c9813d6d11eb" id="r_a13d34d28514d2bf76228c9813d6d11eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__t.html">matd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13d34d28514d2bf76228c9813d6d11eb">matd_create</a> (int rows, int cols)</td></tr>
<tr class="memdesc:a13d34d28514d2bf76228c9813d6d11eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a double matrix with the given number of rows and columns (or a scalar in the case where rows=0 and/or cols=0).  <br /></td></tr>
<tr class="separator:a13d34d28514d2bf76228c9813d6d11eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c37cd6f2bd58b7e119e6060ecce2db" id="r_af4c37cd6f2bd58b7e119e6060ecce2db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__t.html">matd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4c37cd6f2bd58b7e119e6060ecce2db">matd_create_data</a> (int rows, int cols, const double *data)</td></tr>
<tr class="memdesc:af4c37cd6f2bd58b7e119e6060ecce2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a double matrix with the given number of rows and columns (or a scalar in the case where rows=0 and/or cols=0).  <br /></td></tr>
<tr class="separator:af4c37cd6f2bd58b7e119e6060ecce2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98025499e7294edda304f7e9f60b084e" id="r_a98025499e7294edda304f7e9f60b084e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__t.html">matd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98025499e7294edda304f7e9f60b084e">matd_create_dataf</a> (int rows, int cols, const float *data)</td></tr>
<tr class="memdesc:a98025499e7294edda304f7e9f60b084e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a double matrix with the given number of rows and columns (or a scalar in the case where rows=0 and/or cols=0).  <br /></td></tr>
<tr class="separator:a98025499e7294edda304f7e9f60b084e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271eb1bad7e026fb89450155becc8f52" id="r_a271eb1bad7e026fb89450155becc8f52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__t.html">matd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a271eb1bad7e026fb89450155becc8f52">matd_identity</a> (int dim)</td></tr>
<tr class="memdesc:a271eb1bad7e026fb89450155becc8f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a square identity matrix with the given number of rows (and therefore columns), or a scalar with value 1 in the case where dim=0.  <br /></td></tr>
<tr class="separator:a271eb1bad7e026fb89450155becc8f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675e5a3a55510a33a75a8fc13effd263" id="r_a675e5a3a55510a33a75a8fc13effd263"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__t.html">matd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a675e5a3a55510a33a75a8fc13effd263">matd_create_scalar</a> (double v)</td></tr>
<tr class="memdesc:a675e5a3a55510a33a75a8fc13effd263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a scalar with the supplied value 'v'.  <br /></td></tr>
<tr class="separator:a675e5a3a55510a33a75a8fc13effd263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40534e548037cd781db5e6e2bc0c1d21" id="r_a40534e548037cd781db5e6e2bc0c1d21"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40534e548037cd781db5e6e2bc0c1d21">matd_get</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *m, unsigned int row, unsigned int col)</td></tr>
<tr class="memdesc:a40534e548037cd781db5e6e2bc0c1d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the cell value for matrix 'm' at the given zero-based row and column index.  <br /></td></tr>
<tr class="separator:a40534e548037cd781db5e6e2bc0c1d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874d1fda64faa7f5bfd577072207fbc1" id="r_a874d1fda64faa7f5bfd577072207fbc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a874d1fda64faa7f5bfd577072207fbc1">matd_put</a> (<a class="el" href="structmatd__t.html">matd_t</a> *m, unsigned int row, unsigned int col, double value)</td></tr>
<tr class="memdesc:a874d1fda64faa7f5bfd577072207fbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the given value to the matrix cell at the given zero-based row and column index.  <br /></td></tr>
<tr class="separator:a874d1fda64faa7f5bfd577072207fbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ded3dd28178a6428b8dc5068b8b87de" id="r_a1ded3dd28178a6428b8dc5068b8b87de"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ded3dd28178a6428b8dc5068b8b87de">matd_get_scalar</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *m)</td></tr>
<tr class="memdesc:a1ded3dd28178a6428b8dc5068b8b87de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the scalar value of the given element ('m' must be a scalar).  <br /></td></tr>
<tr class="separator:a1ded3dd28178a6428b8dc5068b8b87de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c1fbf9c08531f4e3268a75fc5620de" id="r_ab1c1fbf9c08531f4e3268a75fc5620de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1c1fbf9c08531f4e3268a75fc5620de">matd_put_scalar</a> (<a class="el" href="structmatd__t.html">matd_t</a> *m, double value)</td></tr>
<tr class="memdesc:ab1c1fbf9c08531f4e3268a75fc5620de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the given value to the supplied scalar element ('m' must be a scalar).  <br /></td></tr>
<tr class="separator:ab1c1fbf9c08531f4e3268a75fc5620de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb3b73553b555105fe52b643a54da59" id="r_accb3b73553b555105fe52b643a54da59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__t.html">matd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accb3b73553b555105fe52b643a54da59">matd_copy</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *m)</td></tr>
<tr class="memdesc:accb3b73553b555105fe52b643a54da59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an exact copy of the supplied matrix 'm'.  <br /></td></tr>
<tr class="separator:accb3b73553b555105fe52b643a54da59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6231c3df06e4711cb25728e4931303eb" id="r_a6231c3df06e4711cb25728e4931303eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__t.html">matd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6231c3df06e4711cb25728e4931303eb">matd_select</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *a, unsigned int r0, int r1, unsigned int c0, int c1)</td></tr>
<tr class="memdesc:a6231c3df06e4711cb25728e4931303eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of a subset of the supplied matrix 'a'.  <br /></td></tr>
<tr class="separator:a6231c3df06e4711cb25728e4931303eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e23572241055971f84d3f4b29353e25" id="r_a3e23572241055971f84d3f4b29353e25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e23572241055971f84d3f4b29353e25">matd_print</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *m, const char *fmt)</td></tr>
<tr class="memdesc:a3e23572241055971f84d3f4b29353e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the supplied matrix 'm' to standard output by applying the supplied printf format specifier 'fmt' for each individual element.  <br /></td></tr>
<tr class="separator:a3e23572241055971f84d3f4b29353e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640f782a3fe1a35af0b87150cdba867c" id="r_a640f782a3fe1a35af0b87150cdba867c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a640f782a3fe1a35af0b87150cdba867c">matd_print_transpose</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *m, const char *fmt)</td></tr>
<tr class="memdesc:a640f782a3fe1a35af0b87150cdba867c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the transpose of the supplied matrix 'm' to standard output by applying the supplied printf format specifier 'fmt' for each individual element.  <br /></td></tr>
<tr class="separator:a640f782a3fe1a35af0b87150cdba867c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7049cfecaf6df6512b99373c4cdfeb4" id="r_ab7049cfecaf6df6512b99373c4cdfeb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__t.html">matd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7049cfecaf6df6512b99373c4cdfeb4">matd_add</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *a, const <a class="el" href="structmatd__t.html">matd_t</a> *b)</td></tr>
<tr class="memdesc:ab7049cfecaf6df6512b99373c4cdfeb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the two supplied matrices together, cell-by-cell, and returns the results as a new matrix of the same dimensions.  <br /></td></tr>
<tr class="separator:ab7049cfecaf6df6512b99373c4cdfeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca3f8e92a31656004f5428bfad28de3" id="r_a1ca3f8e92a31656004f5428bfad28de3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ca3f8e92a31656004f5428bfad28de3">matd_add_inplace</a> (<a class="el" href="structmatd__t.html">matd_t</a> *a, const <a class="el" href="structmatd__t.html">matd_t</a> *b)</td></tr>
<tr class="memdesc:a1ca3f8e92a31656004f5428bfad28de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the values of 'b' to matrix 'a', cell-by-cell, and overwrites the contents of 'a' with the results.  <br /></td></tr>
<tr class="separator:a1ca3f8e92a31656004f5428bfad28de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1246fff6c8cdf69b4f8355ff6c938f37" id="r_a1246fff6c8cdf69b4f8355ff6c938f37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__t.html">matd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1246fff6c8cdf69b4f8355ff6c938f37">matd_subtract</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *a, const <a class="el" href="structmatd__t.html">matd_t</a> *b)</td></tr>
<tr class="memdesc:a1246fff6c8cdf69b4f8355ff6c938f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts matrix 'b' from matrix 'a', cell-by-cell, and returns the results as a new matrix of the same dimensions.  <br /></td></tr>
<tr class="separator:a1246fff6c8cdf69b4f8355ff6c938f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed044e0c402a7eaee9a73f56785347d3" id="r_aed044e0c402a7eaee9a73f56785347d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed044e0c402a7eaee9a73f56785347d3">matd_subtract_inplace</a> (<a class="el" href="structmatd__t.html">matd_t</a> *a, const <a class="el" href="structmatd__t.html">matd_t</a> *b)</td></tr>
<tr class="memdesc:aed044e0c402a7eaee9a73f56785347d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the values of 'b' from matrix 'a', cell-by-cell, and overwrites the contents of 'a' with the results.  <br /></td></tr>
<tr class="separator:aed044e0c402a7eaee9a73f56785347d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5302cbc1e5611f8fbb83ff4ff2d52413" id="r_a5302cbc1e5611f8fbb83ff4ff2d52413"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__t.html">matd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5302cbc1e5611f8fbb83ff4ff2d52413">matd_scale</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *a, double s)</td></tr>
<tr class="memdesc:a5302cbc1e5611f8fbb83ff4ff2d52413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales all cell values of matrix 'a' by the given scale factor 's' and returns the result as a new matrix of the same dimensions.  <br /></td></tr>
<tr class="separator:a5302cbc1e5611f8fbb83ff4ff2d52413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a72583244f443a84f7d535ac8aef58" id="r_a55a72583244f443a84f7d535ac8aef58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55a72583244f443a84f7d535ac8aef58">matd_scale_inplace</a> (<a class="el" href="structmatd__t.html">matd_t</a> *a, double s)</td></tr>
<tr class="memdesc:a55a72583244f443a84f7d535ac8aef58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales all cell values of matrix 'a' by the given scale factor 's' and overwrites the contents of 'a' with the results.  <br /></td></tr>
<tr class="separator:a55a72583244f443a84f7d535ac8aef58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9770bcaefe9b0b3907f86f09e30ded96" id="r_a9770bcaefe9b0b3907f86f09e30ded96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__t.html">matd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9770bcaefe9b0b3907f86f09e30ded96">matd_multiply</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *a, const <a class="el" href="structmatd__t.html">matd_t</a> *b)</td></tr>
<tr class="memdesc:a9770bcaefe9b0b3907f86f09e30ded96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the two supplied matrices together (matrix product), and returns the results as a new matrix.  <br /></td></tr>
<tr class="separator:a9770bcaefe9b0b3907f86f09e30ded96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9678e906f52031122212816a0832640d" id="r_a9678e906f52031122212816a0832640d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__t.html">matd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9678e906f52031122212816a0832640d">matd_transpose</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *a)</td></tr>
<tr class="memdesc:a9678e906f52031122212816a0832640d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a matrix which is the transpose of the supplied matrix 'a'.  <br /></td></tr>
<tr class="separator:a9678e906f52031122212816a0832640d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352bb64f091032cae5089efd319e03a3" id="r_a352bb64f091032cae5089efd319e03a3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a352bb64f091032cae5089efd319e03a3">matd_det</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *a)</td></tr>
<tr class="memdesc:a352bb64f091032cae5089efd319e03a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the determinant of the supplied matrix 'a'.  <br /></td></tr>
<tr class="separator:a352bb64f091032cae5089efd319e03a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c2d6eaf425fe9711db7d4e2cd3e940" id="r_a22c2d6eaf425fe9711db7d4e2cd3e940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__t.html">matd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22c2d6eaf425fe9711db7d4e2cd3e940">matd_inverse</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *a)</td></tr>
<tr class="memdesc:a22c2d6eaf425fe9711db7d4e2cd3e940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to compute an inverse of the supplied matrix 'a' and return it as a new matrix.  <br /></td></tr>
<tr class="separator:a22c2d6eaf425fe9711db7d4e2cd3e940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25bd8c392bc00c5d1e40afc10f502d3" id="r_ac25bd8c392bc00c5d1e40afc10f502d3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac25bd8c392bc00c5d1e40afc10f502d3">matd_set_data</a> (<a class="el" href="structmatd__t.html">matd_t</a> *m, const double *data)</td></tr>
<tr class="separator:ac25bd8c392bc00c5d1e40afc10f502d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0dbbc8a2dfd7bdf4743d3d4bcb3129" id="r_acd0dbbc8a2dfd7bdf4743d3d4bcb3129"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd0dbbc8a2dfd7bdf4743d3d4bcb3129">matd_is_scalar</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *a)</td></tr>
<tr class="memdesc:acd0dbbc8a2dfd7bdf4743d3d4bcb3129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the supplied matrix 'a' is a scalar (positive return) or not (zero return, indicating a matrix of dimensions at least 1x1).  <br /></td></tr>
<tr class="separator:acd0dbbc8a2dfd7bdf4743d3d4bcb3129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465f794a45e87c2a8943910cd93419e9" id="r_a465f794a45e87c2a8943910cd93419e9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a465f794a45e87c2a8943910cd93419e9">matd_is_vector</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *a)</td></tr>
<tr class="memdesc:a465f794a45e87c2a8943910cd93419e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the supplied matrix 'a' is a row or column vector (positive return) or not (zero return, indicating either 'a' is a scalar or a matrix with at least one dimension &gt; 1).  <br /></td></tr>
<tr class="separator:a465f794a45e87c2a8943910cd93419e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed2fd24532ca3e1ceeab75fbd4c0803" id="r_afed2fd24532ca3e1ceeab75fbd4c0803"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afed2fd24532ca3e1ceeab75fbd4c0803">matd_is_vector_len</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *a, int len)</td></tr>
<tr class="memdesc:afed2fd24532ca3e1ceeab75fbd4c0803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the supplied matrix 'a' is a row or column vector with a dimension of 'len' (positive return) or not (zero return).  <br /></td></tr>
<tr class="separator:afed2fd24532ca3e1ceeab75fbd4c0803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5a6d427758bfc8a15e57520b1e6b0f" id="r_abf5a6d427758bfc8a15e57520b1e6b0f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf5a6d427758bfc8a15e57520b1e6b0f">matd_vec_mag</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *a)</td></tr>
<tr class="memdesc:abf5a6d427758bfc8a15e57520b1e6b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the magnitude of the supplied matrix 'a'.  <br /></td></tr>
<tr class="separator:abf5a6d427758bfc8a15e57520b1e6b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d5ee6905e6f6eed40ea2ebb9c77b43" id="r_a17d5ee6905e6f6eed40ea2ebb9c77b43"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17d5ee6905e6f6eed40ea2ebb9c77b43">matd_vec_dist</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *a, const <a class="el" href="structmatd__t.html">matd_t</a> *b)</td></tr>
<tr class="memdesc:a17d5ee6905e6f6eed40ea2ebb9c77b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the magnitude of the distance between the points represented by matrices 'a' and 'b'.  <br /></td></tr>
<tr class="separator:a17d5ee6905e6f6eed40ea2ebb9c77b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5189e1ae47e37728583e1497a85863e" id="r_ad5189e1ae47e37728583e1497a85863e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5189e1ae47e37728583e1497a85863e">matd_vec_dist_n</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *a, const <a class="el" href="structmatd__t.html">matd_t</a> *b, int n)</td></tr>
<tr class="memdesc:ad5189e1ae47e37728583e1497a85863e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as matd_vec_dist, but only uses the first 'n' terms to compute distance.  <br /></td></tr>
<tr class="separator:ad5189e1ae47e37728583e1497a85863e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc51cdf6a4e237f941c2078980aeb32" id="r_a5bc51cdf6a4e237f941c2078980aeb32"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bc51cdf6a4e237f941c2078980aeb32">matd_vec_dot_product</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *a, const <a class="el" href="structmatd__t.html">matd_t</a> *b)</td></tr>
<tr class="memdesc:a5bc51cdf6a4e237f941c2078980aeb32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot product of two vectors.  <br /></td></tr>
<tr class="separator:a5bc51cdf6a4e237f941c2078980aeb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b15ab1f567267f25212ac56959d2bf2" id="r_a0b15ab1f567267f25212ac56959d2bf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__t.html">matd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b15ab1f567267f25212ac56959d2bf2">matd_vec_normalize</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *a)</td></tr>
<tr class="memdesc:a0b15ab1f567267f25212ac56959d2bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the normalization of the supplied vector 'a' (i.e.  <br /></td></tr>
<tr class="separator:a0b15ab1f567267f25212ac56959d2bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca13e6eedc8e262d07188fa8008bb00b" id="r_aca13e6eedc8e262d07188fa8008bb00b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__t.html">matd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca13e6eedc8e262d07188fa8008bb00b">matd_crossproduct</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *a, const <a class="el" href="structmatd__t.html">matd_t</a> *b)</td></tr>
<tr class="memdesc:aca13e6eedc8e262d07188fa8008bb00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cross product of supplied matrices 'a' and 'b' (i.e.  <br /></td></tr>
<tr class="separator:aca13e6eedc8e262d07188fa8008bb00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1f52649f7581add5955e4b1b01d700" id="r_adf1f52649f7581add5955e4b1b01d700"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf1f52649f7581add5955e4b1b01d700">matd_err_inf</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *a, const <a class="el" href="structmatd__t.html">matd_t</a> *b)</td></tr>
<tr class="separator:adf1f52649f7581add5955e4b1b01d700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5351508c9b66affb03b206bb6bf243b" id="r_af5351508c9b66affb03b206bb6bf243b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__t.html">matd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5351508c9b66affb03b206bb6bf243b">matd_op</a> (const char *expr,...)</td></tr>
<tr class="memdesc:af5351508c9b66affb03b206bb6bf243b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new matrix by applying a series of matrix operations, as expressed in 'expr', to the supplied list of matrices.  <br /></td></tr>
<tr class="separator:af5351508c9b66affb03b206bb6bf243b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808f0a3a6e8dcebcb2c7f607aa838ea3" id="r_a808f0a3a6e8dcebcb2c7f607aa838ea3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a808f0a3a6e8dcebcb2c7f607aa838ea3">matd_destroy</a> (<a class="el" href="structmatd__t.html">matd_t</a> *m)</td></tr>
<tr class="memdesc:a808f0a3a6e8dcebcb2c7f607aa838ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory associated with matrix 'm', being the result of an earlier call to a matd_*() function, after which 'm' will no longer be usable.  <br /></td></tr>
<tr class="separator:a808f0a3a6e8dcebcb2c7f607aa838ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22fe516092a54bcf11647d93f4e5896" id="r_ab22fe516092a54bcf11647d93f4e5896"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__svd__t.html">matd_svd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab22fe516092a54bcf11647d93f4e5896">matd_svd</a> (<a class="el" href="structmatd__t.html">matd_t</a> *A)</td></tr>
<tr class="memdesc:ab22fe516092a54bcf11647d93f4e5896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a complete SVD of a matrix.  <br /></td></tr>
<tr class="separator:ab22fe516092a54bcf11647d93f4e5896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ead9bf5c09779e4f3b2be8b5aec918" id="r_a88ead9bf5c09779e4f3b2be8b5aec918"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__svd__t.html">matd_svd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88ead9bf5c09779e4f3b2be8b5aec918">matd_svd_flags</a> (<a class="el" href="structmatd__t.html">matd_t</a> *A, int flags)</td></tr>
<tr class="separator:a88ead9bf5c09779e4f3b2be8b5aec918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d157d1e1512356fdadb06cbbe3b955e" id="r_a1d157d1e1512356fdadb06cbbe3b955e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__plu__t.html">matd_plu_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d157d1e1512356fdadb06cbbe3b955e">matd_plu</a> (const <a class="el" href="structmatd__t.html">matd_t</a> *a)</td></tr>
<tr class="separator:a1d157d1e1512356fdadb06cbbe3b955e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae328c586b71d1212293b71a4d661a5f5" id="r_ae328c586b71d1212293b71a4d661a5f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae328c586b71d1212293b71a4d661a5f5">matd_plu_destroy</a> (<a class="el" href="structmatd__plu__t.html">matd_plu_t</a> *mlu)</td></tr>
<tr class="separator:ae328c586b71d1212293b71a4d661a5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb942820e49d324878cfccd1a5e63a1" id="r_a1fb942820e49d324878cfccd1a5e63a1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fb942820e49d324878cfccd1a5e63a1">matd_plu_det</a> (const <a class="el" href="structmatd__plu__t.html">matd_plu_t</a> *lu)</td></tr>
<tr class="separator:a1fb942820e49d324878cfccd1a5e63a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46194294c0bf9eec23da57d9bd89c500" id="r_a46194294c0bf9eec23da57d9bd89c500"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__t.html">matd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46194294c0bf9eec23da57d9bd89c500">matd_plu_p</a> (const <a class="el" href="structmatd__plu__t.html">matd_plu_t</a> *lu)</td></tr>
<tr class="separator:a46194294c0bf9eec23da57d9bd89c500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf74fd40d7edf5a83267dc261f602fad" id="r_abf74fd40d7edf5a83267dc261f602fad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__t.html">matd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf74fd40d7edf5a83267dc261f602fad">matd_plu_l</a> (const <a class="el" href="structmatd__plu__t.html">matd_plu_t</a> *lu)</td></tr>
<tr class="separator:abf74fd40d7edf5a83267dc261f602fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25ec37ffe68616d947f9c50d4155fe1" id="r_ab25ec37ffe68616d947f9c50d4155fe1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__t.html">matd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab25ec37ffe68616d947f9c50d4155fe1">matd_plu_u</a> (const <a class="el" href="structmatd__plu__t.html">matd_plu_t</a> *lu)</td></tr>
<tr class="separator:ab25ec37ffe68616d947f9c50d4155fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadefc27e4c1aa49a110aa8b95ad37750" id="r_aadefc27e4c1aa49a110aa8b95ad37750"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__t.html">matd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadefc27e4c1aa49a110aa8b95ad37750">matd_plu_solve</a> (const <a class="el" href="structmatd__plu__t.html">matd_plu_t</a> *mlu, const <a class="el" href="structmatd__t.html">matd_t</a> *b)</td></tr>
<tr class="separator:aadefc27e4c1aa49a110aa8b95ad37750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac441cc266f6110eafe191907f6bc99" id="r_a6ac441cc266f6110eafe191907f6bc99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__t.html">matd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ac441cc266f6110eafe191907f6bc99">matd_solve</a> (<a class="el" href="structmatd__t.html">matd_t</a> *A, <a class="el" href="structmatd__t.html">matd_t</a> *b)</td></tr>
<tr class="separator:a6ac441cc266f6110eafe191907f6bc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c7e37e624610b19a2941a9871d42cd" id="r_ae9c7e37e624610b19a2941a9871d42cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__chol__t.html">matd_chol_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9c7e37e624610b19a2941a9871d42cd">matd_chol</a> (<a class="el" href="structmatd__t.html">matd_t</a> *A)</td></tr>
<tr class="separator:ae9c7e37e624610b19a2941a9871d42cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cfa73ea7200652b0049e8703d61f5ab" id="r_a9cfa73ea7200652b0049e8703d61f5ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__t.html">matd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cfa73ea7200652b0049e8703d61f5ab">matd_chol_solve</a> (const <a class="el" href="structmatd__chol__t.html">matd_chol_t</a> *chol, const <a class="el" href="structmatd__t.html">matd_t</a> *b)</td></tr>
<tr class="separator:a9cfa73ea7200652b0049e8703d61f5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9516fabf381ec6b47302e2f50ffd791a" id="r_a9516fabf381ec6b47302e2f50ffd791a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9516fabf381ec6b47302e2f50ffd791a">matd_chol_destroy</a> (<a class="el" href="structmatd__chol__t.html">matd_chol_t</a> *chol)</td></tr>
<tr class="separator:a9516fabf381ec6b47302e2f50ffd791a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3b2246aab3c1de5758e3bfbdb27181" id="r_a4c3b2246aab3c1de5758e3bfbdb27181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmatd__t.html">matd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c3b2246aab3c1de5758e3bfbdb27181">matd_chol_inverse</a> (<a class="el" href="structmatd__t.html">matd_t</a> *a)</td></tr>
<tr class="separator:a4c3b2246aab3c1de5758e3bfbdb27181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e94a50d4a4e01d71eb632ccb136b12" id="r_ae6e94a50d4a4e01d71eb632ccb136b12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6e94a50d4a4e01d71eb632ccb136b12">matd_ltransposetriangle_solve</a> (<a class="el" href="structmatd__t.html">matd_t</a> *u, const double *b, double *x)</td></tr>
<tr class="separator:ae6e94a50d4a4e01d71eb632ccb136b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d78e4e226314f5592ab770c5922e23" id="r_ac7d78e4e226314f5592ab770c5922e23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7d78e4e226314f5592ab770c5922e23">matd_ltriangle_solve</a> (<a class="el" href="structmatd__t.html">matd_t</a> *u, const double *b, double *x)</td></tr>
<tr class="separator:ac7d78e4e226314f5592ab770c5922e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae612ff9e9640281025b4d5127b9b1023" id="r_ae612ff9e9640281025b4d5127b9b1023"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae612ff9e9640281025b4d5127b9b1023">matd_utriangle_solve</a> (<a class="el" href="structmatd__t.html">matd_t</a> *u, const double *b, double *x)</td></tr>
<tr class="separator:ae612ff9e9640281025b4d5127b9b1023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9913d2fe1f2e2162b6db7f8fd8aae9c0" id="r_a9913d2fe1f2e2162b6db7f8fd8aae9c0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9913d2fe1f2e2162b6db7f8fd8aae9c0">matd_max</a> (<a class="el" href="structmatd__t.html">matd_t</a> *m)</td></tr>
<tr class="separator:a9913d2fe1f2e2162b6db7f8fd8aae9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a42779663d035cc0fc7aac90c20c12561" name="a42779663d035cc0fc7aac90c20c12561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42779663d035cc0fc7aac90c20c12561">&#9670;&#160;</a></span>MATD_ALLOC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MATD_ALLOC</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nrows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>ncols</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordtype">double</span> name ## _storage [nrows*ncols]; <a class="code hl_struct" href="structmatd__t.html">matd_t</a> name = { .nrows = nrows, .ncols = ncols, .data = &amp;name ## _storage };</div>
<div class="ttc" id="astructmatd__t_html"><div class="ttname"><a href="structmatd__t.html">matd_t</a></div><div class="ttdoc">Defines a matrix structure for holding double-precision values with data in row-major order (i....</div><div class="ttdef"><b>Definition</b> matd.h:46</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab91b10b7048284897e819ed44410b875" name="ab91b10b7048284897e819ed44410b875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91b10b7048284897e819ed44410b875">&#9670;&#160;</a></span>MATD_EL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MATD_EL</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(m)-&gt;data[((row)*(m)-&gt;ncols + (col))]</div>
</div><!-- fragment -->
<p>A macro to reference a specific <a class="el" href="structmatd__t.html" title="Defines a matrix structure for holding double-precision values with data in row-major order (i....">matd_t</a> data element given it's zero-based row and column indexes. </p>
<p>Suitable for both retrieval and assignment. </p>

</div>
</div>
<a id="a26200dbba81e189f8137778652569c87" name="a26200dbba81e189f8137778652569c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26200dbba81e189f8137778652569c87">&#9670;&#160;</a></span>MATD_EPS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MATD_EPS&#160;&#160;&#160;1e-8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a small value which can be used in place of zero for approximating calculations which are singular at zero values (i.e. </p>
<p>inverting a matrix with a zero or near-zero determinant). </p>

</div>
</div>
<a id="a55207d152a7d0341aa6850481f090374" name="a55207d152a7d0341aa6850481f090374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55207d152a7d0341aa6850481f090374">&#9670;&#160;</a></span>MATD_SVD_NO_WARNINGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MATD_SVD_NO_WARNINGS&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab7049cfecaf6df6512b99373c4cdfeb4" name="ab7049cfecaf6df6512b99373c4cdfeb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7049cfecaf6df6512b99373c4cdfeb4">&#9670;&#160;</a></span>matd_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__t.html">matd_t</a> * matd_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the two supplied matrices together, cell-by-cell, and returns the results as a new matrix of the same dimensions. </p>
<p>The supplied matrices must have identical dimensions. It is the caller's responsibility to call <a class="el" href="#a808f0a3a6e8dcebcb2c7f607aa838ea3" title="Frees the memory associated with matrix &#39;m&#39;, being the result of an earlier call to a matd_*() functi...">matd_destroy()</a> on the returned matrix. </p>

</div>
</div>
<a id="a1ca3f8e92a31656004f5428bfad28de3" name="a1ca3f8e92a31656004f5428bfad28de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca3f8e92a31656004f5428bfad28de3">&#9670;&#160;</a></span>matd_add_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matd_add_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the values of 'b' to matrix 'a', cell-by-cell, and overwrites the contents of 'a' with the results. </p>
<p>The supplied matrices must have identical dimensions. </p>

</div>
</div>
<a id="ae9c7e37e624610b19a2941a9871d42cd" name="ae9c7e37e624610b19a2941a9871d42cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c7e37e624610b19a2941a9871d42cd">&#9670;&#160;</a></span>matd_chol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__chol__t.html">matd_chol_t</a> * matd_chol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9516fabf381ec6b47302e2f50ffd791a" name="a9516fabf381ec6b47302e2f50ffd791a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9516fabf381ec6b47302e2f50ffd791a">&#9670;&#160;</a></span>matd_chol_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matd_chol_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatd__chol__t.html">matd_chol_t</a> *</td>          <td class="paramname"><span class="paramname"><em>chol</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c3b2246aab3c1de5758e3bfbdb27181" name="a4c3b2246aab3c1de5758e3bfbdb27181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3b2246aab3c1de5758e3bfbdb27181">&#9670;&#160;</a></span>matd_chol_inverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__t.html">matd_t</a> * matd_chol_inverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9cfa73ea7200652b0049e8703d61f5ab" name="a9cfa73ea7200652b0049e8703d61f5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cfa73ea7200652b0049e8703d61f5ab">&#9670;&#160;</a></span>matd_chol_solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__t.html">matd_t</a> * matd_chol_solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__chol__t.html">matd_chol_t</a> *</td>          <td class="paramname"><span class="paramname"><em>chol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="accb3b73553b555105fe52b643a54da59" name="accb3b73553b555105fe52b643a54da59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb3b73553b555105fe52b643a54da59">&#9670;&#160;</a></span>matd_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__t.html">matd_t</a> * matd_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an exact copy of the supplied matrix 'm'. </p>
<p>It is the caller's responsibility to call <a class="el" href="#a808f0a3a6e8dcebcb2c7f607aa838ea3" title="Frees the memory associated with matrix &#39;m&#39;, being the result of an earlier call to a matd_*() functi...">matd_destroy()</a> on the returned matrix. </p>

</div>
</div>
<a id="a13d34d28514d2bf76228c9813d6d11eb" name="a13d34d28514d2bf76228c9813d6d11eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d34d28514d2bf76228c9813d6d11eb">&#9670;&#160;</a></span>matd_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__t.html">matd_t</a> * matd_create </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a double matrix with the given number of rows and columns (or a scalar in the case where rows=0 and/or cols=0). </p>
<p>All data elements will be initialized to zero. It is the caller's responsibility to call <a class="el" href="#a808f0a3a6e8dcebcb2c7f607aa838ea3" title="Frees the memory associated with matrix &#39;m&#39;, being the result of an earlier call to a matd_*() functi...">matd_destroy()</a> on the returned matrix. </p>

</div>
</div>
<a id="af4c37cd6f2bd58b7e119e6060ecce2db" name="af4c37cd6f2bd58b7e119e6060ecce2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c37cd6f2bd58b7e119e6060ecce2db">&#9670;&#160;</a></span>matd_create_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__t.html">matd_t</a> * matd_create_data </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a double matrix with the given number of rows and columns (or a scalar in the case where rows=0 and/or cols=0). </p>
<p>All data elements will be initialized using the supplied array of data, which must contain at least rows*cols elements, arranged in row-major order (i.e. index = row*ncols + col). It is the caller's responsibility to call <a class="el" href="#a808f0a3a6e8dcebcb2c7f607aa838ea3" title="Frees the memory associated with matrix &#39;m&#39;, being the result of an earlier call to a matd_*() functi...">matd_destroy()</a> on the returned matrix. </p>

</div>
</div>
<a id="a98025499e7294edda304f7e9f60b084e" name="a98025499e7294edda304f7e9f60b084e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98025499e7294edda304f7e9f60b084e">&#9670;&#160;</a></span>matd_create_dataf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__t.html">matd_t</a> * matd_create_dataf </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a double matrix with the given number of rows and columns (or a scalar in the case where rows=0 and/or cols=0). </p>
<p>All data elements will be initialized using the supplied array of float data, which must contain at least rows*cols elements, arranged in row-major order (i.e. index = row*ncols + col). It is the caller's responsibility to call <a class="el" href="#a808f0a3a6e8dcebcb2c7f607aa838ea3" title="Frees the memory associated with matrix &#39;m&#39;, being the result of an earlier call to a matd_*() functi...">matd_destroy()</a> on the returned matrix. </p>

</div>
</div>
<a id="a675e5a3a55510a33a75a8fc13effd263" name="a675e5a3a55510a33a75a8fc13effd263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675e5a3a55510a33a75a8fc13effd263">&#9670;&#160;</a></span>matd_create_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__t.html">matd_t</a> * matd_create_scalar </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a scalar with the supplied value 'v'. </p>
<p>It is the caller's responsibility to call <a class="el" href="#a808f0a3a6e8dcebcb2c7f607aa838ea3" title="Frees the memory associated with matrix &#39;m&#39;, being the result of an earlier call to a matd_*() functi...">matd_destroy()</a> on the returned matrix.</p>
<p>NOTE: Scalars are different than 1x1 matrices (implementation note: they are encoded as 0x0 matrices). For example: for matrices A*B, A and B must both have specific dimensions. However, if A is a scalar, there are no restrictions on the size of B. </p>

</div>
</div>
<a id="aca13e6eedc8e262d07188fa8008bb00b" name="aca13e6eedc8e262d07188fa8008bb00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca13e6eedc8e262d07188fa8008bb00b">&#9670;&#160;</a></span>matd_crossproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__t.html">matd_t</a> * matd_crossproduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the cross product of supplied matrices 'a' and 'b' (i.e. </p>
<p>a x b) and returns it as a new matrix. Both 'a' and 'b' must be vectors of dimension 3, but can be either row or column vectors. It is the caller's responsibility to call <a class="el" href="#a808f0a3a6e8dcebcb2c7f607aa838ea3" title="Frees the memory associated with matrix &#39;m&#39;, being the result of an earlier call to a matd_*() functi...">matd_destroy()</a> on the returned matrix. </p>

</div>
</div>
<a id="a808f0a3a6e8dcebcb2c7f607aa838ea3" name="a808f0a3a6e8dcebcb2c7f607aa838ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808f0a3a6e8dcebcb2c7f607aa838ea3">&#9670;&#160;</a></span>matd_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matd_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the memory associated with matrix 'm', being the result of an earlier call to a matd_*() function, after which 'm' will no longer be usable. </p>

</div>
</div>
<a id="a352bb64f091032cae5089efd319e03a3" name="a352bb64f091032cae5089efd319e03a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352bb64f091032cae5089efd319e03a3">&#9670;&#160;</a></span>matd_det()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double matd_det </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the determinant of the supplied matrix 'a'. </p>

</div>
</div>
<a id="adf1f52649f7581add5955e4b1b01d700" name="adf1f52649f7581add5955e4b1b01d700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1f52649f7581add5955e4b1b01d700">&#9670;&#160;</a></span>matd_err_inf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double matd_err_inf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a40534e548037cd781db5e6e2bc0c1d21" name="a40534e548037cd781db5e6e2bc0c1d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40534e548037cd781db5e6e2bc0c1d21">&#9670;&#160;</a></span>matd_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double matd_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the cell value for matrix 'm' at the given zero-based row and column index. </p>
<p>Performs more thorough validation checking than <a class="el" href="#ab91b10b7048284897e819ed44410b875" title="A macro to reference a specific matd_t data element given it&#39;s zero-based row and column indexes.">MATD_EL()</a>. </p>

</div>
</div>
<a id="a1ded3dd28178a6428b8dc5068b8b87de" name="a1ded3dd28178a6428b8dc5068b8b87de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ded3dd28178a6428b8dc5068b8b87de">&#9670;&#160;</a></span>matd_get_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double matd_get_scalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the scalar value of the given element ('m' must be a scalar). </p>
<p>Performs more thorough validation checking than <a class="el" href="#ab91b10b7048284897e819ed44410b875" title="A macro to reference a specific matd_t data element given it&#39;s zero-based row and column indexes.">MATD_EL()</a>. </p>

</div>
</div>
<a id="a271eb1bad7e026fb89450155becc8f52" name="a271eb1bad7e026fb89450155becc8f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a271eb1bad7e026fb89450155becc8f52">&#9670;&#160;</a></span>matd_identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__t.html">matd_t</a> * matd_identity </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dim</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a square identity matrix with the given number of rows (and therefore columns), or a scalar with value 1 in the case where dim=0. </p>
<p>It is the caller's responsibility to call <a class="el" href="#a808f0a3a6e8dcebcb2c7f607aa838ea3" title="Frees the memory associated with matrix &#39;m&#39;, being the result of an earlier call to a matd_*() functi...">matd_destroy()</a> on the returned matrix. </p>

</div>
</div>
<a id="a22c2d6eaf425fe9711db7d4e2cd3e940" name="a22c2d6eaf425fe9711db7d4e2cd3e940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c2d6eaf425fe9711db7d4e2cd3e940">&#9670;&#160;</a></span>matd_inverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__t.html">matd_t</a> * matd_inverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to compute an inverse of the supplied matrix 'a' and return it as a new matrix. </p>
<p>This is strictly only possible if the determinant of 'a' is non-zero (matd_det(a) != 0).</p>
<p>If the determinant is zero, NULL is returned. It is otherwise the caller's responsibility to cope with the results caused by poorly conditioned matrices. (E.g.., if such a situation is likely to arise, compute the pseudo-inverse from the SVD.) </p>

</div>
</div>
<a id="acd0dbbc8a2dfd7bdf4743d3d4bcb3129" name="acd0dbbc8a2dfd7bdf4743d3d4bcb3129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0dbbc8a2dfd7bdf4743d3d4bcb3129">&#9670;&#160;</a></span>matd_is_scalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int matd_is_scalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the supplied matrix 'a' is a scalar (positive return) or not (zero return, indicating a matrix of dimensions at least 1x1). </p>

</div>
</div>
<a id="a465f794a45e87c2a8943910cd93419e9" name="a465f794a45e87c2a8943910cd93419e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465f794a45e87c2a8943910cd93419e9">&#9670;&#160;</a></span>matd_is_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int matd_is_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the supplied matrix 'a' is a row or column vector (positive return) or not (zero return, indicating either 'a' is a scalar or a matrix with at least one dimension &gt; 1). </p>

</div>
</div>
<a id="afed2fd24532ca3e1ceeab75fbd4c0803" name="afed2fd24532ca3e1ceeab75fbd4c0803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afed2fd24532ca3e1ceeab75fbd4c0803">&#9670;&#160;</a></span>matd_is_vector_len()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int matd_is_vector_len </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the supplied matrix 'a' is a row or column vector with a dimension of 'len' (positive return) or not (zero return). </p>

</div>
</div>
<a id="ae6e94a50d4a4e01d71eb632ccb136b12" name="ae6e94a50d4a4e01d71eb632ccb136b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e94a50d4a4e01d71eb632ccb136b12">&#9670;&#160;</a></span>matd_ltransposetriangle_solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matd_ltransposetriangle_solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7d78e4e226314f5592ab770c5922e23" name="ac7d78e4e226314f5592ab770c5922e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d78e4e226314f5592ab770c5922e23">&#9670;&#160;</a></span>matd_ltriangle_solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matd_ltriangle_solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9913d2fe1f2e2162b6db7f8fd8aae9c0" name="a9913d2fe1f2e2162b6db7f8fd8aae9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9913d2fe1f2e2162b6db7f8fd8aae9c0">&#9670;&#160;</a></span>matd_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double matd_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9770bcaefe9b0b3907f86f09e30ded96" name="a9770bcaefe9b0b3907f86f09e30ded96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9770bcaefe9b0b3907f86f09e30ded96">&#9670;&#160;</a></span>matd_multiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__t.html">matd_t</a> * matd_multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies the two supplied matrices together (matrix product), and returns the results as a new matrix. </p>
<p>The supplied matrices must have dimensions such that columns(a) = rows(b). The returned matrix will have a row count of rows(a) and a column count of columns(b). It is the caller's responsibility to call <a class="el" href="#a808f0a3a6e8dcebcb2c7f607aa838ea3" title="Frees the memory associated with matrix &#39;m&#39;, being the result of an earlier call to a matd_*() functi...">matd_destroy()</a> on the returned matrix. </p>

</div>
</div>
<a id="af5351508c9b66affb03b206bb6bf243b" name="af5351508c9b66affb03b206bb6bf243b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5351508c9b66affb03b206bb6bf243b">&#9670;&#160;</a></span>matd_op()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__t.html">matd_t</a> * matd_op </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new matrix by applying a series of matrix operations, as expressed in 'expr', to the supplied list of matrices. </p>
<p>Each matrix to be operated upon must be represented in the expression by a separate matrix placeholder, 'M', and there must be one matrix supplied as an argument for each matrix placeholder in the expression. All rules and caveats of the corresponding matrix operations apply to the operated-on matrices. It is the caller's responsibility to call <a class="el" href="#a808f0a3a6e8dcebcb2c7f607aa838ea3" title="Frees the memory associated with matrix &#39;m&#39;, being the result of an earlier call to a matd_*() functi...">matd_destroy()</a> on the returned matrix.</p>
<p>Available operators (in order of increasing precedence): M+M add two matrices together M-M subtract one matrix from another M*M multiply two matrices together (matrix product) MM multiply two matrices together (matrix product) -M negate a matrix M^-1 take the inverse of a matrix M' take the transpose of a matrix</p>
<p>Expressions can be combined together and grouped by enclosing them in parenthesis, i.e.: -M(M+M+M)-(M*M)^-1</p>
<p>Scalar values can be generated on-the-fly, i.e.: M*2.2 scales M by 2.2 -2+M adds -2 to all elements of M</p>
<p>All whitespace in the expression is ignored. </p>

</div>
</div>
<a id="a1d157d1e1512356fdadb06cbbe3b955e" name="a1d157d1e1512356fdadb06cbbe3b955e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d157d1e1512356fdadb06cbbe3b955e">&#9670;&#160;</a></span>matd_plu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__plu__t.html">matd_plu_t</a> * matd_plu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae328c586b71d1212293b71a4d661a5f5" name="ae328c586b71d1212293b71a4d661a5f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae328c586b71d1212293b71a4d661a5f5">&#9670;&#160;</a></span>matd_plu_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matd_plu_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatd__plu__t.html">matd_plu_t</a> *</td>          <td class="paramname"><span class="paramname"><em>mlu</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1fb942820e49d324878cfccd1a5e63a1" name="a1fb942820e49d324878cfccd1a5e63a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb942820e49d324878cfccd1a5e63a1">&#9670;&#160;</a></span>matd_plu_det()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double matd_plu_det </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__plu__t.html">matd_plu_t</a> *</td>          <td class="paramname"><span class="paramname"><em>lu</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf74fd40d7edf5a83267dc261f602fad" name="abf74fd40d7edf5a83267dc261f602fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf74fd40d7edf5a83267dc261f602fad">&#9670;&#160;</a></span>matd_plu_l()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__t.html">matd_t</a> * matd_plu_l </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__plu__t.html">matd_plu_t</a> *</td>          <td class="paramname"><span class="paramname"><em>lu</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a46194294c0bf9eec23da57d9bd89c500" name="a46194294c0bf9eec23da57d9bd89c500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46194294c0bf9eec23da57d9bd89c500">&#9670;&#160;</a></span>matd_plu_p()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__t.html">matd_t</a> * matd_plu_p </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__plu__t.html">matd_plu_t</a> *</td>          <td class="paramname"><span class="paramname"><em>lu</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aadefc27e4c1aa49a110aa8b95ad37750" name="aadefc27e4c1aa49a110aa8b95ad37750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadefc27e4c1aa49a110aa8b95ad37750">&#9670;&#160;</a></span>matd_plu_solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__t.html">matd_t</a> * matd_plu_solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__plu__t.html">matd_plu_t</a> *</td>          <td class="paramname"><span class="paramname"><em>mlu</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab25ec37ffe68616d947f9c50d4155fe1" name="ab25ec37ffe68616d947f9c50d4155fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab25ec37ffe68616d947f9c50d4155fe1">&#9670;&#160;</a></span>matd_plu_u()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__t.html">matd_t</a> * matd_plu_u </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__plu__t.html">matd_plu_t</a> *</td>          <td class="paramname"><span class="paramname"><em>lu</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e23572241055971f84d3f4b29353e25" name="a3e23572241055971f84d3f4b29353e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e23572241055971f84d3f4b29353e25">&#9670;&#160;</a></span>matd_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matd_print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the supplied matrix 'm' to standard output by applying the supplied printf format specifier 'fmt' for each individual element. </p>
<p>Each row will be printed on a separate newline. </p>

</div>
</div>
<a id="a640f782a3fe1a35af0b87150cdba867c" name="a640f782a3fe1a35af0b87150cdba867c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640f782a3fe1a35af0b87150cdba867c">&#9670;&#160;</a></span>matd_print_transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matd_print_transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the transpose of the supplied matrix 'm' to standard output by applying the supplied printf format specifier 'fmt' for each individual element. </p>
<p>Each row will be printed on a separate newline. </p>

</div>
</div>
<a id="a874d1fda64faa7f5bfd577072207fbc1" name="a874d1fda64faa7f5bfd577072207fbc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a874d1fda64faa7f5bfd577072207fbc1">&#9670;&#160;</a></span>matd_put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matd_put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the given value to the matrix cell at the given zero-based row and column index. </p>
<p>Performs more thorough validation checking than <a class="el" href="#ab91b10b7048284897e819ed44410b875" title="A macro to reference a specific matd_t data element given it&#39;s zero-based row and column indexes.">MATD_EL()</a>. </p>

</div>
</div>
<a id="ab1c1fbf9c08531f4e3268a75fc5620de" name="ab1c1fbf9c08531f4e3268a75fc5620de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c1fbf9c08531f4e3268a75fc5620de">&#9670;&#160;</a></span>matd_put_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matd_put_scalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the given value to the supplied scalar element ('m' must be a scalar). </p>
<p>Performs more thorough validation checking than <a class="el" href="#ab91b10b7048284897e819ed44410b875" title="A macro to reference a specific matd_t data element given it&#39;s zero-based row and column indexes.">MATD_EL()</a>. </p>

</div>
</div>
<a id="a5302cbc1e5611f8fbb83ff4ff2d52413" name="a5302cbc1e5611f8fbb83ff4ff2d52413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5302cbc1e5611f8fbb83ff4ff2d52413">&#9670;&#160;</a></span>matd_scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__t.html">matd_t</a> * matd_scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales all cell values of matrix 'a' by the given scale factor 's' and returns the result as a new matrix of the same dimensions. </p>
<p>It is the caller's responsibility to call <a class="el" href="#a808f0a3a6e8dcebcb2c7f607aa838ea3" title="Frees the memory associated with matrix &#39;m&#39;, being the result of an earlier call to a matd_*() functi...">matd_destroy()</a> on the returned matrix. </p>

</div>
</div>
<a id="a55a72583244f443a84f7d535ac8aef58" name="a55a72583244f443a84f7d535ac8aef58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a72583244f443a84f7d535ac8aef58">&#9670;&#160;</a></span>matd_scale_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matd_scale_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales all cell values of matrix 'a' by the given scale factor 's' and overwrites the contents of 'a' with the results. </p>

</div>
</div>
<a id="a6231c3df06e4711cb25728e4931303eb" name="a6231c3df06e4711cb25728e4931303eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6231c3df06e4711cb25728e4931303eb">&#9670;&#160;</a></span>matd_select()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__t.html">matd_t</a> * matd_select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>r0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>r1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>c0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>c1</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a copy of a subset of the supplied matrix 'a'. </p>
<p>The subset will include rows 'r0' through 'r1', inclusive ('r1' &gt;= 'r0'), and columns 'c0' through 'c1', inclusive ('c1' &gt;= 'c0'). All parameters are zero-based (i.e. matd_select(a, 0, 0, 0, 0) will return only the first cell). Cannot be used on scalars or to extend beyond the number of rows/columns of 'a'. It is the caller's responsibility to call <a class="el" href="#a808f0a3a6e8dcebcb2c7f607aa838ea3" title="Frees the memory associated with matrix &#39;m&#39;, being the result of an earlier call to a matd_*() functi...">matd_destroy()</a> on the returned matrix. </p>

</div>
</div>
<a id="ac25bd8c392bc00c5d1e40afc10f502d3" name="ac25bd8c392bc00c5d1e40afc10f502d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25bd8c392bc00c5d1e40afc10f502d3">&#9670;&#160;</a></span>matd_set_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void matd_set_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ac441cc266f6110eafe191907f6bc99" name="a6ac441cc266f6110eafe191907f6bc99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac441cc266f6110eafe191907f6bc99">&#9670;&#160;</a></span>matd_solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__t.html">matd_t</a> * matd_solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1246fff6c8cdf69b4f8355ff6c938f37" name="a1246fff6c8cdf69b4f8355ff6c938f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1246fff6c8cdf69b4f8355ff6c938f37">&#9670;&#160;</a></span>matd_subtract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__t.html">matd_t</a> * matd_subtract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts matrix 'b' from matrix 'a', cell-by-cell, and returns the results as a new matrix of the same dimensions. </p>
<p>The supplied matrices must have identical dimensions. It is the caller's responsibility to call <a class="el" href="#a808f0a3a6e8dcebcb2c7f607aa838ea3" title="Frees the memory associated with matrix &#39;m&#39;, being the result of an earlier call to a matd_*() functi...">matd_destroy()</a> on the returned matrix. </p>

</div>
</div>
<a id="aed044e0c402a7eaee9a73f56785347d3" name="aed044e0c402a7eaee9a73f56785347d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed044e0c402a7eaee9a73f56785347d3">&#9670;&#160;</a></span>matd_subtract_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matd_subtract_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts the values of 'b' from matrix 'a', cell-by-cell, and overwrites the contents of 'a' with the results. </p>
<p>The supplied matrices must have identical dimensions. </p>

</div>
</div>
<a id="ab22fe516092a54bcf11647d93f4e5896" name="ab22fe516092a54bcf11647d93f4e5896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22fe516092a54bcf11647d93f4e5896">&#9670;&#160;</a></span>matd_svd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__svd__t.html">matd_svd_t</a> matd_svd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a complete SVD of a matrix. </p>
<p>The SVD exists for all matrices. For a matrix MxN, we will have:</p>
<p>A = U*S*V'</p>
<p>where A is MxN, U is MxM (and is an orthonormal basis), S is MxN (and is diagonal up to machine precision), and V is NxN (and is an orthonormal basis).</p>
<p>The caller is responsible for destroying U, S, and V. </p>

</div>
</div>
<a id="a88ead9bf5c09779e4f3b2be8b5aec918" name="a88ead9bf5c09779e4f3b2be8b5aec918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ead9bf5c09779e4f3b2be8b5aec918">&#9670;&#160;</a></span>matd_svd_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__svd__t.html">matd_svd_t</a> matd_svd_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9678e906f52031122212816a0832640d" name="a9678e906f52031122212816a0832640d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9678e906f52031122212816a0832640d">&#9670;&#160;</a></span>matd_transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__t.html">matd_t</a> * matd_transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a matrix which is the transpose of the supplied matrix 'a'. </p>
<p>It is the caller's responsibility to call <a class="el" href="#a808f0a3a6e8dcebcb2c7f607aa838ea3" title="Frees the memory associated with matrix &#39;m&#39;, being the result of an earlier call to a matd_*() functi...">matd_destroy()</a> on the returned matrix. </p>

</div>
</div>
<a id="ae612ff9e9640281025b4d5127b9b1023" name="ae612ff9e9640281025b4d5127b9b1023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae612ff9e9640281025b4d5127b9b1023">&#9670;&#160;</a></span>matd_utriangle_solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matd_utriangle_solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a17d5ee6905e6f6eed40ea2ebb9c77b43" name="a17d5ee6905e6f6eed40ea2ebb9c77b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d5ee6905e6f6eed40ea2ebb9c77b43">&#9670;&#160;</a></span>matd_vec_dist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double matd_vec_dist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the magnitude of the distance between the points represented by matrices 'a' and 'b'. </p>
<p>Both 'a' and 'b' must be vectors and have the same dimension (although one may be a row vector and one may be a column vector). </p>

</div>
</div>
<a id="ad5189e1ae47e37728583e1497a85863e" name="ad5189e1ae47e37728583e1497a85863e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5189e1ae47e37728583e1497a85863e">&#9670;&#160;</a></span>matd_vec_dist_n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double matd_vec_dist_n </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as matd_vec_dist, but only uses the first 'n' terms to compute distance. </p>

</div>
</div>
<a id="a5bc51cdf6a4e237f941c2078980aeb32" name="a5bc51cdf6a4e237f941c2078980aeb32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc51cdf6a4e237f941c2078980aeb32">&#9670;&#160;</a></span>matd_vec_dot_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double matd_vec_dot_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the dot product of two vectors. </p>
<p>Both 'a' and 'b' must be vectors and have the same dimension (although one may be a row vector and one may be a column vector). </p>

</div>
</div>
<a id="abf5a6d427758bfc8a15e57520b1e6b0f" name="abf5a6d427758bfc8a15e57520b1e6b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5a6d427758bfc8a15e57520b1e6b0f">&#9670;&#160;</a></span>matd_vec_mag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double matd_vec_mag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the magnitude of the supplied matrix 'a'. </p>

</div>
</div>
<a id="a0b15ab1f567267f25212ac56959d2bf2" name="a0b15ab1f567267f25212ac56959d2bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b15ab1f567267f25212ac56959d2bf2">&#9670;&#160;</a></span>matd_vec_normalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmatd__t.html">matd_t</a> * matd_vec_normalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmatd__t.html">matd_t</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the normalization of the supplied vector 'a' (i.e. </p>
<p>a unit vector of the same dimension and orientation as 'a' with a magnitude of 1) and returns it as a new vector. 'a' must be a vector of any dimension and must have a non-zero magnitude. It is the caller's responsibility to call <a class="el" href="#a808f0a3a6e8dcebcb2c7f607aa838ea3" title="Frees the memory associated with matrix &#39;m&#39;, being the result of an earlier call to a matd_*() functi...">matd_destroy()</a> on the returned matrix. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_bce03949b0889f5b77e9e810e79dfd7d.html">thirdparty</a></li><li class="navelem"><a class="el" href="dir_ff0062bb8776854a1feb511e7a5035f7.html">apriltag</a></li><li class="navelem"><a class="el" href="dir_4f37ec3afec411c33430786613d06e76.html">include</a></li><li class="navelem"><a class="el" href="dir_6324afc825a598ce4fef60a1f900074d.html">common</a></li><li class="navelem"><a class="el" href="matd_8h.html">matd.h</a></li>
    <li class="footer">Generated on Thu Oct 24 2024 04:48:52 for WPILibC++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
