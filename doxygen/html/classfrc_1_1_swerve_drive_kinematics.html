<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: frc::SwerveDriveKinematics&lt; NumModules &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="wpilib-128.png"/></td>
  <td id="projectalign">
   <div id="projectname">WPILibC++<span id="projectnumber">&#160;2024.3.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classfrc_1_1_swerve_drive_kinematics.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classfrc_1_1_swerve_drive_kinematics-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">frc::SwerveDriveKinematics&lt; NumModules &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Helper class that converts a chassis velocity (dx, dy, and dtheta components) into individual module states (speed and angle).  
 <a href="classfrc_1_1_swerve_drive_kinematics.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_swerve_drive_kinematics_8h_source.html">frc/kinematics/SwerveDriveKinematics.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for frc::SwerveDriveKinematics&lt; NumModules &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classfrc_1_1_swerve_drive_kinematics.png" usemap="#frc::SwerveDriveKinematics_3C_20NumModules_20_3E_map" alt=""/>
  <map id="frc::SwerveDriveKinematics_3C_20NumModules_20_3E_map" name="frc::SwerveDriveKinematics_3C_20NumModules_20_3E_map">
<area href="classfrc_1_1_kinematics.html" alt="frc::Kinematics&lt; SwerveDriveWheelSpeeds&lt; NumModules &gt;, SwerveDriveWheelPositions&lt; NumModules &gt; &gt;" shape="rect" coords="0,0,631,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a559b64d41180bbe7cbbebdafdec5ad7b"><td class="memTemplParams" colspan="2">template&lt;std::convertible_to&lt; <a class="el" href="classfrc_1_1_translation2d.html">Translation2d</a> &gt;... ModuleTranslations&gt; <br />
requires (sizeof...(ModuleTranslations) == NumModules)</td></tr>
<tr class="memitem:a559b64d41180bbe7cbbebdafdec5ad7b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html#a559b64d41180bbe7cbbebdafdec5ad7b">SwerveDriveKinematics</a> (ModuleTranslations &amp;&amp;... moduleTranslations)</td></tr>
<tr class="memdesc:a559b64d41180bbe7cbbebdafdec5ad7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a swerve drive kinematics object.  <a href="classfrc_1_1_swerve_drive_kinematics.html#a559b64d41180bbe7cbbebdafdec5ad7b">More...</a><br /></td></tr>
<tr class="separator:a559b64d41180bbe7cbbebdafdec5ad7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a28322265bfb541347937d684f575d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html#a8a28322265bfb541347937d684f575d2">SwerveDriveKinematics</a> (const <a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; <a class="el" href="classfrc_1_1_translation2d.html">Translation2d</a>, NumModules &gt; &amp;modules)</td></tr>
<tr class="separator:a8a28322265bfb541347937d684f575d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16db9e36af1eb6ddf4c4dd2a49717fbd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html#a16db9e36af1eb6ddf4c4dd2a49717fbd">SwerveDriveKinematics</a> (const <a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">SwerveDriveKinematics</a> &amp;)=default</td></tr>
<tr class="separator:a16db9e36af1eb6ddf4c4dd2a49717fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22970dd896955f95493e0f530f26e337"><td class="memTemplParams" colspan="2">template&lt;std::convertible_to&lt; <a class="el" href="classfrc_1_1_rotation2d.html">Rotation2d</a> &gt;... ModuleHeadings&gt; <br />
requires (sizeof...(ModuleHeadings) == NumModules)</td></tr>
<tr class="memitem:a22970dd896955f95493e0f530f26e337"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html#a22970dd896955f95493e0f530f26e337">ResetHeadings</a> (ModuleHeadings &amp;&amp;... moduleHeadings)</td></tr>
<tr class="memdesc:a22970dd896955f95493e0f530f26e337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the internal swerve module headings.  <a href="classfrc_1_1_swerve_drive_kinematics.html#a22970dd896955f95493e0f530f26e337">More...</a><br /></td></tr>
<tr class="separator:a22970dd896955f95493e0f530f26e337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc8bc761d8657cd7900a3fb31a32862"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html#a2dc8bc761d8657cd7900a3fb31a32862">ResetHeadings</a> (<a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; <a class="el" href="classfrc_1_1_rotation2d.html">Rotation2d</a>, NumModules &gt; moduleHeadings)</td></tr>
<tr class="memdesc:a2dc8bc761d8657cd7900a3fb31a32862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the internal swerve module headings.  <a href="classfrc_1_1_swerve_drive_kinematics.html#a2dc8bc761d8657cd7900a3fb31a32862">More...</a><br /></td></tr>
<tr class="separator:a2dc8bc761d8657cd7900a3fb31a32862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a485bbe6294b0fc9c39c8efacc3c79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; <a class="el" href="structfrc_1_1_swerve_module_state.html">SwerveModuleState</a>, NumModules &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html#a04a485bbe6294b0fc9c39c8efacc3c79">ToSwerveModuleStates</a> (const <a class="el" href="structfrc_1_1_chassis_speeds.html">ChassisSpeeds</a> &amp;chassisSpeeds, const <a class="el" href="classfrc_1_1_translation2d.html">Translation2d</a> &amp;centerOfRotation=<a class="el" href="classfrc_1_1_translation2d.html">Translation2d</a>{}) const</td></tr>
<tr class="memdesc:a04a485bbe6294b0fc9c39c8efacc3c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs inverse kinematics to return the module states from a desired chassis velocity.  <a href="classfrc_1_1_swerve_drive_kinematics.html#a04a485bbe6294b0fc9c39c8efacc3c79">More...</a><br /></td></tr>
<tr class="separator:a04a485bbe6294b0fc9c39c8efacc3c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a73cce49916084a719ba50078f2d57f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefrc.html#a54ab05b5180d286dd2b1698af349f163">SwerveDriveWheelSpeeds</a>&lt; NumModules &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html#a3a73cce49916084a719ba50078f2d57f">ToWheelSpeeds</a> (const <a class="el" href="structfrc_1_1_chassis_speeds.html">ChassisSpeeds</a> &amp;chassisSpeeds) const override</td></tr>
<tr class="memdesc:a3a73cce49916084a719ba50078f2d57f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs inverse kinematics to return the wheel speeds from a desired chassis velocity.  <a href="classfrc_1_1_swerve_drive_kinematics.html#a3a73cce49916084a719ba50078f2d57f">More...</a><br /></td></tr>
<tr class="separator:a3a73cce49916084a719ba50078f2d57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc586618b937ca90a0d777b99ed076f2"><td class="memTemplParams" colspan="2">template&lt;std::convertible_to&lt; <a class="el" href="structfrc_1_1_swerve_module_state.html">SwerveModuleState</a> &gt;... ModuleStates&gt; <br />
requires (sizeof...(ModuleStates) == NumModules)</td></tr>
<tr class="memitem:acc586618b937ca90a0d777b99ed076f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structfrc_1_1_chassis_speeds.html">ChassisSpeeds</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html#acc586618b937ca90a0d777b99ed076f2">ToChassisSpeeds</a> (ModuleStates &amp;&amp;... moduleStates) const</td></tr>
<tr class="memdesc:acc586618b937ca90a0d777b99ed076f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs forward kinematics to return the resulting chassis state from the given module states.  <a href="classfrc_1_1_swerve_drive_kinematics.html#acc586618b937ca90a0d777b99ed076f2">More...</a><br /></td></tr>
<tr class="separator:acc586618b937ca90a0d777b99ed076f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3321646d2874e4b3adf26f0eac7d3ff2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfrc_1_1_chassis_speeds.html">ChassisSpeeds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html#a3321646d2874e4b3adf26f0eac7d3ff2">ToChassisSpeeds</a> (const <a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; <a class="el" href="structfrc_1_1_swerve_module_state.html">SwerveModuleState</a>, NumModules &gt; &amp;moduleStates) const override</td></tr>
<tr class="memdesc:a3321646d2874e4b3adf26f0eac7d3ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs forward kinematics to return the resulting chassis state from the given module states.  <a href="classfrc_1_1_swerve_drive_kinematics.html#a3321646d2874e4b3adf26f0eac7d3ff2">More...</a><br /></td></tr>
<tr class="separator:a3321646d2874e4b3adf26f0eac7d3ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb0e97731e15e87ffb3909d62f189eb"><td class="memTemplParams" colspan="2">template&lt;std::convertible_to&lt; <a class="el" href="structfrc_1_1_swerve_module_position.html">SwerveModulePosition</a> &gt;... ModuleDeltas&gt; <br />
requires (sizeof...(ModuleDeltas) == NumModules)</td></tr>
<tr class="memitem:a7cb0e97731e15e87ffb3909d62f189eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structfrc_1_1_twist2d.html">Twist2d</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html#a7cb0e97731e15e87ffb3909d62f189eb">ToTwist2d</a> (ModuleDeltas &amp;&amp;... moduleDeltas) const</td></tr>
<tr class="memdesc:a7cb0e97731e15e87ffb3909d62f189eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs forward kinematics to return the resulting <a class="el" href="structfrc_1_1_twist2d.html" title="A change in distance along a 2D arc since the last pose update.">Twist2d</a> from the given module position deltas.  <a href="classfrc_1_1_swerve_drive_kinematics.html#a7cb0e97731e15e87ffb3909d62f189eb">More...</a><br /></td></tr>
<tr class="separator:a7cb0e97731e15e87ffb3909d62f189eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae134d9d3e64e0489bdd9d14cfa4b70d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfrc_1_1_twist2d.html">Twist2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html#ae134d9d3e64e0489bdd9d14cfa4b70d7">ToTwist2d</a> (<a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; <a class="el" href="structfrc_1_1_swerve_module_position.html">SwerveModulePosition</a>, NumModules &gt; moduleDeltas) const</td></tr>
<tr class="memdesc:ae134d9d3e64e0489bdd9d14cfa4b70d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs forward kinematics to return the resulting <a class="el" href="structfrc_1_1_twist2d.html" title="A change in distance along a 2D arc since the last pose update.">Twist2d</a> from the given module position deltas.  <a href="classfrc_1_1_swerve_drive_kinematics.html#ae134d9d3e64e0489bdd9d14cfa4b70d7">More...</a><br /></td></tr>
<tr class="separator:ae134d9d3e64e0489bdd9d14cfa4b70d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a98d6d4035d54a5bd82bd9da3d98e3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfrc_1_1_twist2d.html">Twist2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html#a7a98d6d4035d54a5bd82bd9da3d98e3a">ToTwist2d</a> (const <a class="el" href="structfrc_1_1_swerve_drive_wheel_positions.html">SwerveDriveWheelPositions</a>&lt; NumModules &gt; &amp;start, const <a class="el" href="structfrc_1_1_swerve_drive_wheel_positions.html">SwerveDriveWheelPositions</a>&lt; NumModules &gt; &amp;end) const override</td></tr>
<tr class="memdesc:a7a98d6d4035d54a5bd82bd9da3d98e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs forward kinematics to return the resulting <a class="el" href="structfrc_1_1_twist2d.html" title="A change in distance along a 2D arc since the last pose update.">Twist2d</a> from the given change in wheel positions.  <a href="classfrc_1_1_swerve_drive_kinematics.html#a7a98d6d4035d54a5bd82bd9da3d98e3a">More...</a><br /></td></tr>
<tr class="separator:a7a98d6d4035d54a5bd82bd9da3d98e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classfrc_1_1_kinematics"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classfrc_1_1_kinematics')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classfrc_1_1_kinematics.html">frc::Kinematics&lt; SwerveDriveWheelSpeeds&lt; NumModules &gt;, SwerveDriveWheelPositions&lt; NumModules &gt; &gt;</a></td></tr>
<tr class="memitem:a43ae8ffe3c5a5485d44bde50136fad1a inherit pub_methods_classfrc_1_1_kinematics"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structfrc_1_1_chassis_speeds.html">ChassisSpeeds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1_kinematics.html#a43ae8ffe3c5a5485d44bde50136fad1a">ToChassisSpeeds</a> (const <a class="el" href="namespacefrc.html#a54ab05b5180d286dd2b1698af349f163">SwerveDriveWheelSpeeds</a>&lt; NumModules &gt; &amp;wheelSpeeds) const=0</td></tr>
<tr class="memdesc:a43ae8ffe3c5a5485d44bde50136fad1a inherit pub_methods_classfrc_1_1_kinematics"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs forward kinematics to return the resulting chassis speed from the wheel speeds.  <a href="classfrc_1_1_kinematics.html#a43ae8ffe3c5a5485d44bde50136fad1a">More...</a><br /></td></tr>
<tr class="separator:a43ae8ffe3c5a5485d44bde50136fad1a inherit pub_methods_classfrc_1_1_kinematics"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a8926a4fbf7e5e1b222a2198ad8bd0 inherit pub_methods_classfrc_1_1_kinematics"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacefrc.html#a54ab05b5180d286dd2b1698af349f163">SwerveDriveWheelSpeeds</a>&lt; NumModules &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1_kinematics.html#aa9a8926a4fbf7e5e1b222a2198ad8bd0">ToWheelSpeeds</a> (const <a class="el" href="structfrc_1_1_chassis_speeds.html">ChassisSpeeds</a> &amp;chassisSpeeds) const=0</td></tr>
<tr class="memdesc:aa9a8926a4fbf7e5e1b222a2198ad8bd0 inherit pub_methods_classfrc_1_1_kinematics"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs inverse kinematics to return the wheel speeds from a desired chassis velocity.  <a href="classfrc_1_1_kinematics.html#aa9a8926a4fbf7e5e1b222a2198ad8bd0">More...</a><br /></td></tr>
<tr class="separator:aa9a8926a4fbf7e5e1b222a2198ad8bd0 inherit pub_methods_classfrc_1_1_kinematics"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387602e981611bd586c7f52a16a876ce inherit pub_methods_classfrc_1_1_kinematics"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structfrc_1_1_twist2d.html">Twist2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1_kinematics.html#a387602e981611bd586c7f52a16a876ce">ToTwist2d</a> (const <a class="el" href="structfrc_1_1_swerve_drive_wheel_positions.html">SwerveDriveWheelPositions</a>&lt; NumModules &gt; &amp;start, const <a class="el" href="structfrc_1_1_swerve_drive_wheel_positions.html">SwerveDriveWheelPositions</a>&lt; NumModules &gt; &amp;end) const=0</td></tr>
<tr class="memdesc:a387602e981611bd586c7f52a16a876ce inherit pub_methods_classfrc_1_1_kinematics"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs forward kinematics to return the resulting Twist2d from the given change in wheel positions.  <a href="classfrc_1_1_kinematics.html#a387602e981611bd586c7f52a16a876ce">More...</a><br /></td></tr>
<tr class="separator:a387602e981611bd586c7f52a16a876ce inherit pub_methods_classfrc_1_1_kinematics"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:accd3217a7016eb5246f1184b8bc6cc90"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html#accd3217a7016eb5246f1184b8bc6cc90">DesaturateWheelSpeeds</a> (<a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; <a class="el" href="structfrc_1_1_swerve_module_state.html">SwerveModuleState</a>, NumModules &gt; *moduleStates, units::meters_per_second_t attainableMaxSpeed)</td></tr>
<tr class="memdesc:accd3217a7016eb5246f1184b8bc6cc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renormalizes the wheel speeds if any individual speed is above the specified maximum.  <a href="classfrc_1_1_swerve_drive_kinematics.html#accd3217a7016eb5246f1184b8bc6cc90">More...</a><br /></td></tr>
<tr class="separator:accd3217a7016eb5246f1184b8bc6cc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a0554944672c279362ae41b5ce5473"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html#aa3a0554944672c279362ae41b5ce5473">DesaturateWheelSpeeds</a> (<a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; <a class="el" href="structfrc_1_1_swerve_module_state.html">SwerveModuleState</a>, NumModules &gt; *moduleStates, <a class="el" href="structfrc_1_1_chassis_speeds.html">ChassisSpeeds</a> desiredChassisSpeed, units::meters_per_second_t attainableMaxModuleSpeed, units::meters_per_second_t attainableMaxRobotTranslationSpeed, units::radians_per_second_t attainableMaxRobotRotationSpeed)</td></tr>
<tr class="memdesc:aa3a0554944672c279362ae41b5ce5473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renormalizes the wheel speeds if any individual speed is above the specified maximum, as well as getting rid of joystick saturation at edges of joystick.  <a href="classfrc_1_1_swerve_drive_kinematics.html#aa3a0554944672c279362ae41b5ce5473">More...</a><br /></td></tr>
<tr class="separator:aa3a0554944672c279362ae41b5ce5473"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;size_t NumModules&gt;<br />
class frc::SwerveDriveKinematics&lt; NumModules &gt;</div><p >Helper class that converts a chassis velocity (dx, dy, and dtheta components) into individual module states (speed and angle). </p>
<p >The inverse kinematics (converting from a desired chassis velocity to individual module states) uses the relative locations of the modules with respect to the center of rotation. The center of rotation for inverse kinematics is also variable. This means that you can set your set your center of rotation in a corner of the robot to perform special evasion maneuvers.</p>
<p >Forward kinematics (converting an array of module states into the overall chassis motion) is performs the exact opposite of what inverse kinematics does. Since this is an overdetermined system (more equations than variables), we use a least-squares approximation.</p>
<p >The inverse kinematics: [moduleStates] = [moduleLocations] * [chassisSpeeds] We take the Moore-Penrose pseudoinverse of [moduleLocations] and then multiply by [moduleStates] to get our chassis speeds.</p>
<p >Forward kinematics is also used for odometry &ndash; determining the position of the robot on the field using encoders and a gyro. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a559b64d41180bbe7cbbebdafdec5ad7b" name="a559b64d41180bbe7cbbebdafdec5ad7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559b64d41180bbe7cbbebdafdec5ad7b">&#9670;&nbsp;</a></span>SwerveDriveKinematics() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
<div class="memtemplate">
template&lt;std::convertible_to&lt; <a class="el" href="classfrc_1_1_translation2d.html">Translation2d</a> &gt;... ModuleTranslations&gt; <br />
requires (sizeof...(ModuleTranslations) == NumModules)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::SwerveDriveKinematics </td>
          <td>(</td>
          <td class="paramtype">ModuleTranslations &amp;&amp;...&#160;</td>
          <td class="paramname"><em>moduleTranslations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a swerve drive kinematics object. </p>
<p >This takes in a variable number of module locations as Translation2ds. The order in which you pass in the module locations is the same order that you will receive the module states when performing inverse kinematics. It is also expected that you pass in the module states in the same order when calling the forward kinematics methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleTranslations</td><td>The locations of the modules relative to the physical center of the robot. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a28322265bfb541347937d684f575d2" name="a8a28322265bfb541347937d684f575d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a28322265bfb541347937d684f575d2">&#9670;&nbsp;</a></span>SwerveDriveKinematics() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::SwerveDriveKinematics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; <a class="el" href="classfrc_1_1_translation2d.html">Translation2d</a>, NumModules &gt; &amp;&#160;</td>
          <td class="paramname"><em>modules</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a16db9e36af1eb6ddf4c4dd2a49717fbd" name="a16db9e36af1eb6ddf4c4dd2a49717fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16db9e36af1eb6ddf4c4dd2a49717fbd">&#9670;&nbsp;</a></span>SwerveDriveKinematics() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::SwerveDriveKinematics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">SwerveDriveKinematics</a>&lt; NumModules &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa3a0554944672c279362ae41b5ce5473" name="aa3a0554944672c279362ae41b5ce5473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a0554944672c279362ae41b5ce5473">&#9670;&nbsp;</a></span>DesaturateWheelSpeeds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::DesaturateWheelSpeeds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; <a class="el" href="structfrc_1_1_swerve_module_state.html">SwerveModuleState</a>, NumModules &gt; *&#160;</td>
          <td class="paramname"><em>moduleStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfrc_1_1_chassis_speeds.html">ChassisSpeeds</a>&#160;</td>
          <td class="paramname"><em>desiredChassisSpeed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">units::meters_per_second_t&#160;</td>
          <td class="paramname"><em>attainableMaxModuleSpeed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">units::meters_per_second_t&#160;</td>
          <td class="paramname"><em>attainableMaxRobotTranslationSpeed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">units::radians_per_second_t&#160;</td>
          <td class="paramname"><em>attainableMaxRobotRotationSpeed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renormalizes the wheel speeds if any individual speed is above the specified maximum, as well as getting rid of joystick saturation at edges of joystick. </p>
<p >Sometimes, after inverse kinematics, the requested speed from one or more modules may be above the max attainable speed for the driving motor on that module. To fix this issue, one can reduce all the wheel speeds to make sure that all requested module speeds are at-or-below the absolute threshold, while maintaining the ratio of speeds between modules.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleStates</td><td>Reference to array of module states. The array will be mutated with the normalized speeds! </td></tr>
    <tr><td class="paramname">desiredChassisSpeed</td><td>The desired speed of the robot </td></tr>
    <tr><td class="paramname">attainableMaxModuleSpeed</td><td>The absolute max speed a module can reach </td></tr>
    <tr><td class="paramname">attainableMaxRobotTranslationSpeed</td><td>The absolute max speed the robot can reach while translating </td></tr>
    <tr><td class="paramname">attainableMaxRobotRotationSpeed</td><td>The absolute max speed the robot can reach while rotating </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accd3217a7016eb5246f1184b8bc6cc90" name="accd3217a7016eb5246f1184b8bc6cc90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd3217a7016eb5246f1184b8bc6cc90">&#9670;&nbsp;</a></span>DesaturateWheelSpeeds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::DesaturateWheelSpeeds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; <a class="el" href="structfrc_1_1_swerve_module_state.html">SwerveModuleState</a>, NumModules &gt; *&#160;</td>
          <td class="paramname"><em>moduleStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">units::meters_per_second_t&#160;</td>
          <td class="paramname"><em>attainableMaxSpeed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renormalizes the wheel speeds if any individual speed is above the specified maximum. </p>
<p >Sometimes, after inverse kinematics, the requested speed from one or more modules may be above the max attainable speed for the driving motor on that module. To fix this issue, one can reduce all the wheel speeds to make sure that all requested module speeds are at-or-below the absolute threshold, while maintaining the ratio of speeds between modules.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleStates</td><td>Reference to array of module states. The array will be mutated with the normalized speeds! </td></tr>
    <tr><td class="paramname">attainableMaxSpeed</td><td>The absolute max speed that a module can reach. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22970dd896955f95493e0f530f26e337" name="a22970dd896955f95493e0f530f26e337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22970dd896955f95493e0f530f26e337">&#9670;&nbsp;</a></span>ResetHeadings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
<div class="memtemplate">
template&lt;std::convertible_to&lt; <a class="el" href="classfrc_1_1_rotation2d.html">Rotation2d</a> &gt;... ModuleHeadings&gt; <br />
requires (sizeof...(ModuleHeadings) == NumModules)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::ResetHeadings </td>
          <td>(</td>
          <td class="paramtype">ModuleHeadings &amp;&amp;...&#160;</td>
          <td class="paramname"><em>moduleHeadings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the internal swerve module headings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleHeadings</td><td>The swerve module headings. The order of the module headings should be same as passed into the constructor of this class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2dc8bc761d8657cd7900a3fb31a32862" name="a2dc8bc761d8657cd7900a3fb31a32862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc8bc761d8657cd7900a3fb31a32862">&#9670;&nbsp;</a></span>ResetHeadings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::ResetHeadings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; <a class="el" href="classfrc_1_1_rotation2d.html">Rotation2d</a>, NumModules &gt;&#160;</td>
          <td class="paramname"><em>moduleHeadings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the internal swerve module headings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleHeadings</td><td>The swerve module headings. The order of the module headings should be same as passed into the constructor of this class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3321646d2874e4b3adf26f0eac7d3ff2" name="a3321646d2874e4b3adf26f0eac7d3ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3321646d2874e4b3adf26f0eac7d3ff2">&#9670;&nbsp;</a></span>ToChassisSpeeds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfrc_1_1_chassis_speeds.html">ChassisSpeeds</a> <a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::ToChassisSpeeds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; <a class="el" href="structfrc_1_1_swerve_module_state.html">SwerveModuleState</a>, NumModules &gt; &amp;&#160;</td>
          <td class="paramname"><em>moduleStates</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs forward kinematics to return the resulting chassis state from the given module states. </p>
<p >This method is often used for odometry &ndash; determining the robot's position on the field using data from the real-world speed and angle of each module on the robot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleStates</td><td>The state of the modules as an <a class="el" href="classwpi_1_1array.html" title="This class is a wrapper around std::array that does compile time size checking.">wpi::array</a> of type <a class="el" href="structfrc_1_1_swerve_module_state.html" title="Represents the state of one swerve module.">SwerveModuleState</a>, NumModules long as measured from respective encoders and gyros. The order of the swerve module states should be same as passed into the constructor of this class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting chassis speed. </dd></dl>

</div>
</div>
<a id="acc586618b937ca90a0d777b99ed076f2" name="acc586618b937ca90a0d777b99ed076f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc586618b937ca90a0d777b99ed076f2">&#9670;&nbsp;</a></span>ToChassisSpeeds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
<div class="memtemplate">
template&lt;std::convertible_to&lt; <a class="el" href="structfrc_1_1_swerve_module_state.html">SwerveModuleState</a> &gt;... ModuleStates&gt; <br />
requires (sizeof...(ModuleStates) == NumModules)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfrc_1_1_chassis_speeds.html">ChassisSpeeds</a> <a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::ToChassisSpeeds </td>
          <td>(</td>
          <td class="paramtype">ModuleStates &amp;&amp;...&#160;</td>
          <td class="paramname"><em>moduleStates</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs forward kinematics to return the resulting chassis state from the given module states. </p>
<p >This method is often used for odometry &ndash; determining the robot's position on the field using data from the real-world speed and angle of each module on the robot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleStates</td><td>The state of the modules (as a <a class="el" href="structfrc_1_1_swerve_module_state.html" title="Represents the state of one swerve module.">SwerveModuleState</a> type) as measured from respective encoders and gyros. The order of the swerve module states should be same as passed into the constructor of this class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting chassis speed. </dd></dl>

</div>
</div>
<a id="a04a485bbe6294b0fc9c39c8efacc3c79" name="a04a485bbe6294b0fc9c39c8efacc3c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a485bbe6294b0fc9c39c8efacc3c79">&#9670;&nbsp;</a></span>ToSwerveModuleStates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; <a class="el" href="structfrc_1_1_swerve_module_state.html">SwerveModuleState</a>, NumModules &gt; <a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::ToSwerveModuleStates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfrc_1_1_chassis_speeds.html">ChassisSpeeds</a> &amp;&#160;</td>
          <td class="paramname"><em>chassisSpeeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfrc_1_1_translation2d.html">Translation2d</a> &amp;&#160;</td>
          <td class="paramname"><em>centerOfRotation</em> = <code><a class="el" href="classfrc_1_1_translation2d.html">Translation2d</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs inverse kinematics to return the module states from a desired chassis velocity. </p>
<p >This method is often used to convert joystick values into module speeds and angles.</p>
<p >This function also supports variable centers of rotation. During normal operations, the center of rotation is usually the same as the physical center of the robot; therefore, the argument is defaulted to that use case. However, if you wish to change the center of rotation for evasive maneuvers, vision alignment, or for any other use case, you can do so.</p>
<p >In the case that the desired chassis speeds are zero (i.e. the robot will be stationary), the previously calculated module angle will be maintained.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chassisSpeeds</td><td>The desired chassis speed. </td></tr>
    <tr><td class="paramname">centerOfRotation</td><td>The center of rotation. For example, if you set the center of rotation at one corner of the robot and provide a chassis speed that only has a dtheta component, the robot will rotate around that corner.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array containing the module states. Use caution because these module states are not normalized. Sometimes, a user input may cause one of the module speeds to go above the attainable max velocity. Use the <a class="el" href="classfrc_1_1_swerve_drive_kinematics.html#accd3217a7016eb5246f1184b8bc6cc90" title="Renormalizes the wheel speeds if any individual speed is above the specified maximum.">DesaturateWheelSpeeds(wpi::array&lt;SwerveModuleState, NumModules&gt;*,
units::meters_per_second_t)</a> function to rectify this issue. In addition, you can leverage the power of C++17 to directly assign the module states to variables:</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> [fl, fr, bl, br] = kinematics.ToSwerveModuleStates(chassisSpeeds);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7a98d6d4035d54a5bd82bd9da3d98e3a" name="a7a98d6d4035d54a5bd82bd9da3d98e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a98d6d4035d54a5bd82bd9da3d98e3a">&#9670;&nbsp;</a></span>ToTwist2d() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfrc_1_1_twist2d.html">Twist2d</a> <a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::ToTwist2d </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfrc_1_1_swerve_drive_wheel_positions.html">SwerveDriveWheelPositions</a>&lt; NumModules &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfrc_1_1_swerve_drive_wheel_positions.html">SwerveDriveWheelPositions</a>&lt; NumModules &gt; &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs forward kinematics to return the resulting <a class="el" href="structfrc_1_1_twist2d.html" title="A change in distance along a 2D arc since the last pose update.">Twist2d</a> from the given change in wheel positions. </p>
<p >This method is often used for odometry &ndash; determining the robot's position on the field using changes in the distance driven by each wheel on the robot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The starting distances driven by the wheels. </td></tr>
    <tr><td class="paramname">end</td><td>The ending distances driven by the wheels.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting <a class="el" href="structfrc_1_1_twist2d.html" title="A change in distance along a 2D arc since the last pose update.">Twist2d</a> in the robot's movement. </dd></dl>

<p>Implements <a class="el" href="classfrc_1_1_kinematics.html#a387602e981611bd586c7f52a16a876ce">frc::Kinematics&lt; SwerveDriveWheelSpeeds&lt; NumModules &gt;, SwerveDriveWheelPositions&lt; NumModules &gt; &gt;</a>.</p>

</div>
</div>
<a id="a7cb0e97731e15e87ffb3909d62f189eb" name="a7cb0e97731e15e87ffb3909d62f189eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb0e97731e15e87ffb3909d62f189eb">&#9670;&nbsp;</a></span>ToTwist2d() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
<div class="memtemplate">
template&lt;std::convertible_to&lt; <a class="el" href="structfrc_1_1_swerve_module_position.html">SwerveModulePosition</a> &gt;... ModuleDeltas&gt; <br />
requires (sizeof...(ModuleDeltas) == NumModules)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfrc_1_1_twist2d.html">Twist2d</a> <a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::ToTwist2d </td>
          <td>(</td>
          <td class="paramtype">ModuleDeltas &amp;&amp;...&#160;</td>
          <td class="paramname"><em>moduleDeltas</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs forward kinematics to return the resulting <a class="el" href="structfrc_1_1_twist2d.html" title="A change in distance along a 2D arc since the last pose update.">Twist2d</a> from the given module position deltas. </p>
<p >This method is often used for odometry &ndash; determining the robot's position on the field using data from the real-world position delta and angle of each module on the robot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleDeltas</td><td>The latest change in position of the modules (as a <a class="el" href="structfrc_1_1_swerve_module_position.html" title="Represents the position of one swerve module.">SwerveModulePosition</a> type) as measured from respective encoders and gyros. The order of the swerve module states should be same as passed into the constructor of this class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting <a class="el" href="structfrc_1_1_twist2d.html" title="A change in distance along a 2D arc since the last pose update.">Twist2d</a>. </dd></dl>

</div>
</div>
<a id="ae134d9d3e64e0489bdd9d14cfa4b70d7" name="ae134d9d3e64e0489bdd9d14cfa4b70d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae134d9d3e64e0489bdd9d14cfa4b70d7">&#9670;&nbsp;</a></span>ToTwist2d() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfrc_1_1_twist2d.html">Twist2d</a> <a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::ToTwist2d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1array.html">wpi::array</a>&lt; <a class="el" href="structfrc_1_1_swerve_module_position.html">SwerveModulePosition</a>, NumModules &gt;&#160;</td>
          <td class="paramname"><em>moduleDeltas</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs forward kinematics to return the resulting <a class="el" href="structfrc_1_1_twist2d.html" title="A change in distance along a 2D arc since the last pose update.">Twist2d</a> from the given module position deltas. </p>
<p >This method is often used for odometry &ndash; determining the robot's position on the field using data from the real-world position delta and angle of each module on the robot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleDeltas</td><td>The latest change in position of the modules (as a <a class="el" href="structfrc_1_1_swerve_module_position.html" title="Represents the position of one swerve module.">SwerveModulePosition</a> type) as measured from respective encoders and gyros. The order of the swerve module states should be same as passed into the constructor of this class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting <a class="el" href="structfrc_1_1_twist2d.html" title="A change in distance along a 2D arc since the last pose update.">Twist2d</a>. </dd></dl>

</div>
</div>
<a id="a3a73cce49916084a719ba50078f2d57f" name="a3a73cce49916084a719ba50078f2d57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a73cce49916084a719ba50078f2d57f">&#9670;&nbsp;</a></span>ToWheelSpeeds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefrc.html#a54ab05b5180d286dd2b1698af349f163">SwerveDriveWheelSpeeds</a>&lt; NumModules &gt; <a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::ToWheelSpeeds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfrc_1_1_chassis_speeds.html">ChassisSpeeds</a> &amp;&#160;</td>
          <td class="paramname"><em>chassisSpeeds</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs inverse kinematics to return the wheel speeds from a desired chassis velocity. </p>
<p >This method is often used to convert joystick values into wheel speeds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chassisSpeeds</td><td>The desired chassis speed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The wheel speeds. </dd></dl>

<p>Implements <a class="el" href="classfrc_1_1_kinematics.html#aa9a8926a4fbf7e5e1b222a2198ad8bd0">frc::Kinematics&lt; SwerveDriveWheelSpeeds&lt; NumModules &gt;, SwerveDriveWheelPositions&lt; NumModules &gt; &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>frc/kinematics/<a class="el" href="_swerve_drive_kinematics_8h_source.html">SwerveDriveKinematics.h</a></li>
<li>frc/kinematics/<a class="el" href="_swerve_drive_kinematics_8inc.html">SwerveDriveKinematics.inc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefrc.html">frc</a></li><li class="navelem"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">SwerveDriveKinematics</a></li>
    <li class="footer">Generated on Wed Mar 13 2024 05:20:44 for WPILibC++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
