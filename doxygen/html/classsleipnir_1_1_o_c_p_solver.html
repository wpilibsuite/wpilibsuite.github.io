<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: sleipnir::OCPSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="wpilib-128.png"/></td>
  <td id="projectalign">
   <div id="projectname">WPILibC++<span id="projectnumber">&#160;2025.1.1-beta-1-35-g9a5f73d</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classsleipnir_1_1_o_c_p_solver.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsleipnir_1_1_o_c_p_solver-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">sleipnir::OCPSolver Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This class allows the user to pose and solve a constrained optimal control problem (OCP) in a variety of ways.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_o_c_p_solver_8hpp_source.html">/home/runner/work/allwpilib/allwpilib/wpimath/src/main/native/thirdparty/sleipnir/include/sleipnir/control/OCPSolver.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sleipnir::OCPSolver:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsleipnir_1_1_o_c_p_solver.png" usemap="#sleipnir::OCPSolver_map" alt=""/>
  <map id="sleipnir::OCPSolver_map" name="sleipnir::OCPSolver_map">
<area href="classsleipnir_1_1_optimization_problem.html" title="This class allows the user to pose a constrained nonlinear optimization problem in natural mathematic..." alt="sleipnir::OptimizationProblem" shape="rect" coords="0,0,173,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae43124dc00a36ac0162f0c618dd9d76d" id="r_ae43124dc00a36ac0162f0c618dd9d76d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae43124dc00a36ac0162f0c618dd9d76d">OCPSolver</a> (int numStates, int numInputs, std::chrono::duration&lt; double &gt; dt, int numSteps, <a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a>(const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;x, const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;u)&gt; dynamics, <a class="el" href="namespacesleipnir.html#a38e60fa99ee023884ea7a163a67169f7">DynamicsType</a> dynamicsType=<a class="el" href="namespacesleipnir.html#a38e60fa99ee023884ea7a163a67169f7a6976d4824b9f5192d274a69163d67423">DynamicsType::kExplicitODE</a>, <a class="el" href="namespacesleipnir.html#aa0c8390ba2ad034b958630d8b7d962b4">TimestepMethod</a> timestepMethod=<a class="el" href="namespacesleipnir.html#aa0c8390ba2ad034b958630d8b7d962b4a826888a09763de7e2a9f60eb85d88b24">TimestepMethod::kFixed</a>, <a class="el" href="namespacesleipnir.html#a7b6ff477fca07d31231aade7ce57207a">TranscriptionMethod</a> method=<a class="el" href="namespacesleipnir.html#a7b6ff477fca07d31231aade7ce57207aae09070d9a1cb5eaf8c431ff130d77254">TranscriptionMethod::kDirectTranscription</a>)</td></tr>
<tr class="memdesc:ae43124dc00a36ac0162f0c618dd9d76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an optimization problem using a system evolution function (explicit ODE or discrete state transition function).  <br /></td></tr>
<tr class="separator:ae43124dc00a36ac0162f0c618dd9d76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ca52dad54a9b1887b8eec52adaa7b4" id="r_af9ca52dad54a9b1887b8eec52adaa7b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9ca52dad54a9b1887b8eec52adaa7b4">OCPSolver</a> (int numStates, int numInputs, std::chrono::duration&lt; double &gt; dt, int numSteps, <a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a>(const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;t, const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;x, const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;u, const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;dt)&gt; dynamics, <a class="el" href="namespacesleipnir.html#a38e60fa99ee023884ea7a163a67169f7">DynamicsType</a> dynamicsType=<a class="el" href="namespacesleipnir.html#a38e60fa99ee023884ea7a163a67169f7a6976d4824b9f5192d274a69163d67423">DynamicsType::kExplicitODE</a>, <a class="el" href="namespacesleipnir.html#aa0c8390ba2ad034b958630d8b7d962b4">TimestepMethod</a> timestepMethod=<a class="el" href="namespacesleipnir.html#aa0c8390ba2ad034b958630d8b7d962b4a826888a09763de7e2a9f60eb85d88b24">TimestepMethod::kFixed</a>, <a class="el" href="namespacesleipnir.html#a7b6ff477fca07d31231aade7ce57207a">TranscriptionMethod</a> method=<a class="el" href="namespacesleipnir.html#a7b6ff477fca07d31231aade7ce57207aae09070d9a1cb5eaf8c431ff130d77254">TranscriptionMethod::kDirectTranscription</a>)</td></tr>
<tr class="memdesc:af9ca52dad54a9b1887b8eec52adaa7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an optimization problem using a system evolution function (explicit ODE or discrete state transition function).  <br /></td></tr>
<tr class="separator:af9ca52dad54a9b1887b8eec52adaa7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0927efb3802037b5c4e768a3d90bee51" id="r_a0927efb3802037b5c4e768a3d90bee51"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; <br />
requires ScalarLike&lt;T&gt; || MatrixLike&lt;T&gt;</td></tr>
<tr class="memitem:a0927efb3802037b5c4e768a3d90bee51"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0927efb3802037b5c4e768a3d90bee51">ConstrainInitialState</a> (const T &amp;initialState)</td></tr>
<tr class="memdesc:a0927efb3802037b5c4e768a3d90bee51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to constrain the initial state.  <br /></td></tr>
<tr class="separator:a0927efb3802037b5c4e768a3d90bee51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b57e07446c3c80d41cc92510ea678ce" id="r_a9b57e07446c3c80d41cc92510ea678ce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; <br />
requires ScalarLike&lt;T&gt; || MatrixLike&lt;T&gt;</td></tr>
<tr class="memitem:a9b57e07446c3c80d41cc92510ea678ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9b57e07446c3c80d41cc92510ea678ce">ConstrainFinalState</a> (const T &amp;finalState)</td></tr>
<tr class="memdesc:a9b57e07446c3c80d41cc92510ea678ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to constrain the final state.  <br /></td></tr>
<tr class="separator:a9b57e07446c3c80d41cc92510ea678ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7886adfdd01442aa274800e0930fe252" id="r_a7886adfdd01442aa274800e0930fe252"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7886adfdd01442aa274800e0930fe252">ForEachStep</a> (const <a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; void(const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;x, const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;u)&gt; callback)</td></tr>
<tr class="memdesc:a7886adfdd01442aa274800e0930fe252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the constraint evaluation function.  <br /></td></tr>
<tr class="separator:a7886adfdd01442aa274800e0930fe252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad115c582e25d713304077dde45cddb4" id="r_aad115c582e25d713304077dde45cddb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad115c582e25d713304077dde45cddb4">ForEachStep</a> (const <a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; void(const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;t, const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;x, const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;u, const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;dt)&gt; callback)</td></tr>
<tr class="memdesc:aad115c582e25d713304077dde45cddb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the constraint evaluation function.  <br /></td></tr>
<tr class="separator:aad115c582e25d713304077dde45cddb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4db4ab3731845eab6256b61c9491ec8" id="r_ac4db4ab3731845eab6256b61c9491ec8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; <br />
requires ScalarLike&lt;T&gt; || MatrixLike&lt;T&gt;</td></tr>
<tr class="memitem:ac4db4ab3731845eab6256b61c9491ec8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac4db4ab3731845eab6256b61c9491ec8">SetLowerInputBound</a> (const T &amp;lowerBound)</td></tr>
<tr class="memdesc:ac4db4ab3731845eab6256b61c9491ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to set a lower bound on the input.  <br /></td></tr>
<tr class="separator:ac4db4ab3731845eab6256b61c9491ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff1d385e839c7ea1d8e54d6a840d5af" id="r_a9ff1d385e839c7ea1d8e54d6a840d5af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; <br />
requires ScalarLike&lt;T&gt; || MatrixLike&lt;T&gt;</td></tr>
<tr class="memitem:a9ff1d385e839c7ea1d8e54d6a840d5af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9ff1d385e839c7ea1d8e54d6a840d5af">SetUpperInputBound</a> (const T &amp;upperBound)</td></tr>
<tr class="memdesc:a9ff1d385e839c7ea1d8e54d6a840d5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to set an upper bound on the input.  <br /></td></tr>
<tr class="separator:a9ff1d385e839c7ea1d8e54d6a840d5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248550561132558d7c8ba9d36705387e" id="r_a248550561132558d7c8ba9d36705387e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a248550561132558d7c8ba9d36705387e">SetMinTimestep</a> (std::chrono::duration&lt; double &gt; minTimestep)</td></tr>
<tr class="memdesc:a248550561132558d7c8ba9d36705387e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to set a lower bound on the timestep.  <br /></td></tr>
<tr class="separator:a248550561132558d7c8ba9d36705387e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5184b11be8d2b6a7cf142b41249879ab" id="r_a5184b11be8d2b6a7cf142b41249879ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5184b11be8d2b6a7cf142b41249879ab">SetMaxTimestep</a> (std::chrono::duration&lt; double &gt; maxTimestep)</td></tr>
<tr class="memdesc:a5184b11be8d2b6a7cf142b41249879ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to set an upper bound on the timestep.  <br /></td></tr>
<tr class="separator:a5184b11be8d2b6a7cf142b41249879ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c735bd2a3106790f6406da304fbdeb" id="r_af0c735bd2a3106790f6406da304fbdeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0c735bd2a3106790f6406da304fbdeb">X</a> ()</td></tr>
<tr class="memdesc:af0c735bd2a3106790f6406da304fbdeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the state variables.  <br /></td></tr>
<tr class="separator:af0c735bd2a3106790f6406da304fbdeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c01f4aa9e33b44fb683e6953476c94e" id="r_a3c01f4aa9e33b44fb683e6953476c94e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c01f4aa9e33b44fb683e6953476c94e">U</a> ()</td></tr>
<tr class="memdesc:a3c01f4aa9e33b44fb683e6953476c94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the input variables.  <br /></td></tr>
<tr class="separator:a3c01f4aa9e33b44fb683e6953476c94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b796e9953f833a826ef5ec3b031989" id="r_a87b796e9953f833a826ef5ec3b031989"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87b796e9953f833a826ef5ec3b031989">DT</a> ()</td></tr>
<tr class="memdesc:a87b796e9953f833a826ef5ec3b031989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the timestep variables.  <br /></td></tr>
<tr class="separator:a87b796e9953f833a826ef5ec3b031989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa7ccc8f229931e174edaad4980c2a3" id="r_a2aa7ccc8f229931e174edaad4980c2a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2aa7ccc8f229931e174edaad4980c2a3">InitialState</a> ()</td></tr>
<tr class="memdesc:a2aa7ccc8f229931e174edaad4980c2a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to get the initial state in the trajectory.  <br /></td></tr>
<tr class="separator:a2aa7ccc8f229931e174edaad4980c2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4fb43525aa49bf3279b6b04405b45ba" id="r_aa4fb43525aa49bf3279b6b04405b45ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4fb43525aa49bf3279b6b04405b45ba">FinalState</a> ()</td></tr>
<tr class="memdesc:aa4fb43525aa49bf3279b6b04405b45ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to get the final state in the trajectory.  <br /></td></tr>
<tr class="separator:aa4fb43525aa49bf3279b6b04405b45ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsleipnir_1_1_optimization_problem"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classsleipnir_1_1_optimization_problem')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsleipnir_1_1_optimization_problem.html">sleipnir::OptimizationProblem</a></td></tr>
<tr class="memitem:a640151f39f60be00774a0c8cc261dba9 inherit pub_methods_classsleipnir_1_1_optimization_problem" id="r_a640151f39f60be00774a0c8cc261dba9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_optimization_problem.html#a640151f39f60be00774a0c8cc261dba9">OptimizationProblem</a> () noexcept=default</td></tr>
<tr class="memdesc:a640151f39f60be00774a0c8cc261dba9 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the optimization problem.  <br /></td></tr>
<tr class="separator:a640151f39f60be00774a0c8cc261dba9 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1fb0865ccd97cca8e36e8b64f8c791 inherit pub_methods_classsleipnir_1_1_optimization_problem" id="r_acf1fb0865ccd97cca8e36e8b64f8c791"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsleipnir_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_optimization_problem.html#acf1fb0865ccd97cca8e36e8b64f8c791">DecisionVariable</a> ()</td></tr>
<tr class="memdesc:acf1fb0865ccd97cca8e36e8b64f8c791 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a decision variable in the optimization problem.  <br /></td></tr>
<tr class="separator:acf1fb0865ccd97cca8e36e8b64f8c791 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f03c22303de2438517068a997cadf9e inherit pub_methods_classsleipnir_1_1_optimization_problem" id="r_a8f03c22303de2438517068a997cadf9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_optimization_problem.html#a8f03c22303de2438517068a997cadf9e">DecisionVariable</a> (int rows, int cols=1)</td></tr>
<tr class="memdesc:a8f03c22303de2438517068a997cadf9e inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matrix of decision variables in the optimization problem.  <br /></td></tr>
<tr class="separator:a8f03c22303de2438517068a997cadf9e inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94ab8789eecfeb79f8e8fe309e632f4 inherit pub_methods_classsleipnir_1_1_optimization_problem" id="r_af94ab8789eecfeb79f8e8fe309e632f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_optimization_problem.html#af94ab8789eecfeb79f8e8fe309e632f4">SymmetricDecisionVariable</a> (int rows)</td></tr>
<tr class="memdesc:af94ab8789eecfeb79f8e8fe309e632f4 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a symmetric matrix of decision variables in the optimization problem.  <br /></td></tr>
<tr class="separator:af94ab8789eecfeb79f8e8fe309e632f4 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab668c5281e9624671da59c780515ce98 inherit pub_methods_classsleipnir_1_1_optimization_problem" id="r_ab668c5281e9624671da59c780515ce98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_optimization_problem.html#ab668c5281e9624671da59c780515ce98">Minimize</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;cost)</td></tr>
<tr class="memdesc:ab668c5281e9624671da59c780515ce98 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the solver to minimize the output of the given cost function.  <br /></td></tr>
<tr class="separator:ab668c5281e9624671da59c780515ce98 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfaac1f0fde335e01de46a411d3d3ed4 inherit pub_methods_classsleipnir_1_1_optimization_problem" id="r_acfaac1f0fde335e01de46a411d3d3ed4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_optimization_problem.html#acfaac1f0fde335e01de46a411d3d3ed4">Minimize</a> (<a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&amp;cost)</td></tr>
<tr class="memdesc:acfaac1f0fde335e01de46a411d3d3ed4 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the solver to minimize the output of the given cost function.  <br /></td></tr>
<tr class="separator:acfaac1f0fde335e01de46a411d3d3ed4 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a0a8df764e238933c50c0f7b21a161 inherit pub_methods_classsleipnir_1_1_optimization_problem" id="r_af2a0a8df764e238933c50c0f7b21a161"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_optimization_problem.html#af2a0a8df764e238933c50c0f7b21a161">Maximize</a> (const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;objective)</td></tr>
<tr class="memdesc:af2a0a8df764e238933c50c0f7b21a161 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the solver to maximize the output of the given objective function.  <br /></td></tr>
<tr class="separator:af2a0a8df764e238933c50c0f7b21a161 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31962decb83f8d970560e1f5c09e1da inherit pub_methods_classsleipnir_1_1_optimization_problem" id="r_ae31962decb83f8d970560e1f5c09e1da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_optimization_problem.html#ae31962decb83f8d970560e1f5c09e1da">Maximize</a> (<a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;&amp;objective)</td></tr>
<tr class="memdesc:ae31962decb83f8d970560e1f5c09e1da inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the solver to maximize the output of the given objective function.  <br /></td></tr>
<tr class="separator:ae31962decb83f8d970560e1f5c09e1da inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2612a9883c6dcd05011c54bd28c734 inherit pub_methods_classsleipnir_1_1_optimization_problem" id="r_a9d2612a9883c6dcd05011c54bd28c734"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_optimization_problem.html#a9d2612a9883c6dcd05011c54bd28c734">SubjectTo</a> (const <a class="el" href="structsleipnir_1_1_equality_constraints.html">EqualityConstraints</a> &amp;constraint)</td></tr>
<tr class="memdesc:a9d2612a9883c6dcd05011c54bd28c734 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the solver to solve the problem while satisfying the given equality constraint.  <br /></td></tr>
<tr class="separator:a9d2612a9883c6dcd05011c54bd28c734 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ec279a1e7fea8679e820d83c5151bd inherit pub_methods_classsleipnir_1_1_optimization_problem" id="r_a85ec279a1e7fea8679e820d83c5151bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_optimization_problem.html#a85ec279a1e7fea8679e820d83c5151bd">SubjectTo</a> (<a class="el" href="structsleipnir_1_1_equality_constraints.html">EqualityConstraints</a> &amp;&amp;constraint)</td></tr>
<tr class="memdesc:a85ec279a1e7fea8679e820d83c5151bd inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the solver to solve the problem while satisfying the given equality constraint.  <br /></td></tr>
<tr class="separator:a85ec279a1e7fea8679e820d83c5151bd inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada68a2f2cfa921df207e1708646e2877 inherit pub_methods_classsleipnir_1_1_optimization_problem" id="r_ada68a2f2cfa921df207e1708646e2877"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_optimization_problem.html#ada68a2f2cfa921df207e1708646e2877">SubjectTo</a> (const <a class="el" href="structsleipnir_1_1_inequality_constraints.html">InequalityConstraints</a> &amp;constraint)</td></tr>
<tr class="memdesc:ada68a2f2cfa921df207e1708646e2877 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the solver to solve the problem while satisfying the given inequality constraint.  <br /></td></tr>
<tr class="separator:ada68a2f2cfa921df207e1708646e2877 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9e7158c155290f0553b0c4664f5609 inherit pub_methods_classsleipnir_1_1_optimization_problem" id="r_a3c9e7158c155290f0553b0c4664f5609"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_optimization_problem.html#a3c9e7158c155290f0553b0c4664f5609">SubjectTo</a> (<a class="el" href="structsleipnir_1_1_inequality_constraints.html">InequalityConstraints</a> &amp;&amp;constraint)</td></tr>
<tr class="memdesc:a3c9e7158c155290f0553b0c4664f5609 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the solver to solve the problem while satisfying the given inequality constraint.  <br /></td></tr>
<tr class="separator:a3c9e7158c155290f0553b0c4664f5609 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9e483026fddcd34a110790916e8f92 inherit pub_methods_classsleipnir_1_1_optimization_problem" id="r_a9b9e483026fddcd34a110790916e8f92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsleipnir_1_1_solver_status.html">SolverStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_optimization_problem.html#a9b9e483026fddcd34a110790916e8f92">Solve</a> (const <a class="el" href="structsleipnir_1_1_solver_config.html">SolverConfig</a> &amp;config=<a class="el" href="structsleipnir_1_1_solver_config.html">SolverConfig</a>{})</td></tr>
<tr class="memdesc:a9b9e483026fddcd34a110790916e8f92 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the optimization problem.  <br /></td></tr>
<tr class="separator:a9b9e483026fddcd34a110790916e8f92 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d39fbfb1705fc5ac134fb3b64e9860 inherit pub_methods_classsleipnir_1_1_optimization_problem" id="r_a89d39fbfb1705fc5ac134fb3b64e9860"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; <br />
requires requires(F callback, const <a class="el" href="structsleipnir_1_1_solver_iteration_info.html">SolverIterationInfo</a>&amp; info) { { callback(info) } -&gt; std::same_as&lt;void&gt;; }</td></tr>
<tr class="memitem:a89d39fbfb1705fc5ac134fb3b64e9860 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_optimization_problem.html#a89d39fbfb1705fc5ac134fb3b64e9860">Callback</a> (F &amp;&amp;callback)</td></tr>
<tr class="memdesc:a89d39fbfb1705fc5ac134fb3b64e9860 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a callback to be called at each solver iteration.  <br /></td></tr>
<tr class="separator:a89d39fbfb1705fc5ac134fb3b64e9860 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fa1ffeaecd55daeaaf56c6d4e6fa07 inherit pub_methods_classsleipnir_1_1_optimization_problem" id="r_a44fa1ffeaecd55daeaaf56c6d4e6fa07"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; <br />
requires requires(F callback, const <a class="el" href="structsleipnir_1_1_solver_iteration_info.html">SolverIterationInfo</a>&amp; info) { { callback(info) } -&gt; std::same_as&lt;bool&gt;; }</td></tr>
<tr class="memitem:a44fa1ffeaecd55daeaaf56c6d4e6fa07 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsleipnir_1_1_optimization_problem.html#a44fa1ffeaecd55daeaaf56c6d4e6fa07">Callback</a> (F &amp;&amp;callback)</td></tr>
<tr class="memdesc:a44fa1ffeaecd55daeaaf56c6d4e6fa07 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a callback to be called at each solver iteration.  <br /></td></tr>
<tr class="separator:a44fa1ffeaecd55daeaaf56c6d4e6fa07 inherit pub_methods_classsleipnir_1_1_optimization_problem"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class allows the user to pose and solve a constrained optimal control problem (OCP) in a variety of ways. </p>
<p>The system is transcripted by one of three methods (direct transcription, direct collocation, or single-shooting) and additional constraints can be added.</p>
<p>In direct transcription, each state is a decision variable constrained to the integrated dynamics of the previous state. In direct collocation, the trajectory is modeled as a series of cubic polynomials where the centerpoint slope is constrained. In single-shooting, states depend explicitly as a function of all previous states and all previous inputs.</p>
<p>Explicit ODEs are integrated using RK4.</p>
<p>For explicit ODEs, the function must be in the form dx/dt = f(t, x, u). For discrete state transition functions, the function must be in the form xₖ₊₁ = f(t, xₖ, uₖ).</p>
<p>Direct collocation requires an explicit ODE. Direct transcription and single-shooting can use either an ODE or state transition function.</p>
<p><a href="https://underactuated.mit.edu/trajopt.html">https://underactuated.mit.edu/trajopt.html</a> goes into more detail on each transcription method. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae43124dc00a36ac0162f0c618dd9d76d" name="ae43124dc00a36ac0162f0c618dd9d76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43124dc00a36ac0162f0c618dd9d76d">&#9670;&#160;</a></span>OCPSolver() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sleipnir::OCPSolver::OCPSolver </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numStates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numInputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>dt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSteps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a>(const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;x, const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;u)&gt;</td>          <td class="paramname"><span class="paramname"><em>dynamics</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesleipnir.html#a38e60fa99ee023884ea7a163a67169f7">DynamicsType</a></td>          <td class="paramname"><span class="paramname"><em>dynamicsType</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespacesleipnir.html#a38e60fa99ee023884ea7a163a67169f7a6976d4824b9f5192d274a69163d67423">DynamicsType::kExplicitODE</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesleipnir.html#aa0c8390ba2ad034b958630d8b7d962b4">TimestepMethod</a></td>          <td class="paramname"><span class="paramname"><em>timestepMethod</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespacesleipnir.html#aa0c8390ba2ad034b958630d8b7d962b4a826888a09763de7e2a9f60eb85d88b24">TimestepMethod::kFixed</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesleipnir.html#a7b6ff477fca07d31231aade7ce57207a">TranscriptionMethod</a></td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespacesleipnir.html#a7b6ff477fca07d31231aade7ce57207aae09070d9a1cb5eaf8c431ff130d77254">TranscriptionMethod::kDirectTranscription</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build an optimization problem using a system evolution function (explicit ODE or discrete state transition function). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numStates</td><td>The number of system states. </td></tr>
    <tr><td class="paramname">numInputs</td><td>The number of system inputs. </td></tr>
    <tr><td class="paramname">dt</td><td>The timestep for fixed-step integration. </td></tr>
    <tr><td class="paramname">numSteps</td><td>The number of control points. </td></tr>
    <tr><td class="paramname">dynamics</td><td>Function representing an explicit or implicit ODE, or a discrete state transition function.<ul>
<li>Explicit: dx/dt = f(x, u, *)</li>
<li>Implicit: f([x dx/dt]', u, *) = 0</li>
<li>State transition: xₖ₊₁ = f(xₖ, uₖ) </li>
</ul>
</td></tr>
    <tr><td class="paramname">dynamicsType</td><td>The type of system evolution function. </td></tr>
    <tr><td class="paramname">timestepMethod</td><td>The timestep method. </td></tr>
    <tr><td class="paramname">method</td><td>The transcription method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9ca52dad54a9b1887b8eec52adaa7b4" name="af9ca52dad54a9b1887b8eec52adaa7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ca52dad54a9b1887b8eec52adaa7b4">&#9670;&#160;</a></span>OCPSolver() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sleipnir::OCPSolver::OCPSolver </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numStates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numInputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>dt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSteps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a>(const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;t, const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;x, const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;u, const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;dt)&gt;</td>          <td class="paramname"><span class="paramname"><em>dynamics</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesleipnir.html#a38e60fa99ee023884ea7a163a67169f7">DynamicsType</a></td>          <td class="paramname"><span class="paramname"><em>dynamicsType</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespacesleipnir.html#a38e60fa99ee023884ea7a163a67169f7a6976d4824b9f5192d274a69163d67423">DynamicsType::kExplicitODE</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesleipnir.html#aa0c8390ba2ad034b958630d8b7d962b4">TimestepMethod</a></td>          <td class="paramname"><span class="paramname"><em>timestepMethod</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespacesleipnir.html#aa0c8390ba2ad034b958630d8b7d962b4a826888a09763de7e2a9f60eb85d88b24">TimestepMethod::kFixed</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesleipnir.html#a7b6ff477fca07d31231aade7ce57207a">TranscriptionMethod</a></td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespacesleipnir.html#a7b6ff477fca07d31231aade7ce57207aae09070d9a1cb5eaf8c431ff130d77254">TranscriptionMethod::kDirectTranscription</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build an optimization problem using a system evolution function (explicit ODE or discrete state transition function). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numStates</td><td>The number of system states. </td></tr>
    <tr><td class="paramname">numInputs</td><td>The number of system inputs. </td></tr>
    <tr><td class="paramname">dt</td><td>The timestep for fixed-step integration. </td></tr>
    <tr><td class="paramname">numSteps</td><td>The number of control points. </td></tr>
    <tr><td class="paramname">dynamics</td><td>Function representing an explicit or implicit ODE, or a discrete state transition function.<ul>
<li>Explicit: dx/dt = f(t, x, u, *)</li>
<li>Implicit: f(t, [x dx/dt]', u, *) = 0</li>
<li>State transition: xₖ₊₁ = f(t, xₖ, uₖ, dt) </li>
</ul>
</td></tr>
    <tr><td class="paramname">dynamicsType</td><td>The type of system evolution function. </td></tr>
    <tr><td class="paramname">timestepMethod</td><td>The timestep method. </td></tr>
    <tr><td class="paramname">method</td><td>The transcription method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9b57e07446c3c80d41cc92510ea678ce" name="a9b57e07446c3c80d41cc92510ea678ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b57e07446c3c80d41cc92510ea678ce">&#9670;&#160;</a></span>ConstrainFinalState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; <br />
requires ScalarLike&lt;T&gt; || MatrixLike&lt;T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sleipnir::OCPSolver::ConstrainFinalState </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>finalState</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to constrain the final state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">finalState</td><td>the final state to constrain to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0927efb3802037b5c4e768a3d90bee51" name="a0927efb3802037b5c4e768a3d90bee51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0927efb3802037b5c4e768a3d90bee51">&#9670;&#160;</a></span>ConstrainInitialState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; <br />
requires ScalarLike&lt;T&gt; || MatrixLike&lt;T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sleipnir::OCPSolver::ConstrainInitialState </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>initialState</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to constrain the initial state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initialState</td><td>the initial state to constrain to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87b796e9953f833a826ef5ec3b031989" name="a87b796e9953f833a826ef5ec3b031989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b796e9953f833a826ef5ec3b031989">&#9670;&#160;</a></span>DT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp; sleipnir::OCPSolver::DT </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the timestep variables. </p>
<p>After the problem is solved, this will contain the timesteps corresponding to the optimized trajectory.</p>
<p>Shaped 1x(numSteps+1), although the last timestep is unused in the trajectory.</p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The timestep variable matrix. </dd></dl>

</div>
</div>
<a id="aa4fb43525aa49bf3279b6b04405b45ba" name="aa4fb43525aa49bf3279b6b04405b45ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4fb43525aa49bf3279b6b04405b45ba">&#9670;&#160;</a></span>FinalState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> sleipnir::OCPSolver::FinalState </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to get the final state in the trajectory. </p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The final state of the trajectory. </dd></dl>

</div>
</div>
<a id="aad115c582e25d713304077dde45cddb4" name="aad115c582e25d713304077dde45cddb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad115c582e25d713304077dde45cddb4">&#9670;&#160;</a></span>ForEachStep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sleipnir::OCPSolver::ForEachStep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; void(const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;t, const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;x, const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;u, const <a class="el" href="classsleipnir_1_1_variable.html">Variable</a> &amp;dt)&gt;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the constraint evaluation function. </p>
<p>This function is called <code>numSteps+1</code> times, with the corresponding state and input VariableMatrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback f(t, x, u, dt) where t is time, x is the state vector, u is the input vector, and dt is the timestep duration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7886adfdd01442aa274800e0930fe252" name="a7886adfdd01442aa274800e0930fe252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7886adfdd01442aa274800e0930fe252">&#9670;&#160;</a></span>ForEachStep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sleipnir::OCPSolver::ForEachStep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsleipnir_1_1function__ref.html">function_ref</a>&lt; void(const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;x, const <a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp;u)&gt;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the constraint evaluation function. </p>
<p>This function is called <code>numSteps+1</code> times, with the corresponding state and input VariableMatrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback f(x, u) where x is the state and u is the input vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2aa7ccc8f229931e174edaad4980c2a3" name="a2aa7ccc8f229931e174edaad4980c2a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa7ccc8f229931e174edaad4980c2a3">&#9670;&#160;</a></span>InitialState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> sleipnir::OCPSolver::InitialState </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to get the initial state in the trajectory. </p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The initial state of the trajectory. </dd></dl>

</div>
</div>
<a id="ac4db4ab3731845eab6256b61c9491ec8" name="ac4db4ab3731845eab6256b61c9491ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4db4ab3731845eab6256b61c9491ec8">&#9670;&#160;</a></span>SetLowerInputBound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; <br />
requires ScalarLike&lt;T&gt; || MatrixLike&lt;T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sleipnir::OCPSolver::SetLowerInputBound </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>lowerBound</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to set a lower bound on the input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lowerBound</td><td>The lower bound that inputs must always be above. Must be shaped (numInputs)x1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5184b11be8d2b6a7cf142b41249879ab" name="a5184b11be8d2b6a7cf142b41249879ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5184b11be8d2b6a7cf142b41249879ab">&#9670;&#160;</a></span>SetMaxTimestep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sleipnir::OCPSolver::SetMaxTimestep </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>maxTimestep</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to set an upper bound on the timestep. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxTimestep</td><td>The maximum timestep. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a248550561132558d7c8ba9d36705387e" name="a248550561132558d7c8ba9d36705387e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a248550561132558d7c8ba9d36705387e">&#9670;&#160;</a></span>SetMinTimestep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sleipnir::OCPSolver::SetMinTimestep </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>minTimestep</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to set a lower bound on the timestep. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minTimestep</td><td>The minimum timestep. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ff1d385e839c7ea1d8e54d6a840d5af" name="a9ff1d385e839c7ea1d8e54d6a840d5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff1d385e839c7ea1d8e54d6a840d5af">&#9670;&#160;</a></span>SetUpperInputBound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; <br />
requires ScalarLike&lt;T&gt; || MatrixLike&lt;T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sleipnir::OCPSolver::SetUpperInputBound </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>upperBound</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to set an upper bound on the input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upperBound</td><td>The upper bound that inputs must always be below. Must be shaped (numInputs)x1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c01f4aa9e33b44fb683e6953476c94e" name="a3c01f4aa9e33b44fb683e6953476c94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c01f4aa9e33b44fb683e6953476c94e">&#9670;&#160;</a></span>U()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp; sleipnir::OCPSolver::U </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the input variables. </p>
<p>After the problem is solved, this will contain the inputs corresponding to the optimized trajectory.</p>
<p>Shaped (numInputs)x(numSteps+1), although the last input step is unused in the trajectory.</p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The input variable matrix. </dd></dl>

</div>
</div>
<a id="af0c735bd2a3106790f6406da304fbdeb" name="af0c735bd2a3106790f6406da304fbdeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c735bd2a3106790f6406da304fbdeb">&#9670;&#160;</a></span>X()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsleipnir_1_1_variable_matrix.html">VariableMatrix</a> &amp; sleipnir::OCPSolver::X </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the state variables. </p>
<p>After the problem is solved, this will contain the optimized trajectory.</p>
<p>Shaped (numStates)x(numSteps+1).</p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The state variable matrix. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/allwpilib/allwpilib/wpimath/src/main/native/thirdparty/sleipnir/include/sleipnir/control/<a class="el" href="_o_c_p_solver_8hpp_source.html">OCPSolver.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesleipnir.html">sleipnir</a></li><li class="navelem"><a class="el" href="classsleipnir_1_1_o_c_p_solver.html">OCPSolver</a></li>
    <li class="footer">Generated on Thu Oct 24 2024 04:48:55 for WPILibC++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
