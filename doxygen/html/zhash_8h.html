<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: /home/runner/work/allwpilib/allwpilib/apriltag/src/main/native/thirdparty/apriltag/include/common/zhash.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="wpilib-128.png"/></td>
  <td id="projectalign">
   <div id="projectname">WPILibC++<span id="projectnumber">&#160;2025.1.1-beta-1-35-g9a5f73d</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('zhash_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">zhash.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;<a class="el" href="zarray_8h_source.html">zarray.h</a>&quot;</code><br />
</div>
<p><a href="zhash_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzhash__iterator.html">zhash_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad3e2c894fe80cfcf355be772cea3bc53" id="r_ad3e2c894fe80cfcf355be772cea3bc53"><td class="memItemLeft" align="right" valign="top">typedef struct zhash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a></td></tr>
<tr class="memdesc:ad3e2c894fe80cfcf355be772cea3bc53"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hash table for structs and primitive types that stores entries by value.  <br /></td></tr>
<tr class="separator:ad3e2c894fe80cfcf355be772cea3bc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25fcf8243f5fdaeaab2d01dc9d17b3f" id="r_ad25fcf8243f5fdaeaab2d01dc9d17b3f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structzhash__iterator.html">zhash_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad25fcf8243f5fdaeaab2d01dc9d17b3f">zhash_iterator_t</a></td></tr>
<tr class="separator:ad25fcf8243f5fdaeaab2d01dc9d17b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afada7df5c3b3a9d535f12d9c5290a7c9" id="r_afada7df5c3b3a9d535f12d9c5290a7c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afada7df5c3b3a9d535f12d9c5290a7c9">zhash_create</a> (size_t keysz, size_t valuesz, uint32_t(*hash)(const void *a), int(*equals)(const void *a, const void *b))</td></tr>
<tr class="memdesc:afada7df5c3b3a9d535f12d9c5290a7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create, initializes, and returns an empty hash table structure.  <br /></td></tr>
<tr class="separator:afada7df5c3b3a9d535f12d9c5290a7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c63be960100748115006ba11b9d76b2" id="r_a1c63be960100748115006ba11b9d76b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c63be960100748115006ba11b9d76b2">zhash_destroy</a> (<a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *zh)</td></tr>
<tr class="memdesc:a1c63be960100748115006ba11b9d76b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all resources associated with the hash table structure which was created by <a class="el" href="#afada7df5c3b3a9d535f12d9c5290a7c9" title="Create, initializes, and returns an empty hash table structure.">zhash_create()</a>.  <br /></td></tr>
<tr class="separator:a1c63be960100748115006ba11b9d76b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df7a2ddc7ba8ca9b54f989ae41ff4ae" id="r_a8df7a2ddc7ba8ca9b54f989ae41ff4ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8df7a2ddc7ba8ca9b54f989ae41ff4ae">zhash_copy</a> (const <a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *other)</td></tr>
<tr class="memdesc:a8df7a2ddc7ba8ca9b54f989ae41ff4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a new identical copy of the zhash (i.e.  <br /></td></tr>
<tr class="separator:a8df7a2ddc7ba8ca9b54f989ae41ff4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38ae99a444ee2cfce107f5a52252b06" id="r_ad38ae99a444ee2cfce107f5a52252b06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad38ae99a444ee2cfce107f5a52252b06">zhash_contains</a> (const <a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *zh, const void *key)</td></tr>
<tr class="memdesc:ad38ae99a444ee2cfce107f5a52252b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the supplied key value exists as an entry in the zhash table.  <br /></td></tr>
<tr class="separator:ad38ae99a444ee2cfce107f5a52252b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f733a0f24c9d7d459eb3ffe0fff5bd2" id="r_a5f733a0f24c9d7d459eb3ffe0fff5bd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f733a0f24c9d7d459eb3ffe0fff5bd2">zhash_get</a> (const <a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *zh, const void *key, void *out_value)</td></tr>
<tr class="memdesc:a5f733a0f24c9d7d459eb3ffe0fff5bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the value for the given key, if it exists, by copying its contents into the space pointed to by 'out_value', which must already be allocated.  <br /></td></tr>
<tr class="separator:a5f733a0f24c9d7d459eb3ffe0fff5bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163b4ff2ec3067df5e964af8fa959d4b" id="r_a163b4ff2ec3067df5e964af8fa959d4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a163b4ff2ec3067df5e964af8fa959d4b">zhash_get_volatile</a> (const <a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *zh, const void *key, void *out_p)</td></tr>
<tr class="memdesc:a163b4ff2ec3067df5e964af8fa959d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="#a5f733a0f24c9d7d459eb3ffe0fff5bd2" title="Retrieves the value for the given key, if it exists, by copying its contents into the space pointed t...">zhash_get()</a>, but more dangerous.  <br /></td></tr>
<tr class="separator:a163b4ff2ec3067df5e964af8fa959d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcf3aacd4bcf1113c1b83e8a15b060c" id="r_a1fcf3aacd4bcf1113c1b83e8a15b060c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fcf3aacd4bcf1113c1b83e8a15b060c">zhash_put</a> (<a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *zh, const void *key, const void *value, void *oldkey, void *oldvalue)</td></tr>
<tr class="memdesc:a1fcf3aacd4bcf1113c1b83e8a15b060c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a key/value pair to the hash table, if the supplied key does not already exist in the table, or overwrites the value for the supplied key if it does already exist.  <br /></td></tr>
<tr class="separator:a1fcf3aacd4bcf1113c1b83e8a15b060c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152239132cc50de47c4f3416f80f5d5b" id="r_a152239132cc50de47c4f3416f80f5d5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a152239132cc50de47c4f3416f80f5d5b">zhash_remove</a> (<a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *zh, const void *key, void *oldkey, void *oldvalue)</td></tr>
<tr class="memdesc:a152239132cc50de47c4f3416f80f5d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes from the zhash table the key/value pair for the supplied key, if it exists.  <br /></td></tr>
<tr class="separator:a152239132cc50de47c4f3416f80f5d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2d9a1c9108a1ee9f8bd6489b96b680" id="r_adb2d9a1c9108a1ee9f8bd6489b96b680"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb2d9a1c9108a1ee9f8bd6489b96b680">zhash_clear</a> (<a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *zh)</td></tr>
<tr class="memdesc:adb2d9a1c9108a1ee9f8bd6489b96b680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all entries in the has table to create the equivalent of starting from a <a class="el" href="#afada7df5c3b3a9d535f12d9c5290a7c9" title="Create, initializes, and returns an empty hash table structure.">zhash_create()</a>, using the same size parameters.  <br /></td></tr>
<tr class="separator:adb2d9a1c9108a1ee9f8bd6489b96b680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9044d979e7371c387d366c5d860bdd3c" id="r_a9044d979e7371c387d366c5d860bdd3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9044d979e7371c387d366c5d860bdd3c">zhash_size</a> (const <a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *zh)</td></tr>
<tr class="memdesc:a9044d979e7371c387d366c5d860bdd3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current number of key/value pairs currently contained in the zhash table, or 0 if the table is empty.  <br /></td></tr>
<tr class="separator:a9044d979e7371c387d366c5d860bdd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dff15dee80154e9387afbddd3e1a5a9" id="r_a1dff15dee80154e9387afbddd3e1a5a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1dff15dee80154e9387afbddd3e1a5a9">zhash_iterator_init</a> (<a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *zh, <a class="el" href="#ad25fcf8243f5fdaeaab2d01dc9d17b3f">zhash_iterator_t</a> *zit)</td></tr>
<tr class="memdesc:a1dff15dee80154e9387afbddd3e1a5a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an iterator which can be used to traverse the key/value pairs of the supplied zhash table via successive calls to <a class="el" href="#aabfad3dd37f811b1d7d186cc572b845f" title="Retrieves the next key/value pair from a zhash table via the (previously- initialized) iterator.">zhash_iterator_next()</a> or <a class="el" href="#a88fe3cde4e4906fc210c3897fbc81083" title="Similar to zhash_iterator_next() except that it retrieves a pointer to zhash&#39;s internal storage.">zhash_iterator_next_volatile()</a>.  <br /></td></tr>
<tr class="separator:a1dff15dee80154e9387afbddd3e1a5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a8cfd64481751ae6e97288ba05b2f1" id="r_a88a8cfd64481751ae6e97288ba05b2f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88a8cfd64481751ae6e97288ba05b2f1">zhash_iterator_init_const</a> (const <a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *zh, <a class="el" href="#ad25fcf8243f5fdaeaab2d01dc9d17b3f">zhash_iterator_t</a> *zit)</td></tr>
<tr class="memdesc:a88a8cfd64481751ae6e97288ba05b2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an iterator which can be used to traverse the key/value pairs of the supplied zhash table via successive calls to <a class="el" href="#aabfad3dd37f811b1d7d186cc572b845f" title="Retrieves the next key/value pair from a zhash table via the (previously- initialized) iterator.">zhash_iterator_next()</a> or <a class="el" href="#a88fe3cde4e4906fc210c3897fbc81083" title="Similar to zhash_iterator_next() except that it retrieves a pointer to zhash&#39;s internal storage.">zhash_iterator_next_volatile()</a>.  <br /></td></tr>
<tr class="separator:a88a8cfd64481751ae6e97288ba05b2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfad3dd37f811b1d7d186cc572b845f" id="r_aabfad3dd37f811b1d7d186cc572b845f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabfad3dd37f811b1d7d186cc572b845f">zhash_iterator_next</a> (<a class="el" href="#ad25fcf8243f5fdaeaab2d01dc9d17b3f">zhash_iterator_t</a> *zit, void *outkey, void *outvalue)</td></tr>
<tr class="memdesc:aabfad3dd37f811b1d7d186cc572b845f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the next key/value pair from a zhash table via the (previously- initialized) iterator.  <br /></td></tr>
<tr class="separator:aabfad3dd37f811b1d7d186cc572b845f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88fe3cde4e4906fc210c3897fbc81083" id="r_a88fe3cde4e4906fc210c3897fbc81083"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88fe3cde4e4906fc210c3897fbc81083">zhash_iterator_next_volatile</a> (<a class="el" href="#ad25fcf8243f5fdaeaab2d01dc9d17b3f">zhash_iterator_t</a> *zit, void *outkey, void *outvalue)</td></tr>
<tr class="memdesc:a88fe3cde4e4906fc210c3897fbc81083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="#aabfad3dd37f811b1d7d186cc572b845f" title="Retrieves the next key/value pair from a zhash table via the (previously- initialized) iterator.">zhash_iterator_next()</a> except that it retrieves a pointer to zhash's internal storage.  <br /></td></tr>
<tr class="separator:a88fe3cde4e4906fc210c3897fbc81083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31aba2091ac0de2cfc38d4903d08f237" id="r_a31aba2091ac0de2cfc38d4903d08f237"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31aba2091ac0de2cfc38d4903d08f237">zhash_iterator_remove</a> (<a class="el" href="#ad25fcf8243f5fdaeaab2d01dc9d17b3f">zhash_iterator_t</a> *zit)</td></tr>
<tr class="memdesc:a31aba2091ac0de2cfc38d4903d08f237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes from the zhash table the key/value pair most recently returned via a call to <a class="el" href="#aabfad3dd37f811b1d7d186cc572b845f" title="Retrieves the next key/value pair from a zhash table via the (previously- initialized) iterator.">zhash_iterator_next()</a> or <a class="el" href="#a88fe3cde4e4906fc210c3897fbc81083" title="Similar to zhash_iterator_next() except that it retrieves a pointer to zhash&#39;s internal storage.">zhash_iterator_next_volatile()</a> for the supplied iterator.  <br /></td></tr>
<tr class="separator:a31aba2091ac0de2cfc38d4903d08f237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1fba83933fdf91757e0373d7ae755fc" id="r_ad1fba83933fdf91757e0373d7ae755fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1fba83933fdf91757e0373d7ae755fc">zhash_map_keys</a> (<a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *zh, void(*f)(void *))</td></tr>
<tr class="memdesc:ad1fba83933fdf91757e0373d7ae755fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the supplied function with a pointer to every key in the hash table in turn.  <br /></td></tr>
<tr class="separator:ad1fba83933fdf91757e0373d7ae755fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd6a3e9ab16b8e10c495e3c3fe0d75e" id="r_abfd6a3e9ab16b8e10c495e3c3fe0d75e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfd6a3e9ab16b8e10c495e3c3fe0d75e">zhash_map_values</a> (<a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *zh, void(*f)(void *))</td></tr>
<tr class="memdesc:abfd6a3e9ab16b8e10c495e3c3fe0d75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the supplied function with a pointer to every value in the hash table in turn.  <br /></td></tr>
<tr class="separator:abfd6a3e9ab16b8e10c495e3c3fe0d75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67694d0db20d02ce364262f0fd9206e" id="r_ae67694d0db20d02ce364262f0fd9206e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae67694d0db20d02ce364262f0fd9206e">zhash_vmap_keys</a> (<a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *vh, void(*f)(void *))</td></tr>
<tr class="memdesc:ae67694d0db20d02ce364262f0fd9206e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the supplied function with a copy of every key in the hash table in turn.  <br /></td></tr>
<tr class="separator:ae67694d0db20d02ce364262f0fd9206e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2158cd36c2cdaadd3be86e44f0d981" id="r_ada2158cd36c2cdaadd3be86e44f0d981"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada2158cd36c2cdaadd3be86e44f0d981">zhash_vmap_values</a> (<a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *vh, void(*f)(void *))</td></tr>
<tr class="memdesc:ada2158cd36c2cdaadd3be86e44f0d981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the supplied function with a copy of every value in the hash table in turn.  <br /></td></tr>
<tr class="separator:ada2158cd36c2cdaadd3be86e44f0d981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d7fc2e9335add8584fdbe6da9b5103" id="r_aa4d7fc2e9335add8584fdbe6da9b5103"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zarray_8h.html#af429d8225958865fc14ea0ddcc7c0b06">zarray_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4d7fc2e9335add8584fdbe6da9b5103">zhash_keys</a> (const <a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *zh)</td></tr>
<tr class="memdesc:aa4d7fc2e9335add8584fdbe6da9b5103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array which contains copies of all of the hash table's keys, in no particular order.  <br /></td></tr>
<tr class="separator:aa4d7fc2e9335add8584fdbe6da9b5103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea616752a32261441ba50d052acc595" id="r_aaea616752a32261441ba50d052acc595"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zarray_8h.html#af429d8225958865fc14ea0ddcc7c0b06">zarray_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaea616752a32261441ba50d052acc595">zhash_values</a> (const <a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *zh)</td></tr>
<tr class="memdesc:aaea616752a32261441ba50d052acc595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array which contains copies of all of the hash table's values, in no particular order.  <br /></td></tr>
<tr class="separator:aaea616752a32261441ba50d052acc595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42caf1dfef590a38648d9505860c19d" id="r_af42caf1dfef590a38648d9505860c19d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af42caf1dfef590a38648d9505860c19d">zhash_uint32_hash</a> (const void *a)</td></tr>
<tr class="memdesc:af42caf1dfef590a38648d9505860c19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a hash function which will calculate a zhash value for uint32_t input data.  <br /></td></tr>
<tr class="separator:af42caf1dfef590a38648d9505860c19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cbe317eeb029aec34ffbae7d5706b9" id="r_a75cbe317eeb029aec34ffbae7d5706b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75cbe317eeb029aec34ffbae7d5706b9">zhash_uint32_equals</a> (const void *a, const void *b)</td></tr>
<tr class="memdesc:a75cbe317eeb029aec34ffbae7d5706b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a function to compare zhash values for uint32_t input data.  <br /></td></tr>
<tr class="separator:a75cbe317eeb029aec34ffbae7d5706b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b204d616b68a8678d11d9a0328dac44" id="r_a9b204d616b68a8678d11d9a0328dac44"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b204d616b68a8678d11d9a0328dac44">zhash_uint64_hash</a> (const void *a)</td></tr>
<tr class="memdesc:a9b204d616b68a8678d11d9a0328dac44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a hash function which will calculate a zhash value for uint64_t input data.  <br /></td></tr>
<tr class="separator:a9b204d616b68a8678d11d9a0328dac44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e523df4a9e5e235328422fa3ab83de8" id="r_a6e523df4a9e5e235328422fa3ab83de8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e523df4a9e5e235328422fa3ab83de8">zhash_uint64_equals</a> (const void *a, const void *b)</td></tr>
<tr class="memdesc:a6e523df4a9e5e235328422fa3ab83de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a function to compare zhash values for uint64_t input data.  <br /></td></tr>
<tr class="separator:a6e523df4a9e5e235328422fa3ab83de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30981951f8c90e8eae5da6963abfeb40" id="r_a30981951f8c90e8eae5da6963abfeb40"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30981951f8c90e8eae5da6963abfeb40">zhash_ptr_hash</a> (const void *a)</td></tr>
<tr class="memdesc:a30981951f8c90e8eae5da6963abfeb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a hash function which will calculate a zhash value for pointer input data.  <br /></td></tr>
<tr class="separator:a30981951f8c90e8eae5da6963abfeb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e4e6f57fb66d7b116598bbac024783" id="r_ad0e4e6f57fb66d7b116598bbac024783"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0e4e6f57fb66d7b116598bbac024783">zhash_ptr_equals</a> (const void *a, const void *b)</td></tr>
<tr class="memdesc:ad0e4e6f57fb66d7b116598bbac024783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a function to compare zhash values for pointer input data.  <br /></td></tr>
<tr class="separator:ad0e4e6f57fb66d7b116598bbac024783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84007bbe7b6d529bb4fd8942955eba7" id="r_ae84007bbe7b6d529bb4fd8942955eba7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae84007bbe7b6d529bb4fd8942955eba7">zhash_str_hash</a> (const void *a)</td></tr>
<tr class="memdesc:ae84007bbe7b6d529bb4fd8942955eba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a hash function which will calculate a zhash value for string input data.  <br /></td></tr>
<tr class="separator:ae84007bbe7b6d529bb4fd8942955eba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfa1e472c22e075eec798480c93e26c" id="r_a8cfa1e472c22e075eec798480c93e26c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cfa1e472c22e075eec798480c93e26c">zhash_str_equals</a> (const void *a, const void *b)</td></tr>
<tr class="memdesc:a8cfa1e472c22e075eec798480c93e26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a function to compare zhash values for string input data.  <br /></td></tr>
<tr class="separator:a8cfa1e472c22e075eec798480c93e26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a6af4c4fe8541ddcc4f839cf254ce7" id="r_a92a6af4c4fe8541ddcc4f839cf254ce7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92a6af4c4fe8541ddcc4f839cf254ce7">zhash_debug</a> (<a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *zh)</td></tr>
<tr class="separator:a92a6af4c4fe8541ddcc4f839cf254ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a06fcf2faf835a4213e83d960edb6c" id="r_a07a06fcf2faf835a4213e83d960edb6c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07a06fcf2faf835a4213e83d960edb6c">zhash_str_str_create</a> (void)</td></tr>
<tr class="separator:a07a06fcf2faf835a4213e83d960edb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab008ebd13a8bc0838285f57de6fee9" id="r_afab008ebd13a8bc0838285f57de6fee9"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afab008ebd13a8bc0838285f57de6fee9">zhash_str_str_get</a> (<a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *zh, const char *key)</td></tr>
<tr class="separator:afab008ebd13a8bc0838285f57de6fee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae824811733097f355c9ad0cf13035565" id="r_ae824811733097f355c9ad0cf13035565"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae824811733097f355c9ad0cf13035565">zhash_str_str_put</a> (<a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *zh, char *key, char *value)</td></tr>
<tr class="separator:ae824811733097f355c9ad0cf13035565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e34f1bd1fbf527ee4807dde29cf4724" id="r_a9e34f1bd1fbf527ee4807dde29cf4724"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e34f1bd1fbf527ee4807dde29cf4724">zhash_str_str_destroy</a> (<a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *zh)</td></tr>
<tr class="separator:a9e34f1bd1fbf527ee4807dde29cf4724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628aca4f848c96421f69c7dde5890a57" id="r_a628aca4f848c96421f69c7dde5890a57"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a628aca4f848c96421f69c7dde5890a57">zhash_int_hash</a> (const void *_a)</td></tr>
<tr class="separator:a628aca4f848c96421f69c7dde5890a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c92c9312a8b0ce3d8dc936282a32fe" id="r_a84c92c9312a8b0ce3d8dc936282a32fe"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84c92c9312a8b0ce3d8dc936282a32fe">zhash_int_equals</a> (const void *_a, const void *_b)</td></tr>
<tr class="separator:a84c92c9312a8b0ce3d8dc936282a32fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ad25fcf8243f5fdaeaab2d01dc9d17b3f" name="ad25fcf8243f5fdaeaab2d01dc9d17b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25fcf8243f5fdaeaab2d01dc9d17b3f">&#9670;&#160;</a></span>zhash_iterator_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structzhash__iterator.html">zhash_iterator</a> <a class="el" href="#ad25fcf8243f5fdaeaab2d01dc9d17b3f">zhash_iterator_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3e2c894fe80cfcf355be772cea3bc53" name="ad3e2c894fe80cfcf355be772cea3bc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e2c894fe80cfcf355be772cea3bc53">&#9670;&#160;</a></span>zhash_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct zhash <a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A hash table for structs and primitive types that stores entries by value. </p>
<ul>
<li>The size of the key/values must be known at instantiation time, and remain fixed. e.g. for pointers: zhash_create(sizeof(void*), sizeof(void*)....) for structs: zhash_create(sizeof(struct key_struct), sizeof(struct value_struct)...) for bytes: zhash_create(sizeof(uint8_t), sizeof(uint8_t)...)</li>
<li>Entries are copied by value. This means you must always pass a reference to the start of 'key_size' and 'value_size' bytes, which you have already malloc'd or stack allocated</li>
<li>This data structure can be used to store types of any size, from bytes &amp; doubles to user defined structs Note: if zhash stores pointers, user must be careful to manually manage the lifetime of the memory they point to. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adb2d9a1c9108a1ee9f8bd6489b96b680" name="adb2d9a1c9108a1ee9f8bd6489b96b680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2d9a1c9108a1ee9f8bd6489b96b680">&#9670;&#160;</a></span>zhash_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zhash_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>zh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all entries in the has table to create the equivalent of starting from a <a class="el" href="#afada7df5c3b3a9d535f12d9c5290a7c9" title="Create, initializes, and returns an empty hash table structure.">zhash_create()</a>, using the same size parameters. </p>
<p>If any elements need to be freed manually, this will need to occur before calling clear. </p>

</div>
</div>
<a id="ad38ae99a444ee2cfce107f5a52252b06" name="ad38ae99a444ee2cfce107f5a52252b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38ae99a444ee2cfce107f5a52252b06">&#9670;&#160;</a></span>zhash_contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zhash_contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>zh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the supplied key value exists as an entry in the zhash table. </p>
<p>If zhash stores pointer types as keys, this function can differentiate between a non-existent key and a key mapped to NULL. Returns 1 if the supplied key exists in the zhash table, else 0. </p>

</div>
</div>
<a id="a8df7a2ddc7ba8ca9b54f989ae41ff4ae" name="a8df7a2ddc7ba8ca9b54f989ae41ff4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df7a2ddc7ba8ca9b54f989ae41ff4ae">&#9670;&#160;</a></span>zhash_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> * zhash_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a new identical copy of the zhash (i.e. </p>
<p>a "shallow" copy). If you're storing pointers, be sure not to double free their pointees! It is the caller's responsibility to call <a class="el" href="#a1c63be960100748115006ba11b9d76b2" title="Frees all resources associated with the hash table structure which was created by zhash_create().">zhash_destroy()</a> on the returned array when it is no longer needed (in addition to the <a class="el" href="#a1c63be960100748115006ba11b9d76b2" title="Frees all resources associated with the hash table structure which was created by zhash_create().">zhash_destroy()</a> call for the original zhash). </p>

</div>
</div>
<a id="afada7df5c3b3a9d535f12d9c5290a7c9" name="afada7df5c3b3a9d535f12d9c5290a7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afada7df5c3b3a9d535f12d9c5290a7c9">&#9670;&#160;</a></span>zhash_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> * zhash_create </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>keysz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>valuesz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t(*</td>          <td class="paramname"><span class="paramname"><em>hash&#160;</em></span>)(const void *a), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*</td>          <td class="paramname"><span class="paramname"><em>equals&#160;</em></span>)(const void *a, const void *b)&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create, initializes, and returns an empty hash table structure. </p>
<p>It is the caller's responsibility to call <a class="el" href="#a1c63be960100748115006ba11b9d76b2" title="Frees all resources associated with the hash table structure which was created by zhash_create().">zhash_destroy()</a> on the returned array when it is no longer needed.</p>
<p>The size of values used in the hash and equals function must match 'keysz'. I.e. if keysz = sizeof(uint64_t), then hash() and equals() should accept parameters as *uint64_t. </p>

</div>
</div>
<a id="a92a6af4c4fe8541ddcc4f839cf254ce7" name="a92a6af4c4fe8541ddcc4f839cf254ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a6af4c4fe8541ddcc4f839cf254ce7">&#9670;&#160;</a></span>zhash_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zhash_debug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>zh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c63be960100748115006ba11b9d76b2" name="a1c63be960100748115006ba11b9d76b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c63be960100748115006ba11b9d76b2">&#9670;&#160;</a></span>zhash_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zhash_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>zh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees all resources associated with the hash table structure which was created by <a class="el" href="#afada7df5c3b3a9d535f12d9c5290a7c9" title="Create, initializes, and returns an empty hash table structure.">zhash_create()</a>. </p>
<p>After calling, 'zh' will no longer be valid for storage.</p>
<p>If 'zh' contains pointer data, it is the caller's responsibility to manage the resources pointed to by those pointers. </p>

</div>
</div>
<a id="a5f733a0f24c9d7d459eb3ffe0fff5bd2" name="a5f733a0f24c9d7d459eb3ffe0fff5bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f733a0f24c9d7d459eb3ffe0fff5bd2">&#9670;&#160;</a></span>zhash_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zhash_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>zh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>out_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the value for the given key, if it exists, by copying its contents into the space pointed to by 'out_value', which must already be allocated. </p>
<p>Returns 1 if the supplied key exists in the table, else 0, in which case the contents of 'out_value' will be unchanged. </p>

</div>
</div>
<a id="a163b4ff2ec3067df5e964af8fa959d4b" name="a163b4ff2ec3067df5e964af8fa959d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163b4ff2ec3067df5e964af8fa959d4b">&#9670;&#160;</a></span>zhash_get_volatile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zhash_get_volatile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>zh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>out_p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="#a5f733a0f24c9d7d459eb3ffe0fff5bd2" title="Retrieves the value for the given key, if it exists, by copying its contents into the space pointed t...">zhash_get()</a>, but more dangerous. </p>
<p>Provides a pointer to the zhash's internal storage. This can be used to make simple modifications to the underlying data while avoiding the memcpys associated with zhash_get and zhash_put. However, some zhash operations (that resize the underlying storage, in particular) render this pointer invalid. For maximum safety, call no other zhash functions for the period during which you intend to use the pointer. 'out_p' should be a pointer to the pointer which will be set to the internal data address. </p>

</div>
</div>
<a id="a84c92c9312a8b0ce3d8dc936282a32fe" name="a84c92c9312a8b0ce3d8dc936282a32fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c92c9312a8b0ce3d8dc936282a32fe">&#9670;&#160;</a></span>zhash_int_equals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int zhash_int_equals </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>_a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>_b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a628aca4f848c96421f69c7dde5890a57" name="a628aca4f848c96421f69c7dde5890a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628aca4f848c96421f69c7dde5890a57">&#9670;&#160;</a></span>zhash_int_hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t zhash_int_hash </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>_a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1dff15dee80154e9387afbddd3e1a5a9" name="a1dff15dee80154e9387afbddd3e1a5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dff15dee80154e9387afbddd3e1a5a9">&#9670;&#160;</a></span>zhash_iterator_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zhash_iterator_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>zh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad25fcf8243f5fdaeaab2d01dc9d17b3f">zhash_iterator_t</a> *</td>          <td class="paramname"><span class="paramname"><em>zit</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an iterator which can be used to traverse the key/value pairs of the supplied zhash table via successive calls to <a class="el" href="#aabfad3dd37f811b1d7d186cc572b845f" title="Retrieves the next key/value pair from a zhash table via the (previously- initialized) iterator.">zhash_iterator_next()</a> or <a class="el" href="#a88fe3cde4e4906fc210c3897fbc81083" title="Similar to zhash_iterator_next() except that it retrieves a pointer to zhash&#39;s internal storage.">zhash_iterator_next_volatile()</a>. </p>
<p>The iterator can also be used to remove elements from the zhash with <a class="el" href="#a31aba2091ac0de2cfc38d4903d08f237" title="Removes from the zhash table the key/value pair most recently returned via a call to zhash_iterator_n...">zhash_iterator_remove()</a>.</p>
<p>Any modifications to the zhash table structure will invalidate the iterator, with the exception of <a class="el" href="#a31aba2091ac0de2cfc38d4903d08f237" title="Removes from the zhash table the key/value pair most recently returned via a call to zhash_iterator_n...">zhash_iterator_remove()</a>. </p>

</div>
</div>
<a id="a88a8cfd64481751ae6e97288ba05b2f1" name="a88a8cfd64481751ae6e97288ba05b2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a8cfd64481751ae6e97288ba05b2f1">&#9670;&#160;</a></span>zhash_iterator_init_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zhash_iterator_init_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>zh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad25fcf8243f5fdaeaab2d01dc9d17b3f">zhash_iterator_t</a> *</td>          <td class="paramname"><span class="paramname"><em>zit</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an iterator which can be used to traverse the key/value pairs of the supplied zhash table via successive calls to <a class="el" href="#aabfad3dd37f811b1d7d186cc572b845f" title="Retrieves the next key/value pair from a zhash table via the (previously- initialized) iterator.">zhash_iterator_next()</a> or <a class="el" href="#a88fe3cde4e4906fc210c3897fbc81083" title="Similar to zhash_iterator_next() except that it retrieves a pointer to zhash&#39;s internal storage.">zhash_iterator_next_volatile()</a>. </p>
<p>An iterator initialized with this function cannot be used with <a class="el" href="#a31aba2091ac0de2cfc38d4903d08f237" title="Removes from the zhash table the key/value pair most recently returned via a call to zhash_iterator_n...">zhash_iterator_remove()</a>. For that you must use <a class="el" href="#a1dff15dee80154e9387afbddd3e1a5a9" title="Initializes an iterator which can be used to traverse the key/value pairs of the supplied zhash table...">zhash_iterator_init()</a>.</p>
<p>Any modifications to the zhash table structure will invalidate the iterator. </p>

</div>
</div>
<a id="aabfad3dd37f811b1d7d186cc572b845f" name="aabfad3dd37f811b1d7d186cc572b845f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabfad3dd37f811b1d7d186cc572b845f">&#9670;&#160;</a></span>zhash_iterator_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zhash_iterator_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad25fcf8243f5fdaeaab2d01dc9d17b3f">zhash_iterator_t</a> *</td>          <td class="paramname"><span class="paramname"><em>zit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>outkey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>outvalue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the next key/value pair from a zhash table via the (previously- initialized) iterator. </p>
<p>Copies the key and value data into the space pointed to by outkey and outvalue, respectively, if they are not NULL.</p>
<p>Returns 1 if the call retrieved the next available key/value pair, else 0 indicating that no entries remain, in which case the contents of outkey and outvalue will remain unchanged. </p>

</div>
</div>
<a id="a88fe3cde4e4906fc210c3897fbc81083" name="a88fe3cde4e4906fc210c3897fbc81083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88fe3cde4e4906fc210c3897fbc81083">&#9670;&#160;</a></span>zhash_iterator_next_volatile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zhash_iterator_next_volatile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad25fcf8243f5fdaeaab2d01dc9d17b3f">zhash_iterator_t</a> *</td>          <td class="paramname"><span class="paramname"><em>zit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>outkey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>outvalue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="#aabfad3dd37f811b1d7d186cc572b845f" title="Retrieves the next key/value pair from a zhash table via the (previously- initialized) iterator.">zhash_iterator_next()</a> except that it retrieves a pointer to zhash's internal storage. </p>
<p>This can be used to avoid the memcpys associated with <a class="el" href="#aabfad3dd37f811b1d7d186cc572b845f" title="Retrieves the next key/value pair from a zhash table via the (previously- initialized) iterator.">zhash_iterator_next()</a>. Call no other zhash functions for the period during which you intend to use the pointer. 'outkey' and 'outvalue' should be pointers to the pointers which will be set to the internal data addresses.</p>
<p>Example: key_t *outkey; value_t *outvalue; if (zhash_iterator_next_volatile(&amp;zit, &amp;outkey, &amp;outvalue)) // access internal key and value storage via outkey and outvalue</p>
<p>Returns 1 if the call retrieved the next available key/value pair, else 0 indicating that no entries remain, in which case the pointers outkey and outvalue will remain unchanged. </p>

</div>
</div>
<a id="a31aba2091ac0de2cfc38d4903d08f237" name="a31aba2091ac0de2cfc38d4903d08f237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31aba2091ac0de2cfc38d4903d08f237">&#9670;&#160;</a></span>zhash_iterator_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zhash_iterator_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad25fcf8243f5fdaeaab2d01dc9d17b3f">zhash_iterator_t</a> *</td>          <td class="paramname"><span class="paramname"><em>zit</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes from the zhash table the key/value pair most recently returned via a call to <a class="el" href="#aabfad3dd37f811b1d7d186cc572b845f" title="Retrieves the next key/value pair from a zhash table via the (previously- initialized) iterator.">zhash_iterator_next()</a> or <a class="el" href="#a88fe3cde4e4906fc210c3897fbc81083" title="Similar to zhash_iterator_next() except that it retrieves a pointer to zhash&#39;s internal storage.">zhash_iterator_next_volatile()</a> for the supplied iterator. </p>
<p>Requires that the iterator was initialized with <a class="el" href="#a1dff15dee80154e9387afbddd3e1a5a9" title="Initializes an iterator which can be used to traverse the key/value pairs of the supplied zhash table...">zhash_iterator_init()</a>, not <a class="el" href="#a88a8cfd64481751ae6e97288ba05b2f1" title="Initializes an iterator which can be used to traverse the key/value pairs of the supplied zhash table...">zhash_iterator_init_const()</a>. </p>

</div>
</div>
<a id="aa4d7fc2e9335add8584fdbe6da9b5103" name="aa4d7fc2e9335add8584fdbe6da9b5103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d7fc2e9335add8584fdbe6da9b5103">&#9670;&#160;</a></span>zhash_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zarray_8h.html#af429d8225958865fc14ea0ddcc7c0b06">zarray_t</a> * zhash_keys </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>zh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array which contains copies of all of the hash table's keys, in no particular order. </p>
<p>It is the caller's responsibility to call <a class="el" href="zarray_8h.html#a7535b091a436e6dd7a335ba4ec796481" title="Frees all resources associated with the variable array structure which was created by zarray_create()...">zarray_destroy()</a> on the returned structure when it is no longer needed. </p>

</div>
</div>
<a id="ad1fba83933fdf91757e0373d7ae755fc" name="ad1fba83933fdf91757e0373d7ae755fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1fba83933fdf91757e0373d7ae755fc">&#9670;&#160;</a></span>zhash_map_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zhash_map_keys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>zh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*</td>          <td class="paramname"><span class="paramname"><em>f&#160;</em></span>)(void *)&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the supplied function with a pointer to every key in the hash table in turn. </p>
<p>The function will be passed a pointer to the table's internal storage for the key, which the caller should not modify, as the hash table will not be re-indexed. The function may be NULL, in which case no action is taken. </p>

</div>
</div>
<a id="abfd6a3e9ab16b8e10c495e3c3fe0d75e" name="abfd6a3e9ab16b8e10c495e3c3fe0d75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd6a3e9ab16b8e10c495e3c3fe0d75e">&#9670;&#160;</a></span>zhash_map_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zhash_map_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>zh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*</td>          <td class="paramname"><span class="paramname"><em>f&#160;</em></span>)(void *)&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the supplied function with a pointer to every value in the hash table in turn. </p>
<p>The function will be passed a pointer to the table's internal storage for the value, which the caller may safely modify. The function may be NULL, in which case no action is taken. </p>

</div>
</div>
<a id="ad0e4e6f57fb66d7b116598bbac024783" name="ad0e4e6f57fb66d7b116598bbac024783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e4e6f57fb66d7b116598bbac024783">&#9670;&#160;</a></span>zhash_ptr_equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zhash_ptr_equals </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a function to compare zhash values for pointer input data. </p>
<p>Can be used with <a class="el" href="#afada7df5c3b3a9d535f12d9c5290a7c9" title="Create, initializes, and returns an empty hash table structure.">zhash_create()</a> for a key size of sizeof(void*). </p>

</div>
</div>
<a id="a30981951f8c90e8eae5da6963abfeb40" name="a30981951f8c90e8eae5da6963abfeb40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30981951f8c90e8eae5da6963abfeb40">&#9670;&#160;</a></span>zhash_ptr_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t zhash_ptr_hash </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a hash function which will calculate a zhash value for pointer input data. </p>
<p>Can be used with <a class="el" href="#afada7df5c3b3a9d535f12d9c5290a7c9" title="Create, initializes, and returns an empty hash table structure.">zhash_create()</a> for a key size of sizeof(void*). Will use only the pointer value itself for computing the hash value. </p>

</div>
</div>
<a id="a1fcf3aacd4bcf1113c1b83e8a15b060c" name="a1fcf3aacd4bcf1113c1b83e8a15b060c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fcf3aacd4bcf1113c1b83e8a15b060c">&#9670;&#160;</a></span>zhash_put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zhash_put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>zh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>oldkey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>oldvalue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a key/value pair to the hash table, if the supplied key does not already exist in the table, or overwrites the value for the supplied key if it does already exist. </p>
<p>In the latter case, the previous contents of the key and value will be copied into the spaces pointed to by 'oldkey' and 'oldvalue', respectively, if they are not NULL.</p>
<p>The key/value is added to / updated in the hash table by copying 'keysz' bytes from the data pointed to by 'key' and 'valuesz' bytes from the data pointed to by 'value'. It is up to the caller to manage the memory allocation of the passed-in values, zhash will store and manage a copy.</p>
<p>NOTE: If the key is a pointer type (such as a string), the contents of the data that it points to must not be modified after the call to <a class="el" href="#a1fcf3aacd4bcf1113c1b83e8a15b060c" title="Adds a key/value pair to the hash table, if the supplied key does not already exist in the table,...">zhash_put()</a>, or future zhash calls will not successfully locate the key (using either its previous or new value).</p>
<p>NOTE: When using array data as a key (such as a string), the array should not be passed directly or it will cause a segmentation fault when it is dereferenced. Instead, pass a pointer which points to the array location, i.e.: char key[strlen]; char *keyptr = key; zhash_put(zh, &amp;keyptr, ...)</p>
<p>Example: char * key = ...; zarray_t * val = ...; char * old_key = NULL; zarray_t * old_val = NULL; if (zhash_put(zh, &amp;key, &amp;val, &amp;old_key, &amp;old_value)) // manage resources for old_key and old_value</p>
<p>Returns 1 if the supplied key previously existed in the table, else 0, in which case the data pointed to by 'oldkey' and 'oldvalue' will be set to zero if they are not NULL. </p>

</div>
</div>
<a id="a152239132cc50de47c4f3416f80f5d5b" name="a152239132cc50de47c4f3416f80f5d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152239132cc50de47c4f3416f80f5d5b">&#9670;&#160;</a></span>zhash_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zhash_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>zh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>oldkey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>oldvalue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes from the zhash table the key/value pair for the supplied key, if it exists. </p>
<p>If it does, the contents of the key and value will be copied into the spaces pointed to by 'oldkey' and 'oldvalue', respectively, if they are not NULL. If the key does not exist, the data pointed to by 'oldkey' and 'oldvalue' will be set to zero if they are not NULL.</p>
<p>Returns 1 if the key existed and was removed, else 0, indicating that the table contents were not changed. </p>

</div>
</div>
<a id="a9044d979e7371c387d366c5d860bdd3c" name="a9044d979e7371c387d366c5d860bdd3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9044d979e7371c387d366c5d860bdd3c">&#9670;&#160;</a></span>zhash_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zhash_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>zh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the current number of key/value pairs currently contained in the zhash table, or 0 if the table is empty. </p>

</div>
</div>
<a id="a8cfa1e472c22e075eec798480c93e26c" name="a8cfa1e472c22e075eec798480c93e26c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cfa1e472c22e075eec798480c93e26c">&#9670;&#160;</a></span>zhash_str_equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zhash_str_equals </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a function to compare zhash values for string input data. </p>
<p>Can be used with <a class="el" href="#afada7df5c3b3a9d535f12d9c5290a7c9" title="Create, initializes, and returns an empty hash table structure.">zhash_create()</a> for a key size of sizeof(char*). </p>

</div>
</div>
<a id="ae84007bbe7b6d529bb4fd8942955eba7" name="ae84007bbe7b6d529bb4fd8942955eba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84007bbe7b6d529bb4fd8942955eba7">&#9670;&#160;</a></span>zhash_str_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t zhash_str_hash </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a hash function which will calculate a zhash value for string input data. </p>
<p>Can be used with <a class="el" href="#afada7df5c3b3a9d535f12d9c5290a7c9" title="Create, initializes, and returns an empty hash table structure.">zhash_create()</a> for a key size of sizeof(char*). Will use the contents of the string in computing the hash value. </p>

</div>
</div>
<a id="a07a06fcf2faf835a4213e83d960edb6c" name="a07a06fcf2faf835a4213e83d960edb6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a06fcf2faf835a4213e83d960edb6c">&#9670;&#160;</a></span>zhash_str_str_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> * zhash_str_str_create </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e34f1bd1fbf527ee4807dde29cf4724" name="a9e34f1bd1fbf527ee4807dde29cf4724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e34f1bd1fbf527ee4807dde29cf4724">&#9670;&#160;</a></span>zhash_str_str_destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void zhash_str_str_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>zh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afab008ebd13a8bc0838285f57de6fee9" name="afab008ebd13a8bc0838285f57de6fee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab008ebd13a8bc0838285f57de6fee9">&#9670;&#160;</a></span>zhash_str_str_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char * zhash_str_str_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>zh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae824811733097f355c9ad0cf13035565" name="ae824811733097f355c9ad0cf13035565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae824811733097f355c9ad0cf13035565">&#9670;&#160;</a></span>zhash_str_str_put()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void zhash_str_str_put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>zh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a75cbe317eeb029aec34ffbae7d5706b9" name="a75cbe317eeb029aec34ffbae7d5706b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75cbe317eeb029aec34ffbae7d5706b9">&#9670;&#160;</a></span>zhash_uint32_equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zhash_uint32_equals </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a function to compare zhash values for uint32_t input data. </p>
<p>Can be used with <a class="el" href="#afada7df5c3b3a9d535f12d9c5290a7c9" title="Create, initializes, and returns an empty hash table structure.">zhash_create()</a> for a key size of sizeof(uint32_t). </p>

</div>
</div>
<a id="af42caf1dfef590a38648d9505860c19d" name="af42caf1dfef590a38648d9505860c19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42caf1dfef590a38648d9505860c19d">&#9670;&#160;</a></span>zhash_uint32_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t zhash_uint32_hash </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a hash function which will calculate a zhash value for uint32_t input data. </p>
<p>Can be used with <a class="el" href="#afada7df5c3b3a9d535f12d9c5290a7c9" title="Create, initializes, and returns an empty hash table structure.">zhash_create()</a> for a key size of sizeof(uint32_t). </p>

</div>
</div>
<a id="a6e523df4a9e5e235328422fa3ab83de8" name="a6e523df4a9e5e235328422fa3ab83de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e523df4a9e5e235328422fa3ab83de8">&#9670;&#160;</a></span>zhash_uint64_equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zhash_uint64_equals </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a function to compare zhash values for uint64_t input data. </p>
<p>Can be used with <a class="el" href="#afada7df5c3b3a9d535f12d9c5290a7c9" title="Create, initializes, and returns an empty hash table structure.">zhash_create()</a> for a key size of sizeof(uint64_t). </p>

</div>
</div>
<a id="a9b204d616b68a8678d11d9a0328dac44" name="a9b204d616b68a8678d11d9a0328dac44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b204d616b68a8678d11d9a0328dac44">&#9670;&#160;</a></span>zhash_uint64_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t zhash_uint64_hash </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a hash function which will calculate a zhash value for uint64_t input data. </p>
<p>Can be used with <a class="el" href="#afada7df5c3b3a9d535f12d9c5290a7c9" title="Create, initializes, and returns an empty hash table structure.">zhash_create()</a> for a key size of sizeof(uint64_t). </p>

</div>
</div>
<a id="aaea616752a32261441ba50d052acc595" name="aaea616752a32261441ba50d052acc595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea616752a32261441ba50d052acc595">&#9670;&#160;</a></span>zhash_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zarray_8h.html#af429d8225958865fc14ea0ddcc7c0b06">zarray_t</a> * zhash_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>zh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array which contains copies of all of the hash table's values, in no particular order. </p>
<p>It is the caller's responsibility to call <a class="el" href="zarray_8h.html#a7535b091a436e6dd7a335ba4ec796481" title="Frees all resources associated with the variable array structure which was created by zarray_create()...">zarray_destroy()</a> on the returned structure when it is no longer needed. </p>

</div>
</div>
<a id="ae67694d0db20d02ce364262f0fd9206e" name="ae67694d0db20d02ce364262f0fd9206e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67694d0db20d02ce364262f0fd9206e">&#9670;&#160;</a></span>zhash_vmap_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zhash_vmap_keys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>vh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*</td>          <td class="paramname"><span class="paramname"><em>f&#160;</em></span>)(void *)&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the supplied function with a copy of every key in the hash table in turn. </p>
<p>While <a class="el" href="#ad1fba83933fdf91757e0373d7ae755fc" title="Calls the supplied function with a pointer to every key in the hash table in turn.">zhash_map_keys()</a> passes a pointer to internal storage, this function passes a copy of the actual storage. If the zhash stores pointers to data, functions like <a class="el" href="_third_party_notices_8txt.html#a22852d05d86a994ddfa3c5109b64ebb2">free()</a> can be used directly with <a class="el" href="#ae67694d0db20d02ce364262f0fd9206e" title="Calls the supplied function with a copy of every key in the hash table in turn.">zhash_vmap_keys()</a>. The function may be NULL, in which case no action is taken.</p>
<p>NOTE: <a class="el" href="#ae67694d0db20d02ce364262f0fd9206e" title="Calls the supplied function with a copy of every key in the hash table in turn.">zhash_vmap_keys()</a> can only be used with pointer-data keys. Use with non-pointer keys (i.e. integer, double, etc.) will likely cause a segmentation fault. </p>

</div>
</div>
<a id="ada2158cd36c2cdaadd3be86e44f0d981" name="ada2158cd36c2cdaadd3be86e44f0d981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2158cd36c2cdaadd3be86e44f0d981">&#9670;&#160;</a></span>zhash_vmap_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zhash_vmap_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad3e2c894fe80cfcf355be772cea3bc53">zhash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>vh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*</td>          <td class="paramname"><span class="paramname"><em>f&#160;</em></span>)(void *)&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the supplied function with a copy of every value in the hash table in turn. </p>
<p>While <a class="el" href="#abfd6a3e9ab16b8e10c495e3c3fe0d75e" title="Calls the supplied function with a pointer to every value in the hash table in turn.">zhash_map_values()</a> passes a pointer to internal storage, this function passes a copy of the actual storage. If the zhash stores pointers to data, functions like <a class="el" href="_third_party_notices_8txt.html#a22852d05d86a994ddfa3c5109b64ebb2">free()</a> can be used directly with <a class="el" href="#ada2158cd36c2cdaadd3be86e44f0d981" title="Calls the supplied function with a copy of every value in the hash table in turn.">zhash_vmap_values()</a>. The function may be NULL, in which case no action is taken.</p>
<p>NOTE: <a class="el" href="#ada2158cd36c2cdaadd3be86e44f0d981" title="Calls the supplied function with a copy of every value in the hash table in turn.">zhash_vmap_values()</a> can only be used with pointer-data values. Use with non-pointer values (i.e. integer, double, etc.) will likely cause a segmentation fault. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_bce03949b0889f5b77e9e810e79dfd7d.html">thirdparty</a></li><li class="navelem"><a class="el" href="dir_ff0062bb8776854a1feb511e7a5035f7.html">apriltag</a></li><li class="navelem"><a class="el" href="dir_4f37ec3afec411c33430786613d06e76.html">include</a></li><li class="navelem"><a class="el" href="dir_6324afc825a598ce4fef60a1f900074d.html">common</a></li><li class="navelem"><a class="el" href="zhash_8h.html">zhash.h</a></li>
    <li class="footer">Generated on Thu Oct 24 2024 04:48:52 for WPILibC++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
