<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: units/base.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="wpilib-128.png"/></td>
  <td id="projectalign">
   <div id="projectname">WPILibC++<span id="projectnumber">&#160;2025.1.1-beta-1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('wpimath_2src_2main_2native_2include_2units_2base_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">base.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;chrono&gt;</code><br />
<code>#include &lt;ratio&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;cmath&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;<a class="el" href="gcem_8hpp_source.html">gcem.hpp</a>&gt;</code><br />
</div>
<p><a href="wpimath_2src_2main_2native_2include_2units_2base_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__ratio.html">units::traits::is_ratio&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait that tests whether a type represents a std::ratio.  <a href="structunits_1_1traits_1_1is__ratio.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__base__unit.html">units::traits::is_base_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests if a class is a <code><a class="el" href="structunits_1_1base__unit.html" title="Class representing SI base unit types.">base_unit</a></code> type.  <a href="structunits_1_1traits_1_1is__base__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__unit.html">units::traits::is_unit&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits which tests if a class is a <code>unit</code>  <a href="structunits_1_1traits_1_1is__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1base__unit.html">units::base_unit&lt; Meter, Kilogram, Second, Radian, Ampere, Kelvin, Mole, Candela, Byte &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing SI base unit types.  <a href="structunits_1_1base__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit.html">units::unit&lt; Conversion, BaseUnit, PiExponent, Translation &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type representing an arbitrary unit.  <a href="structunits_1_1unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__convertible__unit.html">units::traits::is_convertible_unit&lt; U1, U2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which checks whether two units can be converted to each other.  <a href="structunits_1_1traits_1_1is__convertible__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__nonlinear__scale.html">units::traits::is_nonlinear_scale&lt; T, Ret &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests that <code>class T</code> meets the requirements for a non-linear scale.  <a href="structunits_1_1traits_1_1is__nonlinear__scale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__convertible__unit__t.html">units::traits::is_convertible_unit_t&lt; U1, U2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether two container types derived from <code><a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a></code> are convertible to each other.  <a href="structunits_1_1traits_1_1is__convertible__unit__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__unit__t.html">units::traits::is_unit_t&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits which tests if a class is a <code>unit</code>  <a href="structunits_1_1traits_1_1is__unit__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classunits_1_1unit__t.html">units::unit_t&lt; Units, T, NonLinearScale &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for values which represent quantities of a given unit.  <a href="classunits_1_1unit__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1has__linear__scale.html">units::traits::has_linear_scale&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type is inherited from a linear scale.  <a href="structunits_1_1traits_1_1has__linear__scale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1has__decibel__scale.html">units::traits::has_decibel_scale&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type is inherited from a decibel scale.  <a href="structunits_1_1traits_1_1has__decibel__scale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__same__scale.html">units::traits::is_same_scale&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether two types has the same non-linear scale.  <a href="structunits_1_1traits_1_1is__same__scale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1linear__scale.html">units::linear_scale&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> scale which is linear  <a href="structunits_1_1linear__scale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1decibel__scale.html">units::decibel_scale&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> scale for representing decibel values.  <a href="structunits_1_1decibel__scale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__t.html">units::unit_value_t&lt; Units, Num, Denom &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a rational unit value as a compile-time constant.  <a href="structunits_1_1unit__value__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__unit__value__t.html">units::traits::is_unit_value_t&lt; T, Units &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether a type is a <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant.">unit_value_t</a> representing the given unit type.  <a href="structunits_1_1traits_1_1is__unit__value__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1traits_1_1is__unit__value__t__category.html">units::traits::is_unit_value_t_category&lt; Category, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which tests whether type T is a <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant.">unit_value_t</a> with a unit type in the given category.  <a href="structunits_1_1traits_1_1is__unit__value__t__category.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__add.html">units::unit_value_add&lt; U1, U2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds two <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant.">unit_value_t</a> types at compile-time  <a href="structunits_1_1unit__value__add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__subtract.html">units::unit_value_subtract&lt; U1, U2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtracts two <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant.">unit_value_t</a> types at compile-time  <a href="structunits_1_1unit__value__subtract.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__multiply.html">units::unit_value_multiply&lt; U1, U2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplies two <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant.">unit_value_t</a> types at compile-time  <a href="structunits_1_1unit__value__multiply.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__divide.html">units::unit_value_divide&lt; U1, U2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">divides two <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant.">unit_value_t</a> types at compile-time  <a href="structunits_1_1unit__value__divide.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__power.html">units::unit_value_power&lt; U1, power &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">raises unit_value_to a power at compile-time  <a href="structunits_1_1unit__value__power.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunits_1_1unit__value__sqrt.html">units::unit_value_sqrt&lt; U1, Eps &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates square root of <a class="el" href="structunits_1_1unit__value__t.html" title="Stores a rational unit value as a compile-time constant.">unit_value_t</a> at compile-time  <a href="structunits_1_1unit__value__sqrt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits.html">units</a></td></tr>
<tr class="memdesc:namespaceunits"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit Conversion Library namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1detail.html">units::detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1traits.html">units::traits</a></td></tr>
<tr class="memdesc:namespaceunits_1_1traits"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace representing type traits which can access the properties of types provided by the units library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html">units::category</a></td></tr>
<tr class="memdesc:namespaceunits_1_1category"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace representing the implemented base and derived unit types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1dimensionless.html">units::dimensionless</a></td></tr>
<tr class="memdesc:namespaceunits_1_1dimensionless"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit types and containers for units that have no dimension (scalar units) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1math.html">units::math</a></td></tr>
<tr class="memdesc:namespaceunits_1_1math"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for unit-enabled versions of the <code>&lt;cmath&gt;</code> library <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1literals.html">units::literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a2b37cc2044d4441105347aa832d0ca2d" id="r_a2b37cc2044d4441105347aa832d0ca2d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b37cc2044d4441105347aa832d0ca2d">UNIT_HAS_LITERAL_SUPPORT</a></td></tr>
<tr class="separator:a2b37cc2044d4441105347aa832d0ca2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071362944b1accb86d71518ab9613412" id="r_a071362944b1accb86d71518ab9613412"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a071362944b1accb86d71518ab9613412">UNIT_LIB_DEFAULT_TYPE</a>&#160;&#160;&#160;double</td></tr>
<tr class="separator:a071362944b1accb86d71518ab9613412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071fcab8dbde86027d1d552f82a92878" id="r_a071fcab8dbde86027d1d552f82a92878"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a071fcab8dbde86027d1d552f82a92878">UNIT_ADD_UNIT_TAGS</a>(namespaceName,  nameSingular,  namePlural,  abbreviation, ...)</td></tr>
<tr class="memdesc:a071fcab8dbde86027d1d552f82a92878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for generating the boiler-plate code generating the tags of a new unit.  <br /></td></tr>
<tr class="separator:a071fcab8dbde86027d1d552f82a92878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a54533ebcadd9146a608a5856a052f" id="r_aa6a54533ebcadd9146a608a5856a052f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6a54533ebcadd9146a608a5856a052f">UNIT_ADD_UNIT_DEFINITION</a>(namespaceName,  nameSingular)</td></tr>
<tr class="memdesc:aa6a54533ebcadd9146a608a5856a052f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for generating the boiler-plate code for the unit_t type definition.  <br /></td></tr>
<tr class="separator:aa6a54533ebcadd9146a608a5856a052f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658d239b68a83cbe1055198bb9aa7823" id="r_a658d239b68a83cbe1055198bb9aa7823"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a658d239b68a83cbe1055198bb9aa7823">UNIT_ADD_CUSTOM_TYPE_UNIT_DEFINITION</a>(namespaceName,  nameSingular,  underlyingType)</td></tr>
<tr class="memdesc:a658d239b68a83cbe1055198bb9aa7823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for generating the boiler-plate code for a unit_t type definition with a non-default underlying type.  <br /></td></tr>
<tr class="separator:a658d239b68a83cbe1055198bb9aa7823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6d926ddfd6f761bb7675984fbf0585" id="r_a4b6d926ddfd6f761bb7675984fbf0585"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b6d926ddfd6f761bb7675984fbf0585">UNIT_ADD_IO</a>(namespaceName,  nameSingular,  abbrev)</td></tr>
<tr class="memdesc:a4b6d926ddfd6f761bb7675984fbf0585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for generating the boiler-plate code needed for I/O for a new unit.  <br /></td></tr>
<tr class="separator:a4b6d926ddfd6f761bb7675984fbf0585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11aa321ef2296c149291424e5c333a4c" id="r_a11aa321ef2296c149291424e5c333a4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11aa321ef2296c149291424e5c333a4c">UNIT_ADD_NAME</a>(namespaceName,  nameSingular,  abbrev)</td></tr>
<tr class="memdesc:a11aa321ef2296c149291424e5c333a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for generating constexpr names/abbreviations for units.  <br /></td></tr>
<tr class="separator:a11aa321ef2296c149291424e5c333a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6407713545d300de2647fb0348bdb6a" id="r_ab6407713545d300de2647fb0348bdb6a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6407713545d300de2647fb0348bdb6a">UNIT_ADD_LITERALS</a>(namespaceName,  nameSingular,  abbreviation)</td></tr>
<tr class="memdesc:ab6407713545d300de2647fb0348bdb6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for generating user-defined literals for units.  <br /></td></tr>
<tr class="separator:ab6407713545d300de2647fb0348bdb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39906c4d2537c6d904d8d44ffb6a4dec" id="r_a39906c4d2537c6d904d8d44ffb6a4dec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39906c4d2537c6d904d8d44ffb6a4dec">UNIT_ADD</a>(namespaceName,  nameSingular,  namePlural,  abbreviation, ...)</td></tr>
<tr class="memdesc:a39906c4d2537c6d904d8d44ffb6a4dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for generating the boiler-plate code needed for a new unit.  <br /></td></tr>
<tr class="separator:a39906c4d2537c6d904d8d44ffb6a4dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb409344e80b38f8ab8d1dc72a599623" id="r_acb409344e80b38f8ab8d1dc72a599623"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb409344e80b38f8ab8d1dc72a599623">UNIT_ADD_WITH_CUSTOM_TYPE</a>(namespaceName,  nameSingular,  namePlural,  abbreviation,  underlyingType, ...)</td></tr>
<tr class="memdesc:acb409344e80b38f8ab8d1dc72a599623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for generating the boiler-plate code needed for a new unit with a non-default underlying type.  <br /></td></tr>
<tr class="separator:acb409344e80b38f8ab8d1dc72a599623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbc20cfef3586d1c51b51c998679b99" id="r_aacbc20cfef3586d1c51b51c998679b99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacbc20cfef3586d1c51b51c998679b99">UNIT_ADD_DECIBEL</a>(namespaceName,  nameSingular,  abbreviation)</td></tr>
<tr class="memdesc:aacbc20cfef3586d1c51b51c998679b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to create decibel container and literals for an existing unit type.  <br /></td></tr>
<tr class="separator:aacbc20cfef3586d1c51b51c998679b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67817e30ee1fc0ee3387657684af35a7" id="r_a67817e30ee1fc0ee3387657684af35a7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67817e30ee1fc0ee3387657684af35a7">UNIT_ADD_CATEGORY_TRAIT_DETAIL</a>(unitCategory)</td></tr>
<tr class="separator:a67817e30ee1fc0ee3387657684af35a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e562029a6c1c7d967ffa531749d0b78" id="r_a4e562029a6c1c7d967ffa531749d0b78"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e562029a6c1c7d967ffa531749d0b78">UNIT_ADD_IS_UNIT_CATEGORY_TRAIT</a>(unitCategory)</td></tr>
<tr class="separator:a4e562029a6c1c7d967ffa531749d0b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b0ec340728bbef5aeab07641a61948" id="r_aa0b0ec340728bbef5aeab07641a61948"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0b0ec340728bbef5aeab07641a61948">UNIT_ADD_CATEGORY_TRAIT</a>(unitCategory)</td></tr>
<tr class="memdesc:aa0b0ec340728bbef5aeab07641a61948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to create the <code>is_category_unit</code> type trait.  <br /></td></tr>
<tr class="separator:aa0b0ec340728bbef5aeab07641a61948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefa09c81bf9352744e7e31164a07d2e" id="r_afefa09c81bf9352744e7e31164a07d2e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afefa09c81bf9352744e7e31164a07d2e">UNIT_ADD_WITH_METRIC_PREFIXES</a>(namespaceName,  nameSingular,  namePlural,  abbreviation, ...)</td></tr>
<tr class="memdesc:afefa09c81bf9352744e7e31164a07d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for generating the boiler-plate code needed for a new unit, including its metric prefixes from femto to peta.  <br /></td></tr>
<tr class="separator:afefa09c81bf9352744e7e31164a07d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdd64f7a2185396fdc1f618a1b4a123" id="r_a9cdd64f7a2185396fdc1f618a1b4a123"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cdd64f7a2185396fdc1f618a1b4a123">UNIT_ADD_WITH_METRIC_AND_BINARY_PREFIXES</a>(namespaceName,  nameSingular,  namePlural,  abbreviation, ...)</td></tr>
<tr class="memdesc:a9cdd64f7a2185396fdc1f618a1b4a123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for generating the boiler-plate code needed for a new unit, including its metric prefixes from femto to peta, and binary prefixes from kibi to exbi.  <br /></td></tr>
<tr class="separator:a9cdd64f7a2185396fdc1f618a1b4a123"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a6a8e59826a504070a1904837b0a80e58" id="r_a6a8e59826a504070a1904837b0a80e58"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a6a8e59826a504070a1904837b0a80e58">units::category::scalar_unit</a></td></tr>
<tr class="memdesc:a6a8e59826a504070a1904837b0a80e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a quantity with no dimension.  <br /></td></tr>
<tr class="separator:a6a8e59826a504070a1904837b0a80e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd8f8c2ecd2fa4688f326c4bc7a20fc" id="r_a5cd8f8c2ecd2fa4688f326c4bc7a20fc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a5cd8f8c2ecd2fa4688f326c4bc7a20fc">units::category::dimensionless_unit</a></td></tr>
<tr class="memdesc:a5cd8f8c2ecd2fa4688f326c4bc7a20fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a quantity with no dimension.  <br /></td></tr>
<tr class="separator:a5cd8f8c2ecd2fa4688f326c4bc7a20fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dede37fafca5ea729d3c4332ebc3901" id="r_a3dede37fafca5ea729d3c4332ebc3901"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a3dede37fafca5ea729d3c4332ebc3901">units::category::length_unit</a></td></tr>
<tr class="memdesc:a3dede37fafca5ea729d3c4332ebc3901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI base unit of length.  <br /></td></tr>
<tr class="separator:a3dede37fafca5ea729d3c4332ebc3901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f67be9610e675eb843a4698e40f8d21" id="r_a0f67be9610e675eb843a4698e40f8d21"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 0 &gt;, std::ratio&lt; 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a0f67be9610e675eb843a4698e40f8d21">units::category::mass_unit</a></td></tr>
<tr class="memdesc:a0f67be9610e675eb843a4698e40f8d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI base unit of mass.  <br /></td></tr>
<tr class="separator:a0f67be9610e675eb843a4698e40f8d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de866363bb9974e1959f789d9a9db86" id="r_a0de866363bb9974e1959f789d9a9db86"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a0de866363bb9974e1959f789d9a9db86">units::category::time_unit</a></td></tr>
<tr class="memdesc:a0de866363bb9974e1959f789d9a9db86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI base unit of time.  <br /></td></tr>
<tr class="separator:a0de866363bb9974e1959f789d9a9db86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f2400dc89006d0f0a79e3c2869b460" id="r_a72f2400dc89006d0f0a79e3c2869b460"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a72f2400dc89006d0f0a79e3c2869b460">units::category::angle_unit</a></td></tr>
<tr class="memdesc:a72f2400dc89006d0f0a79e3c2869b460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI base unit of angle.  <br /></td></tr>
<tr class="separator:a72f2400dc89006d0f0a79e3c2869b460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7971715c2d5773789399530a700c10b5" id="r_a7971715c2d5773789399530a700c10b5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a7971715c2d5773789399530a700c10b5">units::category::current_unit</a></td></tr>
<tr class="memdesc:a7971715c2d5773789399530a700c10b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI base unit of current.  <br /></td></tr>
<tr class="separator:a7971715c2d5773789399530a700c10b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcca935d595facfce91d753c94174281" id="r_afcca935d595facfce91d753c94174281"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#afcca935d595facfce91d753c94174281">units::category::temperature_unit</a></td></tr>
<tr class="memdesc:afcca935d595facfce91d753c94174281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI base unit of temperature.  <br /></td></tr>
<tr class="separator:afcca935d595facfce91d753c94174281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8455cfcc9594b58e2c499095408ff4" id="r_a8f8455cfcc9594b58e2c499095408ff4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a8f8455cfcc9594b58e2c499095408ff4">units::category::substance_unit</a></td></tr>
<tr class="memdesc:a8f8455cfcc9594b58e2c499095408ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI base unit of amount of substance.  <br /></td></tr>
<tr class="separator:a8f8455cfcc9594b58e2c499095408ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2e5c0733f4e4ecf8b3d41492658706" id="r_a4a2e5c0733f4e4ecf8b3d41492658706"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a4a2e5c0733f4e4ecf8b3d41492658706">units::category::luminous_intensity_unit</a></td></tr>
<tr class="memdesc:a4a2e5c0733f4e4ecf8b3d41492658706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI base unit of luminous intensity.  <br /></td></tr>
<tr class="separator:a4a2e5c0733f4e4ecf8b3d41492658706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fc081b1c8b9f1e7d2e26cbf575086f" id="r_a89fc081b1c8b9f1e7d2e26cbf575086f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 2 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a89fc081b1c8b9f1e7d2e26cbf575086f">units::category::solid_angle_unit</a></td></tr>
<tr class="memdesc:a89fc081b1c8b9f1e7d2e26cbf575086f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of solid angle.  <br /></td></tr>
<tr class="separator:a89fc081b1c8b9f1e7d2e26cbf575086f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a92406ae7531da332d8fd2727adf42" id="r_a71a92406ae7531da332d8fd2727adf42"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt;-1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a71a92406ae7531da332d8fd2727adf42">units::category::frequency_unit</a></td></tr>
<tr class="memdesc:a71a92406ae7531da332d8fd2727adf42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of frequency.  <br /></td></tr>
<tr class="separator:a71a92406ae7531da332d8fd2727adf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc650709b31816197530a08cabbd9df2" id="r_adc650709b31816197530a08cabbd9df2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 1 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt;-1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#adc650709b31816197530a08cabbd9df2">units::category::velocity_unit</a></td></tr>
<tr class="memdesc:adc650709b31816197530a08cabbd9df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of velocity.  <br /></td></tr>
<tr class="separator:adc650709b31816197530a08cabbd9df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae69164cc4250e18d555c17b203b121" id="r_a2ae69164cc4250e18d555c17b203b121"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt;-1 &gt;, std::ratio&lt; 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a2ae69164cc4250e18d555c17b203b121">units::category::angular_velocity_unit</a></td></tr>
<tr class="memdesc:a2ae69164cc4250e18d555c17b203b121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of angular velocity.  <br /></td></tr>
<tr class="separator:a2ae69164cc4250e18d555c17b203b121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63109d118398c8b0f4123690c021b352" id="r_a63109d118398c8b0f4123690c021b352"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 1 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt;-2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a63109d118398c8b0f4123690c021b352">units::category::acceleration_unit</a></td></tr>
<tr class="memdesc:a63109d118398c8b0f4123690c021b352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of acceleration.  <br /></td></tr>
<tr class="separator:a63109d118398c8b0f4123690c021b352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf37aecb5ffd5d1990e43ac25891d0a9" id="r_adf37aecb5ffd5d1990e43ac25891d0a9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt;-2 &gt;, std::ratio&lt; 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#adf37aecb5ffd5d1990e43ac25891d0a9">units::category::angular_acceleration_unit</a></td></tr>
<tr class="memdesc:adf37aecb5ffd5d1990e43ac25891d0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of angular acceleration.  <br /></td></tr>
<tr class="separator:adf37aecb5ffd5d1990e43ac25891d0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6cad3f8c67d640d4a616954c1678cd" id="r_a9b6cad3f8c67d640d4a616954c1678cd"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt;-3 &gt;, std::ratio&lt; 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a9b6cad3f8c67d640d4a616954c1678cd">units::category::angular_jerk_unit</a></td></tr>
<tr class="memdesc:a9b6cad3f8c67d640d4a616954c1678cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of angular jerk.  <br /></td></tr>
<tr class="separator:a9b6cad3f8c67d640d4a616954c1678cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdd7d0eaedc290c7a56b2ce5340175c" id="r_adcdd7d0eaedc290c7a56b2ce5340175c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 1 &gt;, std::ratio&lt; 1 &gt;, std::ratio&lt;-2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#adcdd7d0eaedc290c7a56b2ce5340175c">units::category::force_unit</a></td></tr>
<tr class="memdesc:adcdd7d0eaedc290c7a56b2ce5340175c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of force.  <br /></td></tr>
<tr class="separator:adcdd7d0eaedc290c7a56b2ce5340175c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db5bc2dc58fd074af9fe1cea020f857" id="r_a5db5bc2dc58fd074af9fe1cea020f857"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt;-1 &gt;, std::ratio&lt; 1 &gt;, std::ratio&lt;-2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a5db5bc2dc58fd074af9fe1cea020f857">units::category::pressure_unit</a></td></tr>
<tr class="memdesc:a5db5bc2dc58fd074af9fe1cea020f857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of pressure.  <br /></td></tr>
<tr class="separator:a5db5bc2dc58fd074af9fe1cea020f857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b714d031ee06290551c9c85824f2794" id="r_a7b714d031ee06290551c9c85824f2794"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 1 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a7b714d031ee06290551c9c85824f2794">units::category::charge_unit</a></td></tr>
<tr class="memdesc:a7b714d031ee06290551c9c85824f2794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of charge.  <br /></td></tr>
<tr class="separator:a7b714d031ee06290551c9c85824f2794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5238ec9e9d4935062dd25ea1be9ab7f7" id="r_a5238ec9e9d4935062dd25ea1be9ab7f7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 2 &gt;, std::ratio&lt; 1 &gt;, std::ratio&lt;-2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a5238ec9e9d4935062dd25ea1be9ab7f7">units::category::energy_unit</a></td></tr>
<tr class="memdesc:a5238ec9e9d4935062dd25ea1be9ab7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of energy.  <br /></td></tr>
<tr class="separator:a5238ec9e9d4935062dd25ea1be9ab7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4afbbc5c0a5810ef13a7e9517e569e" id="r_a6d4afbbc5c0a5810ef13a7e9517e569e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 2 &gt;, std::ratio&lt; 1 &gt;, std::ratio&lt;-3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a6d4afbbc5c0a5810ef13a7e9517e569e">units::category::power_unit</a></td></tr>
<tr class="memdesc:a6d4afbbc5c0a5810ef13a7e9517e569e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of power.  <br /></td></tr>
<tr class="separator:a6d4afbbc5c0a5810ef13a7e9517e569e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6120e2f5e955204cf40247a767f70b0" id="r_aa6120e2f5e955204cf40247a767f70b0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 2 &gt;, std::ratio&lt; 1 &gt;, std::ratio&lt;-3 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt;-1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#aa6120e2f5e955204cf40247a767f70b0">units::category::voltage_unit</a></td></tr>
<tr class="memdesc:aa6120e2f5e955204cf40247a767f70b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of voltage.  <br /></td></tr>
<tr class="separator:aa6120e2f5e955204cf40247a767f70b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb7c3b9cef2446d8ed0dec7c1c5946d" id="r_aefb7c3b9cef2446d8ed0dec7c1c5946d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt;-2 &gt;, std::ratio&lt;-1 &gt;, std::ratio&lt; 4 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#aefb7c3b9cef2446d8ed0dec7c1c5946d">units::category::capacitance_unit</a></td></tr>
<tr class="memdesc:aefb7c3b9cef2446d8ed0dec7c1c5946d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of capacitance.  <br /></td></tr>
<tr class="separator:aefb7c3b9cef2446d8ed0dec7c1c5946d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f314570cbe9c1c415d1f5d49ff1418" id="r_a30f314570cbe9c1c415d1f5d49ff1418"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 2 &gt;, std::ratio&lt; 1 &gt;, std::ratio&lt;-3 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt;-2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a30f314570cbe9c1c415d1f5d49ff1418">units::category::impedance_unit</a></td></tr>
<tr class="memdesc:a30f314570cbe9c1c415d1f5d49ff1418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of impedance.  <br /></td></tr>
<tr class="separator:a30f314570cbe9c1c415d1f5d49ff1418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a2f6b0c5ebbf2075293ac5b88ef028" id="r_af0a2f6b0c5ebbf2075293ac5b88ef028"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt;-2 &gt;, std::ratio&lt;-1 &gt;, std::ratio&lt; 3 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#af0a2f6b0c5ebbf2075293ac5b88ef028">units::category::conductance_unit</a></td></tr>
<tr class="memdesc:af0a2f6b0c5ebbf2075293ac5b88ef028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of conductance.  <br /></td></tr>
<tr class="separator:af0a2f6b0c5ebbf2075293ac5b88ef028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22297ac1a4539a4f334c673e36071afa" id="r_a22297ac1a4539a4f334c673e36071afa"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 2 &gt;, std::ratio&lt; 1 &gt;, std::ratio&lt;-2 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt;-1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a22297ac1a4539a4f334c673e36071afa">units::category::magnetic_flux_unit</a></td></tr>
<tr class="memdesc:a22297ac1a4539a4f334c673e36071afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of magnetic flux.  <br /></td></tr>
<tr class="separator:a22297ac1a4539a4f334c673e36071afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d8c458796a541a150269512765b486" id="r_af0d8c458796a541a150269512765b486"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 0 &gt;, std::ratio&lt; 1 &gt;, std::ratio&lt;-2 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt;-1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#af0d8c458796a541a150269512765b486">units::category::magnetic_field_strength_unit</a></td></tr>
<tr class="memdesc:af0d8c458796a541a150269512765b486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of magnetic field strength.  <br /></td></tr>
<tr class="separator:af0d8c458796a541a150269512765b486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2faf0f8cb76762e1534a8f35884f8ec" id="r_ad2faf0f8cb76762e1534a8f35884f8ec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 2 &gt;, std::ratio&lt; 1 &gt;, std::ratio&lt;-2 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt;-2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#ad2faf0f8cb76762e1534a8f35884f8ec">units::category::inductance_unit</a></td></tr>
<tr class="memdesc:ad2faf0f8cb76762e1534a8f35884f8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of inductance.  <br /></td></tr>
<tr class="separator:ad2faf0f8cb76762e1534a8f35884f8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa00c198c610ba934b4c47e0fa98cb87" id="r_aaa00c198c610ba934b4c47e0fa98cb87"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 2 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#aaa00c198c610ba934b4c47e0fa98cb87">units::category::luminous_flux_unit</a></td></tr>
<tr class="memdesc:aaa00c198c610ba934b4c47e0fa98cb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of luminous flux.  <br /></td></tr>
<tr class="separator:aaa00c198c610ba934b4c47e0fa98cb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58394ebe6d7b2f0e0224e15b9f6a2637" id="r_a58394ebe6d7b2f0e0224e15b9f6a2637"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt;-2 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 2 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a58394ebe6d7b2f0e0224e15b9f6a2637">units::category::illuminance_unit</a></td></tr>
<tr class="memdesc:a58394ebe6d7b2f0e0224e15b9f6a2637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of illuminance.  <br /></td></tr>
<tr class="separator:a58394ebe6d7b2f0e0224e15b9f6a2637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa924b93c75d56d4098565be2006d618a" id="r_aa924b93c75d56d4098565be2006d618a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt;-1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#aa924b93c75d56d4098565be2006d618a">units::category::radioactivity_unit</a></td></tr>
<tr class="memdesc:aa924b93c75d56d4098565be2006d618a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of radioactivity.  <br /></td></tr>
<tr class="separator:aa924b93c75d56d4098565be2006d618a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0889848e7dda7a24d8fb9bc2f6a90e8" id="r_ab0889848e7dda7a24d8fb9bc2f6a90e8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 2 &gt;, std::ratio&lt; 1 &gt;, std::ratio&lt;-2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#ab0889848e7dda7a24d8fb9bc2f6a90e8">units::category::torque_unit</a></td></tr>
<tr class="memdesc:ab0889848e7dda7a24d8fb9bc2f6a90e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of torque.  <br /></td></tr>
<tr class="separator:ab0889848e7dda7a24d8fb9bc2f6a90e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fb1ded463a284094f448de4c154faf" id="r_af7fb1ded463a284094f448de4c154faf"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#af7fb1ded463a284094f448de4c154faf">units::category::area_unit</a></td></tr>
<tr class="memdesc:af7fb1ded463a284094f448de4c154faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of area.  <br /></td></tr>
<tr class="separator:af7fb1ded463a284094f448de4c154faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546f3cb7c3d969e33487b87a1234d82e" id="r_a546f3cb7c3d969e33487b87a1234d82e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a546f3cb7c3d969e33487b87a1234d82e">units::category::volume_unit</a></td></tr>
<tr class="memdesc:a546f3cb7c3d969e33487b87a1234d82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of volume.  <br /></td></tr>
<tr class="separator:a546f3cb7c3d969e33487b87a1234d82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159523871ed090398ff5ec773164ce85" id="r_a159523871ed090398ff5ec773164ce85"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt;-3 &gt;, std::ratio&lt; 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a159523871ed090398ff5ec773164ce85">units::category::density_unit</a></td></tr>
<tr class="memdesc:a159523871ed090398ff5ec773164ce85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an SI derived unit of density.  <br /></td></tr>
<tr class="separator:a159523871ed090398ff5ec773164ce85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c238e66131241671b3411bf2fef3e24" id="r_a4c238e66131241671b3411bf2fef3e24"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a4c238e66131241671b3411bf2fef3e24">units::category::concentration_unit</a></td></tr>
<tr class="memdesc:a4c238e66131241671b3411bf2fef3e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a unit of concentration.  <br /></td></tr>
<tr class="separator:a4c238e66131241671b3411bf2fef3e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5daae6818590f1cb7cb00f802a45688a" id="r_a5daae6818590f1cb7cb00f802a45688a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#a5daae6818590f1cb7cb00f802a45688a">units::category::data_unit</a></td></tr>
<tr class="memdesc:a5daae6818590f1cb7cb00f802a45688a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a unit of data size.  <br /></td></tr>
<tr class="separator:a5daae6818590f1cb7cb00f802a45688a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23b54e3a6efd89baa3daa8f9369b59f" id="r_ae23b54e3a6efd89baa3daa8f9369b59f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1base__unit.html">base_unit</a>&lt; detail::meter_ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt;-1 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 0 &gt;, std::ratio&lt; 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1category.html#ae23b54e3a6efd89baa3daa8f9369b59f">units::category::data_transfer_rate_unit</a></td></tr>
<tr class="memdesc:ae23b54e3a6efd89baa3daa8f9369b59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a unit of data transfer rate.  <br /></td></tr>
<tr class="separator:ae23b54e3a6efd89baa3daa8f9369b59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923f938c6c71c19aeeee6df290c047a8" id="r_a923f938c6c71c19aeeee6df290c047a8"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a923f938c6c71c19aeeee6df290c047a8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1traits.html#a923f938c6c71c19aeeee6df290c047a8">units::traits::base_unit_of</a> = typename units::detail::base_unit_of_impl&lt;U&gt;::type</td></tr>
<tr class="memdesc:a923f938c6c71c19aeeee6df290c047a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait which returns the <code><a class="el" href="structunits_1_1base__unit.html" title="Class representing SI base unit types.">base_unit</a></code> type that a unit is originally derived from.  <br /></td></tr>
<tr class="separator:a923f938c6c71c19aeeee6df290c047a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18bb1210c1a6ee41bbb21b32bf18c0f5" id="r_ga18bb1210c1a6ee41bbb21b32bf18c0f5"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga18bb1210c1a6ee41bbb21b32bf18c0f5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga18bb1210c1a6ee41bbb21b32bf18c0f5">units::inverse</a> = typename units::detail::inverse_impl&lt;U&gt;::type</td></tr>
<tr class="memdesc:ga18bb1210c1a6ee41bbb21b32bf18c0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the inverse unit type of <code>class U</code>.  <br /></td></tr>
<tr class="separator:ga18bb1210c1a6ee41bbb21b32bf18c0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34ce35a7632b2d8c337d826880f986c0" id="r_ga34ce35a7632b2d8c337d826880f986c0"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga34ce35a7632b2d8c337d826880f986c0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga34ce35a7632b2d8c337d826880f986c0">units::squared</a> = typename units::detail::squared_impl&lt;U&gt;::type</td></tr>
<tr class="memdesc:ga34ce35a7632b2d8c337d826880f986c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the unit type of <code>class U</code> squared  <br /></td></tr>
<tr class="separator:ga34ce35a7632b2d8c337d826880f986c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37cf01def62ad5a02fcd488964c9b755" id="r_ga37cf01def62ad5a02fcd488964c9b755"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga37cf01def62ad5a02fcd488964c9b755"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga37cf01def62ad5a02fcd488964c9b755">units::cubed</a> = typename units::detail::cubed_impl&lt;U&gt;::type</td></tr>
<tr class="memdesc:ga37cf01def62ad5a02fcd488964c9b755"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the type of <code>class U</code> cubed.  <br /></td></tr>
<tr class="separator:ga37cf01def62ad5a02fcd488964c9b755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97a443dbd75d9753f119d389b1828f8b" id="r_ga97a443dbd75d9753f119d389b1828f8b"><td class="memTemplParams" colspan="2">template&lt;typename Ratio , std::intmax_t Eps = 10000000000&gt; </td></tr>
<tr class="memitem:ga97a443dbd75d9753f119d389b1828f8b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_traits.html#ga97a443dbd75d9753f119d389b1828f8b">units::ratio_sqrt</a> = typename units::detail::Sqrt&lt;Ratio, std::ratio&lt;1, Eps&gt;&gt;::type</td></tr>
<tr class="memdesc:ga97a443dbd75d9753f119d389b1828f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate square root of a ratio at compile-time.  <br /></td></tr>
<tr class="separator:ga97a443dbd75d9753f119d389b1828f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf76418b4c13a07800f806ba9f94e30ce" id="r_gaf76418b4c13a07800f806ba9f94e30ce"><td class="memTemplParams" colspan="2">template&lt;class U , std::intmax_t Eps = 10000000000&gt; </td></tr>
<tr class="memitem:gaf76418b4c13a07800f806ba9f94e30ce"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gaf76418b4c13a07800f806ba9f94e30ce">units::square_root</a> = typename units::detail::sqrt_impl&lt;U, Eps&gt;::type</td></tr>
<tr class="memdesc:gaf76418b4c13a07800f806ba9f94e30ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents the square root of type <code>class U</code>.  <br /></td></tr>
<tr class="separator:gaf76418b4c13a07800f806ba9f94e30ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga360a646ae293d44b0dc49223429ecea7" id="r_ga360a646ae293d44b0dc49223429ecea7"><td class="memTemplParams" colspan="2">template&lt;class U , class... Us&gt; </td></tr>
<tr class="memitem:ga360a646ae293d44b0dc49223429ecea7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_types.html#ga360a646ae293d44b0dc49223429ecea7">units::compound_unit</a> = typename units::detail::compound_impl&lt;U, Us...&gt;::type</td></tr>
<tr class="memdesc:ga360a646ae293d44b0dc49223429ecea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a unit type made up from other units.  <br /></td></tr>
<tr class="separator:ga360a646ae293d44b0dc49223429ecea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa05c1eff65b212eba705125a7829f0f" id="r_afa05c1eff65b212eba705125a7829f0f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1unit.html">unit</a>&lt; std::ratio&lt; 1 &gt;, <a class="el" href="namespaceunits_1_1category.html#a6a8e59826a504070a1904837b0a80e58">units::category::scalar_unit</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1dimensionless.html#afa05c1eff65b212eba705125a7829f0f">units::dimensionless::scalar</a></td></tr>
<tr class="separator:afa05c1eff65b212eba705125a7829f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c8dabff15f950fca3c0cbfb0928e91" id="r_a72c8dabff15f950fca3c0cbfb0928e91"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structunits_1_1unit.html">unit</a>&lt; std::ratio&lt; 1 &gt;, <a class="el" href="namespaceunits_1_1category.html#a5cd8f8c2ecd2fa4688f326c4bc7a20fc">units::category::dimensionless_unit</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1dimensionless.html#a72c8dabff15f950fca3c0cbfb0928e91">units::dimensionless::dimensionless</a></td></tr>
<tr class="separator:a72c8dabff15f950fca3c0cbfb0928e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af747bc24203407ff7374ac2cad2b3808" id="r_af747bc24203407ff7374ac2cad2b3808"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="namespaceunits_1_1dimensionless.html#afa05c1eff65b212eba705125a7829f0f">scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1dimensionless.html#af747bc24203407ff7374ac2cad2b3808">units::dimensionless::scalar_t</a></td></tr>
<tr class="separator:af747bc24203407ff7374ac2cad2b3808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d9d40006a8bdac01f5776e42d283f3" id="r_af0d9d40006a8bdac01f5776e42d283f3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceunits_1_1dimensionless.html#af747bc24203407ff7374ac2cad2b3808">scalar_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1dimensionless.html#af0d9d40006a8bdac01f5776e42d283f3">units::dimensionless::dimensionless_t</a></td></tr>
<tr class="separator:af0d9d40006a8bdac01f5776e42d283f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d18e4545db54fa93e0ea3aad6449741" id="r_a5d18e4545db54fa93e0ea3aad6449741"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="namespaceunits_1_1dimensionless.html#afa05c1eff65b212eba705125a7829f0f">scalar</a>, <a class="el" href="#a071362944b1accb86d71518ab9613412">UNIT_LIB_DEFAULT_TYPE</a>, <a class="el" href="structunits_1_1decibel__scale.html">decibel_scale</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1dimensionless.html#a5d18e4545db54fa93e0ea3aad6449741">units::dimensionless::dB_t</a></td></tr>
<tr class="separator:a5d18e4545db54fa93e0ea3aad6449741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85dec047260fe77c02d9fdc6c826af83" id="r_a85dec047260fe77c02d9fdc6c826af83"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceunits_1_1dimensionless.html#a5d18e4545db54fa93e0ea3aad6449741">dB_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1dimensionless.html#a85dec047260fe77c02d9fdc6c826af83">units::dimensionless::dBi_t</a></td></tr>
<tr class="separator:a85dec047260fe77c02d9fdc6c826af83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga8c16631e490264eab5b2ac364315a4e2" id="r_ga8c16631e490264eab5b2ac364315a4e2"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga8c16631e490264eab5b2ac364315a4e2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga8c16631e490264eab5b2ac364315a4e2">units::atto</a> = typename units::detail::prefix&lt;std::atto, U&gt;::type</td></tr>
<tr class="separator:ga8c16631e490264eab5b2ac364315a4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae205a1a4ce7a8b5cde7795bb47b1836b" id="r_gae205a1a4ce7a8b5cde7795bb47b1836b"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:gae205a1a4ce7a8b5cde7795bb47b1836b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gae205a1a4ce7a8b5cde7795bb47b1836b">units::femto</a> = typename units::detail::prefix&lt;std::femto,U&gt;::type</td></tr>
<tr class="memdesc:gae205a1a4ce7a8b5cde7795bb47b1836b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'femto' prefix appended.  <br /></td></tr>
<tr class="separator:gae205a1a4ce7a8b5cde7795bb47b1836b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga787bd8ef18cfdec1f8def2600212f2f0" id="r_ga787bd8ef18cfdec1f8def2600212f2f0"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga787bd8ef18cfdec1f8def2600212f2f0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga787bd8ef18cfdec1f8def2600212f2f0">units::pico</a> = typename units::detail::prefix&lt;std::pico, U&gt;::type</td></tr>
<tr class="memdesc:ga787bd8ef18cfdec1f8def2600212f2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'pico' prefix appended.  <br /></td></tr>
<tr class="separator:ga787bd8ef18cfdec1f8def2600212f2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbd500ebd88ca5b0d45f087a02ed8292" id="r_gabbd500ebd88ca5b0d45f087a02ed8292"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:gabbd500ebd88ca5b0d45f087a02ed8292"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gabbd500ebd88ca5b0d45f087a02ed8292">units::nano</a> = typename units::detail::prefix&lt;std::nano, U&gt;::type</td></tr>
<tr class="memdesc:gabbd500ebd88ca5b0d45f087a02ed8292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'nano' prefix appended.  <br /></td></tr>
<tr class="separator:gabbd500ebd88ca5b0d45f087a02ed8292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga518311f2344e6f5d759cfb328f8e2ffc" id="r_ga518311f2344e6f5d759cfb328f8e2ffc"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga518311f2344e6f5d759cfb328f8e2ffc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga518311f2344e6f5d759cfb328f8e2ffc">units::micro</a> = typename units::detail::prefix&lt;std::micro,U&gt;::type</td></tr>
<tr class="memdesc:ga518311f2344e6f5d759cfb328f8e2ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'micro' prefix appended.  <br /></td></tr>
<tr class="separator:ga518311f2344e6f5d759cfb328f8e2ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39ba1358834a25c025ba91d9e1486b09" id="r_ga39ba1358834a25c025ba91d9e1486b09"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga39ba1358834a25c025ba91d9e1486b09"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga39ba1358834a25c025ba91d9e1486b09">units::milli</a> = typename units::detail::prefix&lt;std::milli,U&gt;::type</td></tr>
<tr class="memdesc:ga39ba1358834a25c025ba91d9e1486b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'milli' prefix appended.  <br /></td></tr>
<tr class="separator:ga39ba1358834a25c025ba91d9e1486b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad534b4dba3c3eb861a7809457110282f" id="r_gad534b4dba3c3eb861a7809457110282f"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:gad534b4dba3c3eb861a7809457110282f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gad534b4dba3c3eb861a7809457110282f">units::centi</a> = typename units::detail::prefix&lt;std::centi,U&gt;::type</td></tr>
<tr class="memdesc:gad534b4dba3c3eb861a7809457110282f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'centi' prefix appended.  <br /></td></tr>
<tr class="separator:gad534b4dba3c3eb861a7809457110282f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62d6c7a95bfad7d5a17a6c2ef57e92cd" id="r_ga62d6c7a95bfad7d5a17a6c2ef57e92cd"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga62d6c7a95bfad7d5a17a6c2ef57e92cd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga62d6c7a95bfad7d5a17a6c2ef57e92cd">units::deci</a> = typename units::detail::prefix&lt;std::deci, U&gt;::type</td></tr>
<tr class="memdesc:ga62d6c7a95bfad7d5a17a6c2ef57e92cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'deci' prefix appended.  <br /></td></tr>
<tr class="separator:ga62d6c7a95bfad7d5a17a6c2ef57e92cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga332a6035bd0e4c2a3d45c74222388252" id="r_ga332a6035bd0e4c2a3d45c74222388252"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga332a6035bd0e4c2a3d45c74222388252"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga332a6035bd0e4c2a3d45c74222388252">units::deca</a> = typename units::detail::prefix&lt;std::deca, U&gt;::type</td></tr>
<tr class="memdesc:ga332a6035bd0e4c2a3d45c74222388252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'deca' prefix appended.  <br /></td></tr>
<tr class="separator:ga332a6035bd0e4c2a3d45c74222388252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac6c7f702e8d4eef757529659dfcf58e" id="r_gaac6c7f702e8d4eef757529659dfcf58e"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:gaac6c7f702e8d4eef757529659dfcf58e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gaac6c7f702e8d4eef757529659dfcf58e">units::hecto</a> = typename units::detail::prefix&lt;std::hecto,U&gt;::type</td></tr>
<tr class="memdesc:gaac6c7f702e8d4eef757529659dfcf58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'hecto' prefix appended.  <br /></td></tr>
<tr class="separator:gaac6c7f702e8d4eef757529659dfcf58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4968a64c943632fd3251e6fb65df01c3" id="r_ga4968a64c943632fd3251e6fb65df01c3"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga4968a64c943632fd3251e6fb65df01c3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga4968a64c943632fd3251e6fb65df01c3">units::kilo</a> = typename units::detail::prefix&lt;std::kilo, U&gt;::type</td></tr>
<tr class="memdesc:ga4968a64c943632fd3251e6fb65df01c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'kilo' prefix appended.  <br /></td></tr>
<tr class="separator:ga4968a64c943632fd3251e6fb65df01c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8b2a0148b88178ba90759c41883f5c1" id="r_gaa8b2a0148b88178ba90759c41883f5c1"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:gaa8b2a0148b88178ba90759c41883f5c1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gaa8b2a0148b88178ba90759c41883f5c1">units::mega</a> = typename units::detail::prefix&lt;std::mega, U&gt;::type</td></tr>
<tr class="memdesc:gaa8b2a0148b88178ba90759c41883f5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'mega' prefix appended.  <br /></td></tr>
<tr class="separator:gaa8b2a0148b88178ba90759c41883f5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66d624a4119c86ba427c43457750e0a7" id="r_ga66d624a4119c86ba427c43457750e0a7"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga66d624a4119c86ba427c43457750e0a7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga66d624a4119c86ba427c43457750e0a7">units::giga</a> = typename units::detail::prefix&lt;std::giga, U&gt;::type</td></tr>
<tr class="memdesc:ga66d624a4119c86ba427c43457750e0a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'giga' prefix appended.  <br /></td></tr>
<tr class="separator:ga66d624a4119c86ba427c43457750e0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9208a3472d07ef20706cea7b6b81abd0" id="r_ga9208a3472d07ef20706cea7b6b81abd0"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga9208a3472d07ef20706cea7b6b81abd0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga9208a3472d07ef20706cea7b6b81abd0">units::tera</a> = typename units::detail::prefix&lt;std::tera, U&gt;::type</td></tr>
<tr class="memdesc:ga9208a3472d07ef20706cea7b6b81abd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'tera' prefix appended.  <br /></td></tr>
<tr class="separator:ga9208a3472d07ef20706cea7b6b81abd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42c6b80aa0865050c42252fca3072829" id="r_ga42c6b80aa0865050c42252fca3072829"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga42c6b80aa0865050c42252fca3072829"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga42c6b80aa0865050c42252fca3072829">units::peta</a> = typename units::detail::prefix&lt;std::peta, U&gt;::type</td></tr>
<tr class="memdesc:ga42c6b80aa0865050c42252fca3072829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'peta' prefix appended.  <br /></td></tr>
<tr class="separator:ga42c6b80aa0865050c42252fca3072829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga290aa5972190799f5012a3a7484832dd" id="r_ga290aa5972190799f5012a3a7484832dd"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga290aa5972190799f5012a3a7484832dd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga290aa5972190799f5012a3a7484832dd">units::exa</a> = typename units::detail::prefix&lt;std::exa, U&gt;::type</td></tr>
<tr class="memdesc:ga290aa5972190799f5012a3a7484832dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the metric 'exa' prefix appended.  <br /></td></tr>
<tr class="separator:ga290aa5972190799f5012a3a7484832dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gae901ebdcee18815ccb9c5015007616c2" id="r_gae901ebdcee18815ccb9c5015007616c2"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:gae901ebdcee18815ccb9c5015007616c2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gae901ebdcee18815ccb9c5015007616c2">units::kibi</a> = typename units::detail::prefix&lt;std::ratio&lt;1024&gt;, U&gt;::type</td></tr>
<tr class="separator:gae901ebdcee18815ccb9c5015007616c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a7506bc6a544205f7873e0f569157d2" id="r_ga6a7506bc6a544205f7873e0f569157d2"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga6a7506bc6a544205f7873e0f569157d2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga6a7506bc6a544205f7873e0f569157d2">units::mebi</a> = typename units::detail::prefix&lt;std::ratio&lt;1048576&gt;, U&gt;::type</td></tr>
<tr class="memdesc:ga6a7506bc6a544205f7873e0f569157d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the binary 'mibi' prefix appended.  <br /></td></tr>
<tr class="separator:ga6a7506bc6a544205f7873e0f569157d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65c28d329b126bbc2e791eecae2e8c1d" id="r_ga65c28d329b126bbc2e791eecae2e8c1d"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga65c28d329b126bbc2e791eecae2e8c1d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga65c28d329b126bbc2e791eecae2e8c1d">units::gibi</a> = typename units::detail::prefix&lt;std::ratio&lt;1073741824&gt;, U&gt;::type</td></tr>
<tr class="memdesc:ga65c28d329b126bbc2e791eecae2e8c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the binary 'gibi' prefix appended.  <br /></td></tr>
<tr class="separator:ga65c28d329b126bbc2e791eecae2e8c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabff2e16370e50d542b844fe7505773da" id="r_gabff2e16370e50d542b844fe7505773da"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:gabff2e16370e50d542b844fe7505773da"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#gabff2e16370e50d542b844fe7505773da">units::tebi</a> = typename units::detail::prefix&lt;std::ratio&lt;1099511627776&gt;, U&gt;::type</td></tr>
<tr class="memdesc:gabff2e16370e50d542b844fe7505773da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the binary 'tebi' prefix appended.  <br /></td></tr>
<tr class="separator:gabff2e16370e50d542b844fe7505773da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cda76a559765e716b1b11c88f4f2dc2" id="r_ga6cda76a559765e716b1b11c88f4f2dc2"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga6cda76a559765e716b1b11c88f4f2dc2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga6cda76a559765e716b1b11c88f4f2dc2">units::pebi</a> = typename units::detail::prefix&lt;std::ratio&lt;1125899906842624&gt;, U&gt;::type</td></tr>
<tr class="memdesc:ga6cda76a559765e716b1b11c88f4f2dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the binary 'pebi' prefix appended.  <br /></td></tr>
<tr class="separator:ga6cda76a559765e716b1b11c88f4f2dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71e2d0d13a815bb782137bc3fa9429e3" id="r_ga71e2d0d13a815bb782137bc3fa9429e3"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ga71e2d0d13a815bb782137bc3fa9429e3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_manipulators.html#ga71e2d0d13a815bb782137bc3fa9429e3">units::exbi</a> = typename units::detail::prefix&lt;std::ratio&lt;1152921504606846976&gt;, U&gt;::type</td></tr>
<tr class="memdesc:ga71e2d0d13a815bb782137bc3fa9429e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of <code>class U</code> with the binary 'exbi' prefix appended.  <br /></td></tr>
<tr class="separator:ga71e2d0d13a815bb782137bc3fa9429e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0fc33d31c4dcf18fd9a2c272f6370b0a" id="r_a0fc33d31c4dcf18fd9a2c272f6370b0a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0fc33d31c4dcf18fd9a2c272f6370b0a"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1detail.html#a0fc33d31c4dcf18fd9a2c272f6370b0a">units::detail::to_string</a> (const T &amp;t)</td></tr>
<tr class="separator:a0fc33d31c4dcf18fd9a2c272f6370b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e0d5a63e2f3163115029c091db136b" id="r_a82e0d5a63e2f3163115029c091db136b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a82e0d5a63e2f3163115029c091db136b"><td class="memTemplItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a82e0d5a63e2f3163115029c091db136b">units::name</a> (const T &amp;)</td></tr>
<tr class="separator:a82e0d5a63e2f3163115029c091db136b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d32cc06de59d524d5e7fa5cf06f362" id="r_a52d32cc06de59d524d5e7fa5cf06f362"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a52d32cc06de59d524d5e7fa5cf06f362"><td class="memTemplItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a52d32cc06de59d524d5e7fa5cf06f362">units::abbreviation</a> (const T &amp;)</td></tr>
<tr class="separator:a52d32cc06de59d524d5e7fa5cf06f362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa03816ee32bb44ddbd6bc866ef89b231" id="r_gaa03816ee32bb44ddbd6bc866ef89b231"><td class="memTemplParams" colspan="2">template&lt;class UnitFrom , class UnitTo , typename T  = UNIT_LIB_DEFAULT_TYPE&gt; </td></tr>
<tr class="memitem:gaa03816ee32bb44ddbd6bc866ef89b231"><td class="memTemplItemLeft" align="right" valign="top">static constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___conversion.html#gaa03816ee32bb44ddbd6bc866ef89b231">units::convert</a> (const T &amp;value) noexcept</td></tr>
<tr class="memdesc:gaa03816ee32bb44ddbd6bc866ef89b231"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a <em>value</em> from one type to another.  <br /></td></tr>
<tr class="separator:gaa03816ee32bb44ddbd6bc866ef89b231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1acd69ada7a93c35850717e3c1b4d5fc" id="r_ga1acd69ada7a93c35850717e3c1b4d5fc"><td class="memTemplParams" colspan="2">template&lt;class UnitType , typename T , class  = std::enable_if_t&lt;std::is_arithmetic&lt;T&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga1acd69ada7a93c35850717e3c1b4d5fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___unit_containers.html#ga1acd69ada7a93c35850717e3c1b4d5fc">units::make_unit</a> (const T value) noexcept</td></tr>
<tr class="memdesc:ga1acd69ada7a93c35850717e3c1b4d5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a unit container from an arithmetic type.  <br /></td></tr>
<tr class="separator:ga1acd69ada7a93c35850717e3c1b4d5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5d2fd30f834f853b96be433c1dc125" id="r_a3a5d2fd30f834f853b96be433c1dc125"><td class="memTemplParams" colspan="2">template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale, typename RhsType &gt; </td></tr>
<tr class="memitem:a3a5d2fd30f834f853b96be433c1dc125"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a3a5d2fd30f834f853b96be433c1dc125">units::operator+=</a> (<a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;lhs, const RhsType &amp;rhs) noexcept</td></tr>
<tr class="separator:a3a5d2fd30f834f853b96be433c1dc125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb603f3c83459a636aaef8385db3a443" id="r_abb603f3c83459a636aaef8385db3a443"><td class="memTemplParams" colspan="2">template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale, typename RhsType &gt; </td></tr>
<tr class="memitem:abb603f3c83459a636aaef8385db3a443"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#abb603f3c83459a636aaef8385db3a443">units::operator-=</a> (<a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;lhs, const RhsType &amp;rhs) noexcept</td></tr>
<tr class="separator:abb603f3c83459a636aaef8385db3a443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0432b551ae941770b97c6015002a4127" id="r_a0432b551ae941770b97c6015002a4127"><td class="memTemplParams" colspan="2">template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale, typename RhsType &gt; </td></tr>
<tr class="memitem:a0432b551ae941770b97c6015002a4127"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a0432b551ae941770b97c6015002a4127">units::operator*=</a> (<a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;lhs, const RhsType &amp;rhs) noexcept</td></tr>
<tr class="separator:a0432b551ae941770b97c6015002a4127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fcd35c60f767d1e4939a63b35be337" id="r_a11fcd35c60f767d1e4939a63b35be337"><td class="memTemplParams" colspan="2">template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale, typename RhsType &gt; </td></tr>
<tr class="memitem:a11fcd35c60f767d1e4939a63b35be337"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a11fcd35c60f767d1e4939a63b35be337">units::operator/=</a> (<a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;lhs, const RhsType &amp;rhs) noexcept</td></tr>
<tr class="separator:a11fcd35c60f767d1e4939a63b35be337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af918dff6e080530ae222f586143c397f" id="r_af918dff6e080530ae222f586143c397f"><td class="memTemplParams" colspan="2">template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale&gt; </td></tr>
<tr class="memitem:af918dff6e080530ae222f586143c397f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#af918dff6e080530ae222f586143c397f">units::operator+</a> (const <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;u) noexcept</td></tr>
<tr class="separator:af918dff6e080530ae222f586143c397f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa713abf1a3897b4ce3af01e759f744b0" id="r_aa713abf1a3897b4ce3af01e759f744b0"><td class="memTemplParams" colspan="2">template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale&gt; </td></tr>
<tr class="memitem:aa713abf1a3897b4ce3af01e759f744b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#aa713abf1a3897b4ce3af01e759f744b0">units::operator++</a> (<a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;u) noexcept</td></tr>
<tr class="separator:aa713abf1a3897b4ce3af01e759f744b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f847b1e32cb269aa9783bc325d6396" id="r_ab2f847b1e32cb269aa9783bc325d6396"><td class="memTemplParams" colspan="2">template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale&gt; </td></tr>
<tr class="memitem:ab2f847b1e32cb269aa9783bc325d6396"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#ab2f847b1e32cb269aa9783bc325d6396">units::operator++</a> (<a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;u, int) noexcept</td></tr>
<tr class="separator:ab2f847b1e32cb269aa9783bc325d6396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5d88c54ed9bf15ebfc5b54fad4a226" id="r_add5d88c54ed9bf15ebfc5b54fad4a226"><td class="memTemplParams" colspan="2">template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale&gt; </td></tr>
<tr class="memitem:add5d88c54ed9bf15ebfc5b54fad4a226"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#add5d88c54ed9bf15ebfc5b54fad4a226">units::operator-</a> (const <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;u) noexcept</td></tr>
<tr class="separator:add5d88c54ed9bf15ebfc5b54fad4a226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd405f8c8254f75f777291f83cf92a0f" id="r_acd405f8c8254f75f777291f83cf92a0f"><td class="memTemplParams" colspan="2">template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale&gt; </td></tr>
<tr class="memitem:acd405f8c8254f75f777291f83cf92a0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#acd405f8c8254f75f777291f83cf92a0f">units::operator--</a> (<a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;u) noexcept</td></tr>
<tr class="separator:acd405f8c8254f75f777291f83cf92a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4676ba7553daca7fa6d911b48558a7d6" id="r_a4676ba7553daca7fa6d911b48558a7d6"><td class="memTemplParams" colspan="2">template&lt;class Units , typename T , template&lt; typename &gt; class NonLinearScale&gt; </td></tr>
<tr class="memitem:a4676ba7553daca7fa6d911b48558a7d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a4676ba7553daca7fa6d911b48558a7d6">units::operator--</a> (<a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; Units, T, NonLinearScale &gt; &amp;u, int) noexcept</td></tr>
<tr class="separator:a4676ba7553daca7fa6d911b48558a7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga850c3e5c380d1eb1d718128966819c70" id="r_ga850c3e5c380d1eb1d718128966819c70"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Units , class  = std::enable_if_t&lt;std::is_arithmetic&lt;T&gt;::value &amp;&amp; traits::is_unit_t&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga850c3e5c380d1eb1d718128966819c70"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___conversion.html#ga850c3e5c380d1eb1d718128966819c70">units::unit_cast</a> (const Units &amp;value) noexcept</td></tr>
<tr class="memdesc:ga850c3e5c380d1eb1d718128966819c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a unit container to an arithmetic type.  <br /></td></tr>
<tr class="separator:ga850c3e5c380d1eb1d718128966819c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cb11390bc6db4d4b3ceb9f098969d9" id="r_a81cb11390bc6db4d4b3ceb9f098969d9"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , std::enable_if_t&lt;!<a class="el" href="structunits_1_1traits_1_1is__same__scale.html">traits::is_same_scale</a>&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a81cb11390bc6db4d4b3ceb9f098969d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a81cb11390bc6db4d4b3ceb9f098969d9">units::operator+</a> (const UnitTypeLhs &amp;, const UnitTypeRhs &amp;) noexcept</td></tr>
<tr class="separator:a81cb11390bc6db4d4b3ceb9f098969d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a71b68052438b9369f3d1a32f7928f2" id="r_a3a71b68052438b9369f3d1a32f7928f2"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , std::enable_if_t&lt; <a class="el" href="structunits_1_1traits_1_1has__linear__scale.html">traits::has_linear_scale</a>&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3a71b68052438b9369f3d1a32f7928f2"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a3a71b68052438b9369f3d1a32f7928f2">units::operator+</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a3a71b68052438b9369f3d1a32f7928f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear">linear_scale</a>.  <br /></td></tr>
<tr class="separator:a3a71b68052438b9369f3d1a32f7928f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e70fbe82fa3e174bec8df6a82978ee3" id="r_a0e70fbe82fa3e174bec8df6a82978ee3"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0e70fbe82fa3e174bec8df6a82978ee3"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceunits_1_1dimensionless.html#af747bc24203407ff7374ac2cad2b3808">dimensionless::scalar_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a0e70fbe82fa3e174bec8df6a82978ee3">units::operator+</a> (const <a class="el" href="namespaceunits_1_1dimensionless.html#af747bc24203407ff7374ac2cad2b3808">dimensionless::scalar_t</a> &amp;lhs, T rhs) noexcept</td></tr>
<tr class="memdesc:a0e70fbe82fa3e174bec8df6a82978ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for scalar <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear">linear_scale</a>. Scalar types can be implicitly converted to built-in types.  <br /></td></tr>
<tr class="separator:a0e70fbe82fa3e174bec8df6a82978ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb285c204ca46e6e01fd60acbfffb4e2" id="r_abb285c204ca46e6e01fd60acbfffb4e2"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:abb285c204ca46e6e01fd60acbfffb4e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceunits_1_1dimensionless.html#af747bc24203407ff7374ac2cad2b3808">dimensionless::scalar_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#abb285c204ca46e6e01fd60acbfffb4e2">units::operator+</a> (T lhs, const <a class="el" href="namespaceunits_1_1dimensionless.html#af747bc24203407ff7374ac2cad2b3808">dimensionless::scalar_t</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:abb285c204ca46e6e01fd60acbfffb4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for scalar <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear">linear_scale</a>. Scalar types can be implicitly converted to built-in types.  <br /></td></tr>
<tr class="separator:abb285c204ca46e6e01fd60acbfffb4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1276f124efd1553bb3ecc7272e89fc00" id="r_a1276f124efd1553bb3ecc7272e89fc00"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , std::enable_if_t&lt; <a class="el" href="structunits_1_1traits_1_1has__linear__scale.html">traits::has_linear_scale</a>&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1276f124efd1553bb3ecc7272e89fc00"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a1276f124efd1553bb3ecc7272e89fc00">units::operator-</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a1276f124efd1553bb3ecc7272e89fc00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear">linear_scale</a>.  <br /></td></tr>
<tr class="separator:a1276f124efd1553bb3ecc7272e89fc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620cdb55bb08bc52fd25e6c7b5747ff5" id="r_a620cdb55bb08bc52fd25e6c7b5747ff5"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a620cdb55bb08bc52fd25e6c7b5747ff5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceunits_1_1dimensionless.html#af747bc24203407ff7374ac2cad2b3808">dimensionless::scalar_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a620cdb55bb08bc52fd25e6c7b5747ff5">units::operator-</a> (const <a class="el" href="namespaceunits_1_1dimensionless.html#af747bc24203407ff7374ac2cad2b3808">dimensionless::scalar_t</a> &amp;lhs, T rhs) noexcept</td></tr>
<tr class="memdesc:a620cdb55bb08bc52fd25e6c7b5747ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for scalar <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear">linear_scale</a>. Scalar types can be implicitly converted to built-in types.  <br /></td></tr>
<tr class="separator:a620cdb55bb08bc52fd25e6c7b5747ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c40cb31fd4fda534f293016693c221" id="r_ad4c40cb31fd4fda534f293016693c221"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad4c40cb31fd4fda534f293016693c221"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceunits_1_1dimensionless.html#af747bc24203407ff7374ac2cad2b3808">dimensionless::scalar_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#ad4c40cb31fd4fda534f293016693c221">units::operator-</a> (T lhs, const <a class="el" href="namespaceunits_1_1dimensionless.html#af747bc24203407ff7374ac2cad2b3808">dimensionless::scalar_t</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ad4c40cb31fd4fda534f293016693c221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for scalar <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1linear__scale.html" title="unit_t scale which is linear">linear_scale</a>. Scalar types can be implicitly converted to built-in types.  <br /></td></tr>
<tr class="separator:ad4c40cb31fd4fda534f293016693c221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8b0bee728dfc3fb3371c242ac4345d" id="r_afe8b0bee728dfc3fb3371c242ac4345d"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , std::enable_if_t&lt; <a class="el" href="structunits_1_1traits_1_1is__convertible__unit__t.html">traits::is_convertible_unit_t</a>&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;<a class="el" href="structunits_1_1traits_1_1has__linear__scale.html">traits::has_linear_scale</a>&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:afe8b0bee728dfc3fb3371c242ac4345d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#afe8b0bee728dfc3fb3371c242ac4345d">units::operator*</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group___unit_types.html#ga360a646ae293d44b0dc49223429ecea7">compound_unit</a>&lt; <a class="el" href="group___unit_manipulators.html#ga34ce35a7632b2d8c337d826880f986c0">squared</a>&lt; typename units::traits::unit_t_traits&lt; UnitTypeLhs &gt;::unit_type &gt; &gt; &gt;</td></tr>
<tr class="memdesc:afe8b0bee728dfc3fb3371c242ac4345d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication type for convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a linear scale.  <br /></td></tr>
<tr class="separator:afe8b0bee728dfc3fb3371c242ac4345d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae149d36dcf39ce19af1bc6e0538415a2" id="r_ae149d36dcf39ce19af1bc6e0538415a2"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , typename UnitTypeRhs , std::enable_if_t&lt; <a class="el" href="structunits_1_1traits_1_1has__linear__scale.html">traits::has_linear_scale</a>&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;!<a class="el" href="structunits_1_1traits_1_1is__dimensionless__unit.html">traits::is_dimensionless_unit</a>&lt; UnitTypeLhs &gt;::value &amp;&amp;<a class="el" href="structunits_1_1traits_1_1is__dimensionless__unit.html">traits::is_dimensionless_unit</a>&lt; UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae149d36dcf39ce19af1bc6e0538415a2"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#ae149d36dcf39ce19af1bc6e0538415a2">units::operator*</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae149d36dcf39ce19af1bc6e0538415a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication by a dimensionless unit for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a linear scale.  <br /></td></tr>
<tr class="separator:ae149d36dcf39ce19af1bc6e0538415a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e5766d8297c69e324996f9a008ff60" id="r_ae0e5766d8297c69e324996f9a008ff60"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , typename UnitTypeRhs , std::enable_if_t&lt; <a class="el" href="structunits_1_1traits_1_1has__linear__scale.html">traits::has_linear_scale</a>&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;<a class="el" href="structunits_1_1traits_1_1is__dimensionless__unit.html">traits::is_dimensionless_unit</a>&lt; UnitTypeLhs &gt;::value &amp;&amp;!<a class="el" href="structunits_1_1traits_1_1is__dimensionless__unit.html">traits::is_dimensionless_unit</a>&lt; UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae0e5766d8297c69e324996f9a008ff60"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeRhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#ae0e5766d8297c69e324996f9a008ff60">units::operator*</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae0e5766d8297c69e324996f9a008ff60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication by a dimensionless unit for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a linear scale.  <br /></td></tr>
<tr class="separator:ae0e5766d8297c69e324996f9a008ff60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ca29120f8a80d0920f22ffb1615df4" id="r_a56ca29120f8a80d0920f22ffb1615df4"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , typename T , std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value &amp;&amp;<a class="el" href="structunits_1_1traits_1_1has__linear__scale.html">traits::has_linear_scale</a>&lt; UnitTypeLhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a56ca29120f8a80d0920f22ffb1615df4"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a56ca29120f8a80d0920f22ffb1615df4">units::operator*</a> (const UnitTypeLhs &amp;lhs, T rhs) noexcept</td></tr>
<tr class="memdesc:a56ca29120f8a80d0920f22ffb1615df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication by a scalar for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a linear scale.  <br /></td></tr>
<tr class="separator:a56ca29120f8a80d0920f22ffb1615df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327ba3108188a585bb67c3f213e1c1b8" id="r_a327ba3108188a585bb67c3f213e1c1b8"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeRhs , typename T , std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value &amp;&amp;<a class="el" href="structunits_1_1traits_1_1has__linear__scale.html">traits::has_linear_scale</a>&lt; UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a327ba3108188a585bb67c3f213e1c1b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeRhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a327ba3108188a585bb67c3f213e1c1b8">units::operator*</a> (T lhs, const UnitTypeRhs &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a327ba3108188a585bb67c3f213e1c1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication by a scalar for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a linear scale.  <br /></td></tr>
<tr class="separator:a327ba3108188a585bb67c3f213e1c1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8277ba3ab0b1d897f5bd59de7854163b" id="r_a8277ba3ab0b1d897f5bd59de7854163b"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , std::enable_if_t&lt; <a class="el" href="structunits_1_1traits_1_1is__convertible__unit__t.html">traits::is_convertible_unit_t</a>&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;<a class="el" href="structunits_1_1traits_1_1has__linear__scale.html">traits::has_linear_scale</a>&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8277ba3ab0b1d897f5bd59de7854163b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceunits_1_1dimensionless.html#af747bc24203407ff7374ac2cad2b3808">dimensionless::scalar_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a8277ba3ab0b1d897f5bd59de7854163b">units::operator/</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a8277ba3ab0b1d897f5bd59de7854163b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division for convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a linear scale.  <br /></td></tr>
<tr class="separator:a8277ba3ab0b1d897f5bd59de7854163b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d51510e8f24656a658b315ebdc9f0f1" id="r_a7d51510e8f24656a658b315ebdc9f0f1"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , std::enable_if_t&lt;!<a class="el" href="structunits_1_1traits_1_1is__convertible__unit__t.html">traits::is_convertible_unit_t</a>&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;<a class="el" href="structunits_1_1traits_1_1has__linear__scale.html">traits::has_linear_scale</a>&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;!<a class="el" href="structunits_1_1traits_1_1is__dimensionless__unit.html">traits::is_dimensionless_unit</a>&lt; UnitTypeLhs &gt;::value &amp;&amp;!<a class="el" href="structunits_1_1traits_1_1is__dimensionless__unit.html">traits::is_dimensionless_unit</a>&lt; UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a7d51510e8f24656a658b315ebdc9f0f1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a7d51510e8f24656a658b315ebdc9f0f1">units::operator/</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group___unit_types.html#ga360a646ae293d44b0dc49223429ecea7">compound_unit</a>&lt; typename units::traits::unit_t_traits&lt; UnitTypeLhs &gt;::unit_type, <a class="el" href="group___unit_manipulators.html#ga18bb1210c1a6ee41bbb21b32bf18c0f5">inverse</a>&lt; typename units::traits::unit_t_traits&lt; UnitTypeRhs &gt;::unit_type &gt; &gt; &gt;</td></tr>
<tr class="memdesc:a7d51510e8f24656a658b315ebdc9f0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division for non-convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a linear scale.  <br /></td></tr>
<tr class="separator:a7d51510e8f24656a658b315ebdc9f0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef27ef8903ff1a75260cb0489c12730e" id="r_aef27ef8903ff1a75260cb0489c12730e"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , std::enable_if_t&lt; <a class="el" href="structunits_1_1traits_1_1has__linear__scale.html">traits::has_linear_scale</a>&lt; UnitTypeLhs, UnitTypeRhs &gt;::value &amp;&amp;!<a class="el" href="structunits_1_1traits_1_1is__dimensionless__unit.html">traits::is_dimensionless_unit</a>&lt; UnitTypeLhs &gt;::value &amp;&amp;<a class="el" href="structunits_1_1traits_1_1is__dimensionless__unit.html">traits::is_dimensionless_unit</a>&lt; UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aef27ef8903ff1a75260cb0489c12730e"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#aef27ef8903ff1a75260cb0489c12730e">units::operator/</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aef27ef8903ff1a75260cb0489c12730e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division by a dimensionless unit for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a linear scale.  <br /></td></tr>
<tr class="separator:aef27ef8903ff1a75260cb0489c12730e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede70a4c0594d33f56f2390430dca1ed" id="r_aede70a4c0594d33f56f2390430dca1ed"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , typename T , std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value &amp;&amp;<a class="el" href="structunits_1_1traits_1_1has__linear__scale.html">traits::has_linear_scale</a>&lt; UnitTypeLhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aede70a4c0594d33f56f2390430dca1ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#aede70a4c0594d33f56f2390430dca1ed">units::operator/</a> (const UnitTypeLhs &amp;lhs, T rhs) noexcept</td></tr>
<tr class="memdesc:aede70a4c0594d33f56f2390430dca1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division by a scalar for <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a linear scale.  <br /></td></tr>
<tr class="separator:aede70a4c0594d33f56f2390430dca1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c0691af74ef23aecf4d068a2516a57" id="r_a41c0691af74ef23aecf4d068a2516a57"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeRhs , typename T , std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value &amp;&amp;<a class="el" href="structunits_1_1traits_1_1has__linear__scale.html">traits::has_linear_scale</a>&lt; UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a41c0691af74ef23aecf4d068a2516a57"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a41c0691af74ef23aecf4d068a2516a57">units::operator/</a> (T lhs, const UnitTypeRhs &amp;rhs) noexcept -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group___unit_manipulators.html#ga18bb1210c1a6ee41bbb21b32bf18c0f5">inverse</a>&lt; typename units::traits::unit_t_traits&lt; UnitTypeRhs &gt;::unit_type &gt; &gt;</td></tr>
<tr class="memdesc:a41c0691af74ef23aecf4d068a2516a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division of a scalar by a <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> type with a linear scale.  <br /></td></tr>
<tr class="separator:a41c0691af74ef23aecf4d068a2516a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6192892493e7f119568546508589c2fe" id="r_a6192892493e7f119568546508589c2fe"><td class="memTemplParams" colspan="2">template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a6192892493e7f119568546508589c2fe"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a6192892493e7f119568546508589c2fe">units::operator==</a> (const <a class="el" href="#a071362944b1accb86d71518ab9613412">UNIT_LIB_DEFAULT_TYPE</a> lhs, const Units &amp;rhs) noexcept</td></tr>
<tr class="separator:a6192892493e7f119568546508589c2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e57cc26790b07bc75699f339de10582" id="r_a2e57cc26790b07bc75699f339de10582"><td class="memTemplParams" colspan="2">template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a2e57cc26790b07bc75699f339de10582"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a2e57cc26790b07bc75699f339de10582">units::operator==</a> (const Units &amp;lhs, const <a class="el" href="#a071362944b1accb86d71518ab9613412">UNIT_LIB_DEFAULT_TYPE</a> rhs) noexcept</td></tr>
<tr class="separator:a2e57cc26790b07bc75699f339de10582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e6a0384e69f8cf0cc840183c407ec3" id="r_a36e6a0384e69f8cf0cc840183c407ec3"><td class="memTemplParams" colspan="2">template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a36e6a0384e69f8cf0cc840183c407ec3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a36e6a0384e69f8cf0cc840183c407ec3">units::operator!=</a> (const <a class="el" href="#a071362944b1accb86d71518ab9613412">UNIT_LIB_DEFAULT_TYPE</a> lhs, const Units &amp;rhs) noexcept</td></tr>
<tr class="separator:a36e6a0384e69f8cf0cc840183c407ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7deb49c3f7a5819462e2021e656932e2" id="r_a7deb49c3f7a5819462e2021e656932e2"><td class="memTemplParams" colspan="2">template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a7deb49c3f7a5819462e2021e656932e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a7deb49c3f7a5819462e2021e656932e2">units::operator!=</a> (const Units &amp;lhs, const <a class="el" href="#a071362944b1accb86d71518ab9613412">UNIT_LIB_DEFAULT_TYPE</a> rhs) noexcept</td></tr>
<tr class="separator:a7deb49c3f7a5819462e2021e656932e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7d26c3ef641666b95ad90b6a143fdd" id="r_acd7d26c3ef641666b95ad90b6a143fdd"><td class="memTemplParams" colspan="2">template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:acd7d26c3ef641666b95ad90b6a143fdd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#acd7d26c3ef641666b95ad90b6a143fdd">units::operator&gt;=</a> (const <a class="el" href="#a071362944b1accb86d71518ab9613412">UNIT_LIB_DEFAULT_TYPE</a> lhs, const Units &amp;rhs) noexcept</td></tr>
<tr class="separator:acd7d26c3ef641666b95ad90b6a143fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9984d65cde63e7b97cfd8df035c50b7b" id="r_a9984d65cde63e7b97cfd8df035c50b7b"><td class="memTemplParams" colspan="2">template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a9984d65cde63e7b97cfd8df035c50b7b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a9984d65cde63e7b97cfd8df035c50b7b">units::operator&gt;=</a> (const Units &amp;lhs, const <a class="el" href="#a071362944b1accb86d71518ab9613412">UNIT_LIB_DEFAULT_TYPE</a> rhs) noexcept</td></tr>
<tr class="separator:a9984d65cde63e7b97cfd8df035c50b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3d43d1395f155226a4c70e33f2e4a2" id="r_add3d43d1395f155226a4c70e33f2e4a2"><td class="memTemplParams" colspan="2">template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:add3d43d1395f155226a4c70e33f2e4a2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#add3d43d1395f155226a4c70e33f2e4a2">units::operator&gt;</a> (const <a class="el" href="#a071362944b1accb86d71518ab9613412">UNIT_LIB_DEFAULT_TYPE</a> lhs, const Units &amp;rhs) noexcept</td></tr>
<tr class="separator:add3d43d1395f155226a4c70e33f2e4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b16156d9fd8964e7a54d7850ee13a88" id="r_a6b16156d9fd8964e7a54d7850ee13a88"><td class="memTemplParams" colspan="2">template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a6b16156d9fd8964e7a54d7850ee13a88"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a6b16156d9fd8964e7a54d7850ee13a88">units::operator&gt;</a> (const Units &amp;lhs, const <a class="el" href="#a071362944b1accb86d71518ab9613412">UNIT_LIB_DEFAULT_TYPE</a> rhs) noexcept</td></tr>
<tr class="separator:a6b16156d9fd8964e7a54d7850ee13a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa430d90dc65e5b3fc4ee81139aaf8d" id="r_acaa430d90dc65e5b3fc4ee81139aaf8d"><td class="memTemplParams" colspan="2">template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:acaa430d90dc65e5b3fc4ee81139aaf8d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#acaa430d90dc65e5b3fc4ee81139aaf8d">units::operator&lt;=</a> (const <a class="el" href="#a071362944b1accb86d71518ab9613412">UNIT_LIB_DEFAULT_TYPE</a> lhs, const Units &amp;rhs) noexcept</td></tr>
<tr class="separator:acaa430d90dc65e5b3fc4ee81139aaf8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20cf047daf09967c469e40a6e578a77a" id="r_a20cf047daf09967c469e40a6e578a77a"><td class="memTemplParams" colspan="2">template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a20cf047daf09967c469e40a6e578a77a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a20cf047daf09967c469e40a6e578a77a">units::operator&lt;=</a> (const Units &amp;lhs, const <a class="el" href="#a071362944b1accb86d71518ab9613412">UNIT_LIB_DEFAULT_TYPE</a> rhs) noexcept</td></tr>
<tr class="separator:a20cf047daf09967c469e40a6e578a77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3712beb53491526b997c043c33ef966" id="r_aa3712beb53491526b997c043c33ef966"><td class="memTemplParams" colspan="2">template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:aa3712beb53491526b997c043c33ef966"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#aa3712beb53491526b997c043c33ef966">units::operator&lt;</a> (const <a class="el" href="#a071362944b1accb86d71518ab9613412">UNIT_LIB_DEFAULT_TYPE</a> lhs, const Units &amp;rhs) noexcept</td></tr>
<tr class="separator:aa3712beb53491526b997c043c33ef966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f7835cb09f1bdebe751c307d579208" id="r_a53f7835cb09f1bdebe751c307d579208"><td class="memTemplParams" colspan="2">template&lt;typename Units , class  = std::enable_if_t&lt;units::traits::is_dimensionless_unit&lt;Units&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a53f7835cb09f1bdebe751c307d579208"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a53f7835cb09f1bdebe751c307d579208">units::operator&lt;</a> (const Units &amp;lhs, const <a class="el" href="#a071362944b1accb86d71518ab9613412">UNIT_LIB_DEFAULT_TYPE</a> rhs) noexcept</td></tr>
<tr class="separator:a53f7835cb09f1bdebe751c307d579208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df30fe2f548ca1941df899800980433" id="r_a8df30fe2f548ca1941df899800980433"><td class="memTemplParams" colspan="2">template&lt;int power, class UnitType , class  = typename std::enable_if&lt;traits::has_linear_scale&lt;UnitType&gt;::value, int&gt;&gt; </td></tr>
<tr class="memitem:a8df30fe2f548ca1941df899800980433"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1math.html#a8df30fe2f548ca1941df899800980433">units::math::pow</a> (const UnitType &amp;value) noexcept -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; typename units::detail::power_of_unit&lt; power, typename units::traits::unit_t_traits&lt; UnitType &gt;::unit_type &gt;::type, typename units::traits::unit_t_traits&lt; UnitType &gt;::underlying_type, <a class="el" href="structunits_1_1linear__scale.html">linear_scale</a> &gt;</td></tr>
<tr class="memdesc:a8df30fe2f548ca1941df899800980433"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the value of <em>value</em> raised to the <em>power</em>  <br /></td></tr>
<tr class="separator:a8df30fe2f548ca1941df899800980433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75594321e6d2c1f9fb463667c70e08bf" id="r_a75594321e6d2c1f9fb463667c70e08bf"><td class="memTemplParams" colspan="2">template&lt;int power, class UnitType , class  = typename std::enable_if&lt;traits::has_linear_scale&lt;UnitType&gt;::value, int&gt;&gt; </td></tr>
<tr class="memitem:a75594321e6d2c1f9fb463667c70e08bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1math.html#a75594321e6d2c1f9fb463667c70e08bf">units::math::cpow</a> (const UnitType &amp;value) noexcept -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; typename units::detail::power_of_unit&lt; power, typename units::traits::unit_t_traits&lt; UnitType &gt;::unit_type &gt;::type, typename units::traits::unit_t_traits&lt; UnitType &gt;::underlying_type, <a class="el" href="structunits_1_1linear__scale.html">linear_scale</a> &gt;</td></tr>
<tr class="memdesc:a75594321e6d2c1f9fb463667c70e08bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the value of <em>value</em> raised to the <em>power</em> as a constexpr  <br /></td></tr>
<tr class="separator:a75594321e6d2c1f9fb463667c70e08bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4de8c335f1c670b8c52f293da07c85" id="r_a5b4de8c335f1c670b8c52f293da07c85"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , std::enable_if_t&lt; <a class="el" href="structunits_1_1traits_1_1has__decibel__scale.html">traits::has_decibel_scale</a>&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5b4de8c335f1c670b8c52f293da07c85"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a5b4de8c335f1c670b8c52f293da07c85">units::operator+</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group___unit_types.html#ga360a646ae293d44b0dc49223429ecea7">compound_unit</a>&lt; <a class="el" href="group___unit_manipulators.html#ga34ce35a7632b2d8c337d826880f986c0">squared</a>&lt; typename units::traits::unit_t_traits&lt; UnitTypeLhs &gt;::unit_type &gt; &gt;, typename units::traits::unit_t_traits&lt; UnitTypeLhs &gt;::underlying_type, <a class="el" href="structunits_1_1decibel__scale.html">decibel_scale</a> &gt;</td></tr>
<tr class="memdesc:a5b4de8c335f1c670b8c52f293da07c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition for convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values.">decibel_scale</a>.  <br /></td></tr>
<tr class="separator:a5b4de8c335f1c670b8c52f293da07c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b831b1b8478ee55f664d53272eeec23" id="r_a9b831b1b8478ee55f664d53272eeec23"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , std::enable_if_t&lt; <a class="el" href="structunits_1_1traits_1_1has__decibel__scale.html">traits::has_decibel_scale</a>&lt; UnitTypeLhs &gt;::value &amp;&amp;!<a class="el" href="structunits_1_1traits_1_1is__dimensionless__unit.html">traits::is_dimensionless_unit</a>&lt; UnitTypeLhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9b831b1b8478ee55f664d53272eeec23"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a9b831b1b8478ee55f664d53272eeec23">units::operator+</a> (const UnitTypeLhs &amp;lhs, const <a class="el" href="namespaceunits_1_1dimensionless.html#a5d18e4545db54fa93e0ea3aad6449741">dimensionless::dB_t</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a9b831b1b8478ee55f664d53272eeec23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition between <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values.">decibel_scale</a> and dimensionless dB units.  <br /></td></tr>
<tr class="separator:a9b831b1b8478ee55f664d53272eeec23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab69905978f40315a9d9a0041016f2e" id="r_a1ab69905978f40315a9d9a0041016f2e"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeRhs , std::enable_if_t&lt; <a class="el" href="structunits_1_1traits_1_1has__decibel__scale.html">traits::has_decibel_scale</a>&lt; UnitTypeRhs &gt;::value &amp;&amp;!<a class="el" href="structunits_1_1traits_1_1is__dimensionless__unit.html">traits::is_dimensionless_unit</a>&lt; UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1ab69905978f40315a9d9a0041016f2e"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeRhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a1ab69905978f40315a9d9a0041016f2e">units::operator+</a> (const <a class="el" href="namespaceunits_1_1dimensionless.html#a5d18e4545db54fa93e0ea3aad6449741">dimensionless::dB_t</a> &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a1ab69905978f40315a9d9a0041016f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition between <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values.">decibel_scale</a> and dimensionless dB units.  <br /></td></tr>
<tr class="separator:a1ab69905978f40315a9d9a0041016f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae711d874dd08cedb282879b1ad47df6a" id="r_ae711d874dd08cedb282879b1ad47df6a"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs , std::enable_if_t&lt; <a class="el" href="structunits_1_1traits_1_1has__decibel__scale.html">traits::has_decibel_scale</a>&lt; UnitTypeLhs, UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae711d874dd08cedb282879b1ad47df6a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#ae711d874dd08cedb282879b1ad47df6a">units::operator-</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group___unit_types.html#ga360a646ae293d44b0dc49223429ecea7">compound_unit</a>&lt; typename units::traits::unit_t_traits&lt; UnitTypeLhs &gt;::unit_type, <a class="el" href="group___unit_manipulators.html#ga18bb1210c1a6ee41bbb21b32bf18c0f5">inverse</a>&lt; typename units::traits::unit_t_traits&lt; UnitTypeRhs &gt;::unit_type &gt; &gt;, typename units::traits::unit_t_traits&lt; UnitTypeLhs &gt;::underlying_type, <a class="el" href="structunits_1_1decibel__scale.html">decibel_scale</a> &gt;</td></tr>
<tr class="memdesc:ae711d874dd08cedb282879b1ad47df6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction for convertible <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values.">decibel_scale</a>.  <br /></td></tr>
<tr class="separator:ae711d874dd08cedb282879b1ad47df6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4fae6a157a451266ef24407b130715" id="r_aaf4fae6a157a451266ef24407b130715"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , std::enable_if_t&lt; <a class="el" href="structunits_1_1traits_1_1has__decibel__scale.html">traits::has_decibel_scale</a>&lt; UnitTypeLhs &gt;::value &amp;&amp;!<a class="el" href="structunits_1_1traits_1_1is__dimensionless__unit.html">traits::is_dimensionless_unit</a>&lt; UnitTypeLhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aaf4fae6a157a451266ef24407b130715"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#aaf4fae6a157a451266ef24407b130715">units::operator-</a> (const UnitTypeLhs &amp;lhs, const <a class="el" href="namespaceunits_1_1dimensionless.html#a5d18e4545db54fa93e0ea3aad6449741">dimensionless::dB_t</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aaf4fae6a157a451266ef24407b130715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction between <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values.">decibel_scale</a> and dimensionless dB units.  <br /></td></tr>
<tr class="separator:aaf4fae6a157a451266ef24407b130715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5504674e253531cff43ca8a3dec8f4d2" id="r_a5504674e253531cff43ca8a3dec8f4d2"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeRhs , std::enable_if_t&lt; <a class="el" href="structunits_1_1traits_1_1has__decibel__scale.html">traits::has_decibel_scale</a>&lt; UnitTypeRhs &gt;::value &amp;&amp;!<a class="el" href="structunits_1_1traits_1_1is__dimensionless__unit.html">traits::is_dimensionless_unit</a>&lt; UnitTypeRhs &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5504674e253531cff43ca8a3dec8f4d2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits.html#a5504674e253531cff43ca8a3dec8f4d2">units::operator-</a> (const <a class="el" href="namespaceunits_1_1dimensionless.html#a5d18e4545db54fa93e0ea3aad6449741">dimensionless::dB_t</a> &amp;lhs, const UnitTypeRhs &amp;rhs) noexcept -&gt; <a class="el" href="classunits_1_1unit__t.html">unit_t</a>&lt; <a class="el" href="group___unit_manipulators.html#ga18bb1210c1a6ee41bbb21b32bf18c0f5">inverse</a>&lt; typename units::traits::unit_t_traits&lt; UnitTypeRhs &gt;::unit_type &gt;, typename units::traits::unit_t_traits&lt; UnitTypeRhs &gt;::underlying_type, <a class="el" href="structunits_1_1decibel__scale.html">decibel_scale</a> &gt;</td></tr>
<tr class="memdesc:a5504674e253531cff43ca8a3dec8f4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction between <a class="el" href="classunits_1_1unit__t.html" title="Container for values which represent quantities of a given unit.">unit_t</a> types with a <a class="el" href="structunits_1_1decibel__scale.html" title="unit_t scale for representing decibel values.">decibel_scale</a> and dimensionless dB units.  <br /></td></tr>
<tr class="separator:a5504674e253531cff43ca8a3dec8f4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6e636d718a856a23007a3831df5010" id="r_aed6e636d718a856a23007a3831df5010"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs &gt; </td></tr>
<tr class="memitem:aed6e636d718a856a23007a3831df5010"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1math.html#aed6e636d718a856a23007a3831df5010">units::math::min</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs)</td></tr>
<tr class="separator:aed6e636d718a856a23007a3831df5010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf027925c5f77defb69fc968891d18b" id="r_a3bf027925c5f77defb69fc968891d18b"><td class="memTemplParams" colspan="2">template&lt;class UnitTypeLhs , class UnitTypeRhs &gt; </td></tr>
<tr class="memitem:a3bf027925c5f77defb69fc968891d18b"><td class="memTemplItemLeft" align="right" valign="top">constexpr UnitTypeLhs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1math.html#a3bf027925c5f77defb69fc968891d18b">units::math::max</a> (const UnitTypeLhs &amp;lhs, const UnitTypeRhs &amp;rhs)</td></tr>
<tr class="separator:a3bf027925c5f77defb69fc968891d18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af854617ff2c81618056fe5c43d5da755" id="r_af854617ff2c81618056fe5c43d5da755"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af854617ff2c81618056fe5c43d5da755"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1traits.html#af854617ff2c81618056fe5c43d5da755">units::traits::is_ratio_v</a> = <a class="el" href="structunits_1_1traits_1_1is__ratio.html">is_ratio</a>&lt;T&gt;::value</td></tr>
<tr class="separator:af854617ff2c81618056fe5c43d5da755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacb2c1570fc66b2d9838618e6b06be3" id="r_abacb2c1570fc66b2d9838618e6b06be3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abacb2c1570fc66b2d9838618e6b06be3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1traits.html#abacb2c1570fc66b2d9838618e6b06be3">units::traits::is_unit_v</a> = <a class="el" href="structunits_1_1traits_1_1is__unit.html">is_unit</a>&lt;T&gt;::value</td></tr>
<tr class="separator:abacb2c1570fc66b2d9838618e6b06be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67512190e68b1583ae56ba6bbcdcaa7c" id="r_a67512190e68b1583ae56ba6bbcdcaa7c"><td class="memTemplParams" colspan="2">template&lt;class U1 , class U2 &gt; </td></tr>
<tr class="memitem:a67512190e68b1583ae56ba6bbcdcaa7c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1traits.html#a67512190e68b1583ae56ba6bbcdcaa7c">units::traits::is_convertible_unit_v</a> = <a class="el" href="structunits_1_1traits_1_1is__convertible__unit.html">is_convertible_unit</a>&lt;U1, U2&gt;::value</td></tr>
<tr class="separator:a67512190e68b1583ae56ba6bbcdcaa7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83d29f444a9de60d7f454200e33ffbc" id="r_ac83d29f444a9de60d7f454200e33ffbc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac83d29f444a9de60d7f454200e33ffbc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1traits.html#ac83d29f444a9de60d7f454200e33ffbc">units::traits::is_unit_t_v</a> = <a class="el" href="structunits_1_1traits_1_1is__unit__t.html">is_unit_t</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ac83d29f444a9de60d7f454200e33ffbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679ec0736cd021e6e37ed0f710b5b6d7" id="r_a679ec0736cd021e6e37ed0f710b5b6d7"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a679ec0736cd021e6e37ed0f710b5b6d7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1traits.html#a679ec0736cd021e6e37ed0f710b5b6d7">units::traits::has_linear_scale_v</a> = <a class="el" href="structunits_1_1traits_1_1has__linear__scale.html">has_linear_scale</a>&lt;T...&gt;::value</td></tr>
<tr class="separator:a679ec0736cd021e6e37ed0f710b5b6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548216e183f61c908e6db527be2a7858" id="r_a548216e183f61c908e6db527be2a7858"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a548216e183f61c908e6db527be2a7858"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1traits.html#a548216e183f61c908e6db527be2a7858">units::traits::has_decibel_scale_v</a> = <a class="el" href="structunits_1_1traits_1_1has__decibel__scale.html">has_decibel_scale</a>&lt;T...&gt;::value</td></tr>
<tr class="separator:a548216e183f61c908e6db527be2a7858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1aeb0147750127deaeef7fe452da3f0" id="r_ab1aeb0147750127deaeef7fe452da3f0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ab1aeb0147750127deaeef7fe452da3f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1traits.html#ab1aeb0147750127deaeef7fe452da3f0">units::traits::is_same_scale_v</a> = <a class="el" href="structunits_1_1traits_1_1is__same__scale.html">is_same_scale</a>&lt;T1, T2&gt;::value</td></tr>
<tr class="separator:ab1aeb0147750127deaeef7fe452da3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff46b9ed6f1f6c7580c7b2a44ce801ab" id="r_aff46b9ed6f1f6c7580c7b2a44ce801ab"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Units  = typename traits::unit_value_t_traits&lt;T&gt;::unit_type&gt; </td></tr>
<tr class="memitem:aff46b9ed6f1f6c7580c7b2a44ce801ab"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1traits.html#aff46b9ed6f1f6c7580c7b2a44ce801ab">units::traits::is_unit_value_t_v</a> = <a class="el" href="structunits_1_1traits_1_1is__unit__value__t.html">is_unit_value_t</a>&lt;T, Units&gt;::value</td></tr>
<tr class="separator:aff46b9ed6f1f6c7580c7b2a44ce801ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923c255fea7c6ba3d4e7f191a42e93e8" id="r_a923c255fea7c6ba3d4e7f191a42e93e8"><td class="memTemplParams" colspan="2">template&lt;typename Category , typename T &gt; </td></tr>
<tr class="memitem:a923c255fea7c6ba3d4e7f191a42e93e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceunits_1_1traits.html#a923c255fea7c6ba3d4e7f191a42e93e8">units::traits::is_unit_value_t_category_v</a> = <a class="el" href="structunits_1_1traits_1_1is__unit__value__t__category.html">is_unit_value_t_category</a>&lt;Category, T&gt;::value</td></tr>
<tr class="separator:a923c255fea7c6ba3d4e7f191a42e93e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a39906c4d2537c6d904d8d44ffb6a4dec" name="a39906c4d2537c6d904d8d44ffb6a4dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39906c4d2537c6d904d8d44ffb6a4dec">&#9670;&#160;</a></span>UNIT_ADD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNIT_ADD</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>namespaceName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nameSingular</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>namePlural</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>abbreviation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em></em></span>...&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="#a071fcab8dbde86027d1d552f82a92878">UNIT_ADD_UNIT_TAGS</a>(namespaceName,nameSingular, namePlural, abbreviation, __VA_ARGS__)\</div>
<div class="line">    UNIT_ADD_UNIT_DEFINITION(namespaceName,nameSingular)\</div>
<div class="line">    UNIT_ADD_NAME(namespaceName,nameSingular, abbreviation)\</div>
<div class="line">    UNIT_ADD_IO(namespaceName,nameSingular, abbreviation)\</div>
<div class="line">    UNIT_ADD_LITERALS(namespaceName,nameSingular, abbreviation)</div>
<div class="ttc" id="awpimath_2src_2main_2native_2include_2units_2base_8h_html_a071fcab8dbde86027d1d552f82a92878"><div class="ttname"><a href="#a071fcab8dbde86027d1d552f82a92878">UNIT_ADD_UNIT_TAGS</a></div><div class="ttdeci">#define UNIT_ADD_UNIT_TAGS(namespaceName, nameSingular, namePlural, abbreviation,...)</div><div class="ttdoc">Helper macro for generating the boiler-plate code generating the tags of a new unit.</div><div class="ttdef"><b>Definition</b> base.h:136</div></div>
</div><!-- fragment -->
<p>Macro for generating the boiler-plate code needed for a new unit. </p>
<p>The macro generates singular, plural, and abbreviated forms of the unit definition (e.g. <code>meter</code>, <code>meters</code>, and <code>m</code>), as well as the appropriately named unit container (e.g. <code>meter_t</code>). A literal suffix is created using the abbreviation (e.g. <code>10.0_m</code>). It also defines a class-specific cout function which prints both the value and abbreviation of the unit when invoked. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">namespaceName</td><td>namespace in which the new units will be encapsulated. All literal values are placed in the <code><a class="el" href="namespaceunits_1_1literals.html">units::literals</a></code> namespace. </td></tr>
    <tr><td class="paramname">nameSingular</td><td>singular version of the unit name, e.g. 'meter' </td></tr>
    <tr><td class="paramname">namePlural</td><td>- plural version of the unit name, e.g. 'meters' </td></tr>
    <tr><td class="paramname">abbreviation</td><td>- abbreviated unit name, e.g. 'm' </td></tr>
    <tr><td class="paramname">definition</td><td>- the variadic parameter is used for the definition of the unit (e.g. <code>unit&lt;std::ratio&lt;1&gt;, <a class="el" href="namespaceunits_1_1category.html#a3dede37fafca5ea729d3c4332ebc3901" title="Represents an SI base unit of length.">units::category::length_unit</a>&gt;</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>a variadic template is used for the definition to allow templates with commas to be easily expanded. All the variadic 'arguments' should together comprise the unit definition. </dd></dl>

</div>
</div>
<a id="aa0b0ec340728bbef5aeab07641a61948" name="aa0b0ec340728bbef5aeab07641a61948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b0ec340728bbef5aeab07641a61948">&#9670;&#160;</a></span>UNIT_ADD_CATEGORY_TRAIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNIT_ADD_CATEGORY_TRAIT</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>unitCategory</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="#a67817e30ee1fc0ee3387657684af35a7">UNIT_ADD_CATEGORY_TRAIT_DETAIL</a>(unitCategory)\<span class="comment"></span></div>
<div class="line"><span class="comment">    /** @ingroup    TypeTraits*/</span>\<span class="comment"></span></div>
<div class="line"><span class="comment">    /** @brief      Trait which tests whether a type represents a unit of unitCategory*/</span>\<span class="comment"></span></div>
<div class="line"><span class="comment">    /** @details    Inherits from `std::true_type` or `std::false_type`. Use `is_ ## unitCategory ## _unit&lt;T&gt;::value` to test the unit represents a unitCategory quantity.*/</span>\<span class="comment"></span></div>
<div class="line"><span class="comment">    /** @tparam     T   one or more types to test*/</span>\</div>
<div class="line">    UNIT_ADD_IS_UNIT_CATEGORY_TRAIT(unitCategory)</div>
<div class="ttc" id="awpimath_2src_2main_2native_2include_2units_2base_8h_html_a67817e30ee1fc0ee3387657684af35a7"><div class="ttname"><a href="#a67817e30ee1fc0ee3387657684af35a7">UNIT_ADD_CATEGORY_TRAIT_DETAIL</a></div><div class="ttdeci">#define UNIT_ADD_CATEGORY_TRAIT_DETAIL(unitCategory)</div><div class="ttdef"><b>Definition</b> base.h:349</div></div>
</div><!-- fragment -->
<p>Macro to create the <code>is_category_unit</code> type trait. </p>
<p>This trait allows users to test whether a given type matches an intended category. This macro comprises all the boiler-plate code necessary to do so. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unitCategory</td><td>The name of the category of unit, e.g. length or mass. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67817e30ee1fc0ee3387657684af35a7" name="a67817e30ee1fc0ee3387657684af35a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67817e30ee1fc0ee3387657684af35a7">&#9670;&#160;</a></span>UNIT_ADD_CATEGORY_TRAIT_DETAIL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNIT_ADD_CATEGORY_TRAIT_DETAIL</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>unitCategory</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">namespace </span>traits\</div>
<div class="line">    {\<span class="comment"></span></div>
<div class="line"><span class="comment">        /** @cond */</span>\</div>
<div class="line">        <span class="keyword">namespace </span><a class="code hl_namespace" href="namespacedetail.html">detail</a>\</div>
<div class="line">        {\</div>
<div class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>is_ ## unitCategory ## _unit_impl : std::false_type {};\</div>
<div class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> U, <span class="keyword">typename</span> P, <span class="keyword">typename</span> T&gt;\</div>
<div class="line">            <span class="keyword">struct </span>is_ ## unitCategory ## _unit_impl&lt;<a class="code hl_namespace" href="namespaceunits.html">units</a>::unit&lt;C, U, P, T&gt;&gt; : std::is_same&lt;units::traits::base_unit_of&lt;typename units::traits::unit_traits&lt;units::unit&lt;C, U, P, T&gt;&gt;::base_unit_type&gt;, units::category::unitCategory ## _unit&gt;::type {};\</div>
<div class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> S, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>N&gt;\</div>
<div class="line">            <span class="keyword">struct </span>is_ ## unitCategory ## _unit_impl&lt;<a class="code hl_namespace" href="namespaceunits.html">units</a>::unit_t&lt;U, S, N&gt;&gt; : std::is_same&lt;units::traits::base_unit_of&lt;typename units::traits::unit_t_traits&lt;units::unit_t&lt;U, S, N&gt;&gt;::unit_type&gt;, units::category::unitCategory ## _unit&gt;::type {};\</div>
<div class="line">        }\<span class="comment"></span></div>
<div class="line"><span class="comment">        /** @endcond */</span>\</div>
<div class="line">    }</div>
<div class="ttc" id="anamespacedetail_html"><div class="ttname"><a href="namespacedetail.html">detail</a></div><div class="ttdoc">detail namespace with internal helper functions</div><div class="ttdef"><b>Definition</b> input_adapters.h:32</div></div>
<div class="ttc" id="anamespaceunits_html"><div class="ttname"><a href="namespaceunits.html">units</a></div><div class="ttdoc">Unit Conversion Library namespace.</div><div class="ttdef"><b>Definition</b> acceleration.h:33</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a658d239b68a83cbe1055198bb9aa7823" name="a658d239b68a83cbe1055198bb9aa7823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658d239b68a83cbe1055198bb9aa7823">&#9670;&#160;</a></span>UNIT_ADD_CUSTOM_TYPE_UNIT_DEFINITION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNIT_ADD_CUSTOM_TYPE_UNIT_DEFINITION</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>namespaceName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nameSingular</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>underlyingType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">namespace </span>namespaceName\</div>
<div class="line">    {\<span class="comment"></span></div>
<div class="line"><span class="comment">    /** @name Unit Containers */</span> <span class="comment">/** @{ */</span> <span class="keyword">typedef</span> unit_t&lt;nameSingular,underlyingType&gt; nameSingular ## _t; <span class="comment">/** @} */</span>\</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Macro for generating the boiler-plate code for a unit_t type definition with a non-default underlying type. </p>
<p>The macro generates the definition of the unit container types, e.g. <code>meter_t</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">namespaceName</td><td>namespace in which the new units will be encapsulated. </td></tr>
    <tr><td class="paramname">nameSingular</td><td>singular version of the unit name, e.g. 'meter' </td></tr>
    <tr><td class="paramname">underlyingType</td><td>the underlying type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacbc20cfef3586d1c51b51c998679b99" name="aacbc20cfef3586d1c51b51c998679b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacbc20cfef3586d1c51b51c998679b99">&#9670;&#160;</a></span>UNIT_ADD_DECIBEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNIT_ADD_DECIBEL</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>namespaceName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nameSingular</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>abbreviation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">namespace </span>namespaceName\</div>
<div class="line">    {\<span class="comment"></span></div>
<div class="line"><span class="comment">        /** @name Unit Containers */</span> <span class="comment">/** @{ */</span> <span class="keyword">typedef</span> unit_t&lt;nameSingular, UNIT_LIB_DEFAULT_TYPE, units::decibel_scale&gt; abbreviation ## _t; <span class="comment">/** @} */</span>\</div>
<div class="line">    }\</div>
<div class="line">    UNIT_ADD_IO(namespaceName, abbreviation, abbreviation)\</div>
<div class="line">    UNIT_ADD_LITERALS(namespaceName, abbreviation, abbreviation)</div>
</div><!-- fragment -->
<p>Macro to create decibel container and literals for an existing unit type. </p>
<p>This macro generates the decibel unit container, cout overload, and literal definitions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">namespaceName</td><td>namespace in which the new units will be encapsulated. All literal values are placed in the <code><a class="el" href="namespaceunits_1_1literals.html">units::literals</a></code> namespace. </td></tr>
    <tr><td class="paramname">nameSingular</td><td>singular version of the base unit name, e.g. 'watt' </td></tr>
    <tr><td class="paramname">abbreviation</td><td>- abbreviated decibel unit name, e.g. 'dBW' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b6d926ddfd6f761bb7675984fbf0585" name="a4b6d926ddfd6f761bb7675984fbf0585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6d926ddfd6f761bb7675984fbf0585">&#9670;&#160;</a></span>UNIT_ADD_IO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNIT_ADD_IO</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>namespaceName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nameSingular</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>abbrev</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for generating the boiler-plate code needed for I/O for a new unit. </p>
<p>The macro generates the code to insert units into an ostream. It prints both the value and abbreviation of the unit when invoked. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">namespaceName</td><td>namespace in which the new units will be encapsulated. </td></tr>
    <tr><td class="paramname">nameSingular</td><td>singular version of the unit name, e.g. 'meter' </td></tr>
    <tr><td class="paramname">abbrev</td><td>- abbreviated unit name, e.g. 'm' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When UNIT_LIB_DISABLE_FMT is defined and UNIT_LIB_ENABLE_IOSTREAM isn't defined, the macro does not generate any code </dd></dl>

</div>
</div>
<a id="a4e562029a6c1c7d967ffa531749d0b78" name="a4e562029a6c1c7d967ffa531749d0b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e562029a6c1c7d967ffa531749d0b78">&#9670;&#160;</a></span>UNIT_ADD_IS_UNIT_CATEGORY_TRAIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNIT_ADD_IS_UNIT_CATEGORY_TRAIT</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>unitCategory</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">namespace </span>traits\</div>
<div class="line">    {\</div>
<div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt; <span class="keyword">struct </span>is_ ## unitCategory ## _unit : std::integral_constant&lt;bool, units::all_true&lt;units::traits::detail::is_ ## unitCategory ## _unit_impl&lt;std::decay_t&lt;T&gt;&gt;::value...&gt;::value&gt; {};\</div>
<div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt; <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> is_ ## unitCategory ## _unit_v = is_ ## unitCategory ## _unit&lt;T...&gt;::value;\</div>
<div class="line">    }\</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;\</div>
<div class="line">    <span class="keyword">concept </span>unitCategory ## _unit = traits::is_ ## unitCategory ## _unit_v&lt;T&gt;;</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab6407713545d300de2647fb0348bdb6a" name="ab6407713545d300de2647fb0348bdb6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6407713545d300de2647fb0348bdb6a">&#9670;&#160;</a></span>UNIT_ADD_LITERALS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNIT_ADD_LITERALS</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>namespaceName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nameSingular</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>abbreviation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceliterals.html">literals</a>\</div>
<div class="line">    {\</div>
<div class="line">        <span class="keyword">inline</span> <span class="keyword">constexpr</span> namespaceName::nameSingular ## _t <span class="keyword">operator</span><span class="stringliteral">&quot;&quot;</span>_ ## abbreviation(<span class="keywordtype">long</span> <span class="keywordtype">double</span> d)\</div>
<div class="line">        {\</div>
<div class="line">            <span class="keywordflow">return</span> namespaceName::nameSingular ## _t(<span class="keyword">static_cast&lt;</span>namespaceName::nameSingular ## _t::underlying_type<span class="keyword">&gt;</span>(d));\</div>
<div class="line">        }\</div>
<div class="line">        <span class="keyword">inline</span> <span class="keyword">constexpr</span> namespaceName::nameSingular ## _t <span class="keyword">operator</span><span class="stringliteral">&quot;&quot;</span>_ ## abbreviation (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> d)\</div>
<div class="line">        {\</div>
<div class="line">            <span class="keywordflow">return</span> namespaceName::nameSingular ## _t(<span class="keyword">static_cast&lt;</span>namespaceName::nameSingular ## _t::underlying_type<span class="keyword">&gt;</span>(d));\</div>
<div class="line">        }\</div>
<div class="line">    }</div>
<div class="ttc" id="anamespaceliterals_html"><div class="ttname"><a href="namespaceliterals.html">literals</a></div><div class="ttdef"><b>Definition</b> json.h:5183</div></div>
</div><!-- fragment -->
<p>Macro for generating user-defined literals for units. </p>
<p>The macro generates user-defined literals for units. A literal suffix is created using the abbreviation (e.g. <code>10.0_m</code>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">namespaceName</td><td>namespace in which the new units will be encapsulated. All literal values are placed in the <code><a class="el" href="namespaceunits_1_1literals.html">units::literals</a></code> namespace. </td></tr>
    <tr><td class="paramname">nameSingular</td><td>singular version of the unit name, e.g. 'meter' </td></tr>
    <tr><td class="paramname">abbreviation</td><td>- abbreviated unit name, e.g. 'm' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When UNIT_HAS_LITERAL_SUPPORT is not defined, the macro does not generate any code </dd></dl>

</div>
</div>
<a id="a11aa321ef2296c149291424e5c333a4c" name="a11aa321ef2296c149291424e5c333a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11aa321ef2296c149291424e5c333a4c">&#9670;&#160;</a></span>UNIT_ADD_NAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNIT_ADD_NAME</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>namespaceName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nameSingular</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>abbrev</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* name(<span class="keyword">const</span> namespaceName::nameSingular ## _t&amp;)\</div>
<div class="line">{\</div>
<div class="line">    <span class="keywordflow">return</span> #nameSingular;\</div>
<div class="line">}\</div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* abbreviation(<span class="keyword">const</span> namespaceName::nameSingular ## _t&amp;)\</div>
<div class="line">{\</div>
<div class="line">    <span class="keywordflow">return</span> #abbrev;\</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Macro for generating constexpr names/abbreviations for units. </p>
<p>The macro generates names for units. E.g. name() of 1_m would be "meter", and abbreviation would be "m". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">namespaceName</td><td>namespace in which the new units will be encapsulated. All literal values are placed in the <code><a class="el" href="namespaceunits_1_1literals.html">units::literals</a></code> namespace. </td></tr>
    <tr><td class="paramname">nameSingular</td><td>singular version of the unit name, e.g. 'meter' </td></tr>
    <tr><td class="paramname">abbreviation</td><td>- abbreviated unit name, e.g. 'm' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6a54533ebcadd9146a608a5856a052f" name="aa6a54533ebcadd9146a608a5856a052f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a54533ebcadd9146a608a5856a052f">&#9670;&#160;</a></span>UNIT_ADD_UNIT_DEFINITION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNIT_ADD_UNIT_DEFINITION</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>namespaceName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nameSingular</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">namespace </span>namespaceName\</div>
<div class="line">    {\<span class="comment"></span></div>
<div class="line"><span class="comment">        /** @name Unit Containers */</span> <span class="comment">/** @{ */</span> <span class="keyword">typedef</span> unit_t&lt;nameSingular&gt; nameSingular ## _t; <span class="comment">/** @} */</span>\</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Macro for generating the boiler-plate code for the unit_t type definition. </p>
<p>The macro generates the definition of the unit container types, e.g. <code>meter_t</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">namespaceName</td><td>namespace in which the new units will be encapsulated. </td></tr>
    <tr><td class="paramname">nameSingular</td><td>singular version of the unit name, e.g. 'meter' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a071fcab8dbde86027d1d552f82a92878" name="a071fcab8dbde86027d1d552f82a92878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a071fcab8dbde86027d1d552f82a92878">&#9670;&#160;</a></span>UNIT_ADD_UNIT_TAGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNIT_ADD_UNIT_TAGS</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>namespaceName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nameSingular</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>namePlural</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>abbreviation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em></em></span>...&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">namespace </span>namespaceName\</div>
<div class="line">    {\<span class="comment"></span></div>
<div class="line"><span class="comment">    /** @name Units (full names plural) */</span> <span class="comment">/** @{ */</span> <span class="keyword">typedef</span> __VA_ARGS__ namePlural; <span class="comment">/** @} */</span>\<span class="comment"></span></div>
<div class="line"><span class="comment">    /** @name Units (full names singular) */</span> <span class="comment">/** @{ */</span> <span class="keyword">typedef</span> namePlural nameSingular; <span class="comment">/** @} */</span>\<span class="comment"></span></div>
<div class="line"><span class="comment">    /** @name Units (abbreviated) */</span> <span class="comment">/** @{ */</span> <span class="keyword">typedef</span> namePlural abbreviation; <span class="comment">/** @} */</span>\</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Helper macro for generating the boiler-plate code generating the tags of a new unit. </p>
<p>The macro generates singular, plural, and abbreviated forms of the unit definition (e.g. <code>meter</code>, <code>meters</code>, and <code>m</code>), as aliases for the unit tag. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">namespaceName</td><td>namespace in which the new units will be encapsulated. </td></tr>
    <tr><td class="paramname">nameSingular</td><td>singular version of the unit name, e.g. 'meter' </td></tr>
    <tr><td class="paramname">namePlural</td><td>- plural version of the unit name, e.g. 'meters' </td></tr>
    <tr><td class="paramname">abbreviation</td><td>- abbreviated unit name, e.g. 'm' </td></tr>
    <tr><td class="paramname">definition</td><td>- the variadic parameter is used for the definition of the unit (e.g. <code>unit&lt;std::ratio&lt;1&gt;, <a class="el" href="namespaceunits_1_1category.html#a3dede37fafca5ea729d3c4332ebc3901" title="Represents an SI base unit of length.">units::category::length_unit</a>&gt;</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>a variadic template is used for the definition to allow templates with commas to be easily expanded. All the variadic 'arguments' should together comprise the unit definition. </dd></dl>

</div>
</div>
<a id="acb409344e80b38f8ab8d1dc72a599623" name="acb409344e80b38f8ab8d1dc72a599623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb409344e80b38f8ab8d1dc72a599623">&#9670;&#160;</a></span>UNIT_ADD_WITH_CUSTOM_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNIT_ADD_WITH_CUSTOM_TYPE</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>namespaceName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nameSingular</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>namePlural</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>abbreviation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>underlyingType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em></em></span>...&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="#a071fcab8dbde86027d1d552f82a92878">UNIT_ADD_UNIT_TAGS</a>(namespaceName,nameSingular, namePlural, abbreviation, __VA_ARGS__)\</div>
<div class="line">    UNIT_ADD_CUSTOM_TYPE_UNIT_DEFINITION(namespaceName,nameSingular,underlyingType)\</div>
<div class="line">    UNIT_ADD_IO(namespaceName,nameSingular, abbreviation)\</div>
<div class="line">    UNIT_ADD_LITERALS(namespaceName,nameSingular, abbreviation)</div>
</div><!-- fragment -->
<p>Macro for generating the boiler-plate code needed for a new unit with a non-default underlying type. </p>
<p>The macro generates singular, plural, and abbreviated forms of the unit definition (e.g. <code>meter</code>, <code>meters</code>, and <code>m</code>), as well as the appropriately named unit container (e.g. <code>meter_t</code>). A literal suffix is created using the abbreviation (e.g. <code>10.0_m</code>). It also defines a class-specific cout function which prints both the value and abbreviation of the unit when invoked. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">namespaceName</td><td>namespace in which the new units will be encapsulated. All literal values are placed in the <code><a class="el" href="namespaceunits_1_1literals.html">units::literals</a></code> namespace. </td></tr>
    <tr><td class="paramname">nameSingular</td><td>singular version of the unit name, e.g. 'meter' </td></tr>
    <tr><td class="paramname">namePlural</td><td>- plural version of the unit name, e.g. 'meters' </td></tr>
    <tr><td class="paramname">abbreviation</td><td>- abbreviated unit name, e.g. 'm' </td></tr>
    <tr><td class="paramname">underlyingType</td><td>- the underlying type, e.g. 'int' or 'float' </td></tr>
    <tr><td class="paramname">definition</td><td>- the variadic parameter is used for the definition of the unit (e.g. <code>unit&lt;std::ratio&lt;1&gt;, <a class="el" href="namespaceunits_1_1category.html#a3dede37fafca5ea729d3c4332ebc3901" title="Represents an SI base unit of length.">units::category::length_unit</a>&gt;</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>a variadic template is used for the definition to allow templates with commas to be easily expanded. All the variadic 'arguments' should together comprise the unit definition. </dd></dl>

</div>
</div>
<a id="a9cdd64f7a2185396fdc1f618a1b4a123" name="a9cdd64f7a2185396fdc1f618a1b4a123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdd64f7a2185396fdc1f618a1b4a123">&#9670;&#160;</a></span>UNIT_ADD_WITH_METRIC_AND_BINARY_PREFIXES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNIT_ADD_WITH_METRIC_AND_BINARY_PREFIXES</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>namespaceName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nameSingular</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>namePlural</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>abbreviation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em></em></span>...&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="#afefa09c81bf9352744e7e31164a07d2e">UNIT_ADD_WITH_METRIC_PREFIXES</a>(namespaceName, nameSingular, namePlural, abbreviation, __VA_ARGS__)\</div>
<div class="line">    UNIT_ADD(namespaceName, kibi ## nameSingular, kibi ## namePlural, Ki ## abbreviation, kibi&lt;namePlural&gt;)\</div>
<div class="line">    UNIT_ADD(namespaceName, mebi ## nameSingular, mebi ## namePlural, Mi ## abbreviation, mebi&lt;namePlural&gt;)\</div>
<div class="line">    UNIT_ADD(namespaceName, gibi ## nameSingular, gibi ## namePlural, Gi ## abbreviation, gibi&lt;namePlural&gt;)\</div>
<div class="line">    UNIT_ADD(namespaceName, tebi ## nameSingular, tebi ## namePlural, Ti ## abbreviation, tebi&lt;namePlural&gt;)\</div>
<div class="line">    UNIT_ADD(namespaceName, pebi ## nameSingular, pebi ## namePlural, Pi ## abbreviation, pebi&lt;namePlural&gt;)\</div>
<div class="line">    UNIT_ADD(namespaceName, exbi ## nameSingular, exbi ## namePlural, Ei ## abbreviation, exbi&lt;namePlural&gt;)</div>
<div class="ttc" id="awpimath_2src_2main_2native_2include_2units_2base_8h_html_afefa09c81bf9352744e7e31164a07d2e"><div class="ttname"><a href="#afefa09c81bf9352744e7e31164a07d2e">UNIT_ADD_WITH_METRIC_PREFIXES</a></div><div class="ttdeci">#define UNIT_ADD_WITH_METRIC_PREFIXES(namespaceName, nameSingular, namePlural, abbreviation,...)</div><div class="ttdoc">Macro for generating the boiler-plate code needed for a new unit, including its metric prefixes from ...</div><div class="ttdef"><b>Definition</b> base.h:399</div></div>
</div><!-- fragment -->
<p>Macro for generating the boiler-plate code needed for a new unit, including its metric prefixes from femto to peta, and binary prefixes from kibi to exbi. </p>
<p>See UNIT_ADD. In addition to generating the unit definition and containers '(e.g. <code>bytes</code> and 'byte_t', it also creates corresponding units with metric suffixes such as <code>millimeters</code>, and <code>millimeter_t</code>), as well as the literal suffixes (e.g. <code>10.0_B</code>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">namespaceName</td><td>namespace in which the new units will be encapsulated. All literal values are placed in the <code><a class="el" href="namespaceunits_1_1literals.html">units::literals</a></code> namespace. </td></tr>
    <tr><td class="paramname">nameSingular</td><td>singular version of the unit name, e.g. 'byte' </td></tr>
    <tr><td class="paramname">namePlural</td><td>- plural version of the unit name, e.g. 'bytes' </td></tr>
    <tr><td class="paramname">abbreviation</td><td>- abbreviated unit name, e.g. 'B' </td></tr>
    <tr><td class="paramname">definition</td><td>- the variadic parameter is used for the definition of the unit (e.g. <code>unit&lt;std::ratio&lt;1&gt;, <a class="el" href="namespaceunits_1_1category.html#a5daae6818590f1cb7cb00f802a45688a" title="Represents a unit of data size.">units::category::data_unit</a>&gt;</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>a variadic template is used for the definition to allow templates with commas to be easily expanded. All the variadic 'arguments' should together comprise the unit definition. </dd></dl>

</div>
</div>
<a id="afefa09c81bf9352744e7e31164a07d2e" name="afefa09c81bf9352744e7e31164a07d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afefa09c81bf9352744e7e31164a07d2e">&#9670;&#160;</a></span>UNIT_ADD_WITH_METRIC_PREFIXES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNIT_ADD_WITH_METRIC_PREFIXES</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>namespaceName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>nameSingular</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>namePlural</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>abbreviation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em></em></span>...&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="#a39906c4d2537c6d904d8d44ffb6a4dec">UNIT_ADD</a>(namespaceName, nameSingular, namePlural, abbreviation, __VA_ARGS__)\</div>
<div class="line">    UNIT_ADD(namespaceName, femto ## nameSingular, femto ## namePlural, f ## abbreviation, femto&lt;namePlural&gt;)\</div>
<div class="line">    UNIT_ADD(namespaceName, pico ## nameSingular, pico ## namePlural, p ## abbreviation, pico&lt;namePlural&gt;)\</div>
<div class="line">    UNIT_ADD(namespaceName, nano ## nameSingular, nano ## namePlural, n ## abbreviation, nano&lt;namePlural&gt;)\</div>
<div class="line">    UNIT_ADD(namespaceName, micro ## nameSingular, micro ## namePlural, u ## abbreviation, micro&lt;namePlural&gt;)\</div>
<div class="line">    UNIT_ADD(namespaceName, milli ## nameSingular, milli ## namePlural, m ## abbreviation, milli&lt;namePlural&gt;)\</div>
<div class="line">    UNIT_ADD(namespaceName, centi ## nameSingular, centi ## namePlural, c ## abbreviation, centi&lt;namePlural&gt;)\</div>
<div class="line">    UNIT_ADD(namespaceName, deci ## nameSingular, deci ## namePlural, d ## abbreviation, deci&lt;namePlural&gt;)\</div>
<div class="line">    UNIT_ADD(namespaceName, deca ## nameSingular, deca ## namePlural, da ## abbreviation, deca&lt;namePlural&gt;)\</div>
<div class="line">    UNIT_ADD(namespaceName, hecto ## nameSingular, hecto ## namePlural, h ## abbreviation, hecto&lt;namePlural&gt;)\</div>
<div class="line">    UNIT_ADD(namespaceName, kilo ## nameSingular, kilo ## namePlural, k ## abbreviation, kilo&lt;namePlural&gt;)\</div>
<div class="line">    UNIT_ADD(namespaceName, mega ## nameSingular, mega ## namePlural, M ## abbreviation, mega&lt;namePlural&gt;)\</div>
<div class="line">    UNIT_ADD(namespaceName, giga ## nameSingular, giga ## namePlural, G ## abbreviation, giga&lt;namePlural&gt;)\</div>
<div class="line">    UNIT_ADD(namespaceName, tera ## nameSingular, tera ## namePlural, T ## abbreviation, tera&lt;namePlural&gt;)\</div>
<div class="line">    UNIT_ADD(namespaceName, peta ## nameSingular, peta ## namePlural, P ## abbreviation, peta&lt;namePlural&gt;)\</div>
<div class="ttc" id="awpimath_2src_2main_2native_2include_2units_2base_8h_html_a39906c4d2537c6d904d8d44ffb6a4dec"><div class="ttname"><a href="#a39906c4d2537c6d904d8d44ffb6a4dec">UNIT_ADD</a></div><div class="ttdeci">#define UNIT_ADD(namespaceName, nameSingular, namePlural, abbreviation,...)</div><div class="ttdoc">Macro for generating the boiler-plate code needed for a new unit.</div><div class="ttdef"><b>Definition</b> base.h:290</div></div>
</div><!-- fragment -->
<p>Macro for generating the boiler-plate code needed for a new unit, including its metric prefixes from femto to peta. </p>
<p>See UNIT_ADD. In addition to generating the unit definition and containers '(e.g. <code>meters</code> and 'meter_t', it also creates corresponding units with metric suffixes such as <code>millimeters</code>, and <code>millimeter_t</code>), as well as the literal suffixes (e.g. <code>10.0_mm</code>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">namespaceName</td><td>namespace in which the new units will be encapsulated. All literal values are placed in the <code><a class="el" href="namespaceunits_1_1literals.html">units::literals</a></code> namespace. </td></tr>
    <tr><td class="paramname">nameSingular</td><td>singular version of the unit name, e.g. 'meter' </td></tr>
    <tr><td class="paramname">namePlural</td><td>- plural version of the unit name, e.g. 'meters' </td></tr>
    <tr><td class="paramname">abbreviation</td><td>- abbreviated unit name, e.g. 'm' </td></tr>
    <tr><td class="paramname">definition</td><td>- the variadic parameter is used for the definition of the unit (e.g. <code>unit&lt;std::ratio&lt;1&gt;, <a class="el" href="namespaceunits_1_1category.html#a3dede37fafca5ea729d3c4332ebc3901" title="Represents an SI base unit of length.">units::category::length_unit</a>&gt;</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>a variadic template is used for the definition to allow templates with commas to be easily expanded. All the variadic 'arguments' should together comprise the unit definition. </dd></dl>

</div>
</div>
<a id="a2b37cc2044d4441105347aa832d0ca2d" name="a2b37cc2044d4441105347aa832d0ca2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b37cc2044d4441105347aa832d0ca2d">&#9670;&#160;</a></span>UNIT_HAS_LITERAL_SUPPORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNIT_HAS_LITERAL_SUPPORT</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a071362944b1accb86d71518ab9613412" name="a071362944b1accb86d71518ab9613412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a071362944b1accb86d71518ab9613412">&#9670;&#160;</a></span>UNIT_LIB_DEFAULT_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNIT_LIB_DEFAULT_TYPE&#160;&#160;&#160;double</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_8398b3b11a49d1b73baf320477e5bcca.html">units</a></li><li class="navelem"><a class="el" href="wpimath_2src_2main_2native_2include_2units_2base_8h.html">base.h</a></li>
    <li class="footer">Generated on Sun Oct 13 2024 07:18:59 for WPILibC++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
