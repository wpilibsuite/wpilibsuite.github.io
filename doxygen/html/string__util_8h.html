<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: /home/runner/work/allwpilib/allwpilib/apriltag/src/main/native/thirdparty/apriltag/include/common/string_util.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="wpilib-128.png"/></td>
  <td id="projectalign">
   <div id="projectname">WPILibC++<span id="projectnumber">&#160;2025.1.1-beta-1-35-g9a5f73d</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('string__util_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">string_util.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;ctype.h&gt;</code><br />
<code>#include &quot;<a class="el" href="zarray_8h_source.html">zarray.h</a>&quot;</code><br />
</div>
<p><a href="string__util_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstring__feeder.html">string_feeder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a83d9958ff260a9111db7b6b7d74c92db" id="r_a83d9958ff260a9111db7b6b7d74c92db"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83d9958ff260a9111db7b6b7d74c92db">str_concat</a>(...)</td></tr>
<tr class="memdesc:a83d9958ff260a9111db7b6b7d74c92db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates 1 or more strings together and returns the result, which will be a newly allocated string which it is the caller's responsibility to free.  <br /></td></tr>
<tr class="separator:a83d9958ff260a9111db7b6b7d74c92db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac8b132ce2a66299a01dcebad2cc59309" id="r_ac8b132ce2a66299a01dcebad2cc59309"><td class="memItemLeft" align="right" valign="top">typedef struct string_buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8b132ce2a66299a01dcebad2cc59309">string_buffer_t</a></td></tr>
<tr class="separator:ac8b132ce2a66299a01dcebad2cc59309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe73f42beb7fd799c2c93d0fdf3d19c6" id="r_afe73f42beb7fd799c2c93d0fdf3d19c6"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structstring__feeder.html">string_feeder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a></td></tr>
<tr class="separator:afe73f42beb7fd799c2c93d0fdf3d19c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a96927ba6ccdf0f501f5a8b3d6acbd02c" id="r_a96927ba6ccdf0f501f5a8b3d6acbd02c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96927ba6ccdf0f501f5a8b3d6acbd02c">sprintf_alloc</a> (const char *fmt,...) __attribute__((<a class="el" href="format_8h.html#a040af707f7f42f401696d0e7263d07cf">format</a>(<a class="el" href="printf_8h.html#aee3ed3a831f25f07e7be3919fff2203a">printf</a></td></tr>
<tr class="memdesc:a96927ba6ccdf0f501f5a8b3d6acbd02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="printf_8h.html#aa7d2e7e454d3fe606a71504a119dc894" title="Formats args according to specifications in fmt and returns the result as as string.">sprintf()</a>, except that it will malloc() enough space for the formatted string which it returns.  <br /></td></tr>
<tr class="separator:a96927ba6ccdf0f501f5a8b3d6acbd02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9b9e6c113d46c1f108afb7d4e5dd58" id="r_a4a9b9e6c113d46c1f108afb7d4e5dd58"><td class="memItemLeft" align="right" valign="top">char char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a9b9e6c113d46c1f108afb7d4e5dd58">vsprintf_alloc</a> (const char *fmt, va_list args)</td></tr>
<tr class="memdesc:a4a9b9e6c113d46c1f108afb7d4e5dd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="printf_8h.html#a5e1075a6c1fce5050424f97a2fac648f">vsprintf()</a>, except that it will malloc() enough space for the formatted string which it returns.  <br /></td></tr>
<tr class="separator:a4a9b9e6c113d46c1f108afb7d4e5dd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389b8b7076ba98f44b92ea387ff44476" id="r_a389b8b7076ba98f44b92ea387ff44476"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a389b8b7076ba98f44b92ea387ff44476">_str_concat_private</a> (const char *first,...)</td></tr>
<tr class="separator:a389b8b7076ba98f44b92ea387ff44476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4085d76639a0fd02ce74f449432a8d37" id="r_a4085d76639a0fd02ce74f449432a8d37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4085d76639a0fd02ce74f449432a8d37">str_diff_idx</a> (const char *a, const char *b)</td></tr>
<tr class="separator:a4085d76639a0fd02ce74f449432a8d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553b61c2fa0c3484c57e66927023d810" id="r_a553b61c2fa0c3484c57e66927023d810"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zarray_8h.html#af429d8225958865fc14ea0ddcc7c0b06">zarray_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a553b61c2fa0c3484c57e66927023d810">str_split</a> (const char *str, const char *delim)</td></tr>
<tr class="memdesc:a553b61c2fa0c3484c57e66927023d810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the supplied string into an array of strings by subdividing it at each occurrence of the supplied delimiter string.  <br /></td></tr>
<tr class="separator:a553b61c2fa0c3484c57e66927023d810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70cb3d06c9e18d543c42dfda87bb033" id="r_ad70cb3d06c9e18d543c42dfda87bb033"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zarray_8h.html#af429d8225958865fc14ea0ddcc7c0b06">zarray_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad70cb3d06c9e18d543c42dfda87bb033">str_split_spaces</a> (const char *str)</td></tr>
<tr class="separator:ad70cb3d06c9e18d543c42dfda87bb033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c2c528e3f4795cd1ed7f40105b1907" id="r_a42c2c528e3f4795cd1ed7f40105b1907"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42c2c528e3f4795cd1ed7f40105b1907">str_split_destroy</a> (<a class="el" href="zarray_8h.html#af429d8225958865fc14ea0ddcc7c0b06">zarray_t</a> *s)</td></tr>
<tr class="separator:a42c2c528e3f4795cd1ed7f40105b1907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0082971520dd192cba6c8e67b0d1f111" id="r_a0082971520dd192cba6c8e67b0d1f111"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0082971520dd192cba6c8e67b0d1f111">streq</a> (const char *str1, const char *str2)</td></tr>
<tr class="separator:a0082971520dd192cba6c8e67b0d1f111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa256111b35267eccce5fb88e9fe1e9" id="r_adfa256111b35267eccce5fb88e9fe1e9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfa256111b35267eccce5fb88e9fe1e9">strcaseeq</a> (const char *str1, const char *str2)</td></tr>
<tr class="memdesc:adfa256111b35267eccce5fb88e9fe1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if str1 exactly matches str2, ignoring case (more efficient than strcasecmp(...) == 0)  <br /></td></tr>
<tr class="separator:adfa256111b35267eccce5fb88e9fe1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4016701bd5241b39f95cd3c69b706fbc" id="r_a4016701bd5241b39f95cd3c69b706fbc"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4016701bd5241b39f95cd3c69b706fbc">str_trim</a> (char *str)</td></tr>
<tr class="memdesc:a4016701bd5241b39f95cd3c69b706fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims whitespace characters (i.e.  <br /></td></tr>
<tr class="separator:a4016701bd5241b39f95cd3c69b706fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a25da24f5203ed578c9531bc31735e" id="r_a34a25da24f5203ed578c9531bc31735e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34a25da24f5203ed578c9531bc31735e">str_lstrip</a> (char *str)</td></tr>
<tr class="memdesc:a34a25da24f5203ed578c9531bc31735e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims whitespace characters (i.e.  <br /></td></tr>
<tr class="separator:a34a25da24f5203ed578c9531bc31735e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14559074f80c32a036733f8ea00d485" id="r_aa14559074f80c32a036733f8ea00d485"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa14559074f80c32a036733f8ea00d485">str_rstrip</a> (char *str)</td></tr>
<tr class="memdesc:aa14559074f80c32a036733f8ea00d485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims whitespace characters (i.e.  <br /></td></tr>
<tr class="separator:aa14559074f80c32a036733f8ea00d485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4dc7eb21ccb69aaa29a277b4c55f3d6" id="r_ac4dc7eb21ccb69aaa29a277b4c55f3d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4dc7eb21ccb69aaa29a277b4c55f3d6">str_ends_with</a> (const char *haystack, const char *needle)</td></tr>
<tr class="memdesc:ac4dc7eb21ccb69aaa29a277b4c55f3d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the end of string 'haystack' matches 'needle', else false.  <br /></td></tr>
<tr class="separator:ac4dc7eb21ccb69aaa29a277b4c55f3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a76a05527a7efb8bfc37e96eeee95f" id="r_ac9a76a05527a7efb8bfc37e96eeee95f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9a76a05527a7efb8bfc37e96eeee95f">str_starts_with</a> (const char *haystack, const char *needle)</td></tr>
<tr class="memdesc:ac9a76a05527a7efb8bfc37e96eeee95f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the start of string 'haystack' matches 'needle', else false.  <br /></td></tr>
<tr class="separator:ac9a76a05527a7efb8bfc37e96eeee95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6dbe2fe9c113587f57106adf9a5d4c2" id="r_ad6dbe2fe9c113587f57106adf9a5d4c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6dbe2fe9c113587f57106adf9a5d4c2">str_starts_with_any</a> (const char *haystack, const char **needles, int num_needles)</td></tr>
<tr class="memdesc:ad6dbe2fe9c113587f57106adf9a5d4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the start of string 'haystack' matches any needle, else false.  <br /></td></tr>
<tr class="separator:ad6dbe2fe9c113587f57106adf9a5d4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6defe7bca38fcfe8e704fe15fc0f10" id="r_a5b6defe7bca38fcfe8e704fe15fc0f10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b6defe7bca38fcfe8e704fe15fc0f10">str_matches_any</a> (const char *haystack, const char **needles, int num_needles)</td></tr>
<tr class="memdesc:a5b6defe7bca38fcfe8e704fe15fc0f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the string 'haystack' matches any needle, else false.  <br /></td></tr>
<tr class="separator:a5b6defe7bca38fcfe8e704fe15fc0f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361b625259415c25ac6d51d95aa747bd" id="r_a361b625259415c25ac6d51d95aa747bd"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a361b625259415c25ac6d51d95aa747bd">str_substring</a> (const char *str, size_t startidx, size_t endidx)</td></tr>
<tr class="memdesc:a361b625259415c25ac6d51d95aa747bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a (newly-allocated) substring of the given string, 'str', starting from character index 'startidx' through index 'endidx' - 1 (inclusive).  <br /></td></tr>
<tr class="separator:a361b625259415c25ac6d51d95aa747bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f092c57e761ee049df00ea1e0b3e88e" id="r_a6f092c57e761ee049df00ea1e0b3e88e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f092c57e761ee049df00ea1e0b3e88e">str_indexof</a> (const char *haystack, const char *needle)</td></tr>
<tr class="memdesc:a6f092c57e761ee049df00ea1e0b3e88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the zero-based index of the beginning of the supplied substring (needle) within the search string (haystack) if it exists.  <br /></td></tr>
<tr class="separator:a6f092c57e761ee049df00ea1e0b3e88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4332ab4b30afc8a6b4ad6e87d7b7aa11" id="r_a4332ab4b30afc8a6b4ad6e87d7b7aa11"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4332ab4b30afc8a6b4ad6e87d7b7aa11">str_contains</a> (const char *haystack, const char *needle)</td></tr>
<tr class="separator:a4332ab4b30afc8a6b4ad6e87d7b7aa11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59843771adaac01abe117fae0c6f6bb7" id="r_a59843771adaac01abe117fae0c6f6bb7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59843771adaac01abe117fae0c6f6bb7">str_last_indexof</a> (const char *haystack, const char *needle)</td></tr>
<tr class="separator:a59843771adaac01abe117fae0c6f6bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3bd192ba2530593148b8e8f5d8ad74" id="r_a2c3bd192ba2530593148b8e8f5d8ad74"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c3bd192ba2530593148b8e8f5d8ad74">str_tolowercase</a> (char *s)</td></tr>
<tr class="memdesc:a2c3bd192ba2530593148b8e8f5d8ad74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all upper-case characters within the supplied string with their lower-case counterparts, modifying the original string's contents.  <br /></td></tr>
<tr class="separator:a2c3bd192ba2530593148b8e8f5d8ad74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4e25b614d67cdf531155ecfbf906aa" id="r_a8b4e25b614d67cdf531155ecfbf906aa"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b4e25b614d67cdf531155ecfbf906aa">str_touppercase</a> (char *s)</td></tr>
<tr class="memdesc:a8b4e25b614d67cdf531155ecfbf906aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all lower-case characters within the supplied string with their upper-case counterparts, modifying the original string's contents.  <br /></td></tr>
<tr class="separator:a8b4e25b614d67cdf531155ecfbf906aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f0d7eca7cfffb54c41a103f6d76139" id="r_a72f0d7eca7cfffb54c41a103f6d76139"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72f0d7eca7cfffb54c41a103f6d76139">str_replace</a> (const char *haystack, const char *needle, const char *replacement)</td></tr>
<tr class="memdesc:a72f0d7eca7cfffb54c41a103f6d76139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of 'needle' in the string 'haystack', substituting for them the value of 'replacement', and returns the result as a newly-allocated string.  <br /></td></tr>
<tr class="separator:a72f0d7eca7cfffb54c41a103f6d76139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9444ba9a777ca56b07dd28203fdb10" id="r_a6e9444ba9a777ca56b07dd28203fdb10"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e9444ba9a777ca56b07dd28203fdb10">str_replace_many</a> (const char *_haystack,...)</td></tr>
<tr class="separator:a6e9444ba9a777ca56b07dd28203fdb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f330c814ee6f5f2bcb2f5ad3786cc89" id="r_a3f330c814ee6f5f2bcb2f5ad3786cc89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac8b132ce2a66299a01dcebad2cc59309">string_buffer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f330c814ee6f5f2bcb2f5ad3786cc89">string_buffer_create</a> (void)</td></tr>
<tr class="memdesc:a3f330c814ee6f5f2bcb2f5ad3786cc89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a string buffer object which can be used with any of the string_buffer_*() functions.  <br /></td></tr>
<tr class="separator:a3f330c814ee6f5f2bcb2f5ad3786cc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0418b0d5c1d6396e33b8e7d9b8fa54" id="r_a0a0418b0d5c1d6396e33b8e7d9b8fa54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a0418b0d5c1d6396e33b8e7d9b8fa54">string_buffer_destroy</a> (<a class="el" href="#ac8b132ce2a66299a01dcebad2cc59309">string_buffer_t</a> *sb)</td></tr>
<tr class="memdesc:a0a0418b0d5c1d6396e33b8e7d9b8fa54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the resources associated with a string buffer object, including space allocated for any appended characters / strings.  <br /></td></tr>
<tr class="separator:a0a0418b0d5c1d6396e33b8e7d9b8fa54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f53cad9a87feaa9c9f6c9b63af20e11" id="r_a2f53cad9a87feaa9c9f6c9b63af20e11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f53cad9a87feaa9c9f6c9b63af20e11">string_buffer_append</a> (<a class="el" href="#ac8b132ce2a66299a01dcebad2cc59309">string_buffer_t</a> *sb, char c)</td></tr>
<tr class="memdesc:a2f53cad9a87feaa9c9f6c9b63af20e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a single character to the end of the supplied string buffer.  <br /></td></tr>
<tr class="separator:a2f53cad9a87feaa9c9f6c9b63af20e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13edc9bfa7666cba79f28ededc7ec39e" id="r_a13edc9bfa7666cba79f28ededc7ec39e"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13edc9bfa7666cba79f28ededc7ec39e">string_buffer_pop_back</a> (<a class="el" href="#ac8b132ce2a66299a01dcebad2cc59309">string_buffer_t</a> *sb)</td></tr>
<tr class="memdesc:a13edc9bfa7666cba79f28ededc7ec39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a single character from the end of the string and returns it.  <br /></td></tr>
<tr class="separator:a13edc9bfa7666cba79f28ededc7ec39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bec654f83373c26ad828a41bb623d32" id="r_a9bec654f83373c26ad828a41bb623d32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bec654f83373c26ad828a41bb623d32">string_buffer_append_string</a> (<a class="el" href="#ac8b132ce2a66299a01dcebad2cc59309">string_buffer_t</a> *sb, const char *str)</td></tr>
<tr class="memdesc:a9bec654f83373c26ad828a41bb623d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the supplied string to the end of the supplied string buffer.  <br /></td></tr>
<tr class="separator:a9bec654f83373c26ad828a41bb623d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85a4fb78195378be29a562e0a9e6b31" id="r_ab85a4fb78195378be29a562e0a9e6b31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab85a4fb78195378be29a562e0a9e6b31">string_buffer_appendf</a> (<a class="el" href="#ac8b132ce2a66299a01dcebad2cc59309">string_buffer_t</a> *sb, const char *fmt,...) __attribute__((<a class="el" href="format_8h.html#a040af707f7f42f401696d0e7263d07cf">format</a>(<a class="el" href="printf_8h.html#aee3ed3a831f25f07e7be3919fff2203a">printf</a></td></tr>
<tr class="memdesc:ab85a4fb78195378be29a562e0a9e6b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats the supplied string and arguments in a manner akin to <a class="el" href="printf_8h.html#aee3ed3a831f25f07e7be3919fff2203a" title="Formats args according to specifications in fmt and writes the output to stdout.">printf()</a>, and appends the resulting string to the end of the supplied string buffer.  <br /></td></tr>
<tr class="separator:ab85a4fb78195378be29a562e0a9e6b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3f33cfbab8c5659473768bd7483ea7" id="r_a9d3f33cfbab8c5659473768bd7483ea7"><td class="memItemLeft" align="right" valign="top">void bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d3f33cfbab8c5659473768bd7483ea7">string_buffer_ends_with</a> (<a class="el" href="#ac8b132ce2a66299a01dcebad2cc59309">string_buffer_t</a> *sb, const char *str)</td></tr>
<tr class="memdesc:a9d3f33cfbab8c5659473768bd7483ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the character contents held by the supplied string buffer ends with the supplied string.  <br /></td></tr>
<tr class="separator:a9d3f33cfbab8c5659473768bd7483ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1212d3276a3a334ff6874cbd8b915fa" id="r_ad1212d3276a3a334ff6874cbd8b915fa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1212d3276a3a334ff6874cbd8b915fa">string_buffer_size</a> (<a class="el" href="#ac8b132ce2a66299a01dcebad2cc59309">string_buffer_t</a> *sb)</td></tr>
<tr class="memdesc:ad1212d3276a3a334ff6874cbd8b915fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string-length of the contents of the string buffer (not counting \0).  <br /></td></tr>
<tr class="separator:ad1212d3276a3a334ff6874cbd8b915fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc12b6172d009e605c279a7a928322d" id="r_afbc12b6172d009e605c279a7a928322d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbc12b6172d009e605c279a7a928322d">string_buffer_to_string</a> (<a class="el" href="#ac8b132ce2a66299a01dcebad2cc59309">string_buffer_t</a> *sb)</td></tr>
<tr class="memdesc:afbc12b6172d009e605c279a7a928322d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contents of the string buffer in a newly-allocated string, which it is the caller's responsibility to free once it is no longer needed.  <br /></td></tr>
<tr class="separator:afbc12b6172d009e605c279a7a928322d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b99afd18946fe6687642eb9b2e0e81" id="r_a37b99afd18946fe6687642eb9b2e0e81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37b99afd18946fe6687642eb9b2e0e81">string_buffer_reset</a> (<a class="el" href="#ac8b132ce2a66299a01dcebad2cc59309">string_buffer_t</a> *sb)</td></tr>
<tr class="memdesc:a37b99afd18946fe6687642eb9b2e0e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the contents of the string buffer, setting its length to zero.  <br /></td></tr>
<tr class="separator:a37b99afd18946fe6687642eb9b2e0e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8494519c8918bb63070245b484ec6ef4" id="r_a8494519c8918bb63070245b484ec6ef4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8494519c8918bb63070245b484ec6ef4">string_feeder_create</a> (const char *str)</td></tr>
<tr class="memdesc:a8494519c8918bb63070245b484ec6ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a string feeder object which can be used to traverse the supplied string using the string_feeder_*() functions.  <br /></td></tr>
<tr class="separator:a8494519c8918bb63070245b484ec6ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d81b9611d6b557001a4b213ed337c0c" id="r_a3d81b9611d6b557001a4b213ed337c0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d81b9611d6b557001a4b213ed337c0c">string_feeder_destroy</a> (<a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a> *sf)</td></tr>
<tr class="memdesc:a3d81b9611d6b557001a4b213ed337c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees resources associated with the supplied string feeder object, after which it will no longer be valid for use.  <br /></td></tr>
<tr class="separator:a3d81b9611d6b557001a4b213ed337c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50dab5ff66a1b73040c10977889bc745" id="r_a50dab5ff66a1b73040c10977889bc745"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50dab5ff66a1b73040c10977889bc745">string_feeder_has_next</a> (<a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a> *sf)</td></tr>
<tr class="memdesc:a50dab5ff66a1b73040c10977889bc745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any characters remain to be retrieved from the string feeder's string (not including the terminating '\0').  <br /></td></tr>
<tr class="separator:a50dab5ff66a1b73040c10977889bc745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d278128e30928ebf1eb13d3c9668f6c" id="r_a1d278128e30928ebf1eb13d3c9668f6c"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d278128e30928ebf1eb13d3c9668f6c">string_feeder_next</a> (<a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a> *sf)</td></tr>
<tr class="memdesc:a1d278128e30928ebf1eb13d3c9668f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the next available character from the supplied string feeder (which may be the terminating '\0' character) and advances the feeder's position to the next character in the string.  <br /></td></tr>
<tr class="separator:a1d278128e30928ebf1eb13d3c9668f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac394944241588610d7c8d7df931036e7" id="r_ac394944241588610d7c8d7df931036e7"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac394944241588610d7c8d7df931036e7">string_feeder_next_length</a> (<a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a> *sf, size_t length)</td></tr>
<tr class="memdesc:ac394944241588610d7c8d7df931036e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a series of characters from the supplied string feeder.  <br /></td></tr>
<tr class="separator:ac394944241588610d7c8d7df931036e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2aeb2a4716c370cc43499c3d9c2496d" id="r_ac2aeb2a4716c370cc43499c3d9c2496d"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2aeb2a4716c370cc43499c3d9c2496d">string_feeder_peek</a> (<a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a> *sf)</td></tr>
<tr class="memdesc:ac2aeb2a4716c370cc43499c3d9c2496d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the next available character from the supplied string feeder (which may be the terminating '\0' character), but does not advance the feeder's position so that subsequent calls to _next() or _peek() will retrieve the same character.  <br /></td></tr>
<tr class="separator:ac2aeb2a4716c370cc43499c3d9c2496d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eac21ee06d22fe87b01308955309fb0" id="r_a1eac21ee06d22fe87b01308955309fb0"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1eac21ee06d22fe87b01308955309fb0">string_feeder_peek_length</a> (<a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a> *sf, size_t length)</td></tr>
<tr class="memdesc:a1eac21ee06d22fe87b01308955309fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a series of characters from the supplied string feeder.  <br /></td></tr>
<tr class="separator:a1eac21ee06d22fe87b01308955309fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2de543b90d2254c23674dcd51b07636" id="r_af2de543b90d2254c23674dcd51b07636"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2de543b90d2254c23674dcd51b07636">string_feeder_get_line</a> (<a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a> *sf)</td></tr>
<tr class="memdesc:af2de543b90d2254c23674dcd51b07636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the line number of the current position in the supplied string feeder, which will be incremented whenever a newline is consumed.  <br /></td></tr>
<tr class="separator:af2de543b90d2254c23674dcd51b07636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4125a5741742b15b965c5ca5a240b0c5" id="r_a4125a5741742b15b965c5ca5a240b0c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4125a5741742b15b965c5ca5a240b0c5">string_feeder_get_column</a> (<a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a> *sf)</td></tr>
<tr class="memdesc:a4125a5741742b15b965c5ca5a240b0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the column index in the current line for the current position in the supplied string feeder, which will be incremented with each non-newline character consumed, and reset to 0 whenever a newline (<br  />
) is consumed.  <br /></td></tr>
<tr class="separator:a4125a5741742b15b965c5ca5a240b0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a913aea8f84254c3eb476b9c19462f6" id="r_a3a913aea8f84254c3eb476b9c19462f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a913aea8f84254c3eb476b9c19462f6">string_feeder_starts_with</a> (<a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a> *sf, const char *str)</td></tr>
<tr class="memdesc:a3a913aea8f84254c3eb476b9c19462f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the supplied string feeder's remaining contents starts with the given string.  <br /></td></tr>
<tr class="separator:a3a913aea8f84254c3eb476b9c19462f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90192e4954220b5eaa97e6a4e9841ede" id="r_a90192e4954220b5eaa97e6a4e9841ede"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90192e4954220b5eaa97e6a4e9841ede">string_feeder_require</a> (<a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a> *sf, const char *str)</td></tr>
<tr class="memdesc:a90192e4954220b5eaa97e6a4e9841ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes from the string feeder the number of characters contained in the given string (not including the terminating '\0').  <br /></td></tr>
<tr class="separator:a90192e4954220b5eaa97e6a4e9841ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc00d4cfd66c27ed44fca669fa9b4f2" id="r_a7cc00d4cfd66c27ed44fca669fa9b4f2"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cc00d4cfd66c27ed44fca669fa9b4f2">str_expand_envs</a> (const char *in)</td></tr>
<tr class="separator:a7cc00d4cfd66c27ed44fca669fa9b4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a83d9958ff260a9111db7b6b7d74c92db" name="a83d9958ff260a9111db7b6b7d74c92db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d9958ff260a9111db7b6b7d74c92db">&#9670;&#160;</a></span>str_concat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define str_concat</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em></em></span>...</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_function" href="#a389b8b7076ba98f44b92ea387ff44476">_str_concat_private</a>(__VA_ARGS__, NULL)</div>
<div class="ttc" id="astring__util_8h_html_a389b8b7076ba98f44b92ea387ff44476"><div class="ttname"><a href="#a389b8b7076ba98f44b92ea387ff44476">_str_concat_private</a></div><div class="ttdeci">char * _str_concat_private(const char *first,...)</div></div>
</div><!-- fragment -->
<p>Concatenates 1 or more strings together and returns the result, which will be a newly allocated string which it is the caller's responsibility to free. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ac8b132ce2a66299a01dcebad2cc59309" name="ac8b132ce2a66299a01dcebad2cc59309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b132ce2a66299a01dcebad2cc59309">&#9670;&#160;</a></span>string_buffer_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct string_buffer <a class="el" href="#ac8b132ce2a66299a01dcebad2cc59309">string_buffer_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe73f42beb7fd799c2c93d0fdf3d19c6" name="afe73f42beb7fd799c2c93d0fdf3d19c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe73f42beb7fd799c2c93d0fdf3d19c6">&#9670;&#160;</a></span>string_feeder_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structstring__feeder.html">string_feeder</a> <a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a389b8b7076ba98f44b92ea387ff44476" name="a389b8b7076ba98f44b92ea387ff44476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389b8b7076ba98f44b92ea387ff44476">&#9670;&#160;</a></span>_str_concat_private()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * _str_concat_private </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96927ba6ccdf0f501f5a8b3d6acbd02c" name="a96927ba6ccdf0f501f5a8b3d6acbd02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96927ba6ccdf0f501f5a8b3d6acbd02c">&#9670;&#160;</a></span>sprintf_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * sprintf_alloc </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="printf_8h.html#aa7d2e7e454d3fe606a71504a119dc894" title="Formats args according to specifications in fmt and returns the result as as string.">sprintf()</a>, except that it will malloc() enough space for the formatted string which it returns. </p>
<p>It is the caller's responsibility to call <a class="el" href="_third_party_notices_8txt.html#a22852d05d86a994ddfa3c5109b64ebb2">free()</a> on the returned string when it is no longer needed. </p>

</div>
</div>
<a id="a4332ab4b30afc8a6b4ad6e87d7b7aa11" name="a4332ab4b30afc8a6b4ad6e87d7b7aa11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4332ab4b30afc8a6b4ad6e87d7b7aa11">&#9670;&#160;</a></span>str_contains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int str_contains </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>haystack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>needle</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4085d76639a0fd02ce74f449432a8d37" name="a4085d76639a0fd02ce74f449432a8d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4085d76639a0fd02ce74f449432a8d37">&#9670;&#160;</a></span>str_diff_idx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int str_diff_idx </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4dc7eb21ccb69aaa29a277b4c55f3d6" name="ac4dc7eb21ccb69aaa29a277b4c55f3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4dc7eb21ccb69aaa29a277b4c55f3d6">&#9670;&#160;</a></span>str_ends_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool str_ends_with </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>haystack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>needle</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the end of string 'haystack' matches 'needle', else false. </p>
<p>Note: An empty needle ("") will match any source. </p>

</div>
</div>
<a id="a7cc00d4cfd66c27ed44fca669fa9b4f2" name="a7cc00d4cfd66c27ed44fca669fa9b4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc00d4cfd66c27ed44fca669fa9b4f2">&#9670;&#160;</a></span>str_expand_envs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * str_expand_envs </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f092c57e761ee049df00ea1e0b3e88e" name="a6f092c57e761ee049df00ea1e0b3e88e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f092c57e761ee049df00ea1e0b3e88e">&#9670;&#160;</a></span>str_indexof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int str_indexof </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>haystack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>needle</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the zero-based index of the beginning of the supplied substring (needle) within the search string (haystack) if it exists. </p>
<p>Returns -1 if the supplied needle is not found within the haystack. </p>

</div>
</div>
<a id="a59843771adaac01abe117fae0c6f6bb7" name="a59843771adaac01abe117fae0c6f6bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59843771adaac01abe117fae0c6f6bb7">&#9670;&#160;</a></span>str_last_indexof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int str_last_indexof </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>haystack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>needle</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34a25da24f5203ed578c9531bc31735e" name="a34a25da24f5203ed578c9531bc31735e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a25da24f5203ed578c9531bc31735e">&#9670;&#160;</a></span>str_lstrip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * str_lstrip </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims whitespace characters (i.e. </p>
<p>matching isspace()) from the beginning of the supplied string. This change affects the supplied string in-place. The supplied/edited string is returned to enable chained reference.</p>
<p>Note: do not pass a string literal to this function </p>

</div>
</div>
<a id="a5b6defe7bca38fcfe8e704fe15fc0f10" name="a5b6defe7bca38fcfe8e704fe15fc0f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6defe7bca38fcfe8e704fe15fc0f10">&#9670;&#160;</a></span>str_matches_any()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool str_matches_any </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>haystack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>needles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_needles</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the string 'haystack' matches any needle, else false. </p>

</div>
</div>
<a id="a72f0d7eca7cfffb54c41a103f6d76139" name="a72f0d7eca7cfffb54c41a103f6d76139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f0d7eca7cfffb54c41a103f6d76139">&#9670;&#160;</a></span>str_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * str_replace </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>haystack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>needle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>replacement</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all occurrences of 'needle' in the string 'haystack', substituting for them the value of 'replacement', and returns the result as a newly-allocated string. </p>
<p>The original strings remain unchanged.</p>
<p>It is the caller's responsibility to free the returned string.</p>
<p>Examples: str_replace("string", "ri", "u") = "stung" str_replace("singing", "ing", "") = "s" str_replace("string", "foo", "bar") = "string"</p>
<p>Note: An empty needle will match only an empty haystack </p>

</div>
</div>
<a id="a6e9444ba9a777ca56b07dd28203fdb10" name="a6e9444ba9a777ca56b07dd28203fdb10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9444ba9a777ca56b07dd28203fdb10">&#9670;&#160;</a></span>str_replace_many()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * str_replace_many </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>_haystack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa14559074f80c32a036733f8ea00d485" name="aa14559074f80c32a036733f8ea00d485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14559074f80c32a036733f8ea00d485">&#9670;&#160;</a></span>str_rstrip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * str_rstrip </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims whitespace characters (i.e. </p>
<p>matching isspace()) from the end of the supplied string. This change affects the supplied string in-place. The supplied/edited string is returned to enable chained reference.</p>
<p>Note: do not pass a string literal to this function </p>

</div>
</div>
<a id="a553b61c2fa0c3484c57e66927023d810" name="a553b61c2fa0c3484c57e66927023d810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553b61c2fa0c3484c57e66927023d810">&#9670;&#160;</a></span>str_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zarray_8h.html#af429d8225958865fc14ea0ddcc7c0b06">zarray_t</a> * str_split </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>delim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits the supplied string into an array of strings by subdividing it at each occurrence of the supplied delimiter string. </p>
<p>The split strings will not contain the delimiter. The original string will remain unchanged. If str is composed of all delimiters, an empty array will be returned.</p>
<p>It is the caller's responsibility to free the returned zarray, as well as the strings contained within it, e.g.:</p>
<p>zarray_t *za = str_split("this is a haystack", " "); =&gt; ["this", "is", "a", "haystack"] zarray_vmap(za, free); zarray_destroy(za); </p>

</div>
</div>
<a id="a42c2c528e3f4795cd1ed7f40105b1907" name="a42c2c528e3f4795cd1ed7f40105b1907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c2c528e3f4795cd1ed7f40105b1907">&#9670;&#160;</a></span>str_split_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void str_split_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zarray_8h.html#af429d8225958865fc14ea0ddcc7c0b06">zarray_t</a> *</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad70cb3d06c9e18d543c42dfda87bb033" name="ad70cb3d06c9e18d543c42dfda87bb033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad70cb3d06c9e18d543c42dfda87bb033">&#9670;&#160;</a></span>str_split_spaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zarray_8h.html#af429d8225958865fc14ea0ddcc7c0b06">zarray_t</a> * str_split_spaces </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9a76a05527a7efb8bfc37e96eeee95f" name="ac9a76a05527a7efb8bfc37e96eeee95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a76a05527a7efb8bfc37e96eeee95f">&#9670;&#160;</a></span>str_starts_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool str_starts_with </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>haystack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>needle</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the start of string 'haystack' matches 'needle', else false. </p>
<p>Note: An empty needle ("") will match any source. </p>

</div>
</div>
<a id="ad6dbe2fe9c113587f57106adf9a5d4c2" name="ad6dbe2fe9c113587f57106adf9a5d4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6dbe2fe9c113587f57106adf9a5d4c2">&#9670;&#160;</a></span>str_starts_with_any()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool str_starts_with_any </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>haystack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>needles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_needles</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the start of string 'haystack' matches any needle, else false. </p>
<p>Note: An empty needle ("") will match any source. </p>

</div>
</div>
<a id="a361b625259415c25ac6d51d95aa747bd" name="a361b625259415c25ac6d51d95aa747bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a361b625259415c25ac6d51d95aa747bd">&#9670;&#160;</a></span>str_substring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * str_substring </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>startidx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>endidx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a (newly-allocated) substring of the given string, 'str', starting from character index 'startidx' through index 'endidx' - 1 (inclusive). </p>
<p>An 'endidx' value -1 is equivalent to strlen(str).</p>
<p>It is the caller's responsibility to free the returned string.</p>
<p>Examples: str_substring("string", 1, 3) = "tr" str_substring("string", 2, -1) = "ring" str_substring("string", 3, 3) = ""</p>
<p>Note: startidx must be &gt;= endidx </p>

</div>
</div>
<a id="a2c3bd192ba2530593148b8e8f5d8ad74" name="a2c3bd192ba2530593148b8e8f5d8ad74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3bd192ba2530593148b8e8f5d8ad74">&#9670;&#160;</a></span>str_tolowercase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * str_tolowercase </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all upper-case characters within the supplied string with their lower-case counterparts, modifying the original string's contents. </p>
<p>Returns the supplied / modified string. </p>

</div>
</div>
<a id="a8b4e25b614d67cdf531155ecfbf906aa" name="a8b4e25b614d67cdf531155ecfbf906aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4e25b614d67cdf531155ecfbf906aa">&#9670;&#160;</a></span>str_touppercase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * str_touppercase </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all lower-case characters within the supplied string with their upper-case counterparts, modifying the original string's contents. </p>
<p>Returns the supplied / modified string. </p>

</div>
</div>
<a id="a4016701bd5241b39f95cd3c69b706fbc" name="a4016701bd5241b39f95cd3c69b706fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4016701bd5241b39f95cd3c69b706fbc">&#9670;&#160;</a></span>str_trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * str_trim </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims whitespace characters (i.e. </p>
<p>matching isspace()) from the beginning and/or end of the supplied string. This change affects the supplied string in-place. The supplied/edited string is returned to enable chained reference.</p>
<p>Note: do not pass a string literal to this function </p>

</div>
</div>
<a id="adfa256111b35267eccce5fb88e9fe1e9" name="adfa256111b35267eccce5fb88e9fe1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa256111b35267eccce5fb88e9fe1e9">&#9670;&#160;</a></span>strcaseeq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool strcaseeq </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if str1 exactly matches str2, ignoring case (more efficient than strcasecmp(...) == 0) </p>

</div>
</div>
<a id="a0082971520dd192cba6c8e67b0d1f111" name="a0082971520dd192cba6c8e67b0d1f111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0082971520dd192cba6c8e67b0d1f111">&#9670;&#160;</a></span>streq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool streq </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f53cad9a87feaa9c9f6c9b63af20e11" name="a2f53cad9a87feaa9c9f6c9b63af20e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f53cad9a87feaa9c9f6c9b63af20e11">&#9670;&#160;</a></span>string_buffer_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void string_buffer_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac8b132ce2a66299a01dcebad2cc59309">string_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a single character to the end of the supplied string buffer. </p>

</div>
</div>
<a id="a9bec654f83373c26ad828a41bb623d32" name="a9bec654f83373c26ad828a41bb623d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bec654f83373c26ad828a41bb623d32">&#9670;&#160;</a></span>string_buffer_append_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void string_buffer_append_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac8b132ce2a66299a01dcebad2cc59309">string_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the supplied string to the end of the supplied string buffer. </p>

</div>
</div>
<a id="ab85a4fb78195378be29a562e0a9e6b31" name="ab85a4fb78195378be29a562e0a9e6b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85a4fb78195378be29a562e0a9e6b31">&#9670;&#160;</a></span>string_buffer_appendf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void string_buffer_appendf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac8b132ce2a66299a01dcebad2cc59309">string_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formats the supplied string and arguments in a manner akin to <a class="el" href="printf_8h.html#aee3ed3a831f25f07e7be3919fff2203a" title="Formats args according to specifications in fmt and writes the output to stdout.">printf()</a>, and appends the resulting string to the end of the supplied string buffer. </p>

</div>
</div>
<a id="a3f330c814ee6f5f2bcb2f5ad3786cc89" name="a3f330c814ee6f5f2bcb2f5ad3786cc89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f330c814ee6f5f2bcb2f5ad3786cc89">&#9670;&#160;</a></span>string_buffer_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac8b132ce2a66299a01dcebad2cc59309">string_buffer_t</a> * string_buffer_create </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and initializes a string buffer object which can be used with any of the string_buffer_*() functions. </p>
<p>It is the caller's responsibility to free the string buffer resources with a call to <a class="el" href="#a0a0418b0d5c1d6396e33b8e7d9b8fa54" title="Frees the resources associated with a string buffer object, including space allocated for any appende...">string_buffer_destroy()</a> when it is no longer needed. </p>

</div>
</div>
<a id="a0a0418b0d5c1d6396e33b8e7d9b8fa54" name="a0a0418b0d5c1d6396e33b8e7d9b8fa54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a0418b0d5c1d6396e33b8e7d9b8fa54">&#9670;&#160;</a></span>string_buffer_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void string_buffer_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac8b132ce2a66299a01dcebad2cc59309">string_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the resources associated with a string buffer object, including space allocated for any appended characters / strings. </p>

</div>
</div>
<a id="a9d3f33cfbab8c5659473768bd7483ea7" name="a9d3f33cfbab8c5659473768bd7483ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3f33cfbab8c5659473768bd7483ea7">&#9670;&#160;</a></span>string_buffer_ends_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bool string_buffer_ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac8b132ce2a66299a01dcebad2cc59309">string_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the character contents held by the supplied string buffer ends with the supplied string. </p>
<p>Returns true if the string buffer's contents ends with 'str', else false. </p>

</div>
</div>
<a id="a13edc9bfa7666cba79f28ededc7ec39e" name="a13edc9bfa7666cba79f28ededc7ec39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13edc9bfa7666cba79f28ededc7ec39e">&#9670;&#160;</a></span>string_buffer_pop_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char string_buffer_pop_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac8b132ce2a66299a01dcebad2cc59309">string_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a single character from the end of the string and returns it. </p>
<p>Does nothing if string is empty and returns NULL </p>

</div>
</div>
<a id="a37b99afd18946fe6687642eb9b2e0e81" name="a37b99afd18946fe6687642eb9b2e0e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b99afd18946fe6687642eb9b2e0e81">&#9670;&#160;</a></span>string_buffer_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void string_buffer_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac8b132ce2a66299a01dcebad2cc59309">string_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the contents of the string buffer, setting its length to zero. </p>

</div>
</div>
<a id="ad1212d3276a3a334ff6874cbd8b915fa" name="ad1212d3276a3a334ff6874cbd8b915fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1212d3276a3a334ff6874cbd8b915fa">&#9670;&#160;</a></span>string_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t string_buffer_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac8b132ce2a66299a01dcebad2cc59309">string_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the string-length of the contents of the string buffer (not counting \0). </p>
<p>Equivalent to calling strlen() on the string returned by string_buffer_to_string(sb). </p>

</div>
</div>
<a id="afbc12b6172d009e605c279a7a928322d" name="afbc12b6172d009e605c279a7a928322d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc12b6172d009e605c279a7a928322d">&#9670;&#160;</a></span>string_buffer_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * string_buffer_to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac8b132ce2a66299a01dcebad2cc59309">string_buffer_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contents of the string buffer in a newly-allocated string, which it is the caller's responsibility to free once it is no longer needed. </p>

</div>
</div>
<a id="a8494519c8918bb63070245b484ec6ef4" name="a8494519c8918bb63070245b484ec6ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8494519c8918bb63070245b484ec6ef4">&#9670;&#160;</a></span>string_feeder_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a> * string_feeder_create </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a string feeder object which can be used to traverse the supplied string using the string_feeder_*() functions. </p>
<p>A local copy of the string's contents will be stored so that future changes to 'str' will not be reflected by the string feeder object.</p>
<p>It is the caller's responsibility to call <a class="el" href="#a3d81b9611d6b557001a4b213ed337c0c" title="Frees resources associated with the supplied string feeder object, after which it will no longer be v...">string_feeder_destroy()</a> on the returned object when it is no longer needed. </p>

</div>
</div>
<a id="a3d81b9611d6b557001a4b213ed337c0c" name="a3d81b9611d6b557001a4b213ed337c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d81b9611d6b557001a4b213ed337c0c">&#9670;&#160;</a></span>string_feeder_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void string_feeder_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees resources associated with the supplied string feeder object, after which it will no longer be valid for use. </p>

</div>
</div>
<a id="a4125a5741742b15b965c5ca5a240b0c5" name="a4125a5741742b15b965c5ca5a240b0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4125a5741742b15b965c5ca5a240b0c5">&#9670;&#160;</a></span>string_feeder_get_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int string_feeder_get_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the column index in the current line for the current position in the supplied string feeder, which will be incremented with each non-newline character consumed, and reset to 0 whenever a newline (<br  />
) is consumed. </p>
<p>Examples: prior to reading 1st character: line = 1, column = 0 after reading 1st non-newline character: line = 1, column = 1 after reading 2nd non-newline character: line = 1, column = 2 after reading 1st newline character: line = 2, column = 0 after reading 1st character after 1st newline: line = 2, column = 1 after reading 2nd newline character: line = 3, column = 0 </p>

</div>
</div>
<a id="af2de543b90d2254c23674dcd51b07636" name="af2de543b90d2254c23674dcd51b07636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2de543b90d2254c23674dcd51b07636">&#9670;&#160;</a></span>string_feeder_get_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int string_feeder_get_line </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the line number of the current position in the supplied string feeder, which will be incremented whenever a newline is consumed. </p>
<p>Examples: prior to reading 1st character: line = 1, column = 0 after reading 1st non-newline character: line = 1, column = 1 after reading 2nd non-newline character: line = 1, column = 2 after reading 1st newline character: line = 2, column = 0 after reading 1st character after 1st newline: line = 2, column = 1 after reading 2nd newline character: line = 3, column = 0 </p>

</div>
</div>
<a id="a50dab5ff66a1b73040c10977889bc745" name="a50dab5ff66a1b73040c10977889bc745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50dab5ff66a1b73040c10977889bc745">&#9670;&#160;</a></span>string_feeder_has_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool string_feeder_has_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether any characters remain to be retrieved from the string feeder's string (not including the terminating '\0'). </p>
<p>Returns true if at least one more character can be retrieved with calls to <a class="el" href="#a1d278128e30928ebf1eb13d3c9668f6c" title="Retrieves the next available character from the supplied string feeder (which may be the terminating ...">string_feeder_next()</a>, <a class="el" href="#ac2aeb2a4716c370cc43499c3d9c2496d" title="Retrieves the next available character from the supplied string feeder (which may be the terminating ...">string_feeder_peek()</a>, <a class="el" href="#ac2aeb2a4716c370cc43499c3d9c2496d" title="Retrieves the next available character from the supplied string feeder (which may be the terminating ...">string_feeder_peek()</a>, or string_feeder_consume(), else false. </p>

</div>
</div>
<a id="a1d278128e30928ebf1eb13d3c9668f6c" name="a1d278128e30928ebf1eb13d3c9668f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d278128e30928ebf1eb13d3c9668f6c">&#9670;&#160;</a></span>string_feeder_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char string_feeder_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the next available character from the supplied string feeder (which may be the terminating '\0' character) and advances the feeder's position to the next character in the string. </p>
<p>Note: Attempts to read past the end of the string will throw an assertion. </p>

</div>
</div>
<a id="ac394944241588610d7c8d7df931036e7" name="ac394944241588610d7c8d7df931036e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac394944241588610d7c8d7df931036e7">&#9670;&#160;</a></span>string_feeder_next_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * string_feeder_next_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a series of characters from the supplied string feeder. </p>
<p>The number of characters returned will be 'length' or the number of characters remaining in the string, whichever is shorter. The string feeder's position will be advanced by the number of characters returned.</p>
<p>It is the caller's responsibility to free the returned string when it is no longer needed.</p>
<p>Note: Calling once the end of the string has already been read will throw an assertion. </p>

</div>
</div>
<a id="ac2aeb2a4716c370cc43499c3d9c2496d" name="ac2aeb2a4716c370cc43499c3d9c2496d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2aeb2a4716c370cc43499c3d9c2496d">&#9670;&#160;</a></span>string_feeder_peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char string_feeder_peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the next available character from the supplied string feeder (which may be the terminating '\0' character), but does not advance the feeder's position so that subsequent calls to _next() or _peek() will retrieve the same character. </p>
<p>Note: Attempts to peek past the end of the string will throw an assertion. </p>

</div>
</div>
<a id="a1eac21ee06d22fe87b01308955309fb0" name="a1eac21ee06d22fe87b01308955309fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eac21ee06d22fe87b01308955309fb0">&#9670;&#160;</a></span>string_feeder_peek_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * string_feeder_peek_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a series of characters from the supplied string feeder. </p>
<p>The number of characters returned will be 'length' or the number of characters remaining in the string, whichever is shorter. The string feeder's position will not be advanced.</p>
<p>It is the caller's responsibility to free the returned string when it is no longer needed.</p>
<p>Note: Calling once the end of the string has already been read will throw an assertion. </p>

</div>
</div>
<a id="a90192e4954220b5eaa97e6a4e9841ede" name="a90192e4954220b5eaa97e6a4e9841ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90192e4954220b5eaa97e6a4e9841ede">&#9670;&#160;</a></span>string_feeder_require()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void string_feeder_require </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consumes from the string feeder the number of characters contained in the given string (not including the terminating '\0'). </p>
<p>Throws an assertion if the consumed characters do not exactly match the contents of the supplied string. </p>

</div>
</div>
<a id="a3a913aea8f84254c3eb476b9c19462f6" name="a3a913aea8f84254c3eb476b9c19462f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a913aea8f84254c3eb476b9c19462f6">&#9670;&#160;</a></span>string_feeder_starts_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool string_feeder_starts_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afe73f42beb7fd799c2c93d0fdf3d19c6">string_feeder_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the supplied string feeder's remaining contents starts with the given string. </p>
<p>Returns true if the beginning of the string feeder's remaining contents matches the supplied string exactly, else false. </p>

</div>
</div>
<a id="a4a9b9e6c113d46c1f108afb7d4e5dd58" name="a4a9b9e6c113d46c1f108afb7d4e5dd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9b9e6c113d46c1f108afb7d4e5dd58">&#9670;&#160;</a></span>vsprintf_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char char * vsprintf_alloc </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="printf_8h.html#a5e1075a6c1fce5050424f97a2fac648f">vsprintf()</a>, except that it will malloc() enough space for the formatted string which it returns. </p>
<p>It is the caller's responsibility to call <a class="el" href="_third_party_notices_8txt.html#a22852d05d86a994ddfa3c5109b64ebb2">free()</a> on the returned string when it is no longer needed. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_bce03949b0889f5b77e9e810e79dfd7d.html">thirdparty</a></li><li class="navelem"><a class="el" href="dir_ff0062bb8776854a1feb511e7a5035f7.html">apriltag</a></li><li class="navelem"><a class="el" href="dir_4f37ec3afec411c33430786613d06e76.html">include</a></li><li class="navelem"><a class="el" href="dir_6324afc825a598ce4fef60a1f900074d.html">common</a></li><li class="navelem"><a class="el" href="string__util_8h.html">string_util.h</a></li>
    <li class="footer">Generated on Thu Oct 24 2024 04:48:52 for WPILibC++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
