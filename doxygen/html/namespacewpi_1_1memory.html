<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: wpi::memory Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="wpilib-128.png"/></td>
  <td id="projectalign">
   <div id="projectname">WPILibC++<span id="projectnumber">&#160;2025.1.1-beta-1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacewpi_1_1memory.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">wpi::memory Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Memory namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory_1_1literals.html">literals</a></td></tr>
<tr class="memdesc:namespacewpi_1_1memory_1_1literals"><td class="mdescLeft">&#160;</td><td class="mdescRight">Literals namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewpi_1_1memory_1_1traits__detail.html">traits_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1aligned__allocator.html">aligned_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A RawAllocator adapter that ensures a minimum alignment.  <a href="classwpi_1_1memory_1_1aligned__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1allocate__shared__node__size.html">allocate_shared_node_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The node size required by <a class="el" href="group__memory__adapter.html#ga1ad71e94176eddd2fe4eab53c41fca57">allocate_shared</a>.  <a href="structwpi_1_1memory_1_1allocate__shared__node__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__adapter.html">allocator_adapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias template for <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a> using the <a class="el" href="classwpi_1_1memory_1_1direct__storage.html">direct_storage</a> policy without a mutex.  <a href="classwpi_1_1memory_1_1allocator__adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__deallocator.html">allocator_deallocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deleter class that deallocates the memory through a specified RawAllocator.  <a href="classwpi_1_1memory_1_1allocator__deallocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__deallocator_3_01_type_0f_0e_00_01_raw_allocator_01_4.html">allocator_deallocator&lt; Type[], RawAllocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classwpi_1_1memory_1_1allocator__deallocator.html">allocator_deallocator</a> for array types.  <a href="classwpi_1_1memory_1_1allocator__deallocator_3_01_type_0f_0e_00_01_raw_allocator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__deleter.html">allocator_deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classwpi_1_1memory_1_1allocator__deallocator.html">allocator_deallocator</a> but calls the destructors of the object.  <a href="classwpi_1_1memory_1_1allocator__deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__deleter_3_01_type_0f_0e_00_01_raw_allocator_01_4.html">allocator_deleter&lt; Type[], RawAllocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classwpi_1_1memory_1_1allocator__deleter.html">allocator_deleter</a> for array types.  <a href="classwpi_1_1memory_1_1allocator__deleter_3_01_type_0f_0e_00_01_raw_allocator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1allocator__info.html">allocator_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains information about an allocator.  <a href="structwpi_1_1memory_1_1allocator__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1allocator__is__raw__allocator.html">allocator_is_raw_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class that checks whether or not a standard <code>Allocator</code> can be used as RawAllocator.  <a href="structwpi_1_1memory_1_1allocator__is__raw__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1allocator__is__raw__allocator_3_01std_1_1allocator_3_01_t_01_4_01_4.html">allocator_is_raw_allocator&lt; std::allocator&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structwpi_1_1memory_1_1allocator__is__raw__allocator.html">allocator_is_raw_allocator</a> that allows <code>std::allocator</code> again.  <a href="structwpi_1_1memory_1_1allocator__is__raw__allocator_3_01std_1_1allocator_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__polymorphic__deallocator.html">allocator_polymorphic_deallocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deleter class that deallocates the memory of a derived type through a specified RawAllocator.  <a href="classwpi_1_1memory_1_1allocator__polymorphic__deallocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__polymorphic__deleter.html">allocator_polymorphic_deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classwpi_1_1memory_1_1allocator__polymorphic__deallocator.html">allocator_polymorphic_deallocator</a> but calls the destructors of the object.  <a href="classwpi_1_1memory_1_1allocator__polymorphic__deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__reference.html">allocator_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias template for <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a> using the <a class="el" href="classwpi_1_1memory_1_1reference__storage.html">reference_storage</a> policy.  <a href="classwpi_1_1memory_1_1allocator__reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A RawAllocator that stores another allocator.  <a href="classwpi_1_1memory_1_1allocator__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__traits.html">allocator_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default specialization of the <a class="el" href="classwpi_1_1memory_1_1allocator__traits.html" title="The default specialization of the allocator_traits for a RawAllocator.">allocator_traits</a> for a RawAllocator.  <a href="classwpi_1_1memory_1_1allocator__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__traits_3_01iteration__allocator_3_01_n_00_01_block_allocator_01_4_01_4.html">allocator_traits&lt; iteration_allocator&lt; N, BlockAllocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="classwpi_1_1memory_1_1allocator__traits.html">allocator_traits</a> for <a class="el" href="classwpi_1_1memory_1_1iteration__allocator.html">iteration_allocator</a>.  <a href="classwpi_1_1memory_1_1allocator__traits_3_01iteration__allocator_3_01_n_00_01_block_allocator_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__traits_3_01memory__pool_3_01_pool_type_00_01_impl_raw_allocator_01_4_01_4.html">allocator_traits&lt; memory_pool&lt; PoolType, ImplRawAllocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="classwpi_1_1memory_1_1allocator__traits.html">allocator_traits</a> for <a class="el" href="classwpi_1_1memory_1_1memory__pool.html">memory_pool</a> classes.  <a href="classwpi_1_1memory_1_1allocator__traits_3_01memory__pool_3_01_pool_type_00_01_impl_raw_allocator_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__traits_3_01memory__pool__collection_3_01_pool_00_01_bucket_dist_00_01_raw_allocator_01_4_01_4.html">allocator_traits&lt; memory_pool_collection&lt; Pool, BucketDist, RawAllocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="classwpi_1_1memory_1_1allocator__traits.html">allocator_traits</a> for <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a> classes.  <a href="classwpi_1_1memory_1_1allocator__traits_3_01memory__pool__collection_3_01_pool_00_01_bucket_dist_00_01_raw_allocator_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__traits_3_01memory__stack_3_01_block_allocator_01_4_01_4.html">allocator_traits&lt; memory_stack&lt; BlockAllocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="classwpi_1_1memory_1_1allocator__traits.html">allocator_traits</a> for <a class="el" href="classwpi_1_1memory_1_1memory__stack.html">memory_stack</a> classes.  <a href="classwpi_1_1memory_1_1allocator__traits_3_01memory__stack_3_01_block_allocator_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__traits_3_01temporary__allocator_01_4.html">allocator_traits&lt; temporary_allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="classwpi_1_1memory_1_1allocator__traits.html">allocator_traits</a> for <a class="el" href="classwpi_1_1memory_1_1temporary__allocator.html">temporary_allocator</a> classes.  <a href="classwpi_1_1memory_1_1allocator__traits_3_01temporary__allocator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1any__allocator.html">any_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type that enables type-erasure in <a class="el" href="classwpi_1_1memory_1_1reference__storage.html">reference_storage</a>.  <a href="structwpi_1_1memory_1_1any__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1any__std__allocator.html">any_std_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias template for <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a> using a type-erased RawAllocator.  <a href="classwpi_1_1memory_1_1any__std__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1array__pool.html">array_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type defining a memory pool optimized for arrays.  <a href="structwpi_1_1memory_1_1array__pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1bad__alignment.html">bad_alignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when the alignment exceeds the supported maximum, i.e.  <a href="classwpi_1_1memory_1_1bad__alignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1bad__allocation__size.html">bad_allocation_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when an allocation size is bigger than the supported maximum.  <a href="classwpi_1_1memory_1_1bad__allocation__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1bad__array__size.html">bad_array_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when the array size exceeds the supported maximum, i.e.  <a href="classwpi_1_1memory_1_1bad__array__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1bad__node__size.html">bad_node_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when the node size exceeds the supported maximum, i.e.  <a href="classwpi_1_1memory_1_1bad__node__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A RawAllocator that either uses the Segregatable or the other <code>RawAllocator</code>.  <a href="classwpi_1_1memory_1_1binary__segregator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1bucket__allocator.html">bucket_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a> using the <a class="el" href="structwpi_1_1memory_1_1identity__buckets.html">identity_buckets</a> policy and a <code>PoolType</code> defaulting to <a class="el" href="structwpi_1_1memory_1_1node__pool.html">node_pool</a>.  <a href="classwpi_1_1memory_1_1bucket__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1composable__allocator__traits.html">composable_allocator_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default specialization of the <a class="el" href="classwpi_1_1memory_1_1composable__allocator__traits.html" title="The default specialization of the composable_allocator_traits for a ComposableAllocator.">composable_allocator_traits</a> for a ComposableAllocator.  <a href="classwpi_1_1memory_1_1composable__allocator__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1composable__allocator__traits_3_01iteration__allocator_3_01_n_00_01_block_allocator_01_4_01_4.html">composable_allocator_traits&lt; iteration_allocator&lt; N, BlockAllocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="classwpi_1_1memory_1_1composable__allocator__traits.html">composable_allocator_traits</a> for <a class="el" href="classwpi_1_1memory_1_1iteration__allocator.html">iteration_allocator</a> classes.  <a href="classwpi_1_1memory_1_1composable__allocator__traits_3_01iteration__allocator_3_01_n_00_01_block_allocator_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1composable__allocator__traits_3_01memory__pool_3_01_pool_type_00_01_block_or_raw_allocator_01_4_01_4.html">composable_allocator_traits&lt; memory_pool&lt; PoolType, BlockOrRawAllocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="classwpi_1_1memory_1_1composable__allocator__traits.html">composable_allocator_traits</a> for <a class="el" href="classwpi_1_1memory_1_1memory__pool.html">memory_pool</a> classes.  <a href="classwpi_1_1memory_1_1composable__allocator__traits_3_01memory__pool_3_01_pool_type_00_01_block_or_raw_allocator_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1composable__allocator__traits_3_01memory__pool__collection_3_01_pool_00_01cb002dcf07085c1d53352faa4ab48c7f.html">composable_allocator_traits&lt; memory_pool_collection&lt; Pool, BucketDist, RawAllocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="classwpi_1_1memory_1_1composable__allocator__traits.html">composable_allocator_traits</a> for <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a> classes.  <a href="classwpi_1_1memory_1_1composable__allocator__traits_3_01memory__pool__collection_3_01_pool_00_01cb002dcf07085c1d53352faa4ab48c7f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1composable__allocator__traits_3_01memory__stack_3_01_block_allocator_01_4_01_4.html">composable_allocator_traits&lt; memory_stack&lt; BlockAllocator &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="classwpi_1_1memory_1_1composable__allocator__traits.html">composable_allocator_traits</a> for <a class="el" href="classwpi_1_1memory_1_1memory__stack.html">memory_stack</a> classes.  <a href="classwpi_1_1memory_1_1composable__allocator__traits_3_01memory__stack_3_01_block_allocator_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1deeply__tracked__allocator.html">deeply_tracked_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classwpi_1_1memory_1_1tracked__allocator.html">tracked_allocator</a> that has rebound any BlockAllocator to the corresponding <a class="el" href="group__memory__adapter.html#gab5f1b034a97535516c8997b6c8a3cfd9">deeply_tracked_block_allocator</a>.  <a href="classwpi_1_1memory_1_1deeply__tracked__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1deque.html">deque</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template for an STL container that uses a certain RawAllocator.     <a href="classwpi_1_1memory_1_1deque.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1deque__scoped__alloc.html">deque_scoped_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but uses <code>std::scoped_allocator_adaptor</code> so the allocator is inherited by all nested containers.     <a href="classwpi_1_1memory_1_1deque__scoped__alloc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1direct__storage.html">direct_storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A StoragePolicy that stores the allocator directly.  <a href="classwpi_1_1memory_1_1direct__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1double__frame__allocator.html">double_frame_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for <a class="el" href="classwpi_1_1memory_1_1iteration__allocator.html">iteration_allocator</a> for two iterations.  <a href="classwpi_1_1memory_1_1double__frame__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1fallback__allocator.html">fallback_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A RawAllocator with a fallback.  <a href="classwpi_1_1memory_1_1fallback__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1fixed__block__allocator.html">fixed_block_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A BlockAllocator that allows only one block allocation.  <a href="classwpi_1_1memory_1_1fixed__block__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1forward__list.html">forward_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template for an STL container that uses a certain RawAllocator.     <a href="classwpi_1_1memory_1_1forward__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1forward__list__node__size.html">forward_list_node_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the node size of a node based STL container with a specific type.  <a href="structwpi_1_1memory_1_1forward__list__node__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1forward__list__scoped__alloc.html">forward_list_scoped_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but uses <code>std::scoped_allocator_adaptor</code> so the allocator is inherited by all nested containers.     <a href="classwpi_1_1memory_1_1forward__list__scoped__alloc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1growing__block__allocator.html">growing_block_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A BlockAllocator that uses a given RawAllocator for allocating the blocks.  <a href="classwpi_1_1memory_1_1growing__block__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1identity__buckets.html">identity_buckets</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>BucketDistribution</code> for <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a> defining that there is a bucket, i.e.  <a href="structwpi_1_1memory_1_1identity__buckets.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1is__block__allocator.html">is_block_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits that check whether a type models concept BlockAllocator.  <a href="structwpi_1_1memory_1_1is__block__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1is__composable__allocator.html">is_composable_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits that check whether a type models concept ComposableAllocator.  <a href="structwpi_1_1memory_1_1is__composable__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1is__raw__allocator.html">is_raw_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits that check whether a type models concept RawAllocator.  <a href="structwpi_1_1memory_1_1is__raw__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1is__shared__allocator.html">is_shared_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether or not a RawAllocator has shared semantics.  <a href="structwpi_1_1memory_1_1is__shared__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1is__shared__allocator_3_01joint__allocator_01_4.html">is_shared_allocator&lt; joint_allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structwpi_1_1memory_1_1is__shared__allocator.html">is_shared_allocator</a> to mark <a class="el" href="classwpi_1_1memory_1_1joint__allocator.html">joint_allocator</a> as shared.  <a href="structwpi_1_1memory_1_1is__shared__allocator_3_01joint__allocator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1is__shared__allocator_3_01memory__resource__allocator_01_4.html">is_shared_allocator&lt; memory_resource_allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structwpi_1_1memory_1_1is__shared__allocator.html">is_shared_allocator</a> to mark <a class="el" href="classwpi_1_1memory_1_1memory__resource__allocator.html">memory_resource_allocator</a> as shared.  <a href="structwpi_1_1memory_1_1is__shared__allocator_3_01memory__resource__allocator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1is__thread__safe__allocator.html">is_thread_safe_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether or not a RawAllocator is thread safe as-is.  <a href="structwpi_1_1memory_1_1is__thread__safe__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1is__thread__safe__allocator_3_01joint__allocator_01_4.html">is_thread_safe_allocator&lt; joint_allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structwpi_1_1memory_1_1is__thread__safe__allocator.html">is_thread_safe_allocator</a> to mark <a class="el" href="classwpi_1_1memory_1_1joint__allocator.html">joint_allocator</a> as thread safe.  <a href="structwpi_1_1memory_1_1is__thread__safe__allocator_3_01joint__allocator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1iteration__allocator.html">iteration_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stateful RawAllocator that is designed for allocations in a loop.  <a href="classwpi_1_1memory_1_1iteration__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1joint.html">joint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type that can't be created.  <a href="classwpi_1_1memory_1_1joint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1joint__allocator.html">joint_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A RawAllocator that uses the additional joint memory for its allocation.  <a href="classwpi_1_1memory_1_1joint__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1joint__array.html">joint_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A zero overhead dynamic array using joint memory.  <a href="classwpi_1_1memory_1_1joint__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to an object where all allocations are joint.  <a href="classwpi_1_1memory_1_1joint__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1joint__size.html">joint_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type to make the joint size more explicit.  <a href="structwpi_1_1memory_1_1joint__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1joint__type.html">joint_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP base class for all objects that want to use joint memory.  <a href="classwpi_1_1memory_1_1joint__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1list.html">list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template for an STL container that uses a certain RawAllocator.     <a href="classwpi_1_1memory_1_1list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1list__node__size.html">list_node_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the node size of a node based STL container with a specific type.     <a href="structwpi_1_1memory_1_1list__node__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1list__scoped__alloc.html">list_scoped_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but uses <code>std::scoped_allocator_adaptor</code> so the allocator is inherited by all nested containers.     <a href="classwpi_1_1memory_1_1list__scoped__alloc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1log2__buckets.html">log2_buckets</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>BucketDistribution</code> for <a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a> defining that there is a bucket, i.e.  <a href="structwpi_1_1memory_1_1log2__buckets.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1map.html">map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template for an STL container that uses a certain RawAllocator.     <a href="classwpi_1_1memory_1_1map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1map__node__size.html">map_node_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the node size of a node based STL container with a specific type.  <a href="structwpi_1_1memory_1_1map__node__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1map__scoped__alloc.html">map_scoped_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but uses <code>std::scoped_allocator_adaptor</code> so the allocator is inherited by all nested containers.     <a href="classwpi_1_1memory_1_1map__scoped__alloc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1memory__arena.html">memory_arena</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory arena that manages huge memory blocks for a higher-level allocator.  <a href="classwpi_1_1memory_1_1memory__arena.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1memory__block.html">memory_block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory block.  <a href="structwpi_1_1memory_1_1memory__block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1memory__pool.html">memory_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stateful RawAllocator that manages nodes of fixed size.  <a href="classwpi_1_1memory_1_1memory__pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stateful RawAllocator that behaves as a collection of multiple <a class="el" href="classwpi_1_1memory_1_1memory__pool.html">memory_pool</a> objects.  <a href="classwpi_1_1memory_1_1memory__pool__collection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1memory__resource.html">memory_resource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="classwpi_1_1memory_1_1memory__resource.html" title="The memory_resource abstract base class used in the implementation.">memory_resource</a></code> abstract base class used in the implementation.  <a href="classwpi_1_1memory_1_1memory__resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1memory__resource__adapter.html">memory_resource_adapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a RawAllocator and makes it a <a class="el" href="classwpi_1_1memory_1_1memory__resource.html">memory_resource</a>.  <a href="classwpi_1_1memory_1_1memory__resource__adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1memory__resource__allocator.html">memory_resource_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a <a class="el" href="classwpi_1_1memory_1_1memory__resource.html">memory_resource</a> and makes it a RawAllocator.  <a href="classwpi_1_1memory_1_1memory__resource__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1memory__stack.html">memory_stack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stateful RawAllocator that provides stack-like (LIFO) allocations.  <a href="classwpi_1_1memory_1_1memory__stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1memory__stack__raii__unwind.html">memory_stack_raii_unwind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple utility that automatically unwinds a <code>Stack</code> to a previously saved location.  <a href="classwpi_1_1memory_1_1memory__stack__raii__unwind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1multimap.html">multimap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template for an STL container that uses a certain RawAllocator.     <a href="classwpi_1_1memory_1_1multimap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1multimap__node__size.html">multimap_node_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the node size of a node based STL container with a specific type.     <a href="structwpi_1_1memory_1_1multimap__node__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1multimap__scoped__alloc.html">multimap_scoped_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but uses <code>std::scoped_allocator_adaptor</code> so the allocator is inherited by all nested containers.     <a href="classwpi_1_1memory_1_1multimap__scoped__alloc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1multiset.html">multiset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template for an STL container that uses a certain RawAllocator.     <a href="classwpi_1_1memory_1_1multiset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1multiset__node__size.html">multiset_node_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the node size of a node based STL container with a specific type.     <a href="structwpi_1_1memory_1_1multiset__node__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1multiset__scoped__alloc.html">multiset_scoped_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but uses <code>std::scoped_allocator_adaptor</code> so the allocator is inherited by all nested containers.     <a href="classwpi_1_1memory_1_1multiset__scoped__alloc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1no__mutex.html">no_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dummy <code>Mutex</code> class that does not lock anything.  <a href="structwpi_1_1memory_1_1no__mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1node__pool.html">node_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type defining a memory pool optimized for nodes.  <a href="structwpi_1_1memory_1_1node__pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1null__allocator.html">null_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A composable RawAllocator that will always fail.  <a href="classwpi_1_1memory_1_1null__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1out__of__fixed__memory.html">out_of_fixed_memory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special case of <a class="el" href="classwpi_1_1memory_1_1out__of__memory.html">out_of_memory</a> errors thrown when a low-level allocator with a fixed size runs out of memory.  <a href="classwpi_1_1memory_1_1out__of__fixed__memory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1out__of__memory.html">out_of_memory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when a low level allocator runs out of memory.  <a href="classwpi_1_1memory_1_1out__of__memory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1priority__queue.html">priority_queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template for an STL container that uses a certain RawAllocator.     <a href="classwpi_1_1memory_1_1priority__queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1priority__queue__scoped__alloc.html">priority_queue_scoped_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but uses <code>std::scoped_allocator_adaptor</code> so the allocator is inherited by all nested containers.     <a href="classwpi_1_1memory_1_1priority__queue__scoped__alloc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1propagation__traits.html">propagation_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the propagation of a <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a> for a certain RawAllocator.  <a href="structwpi_1_1memory_1_1propagation__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1propagation__traits_3_01joint__allocator_01_4.html">propagation_traits&lt; joint_allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="structwpi_1_1memory_1_1propagation__traits.html">propagation_traits</a> for the <a class="el" href="classwpi_1_1memory_1_1joint__allocator.html">joint_allocator</a>.  <a href="structwpi_1_1memory_1_1propagation__traits_3_01joint__allocator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1queue.html">queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template for an STL container that uses a certain RawAllocator.     <a href="classwpi_1_1memory_1_1queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1queue__scoped__alloc.html">queue_scoped_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but uses <code>std::scoped_allocator_adaptor</code> so the allocator is inherited by all nested containers.     <a href="classwpi_1_1memory_1_1queue__scoped__alloc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1reference__storage.html">reference_storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A StoragePolicy that stores a reference to an allocator.  <a href="classwpi_1_1memory_1_1reference__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1reference__storage_3_01any__allocator_01_4.html">reference_storage&lt; any_allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the class template <a class="el" href="classwpi_1_1memory_1_1reference__storage.html">reference_storage</a> that is type-erased.  <a href="classwpi_1_1memory_1_1reference__storage_3_01any__allocator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1segregator.html">segregator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates multiple nested <a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>.  <a href="classwpi_1_1memory_1_1segregator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1segregator__size.html">segregator_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of Segregatable a <a class="el" href="classwpi_1_1memory_1_1segregator.html">segregator</a> has.  <a href="structwpi_1_1memory_1_1segregator__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1set.html">set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template for an STL container that uses a certain RawAllocator.     <a href="classwpi_1_1memory_1_1set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1set__node__size.html">set_node_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the node size of a node based STL container with a specific type.     <a href="structwpi_1_1memory_1_1set__node__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1set__scoped__alloc.html">set_scoped_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but uses <code>std::scoped_allocator_adaptor</code> so the allocator is inherited by all nested containers.     <a href="classwpi_1_1memory_1_1set__scoped__alloc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1shared__ptr__node__size.html">shared_ptr_node_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the node size of a node based STL container with a specific type.     <a href="structwpi_1_1memory_1_1shared__ptr__node__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1small__node__pool.html">small_node_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type defining a memory pool optimized for small nodes.  <a href="structwpi_1_1memory_1_1small__node__pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1stack.html">stack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template for an STL container that uses a certain RawAllocator.     <a href="classwpi_1_1memory_1_1stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1stack__scoped__alloc.html">stack_scoped_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but uses <code>std::scoped_allocator_adaptor</code> so the allocator is inherited by all nested containers.     <a href="classwpi_1_1memory_1_1stack__scoped__alloc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1static__allocator.html">static_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stateful RawAllocator that uses a fixed sized storage for the allocations.  <a href="classwpi_1_1memory_1_1static__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1static__allocator__storage.html">static_allocator_storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for a <a class="el" href="classwpi_1_1memory_1_1static__allocator.html">static_allocator</a>.  <a href="structwpi_1_1memory_1_1static__allocator__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1static__block__allocator.html">static_block_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A BlockAllocator that allocates the blocks from a fixed size storage.  <a href="classwpi_1_1memory_1_1static__block__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a RawAllocator and makes it a "normal" <code>Allocator</code>.  <a href="classwpi_1_1memory_1_1std__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1string.html">string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template for an STL container that uses a certain RawAllocator.     <a href="classwpi_1_1memory_1_1string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1temporary__allocator.html">temporary_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stateful RawAllocator that handles temporary allocations.  <a href="classwpi_1_1memory_1_1temporary__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1temporary__stack.html">temporary_stack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around the <a class="el" href="classwpi_1_1memory_1_1memory__stack.html">memory_stack</a> that is used by the <a class="el" href="classwpi_1_1memory_1_1temporary__allocator.html">temporary_allocator</a>.  <a href="classwpi_1_1memory_1_1temporary__stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1temporary__stack__initializer.html">temporary_stack_initializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually takes care of the lifetime of the per-thread <a class="el" href="classwpi_1_1memory_1_1temporary__stack.html">temporary_stack</a>.  <a href="classwpi_1_1memory_1_1temporary__stack__initializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1thread__safe__allocator.html">thread_safe_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias template for <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a> using the <a class="el" href="classwpi_1_1memory_1_1direct__storage.html">direct_storage</a> policy with a mutex.  <a href="classwpi_1_1memory_1_1thread__safe__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1threshold__segregatable.html">threshold_segregatable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Segregatable that allocates until a maximum size.  <a href="classwpi_1_1memory_1_1threshold__segregatable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1tracked__allocator.html">tracked_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A RawAllocator adapter that tracks another allocator using a tracker.  <a href="classwpi_1_1memory_1_1tracked__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1tracked__block__allocator.html">tracked_block_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A BlockAllocator adapter that tracks another allocator using a tracker.  <a href="classwpi_1_1memory_1_1tracked__block__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1unique__base__ptr.html">unique_base_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>std::unique_ptr</code> that deletes using a RawAllocator and allows polymorphic types.  <a href="classwpi_1_1memory_1_1unique__base__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1unique__ptr.html">unique_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>std::unique_ptr</code> that deletes using a RawAllocator.  <a href="classwpi_1_1memory_1_1unique__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1unordered__map.html">unordered_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template for an STL container that uses a certain RawAllocator.     <a href="classwpi_1_1memory_1_1unordered__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1unordered__map__node__size.html">unordered_map_node_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the node size of a node based STL container with a specific type.     <a href="structwpi_1_1memory_1_1unordered__map__node__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1unordered__map__scoped__alloc.html">unordered_map_scoped_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but uses <code>std::scoped_allocator_adaptor</code> so the allocator is inherited by all nested containers.     <a href="classwpi_1_1memory_1_1unordered__map__scoped__alloc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1unordered__multimap.html">unordered_multimap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template for an STL container that uses a certain RawAllocator.     <a href="classwpi_1_1memory_1_1unordered__multimap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1unordered__multimap__node__size.html">unordered_multimap_node_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the node size of a node based STL container with a specific type.     <a href="structwpi_1_1memory_1_1unordered__multimap__node__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1unordered__multimap__scoped__alloc.html">unordered_multimap_scoped_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but uses <code>std::scoped_allocator_adaptor</code> so the allocator is inherited by all nested containers.     <a href="classwpi_1_1memory_1_1unordered__multimap__scoped__alloc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1unordered__multiset.html">unordered_multiset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template for an STL container that uses a certain RawAllocator.     <a href="classwpi_1_1memory_1_1unordered__multiset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1unordered__multiset__node__size.html">unordered_multiset_node_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the node size of a node based STL container with a specific type.     <a href="structwpi_1_1memory_1_1unordered__multiset__node__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1unordered__multiset__scoped__alloc.html">unordered_multiset_scoped_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but uses <code>std::scoped_allocator_adaptor</code> so the allocator is inherited by all nested containers.     <a href="classwpi_1_1memory_1_1unordered__multiset__scoped__alloc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1unordered__set.html">unordered_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template for an STL container that uses a certain RawAllocator.     <a href="classwpi_1_1memory_1_1unordered__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1unordered__set__node__size.html">unordered_set_node_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the node size of a node based STL container with a specific type.     <a href="structwpi_1_1memory_1_1unordered__set__node__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1unordered__set__scoped__alloc.html">unordered_set_scoped_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but uses <code>std::scoped_allocator_adaptor</code> so the allocator is inherited by all nested containers.     <a href="classwpi_1_1memory_1_1unordered__set__scoped__alloc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1vector.html">vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template for an STL container that uses a certain RawAllocator.  <a href="classwpi_1_1memory_1_1vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1vector__scoped__alloc.html">vector_scoped_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but uses <code>std::scoped_allocator_adaptor</code> so the allocator is inherited by all nested containers.  <a href="classwpi_1_1memory_1_1vector__scoped__alloc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1virtual__block__allocator.html">virtual_block_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A BlockAllocator that reserves virtual memory and commits it part by part.  <a href="classwpi_1_1memory_1_1virtual__block__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1virtual__memory__allocator.html">virtual_memory_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stateless RawAllocator that allocates memory using the virtual memory allocation functions.  <a href="classwpi_1_1memory_1_1virtual__memory__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9b49aa12f10a175d3d73cdbd089cdd14" id="r_ga9b49aa12f10a175d3d73cdbd089cdd14"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__allocator.html#ga9b49aa12f10a175d3d73cdbd089cdd14">heap_allocator</a></td></tr>
<tr class="memdesc:ga9b49aa12f10a175d3d73cdbd089cdd14"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stateless RawAllocator that allocates memory from the heap.  <br /></td></tr>
<tr class="separator:ga9b49aa12f10a175d3d73cdbd089cdd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5f1b034a97535516c8997b6c8a3cfd9" id="r_gab5f1b034a97535516c8997b6c8a3cfd9"><td class="memTemplParams" colspan="2">template&lt;class Tracker , class BlockOrRawAllocator &gt; </td></tr>
<tr class="memitem:gab5f1b034a97535516c8997b6c8a3cfd9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__adapter.html#gab5f1b034a97535516c8997b6c8a3cfd9">deeply_tracked_block_allocator</a></td></tr>
<tr class="memdesc:gab5f1b034a97535516c8997b6c8a3cfd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classwpi_1_1memory_1_1tracked__block__allocator.html">tracked_block_allocator</a>, but shares the tracker with the higher level allocator.  <br /></td></tr>
<tr class="separator:gab5f1b034a97535516c8997b6c8a3cfd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga457f611be747c344670e962e5f7da659" id="r_ga457f611be747c344670e962e5f7da659"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__storage.html#ga457f611be747c344670e962e5f7da659">any_reference_storage</a> = <a class="el" href="classwpi_1_1memory_1_1reference__storage.html">reference_storage</a>&lt;<a class="el" href="structwpi_1_1memory_1_1any__allocator.html">any_allocator</a>&gt;</td></tr>
<tr class="memdesc:ga457f611be747c344670e962e5f7da659"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for the <a class="el" href="classwpi_1_1memory_1_1reference__storage.html">reference_storage</a> specialization using type-erasure.  <br /></td></tr>
<tr class="separator:ga457f611be747c344670e962e5f7da659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71a278fa1dc8416f5aac057d83cf6364" id="r_ga71a278fa1dc8416f5aac057d83cf6364"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__storage.html#ga71a278fa1dc8416f5aac057d83cf6364">any_allocator_reference</a> = <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a>&lt;<a class="el" href="group__memory__storage.html#ga457f611be747c344670e962e5f7da659">any_reference_storage</a>, <a class="el" href="structwpi_1_1memory_1_1no__mutex.html">no_mutex</a>&gt;</td></tr>
<tr class="memdesc:ga71a278fa1dc8416f5aac057d83cf6364"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for <a class="el" href="classwpi_1_1memory_1_1allocator__storage.html">allocator_storage</a> using the <a class="el" href="group__memory__storage.html#ga457f611be747c344670e962e5f7da659">any_reference_storage</a>.  <br /></td></tr>
<tr class="separator:ga71a278fa1dc8416f5aac057d83cf6364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0f5f5e2c9d4625b38797d3dca598c76" id="r_gaa0f5f5e2c9d4625b38797d3dca598c76"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__allocator.html#gaa0f5f5e2c9d4625b38797d3dca598c76">default_allocator</a> = implementation_defined</td></tr>
<tr class="memdesc:gaa0f5f5e2c9d4625b38797d3dca598c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default RawAllocator that will be used as BlockAllocator in memory arenas.  <br /></td></tr>
<tr class="separator:gaa0f5f5e2c9d4625b38797d3dca598c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab733928ea0e3a61b72819ee79a658109" id="r_gab733928ea0e3a61b72819ee79a658109"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__allocator.html#gab733928ea0e3a61b72819ee79a658109">new_allocator</a></td></tr>
<tr class="memdesc:gab733928ea0e3a61b72819ee79a658109"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stateless RawAllocator that allocates memory using (nothrow) <code>operator new</code>.  <br /></td></tr>
<tr class="separator:gab733928ea0e3a61b72819ee79a658109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03961d3e711fd3cf853af44d4f2352fa" id="r_ga03961d3e711fd3cf853af44d4f2352fa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__allocator.html#ga03961d3e711fd3cf853af44d4f2352fa">malloc_allocator</a></td></tr>
<tr class="memdesc:ga03961d3e711fd3cf853af44d4f2352fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stateless RawAllocator that allocates memory using <code>std::malloc()</code>.  <br /></td></tr>
<tr class="separator:ga03961d3e711fd3cf853af44d4f2352fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c98b0ef7658d9beda86fa166f4c02fb" id="r_ga2c98b0ef7658d9beda86fa166f4c02fb"><td class="memTemplParams" colspan="2">template&lt;class BlockOrRawAllocator , template&lt; typename... &gt; class BlockAllocator = detail::default_block_wrapper&gt; </td></tr>
<tr class="memitem:ga2c98b0ef7658d9beda86fa166f4c02fb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__core.html#ga2c98b0ef7658d9beda86fa166f4c02fb">make_block_allocator_t</a></td></tr>
<tr class="memdesc:ga2c98b0ef7658d9beda86fa166f4c02fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes either a BlockAllocator or a RawAllocator.  <br /></td></tr>
<tr class="separator:ga2c98b0ef7658d9beda86fa166f4c02fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a0fece8ca703197ea9d82ffd20ccd05" id="r_ga8a0fece8ca703197ea9d82ffd20ccd05"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__core.html#ga8a0fece8ca703197ea9d82ffd20ccd05">leak_handler</a> = void (*)(const <a class="el" href="structwpi_1_1memory_1_1allocator__info.html">allocator_info</a>&amp; info, std::ptrdiff_t amount)</td></tr>
<tr class="memdesc:ga8a0fece8ca703197ea9d82ffd20ccd05"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the handler called when a memory leak is detected.  <br /></td></tr>
<tr class="separator:ga8a0fece8ca703197ea9d82ffd20ccd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4328906339679434218f91b2eb168ae" id="r_gab4328906339679434218f91b2eb168ae"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__core.html#gab4328906339679434218f91b2eb168ae">invalid_pointer_handler</a> = void (*)(const <a class="el" href="structwpi_1_1memory_1_1allocator__info.html">allocator_info</a>&amp; info, const void* <a class="el" href="format_8h.html#adb6e274f8eb0b74b2865215e1b49c535">ptr</a>)</td></tr>
<tr class="memdesc:gab4328906339679434218f91b2eb168ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the handler called when an invalid pointer is passed to a deallocation function.  <br /></td></tr>
<tr class="separator:gab4328906339679434218f91b2eb168ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga383a711a2f5768faf100865babda61b3" id="r_ga383a711a2f5768faf100865babda61b3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__core.html#ga383a711a2f5768faf100865babda61b3">buffer_overflow_handler</a></td></tr>
<tr class="memdesc:ga383a711a2f5768faf100865babda61b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the handler called when a buffer under/overflow is detected.  <br /></td></tr>
<tr class="separator:ga383a711a2f5768faf100865babda61b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gadea26fb93affed8c409ec360412d762e" id="r_gadea26fb93affed8c409ec360412d762e"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__core.html#gadea26fb93affed8c409ec360412d762e">debug_magic</a> : unsigned char { <br />
&#160;&#160;<a class="el" href="group__memory__core.html#ggadea26fb93affed8c409ec360412d762ea7bd4be20559c1a287369c8df4c117afe">debug_magic::internal_memory</a> = 0xAB
, <a class="el" href="group__memory__core.html#ggadea26fb93affed8c409ec360412d762eaa5c32a0fcc06d646d53c71b55c9cf5cb">debug_magic::internal_freed_memory</a> = 0xFB
, <a class="el" href="group__memory__core.html#ggadea26fb93affed8c409ec360412d762ea9e1988b82181dbe51272459a8ac8e0c0">debug_magic::new_memory</a> = 0xCD
, <a class="el" href="group__memory__core.html#ggadea26fb93affed8c409ec360412d762ea635e5f9da5635b909461fd93c09130ed">debug_magic::freed_memory</a> = 0xDD
, <br />
&#160;&#160;<a class="el" href="group__memory__core.html#ggadea26fb93affed8c409ec360412d762ea682318fff515ed43a48b718f46c21308">debug_magic::alignment_memory</a> = 0xED
, <a class="el" href="group__memory__core.html#ggadea26fb93affed8c409ec360412d762ea99ec421b05ddc9b5565897f6a0cfb360">debug_magic::fence_memory</a> = 0xFD
<br />
 }</td></tr>
<tr class="memdesc:gadea26fb93affed8c409ec360412d762e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The magic values that are used for debug filling.  <a href="group__memory__core.html#gadea26fb93affed8c409ec360412d762e">More...</a><br /></td></tr>
<tr class="separator:gadea26fb93affed8c409ec360412d762e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga48968808f543510ec82f603606907bfa" id="r_ga48968808f543510ec82f603606907bfa"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__allocator.html#ga48968808f543510ec82f603606907bfa">heap_alloc</a> (std::size_t size) noexcept</td></tr>
<tr class="memdesc:ga48968808f543510ec82f603606907bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates heap memory.  <br /></td></tr>
<tr class="separator:ga48968808f543510ec82f603606907bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c1515d80116d4e210dfc0476731c01d" id="r_ga3c1515d80116d4e210dfc0476731c01d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__allocator.html#ga3c1515d80116d4e210dfc0476731c01d">heap_dealloc</a> (void *<a class="el" href="format_8h.html#adb6e274f8eb0b74b2865215e1b49c535">ptr</a>, std::size_t size) noexcept</td></tr>
<tr class="memdesc:ga3c1515d80116d4e210dfc0476731c01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates heap memory.  <br /></td></tr>
<tr class="separator:ga3c1515d80116d4e210dfc0476731c01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f311d60d4857926d16396fc6a3be15a" id="r_a7f311d60d4857926d16396fc6a3be15a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1memory_1_1temporary__stack.html">temporary_stack</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f311d60d4857926d16396fc6a3be15a">get_temporary_stack</a> (std::size_t initial_size=<a class="el" href="classwpi_1_1memory_1_1temporary__stack__initializer.html#a0865fd66d723b06d205efe6a295bfa0c">temporary_stack_initializer::default_stack_size</a>)</td></tr>
<tr class="separator:a7f311d60d4857926d16396fc6a3be15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ab569e3fe7bed317ce2bc5de78cc46b" id="r_ga6ab569e3fe7bed317ce2bc5de78cc46b"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator , typename... Args&gt; </td></tr>
<tr class="memitem:ga6ab569e3fe7bed317ce2bc5de78cc46b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__adapter.html#ga6ab569e3fe7bed317ce2bc5de78cc46b">allocate_unique</a> (RawAllocator &amp;&amp;alloc, Args &amp;&amp;... args) -&gt;</td></tr>
<tr class="memdesc:ga6ab569e3fe7bed317ce2bc5de78cc46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code>std::unique_ptr</code> using a RawAllocator for the allocation.  <br /></td></tr>
<tr class="separator:ga6ab569e3fe7bed317ce2bc5de78cc46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2a5b01330a740730f4bc46b646bd085" id="r_gab2a5b01330a740730f4bc46b646bd085"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator , typename... Args&gt; </td></tr>
<tr class="memitem:gab2a5b01330a740730f4bc46b646bd085"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__adapter.html#gab2a5b01330a740730f4bc46b646bd085">allocate_unique</a> (<a class="el" href="structwpi_1_1memory_1_1any__allocator.html">any_allocator</a>, RawAllocator &amp;&amp;alloc, Args &amp;&amp;... args) -&gt;</td></tr>
<tr class="memdesc:gab2a5b01330a740730f4bc46b646bd085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code>std::unique_ptr</code> using a type-erased RawAllocator for the allocation.  <br /></td></tr>
<tr class="separator:gab2a5b01330a740730f4bc46b646bd085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga666fd882288f559a47e36577a62f4f30" id="r_ga666fd882288f559a47e36577a62f4f30"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:ga666fd882288f559a47e36577a62f4f30"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__adapter.html#ga666fd882288f559a47e36577a62f4f30">allocate_unique</a> (RawAllocator &amp;&amp;alloc, std::size_t size) -&gt;</td></tr>
<tr class="memdesc:ga666fd882288f559a47e36577a62f4f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code>std::unique_ptr</code> owning an array using a RawAllocator for the allocation.  <br /></td></tr>
<tr class="separator:ga666fd882288f559a47e36577a62f4f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga569e24230cc2d50d40b7ba45dae75a23" id="r_ga569e24230cc2d50d40b7ba45dae75a23"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:ga569e24230cc2d50d40b7ba45dae75a23"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__adapter.html#ga569e24230cc2d50d40b7ba45dae75a23">allocate_unique</a> (<a class="el" href="structwpi_1_1memory_1_1any__allocator.html">any_allocator</a>, RawAllocator &amp;&amp;alloc, std::size_t size) -&gt;</td></tr>
<tr class="memdesc:ga569e24230cc2d50d40b7ba45dae75a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code>std::unique_ptr</code> owning an array using a type-erased RawAllocator for the allocation.  <br /></td></tr>
<tr class="separator:ga569e24230cc2d50d40b7ba45dae75a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ad71e94176eddd2fe4eab53c41fca57" id="r_ga1ad71e94176eddd2fe4eab53c41fca57"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator , typename... Args&gt; </td></tr>
<tr class="memitem:ga1ad71e94176eddd2fe4eab53c41fca57"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__adapter.html#ga1ad71e94176eddd2fe4eab53c41fca57">allocate_shared</a> (RawAllocator &amp;&amp;alloc, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga1ad71e94176eddd2fe4eab53c41fca57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code>std::shared_ptr</code> using a RawAllocator for the allocation.  <br /></td></tr>
<tr class="separator:ga1ad71e94176eddd2fe4eab53c41fca57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1c35d9564850140e8d4b11f62a546c4" id="r_gac1c35d9564850140e8d4b11f62a546c4"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__allocator.html#gac1c35d9564850140e8d4b11f62a546c4">get_virtual_memory_page_size</a> () noexcept</td></tr>
<tr class="separator:gac1c35d9564850140e8d4b11f62a546c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1a7c43913988fb500fba5d302314152" id="r_gad1a7c43913988fb500fba5d302314152"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__allocator.html#gad1a7c43913988fb500fba5d302314152">virtual_memory_reserve</a> (std::size_t no_pages) noexcept</td></tr>
<tr class="memdesc:gad1a7c43913988fb500fba5d302314152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves virtual memory.  <br /></td></tr>
<tr class="separator:gad1a7c43913988fb500fba5d302314152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22132476ee264f257141467ef137fce0" id="r_ga22132476ee264f257141467ef137fce0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__allocator.html#ga22132476ee264f257141467ef137fce0">virtual_memory_release</a> (void *pages, std::size_t no_pages) noexcept</td></tr>
<tr class="memdesc:ga22132476ee264f257141467ef137fce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases reserved virtual memory.  <br /></td></tr>
<tr class="separator:ga22132476ee264f257141467ef137fce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22dd891cd2e42c178cf34b695c4cbd5f" id="r_ga22dd891cd2e42c178cf34b695c4cbd5f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__allocator.html#ga22dd891cd2e42c178cf34b695c4cbd5f">virtual_memory_commit</a> (void *memory, std::size_t no_pages) noexcept</td></tr>
<tr class="memdesc:ga22dd891cd2e42c178cf34b695c4cbd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commits reserved virtual memory.  <br /></td></tr>
<tr class="separator:ga22dd891cd2e42c178cf34b695c4cbd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadf2703a4f915416dcc1c90081b2d708" id="r_gaadf2703a4f915416dcc1c90081b2d708"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__allocator.html#gaadf2703a4f915416dcc1c90081b2d708">virtual_memory_decommit</a> (void *memory, std::size_t no_pages) noexcept</td></tr>
<tr class="memdesc:gaadf2703a4f915416dcc1c90081b2d708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decommits commited virtual memory.  <br /></td></tr>
<tr class="separator:gaadf2703a4f915416dcc1c90081b2d708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24426d9ba265765e4762dd23e2a9f70a" id="r_a24426d9ba265765e4762dd23e2a9f70a"><td class="memTemplParams" colspan="2">template&lt;class RawAllocator &gt; </td></tr>
<tr class="memitem:a24426d9ba265765e4762dd23e2a9f70a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1memory_1_1threshold__segregatable.html">threshold_segregatable</a>&lt; typename std::decay&lt; RawAllocator &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a24426d9ba265765e4762dd23e2a9f70a">threshold</a> (std::size_t max_size, RawAllocator &amp;&amp;alloc)</td></tr>
<tr class="separator:a24426d9ba265765e4762dd23e2a9f70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga834abe9622c747efdfa8619009d2e373" id="r_ga834abe9622c747efdfa8619009d2e373"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__memory__core.html#ga8a0fece8ca703197ea9d82ffd20ccd05">leak_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__core.html#ga834abe9622c747efdfa8619009d2e373">set_leak_handler</a> (<a class="el" href="group__memory__core.html#ga8a0fece8ca703197ea9d82ffd20ccd05">leak_handler</a> h)</td></tr>
<tr class="memdesc:ga834abe9622c747efdfa8619009d2e373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the <a class="el" href="group__memory__core.html#ga8a0fece8ca703197ea9d82ffd20ccd05">leak_handler</a>.  <br /></td></tr>
<tr class="separator:ga834abe9622c747efdfa8619009d2e373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa60befedaaf9af29fcf7ce4aa837cc6e" id="r_gaa60befedaaf9af29fcf7ce4aa837cc6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__memory__core.html#ga8a0fece8ca703197ea9d82ffd20ccd05">leak_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__core.html#gaa60befedaaf9af29fcf7ce4aa837cc6e">get_leak_handler</a> ()</td></tr>
<tr class="memdesc:gaa60befedaaf9af29fcf7ce4aa837cc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="group__memory__core.html#ga8a0fece8ca703197ea9d82ffd20ccd05">leak_handler</a>.  <br /></td></tr>
<tr class="separator:gaa60befedaaf9af29fcf7ce4aa837cc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8d5aef2a6a2d4e65cfcc0eeac06c02b" id="r_gab8d5aef2a6a2d4e65cfcc0eeac06c02b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__memory__core.html#gab4328906339679434218f91b2eb168ae">invalid_pointer_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__core.html#gab8d5aef2a6a2d4e65cfcc0eeac06c02b">set_invalid_pointer_handler</a> (<a class="el" href="group__memory__core.html#gab4328906339679434218f91b2eb168ae">invalid_pointer_handler</a> h)</td></tr>
<tr class="memdesc:gab8d5aef2a6a2d4e65cfcc0eeac06c02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the <a class="el" href="group__memory__core.html#gab4328906339679434218f91b2eb168ae">invalid_pointer_handler</a>.  <br /></td></tr>
<tr class="separator:gab8d5aef2a6a2d4e65cfcc0eeac06c02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34d9478573193d39208d340a6586f8a1" id="r_ga34d9478573193d39208d340a6586f8a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__memory__core.html#gab4328906339679434218f91b2eb168ae">invalid_pointer_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__core.html#ga34d9478573193d39208d340a6586f8a1">get_invalid_pointer_handler</a> ()</td></tr>
<tr class="memdesc:ga34d9478573193d39208d340a6586f8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="group__memory__core.html#gab4328906339679434218f91b2eb168ae">invalid_pointer_handler</a>.  <br /></td></tr>
<tr class="separator:ga34d9478573193d39208d340a6586f8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93b00d2fd1d3cd1f85f5331cf843fac3" id="r_ga93b00d2fd1d3cd1f85f5331cf843fac3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__memory__core.html#ga383a711a2f5768faf100865babda61b3">buffer_overflow_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__core.html#ga93b00d2fd1d3cd1f85f5331cf843fac3">set_buffer_overflow_handler</a> (<a class="el" href="group__memory__core.html#ga383a711a2f5768faf100865babda61b3">buffer_overflow_handler</a> h)</td></tr>
<tr class="memdesc:ga93b00d2fd1d3cd1f85f5331cf843fac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the <a class="el" href="group__memory__core.html#ga383a711a2f5768faf100865babda61b3">buffer_overflow_handler</a>.  <br /></td></tr>
<tr class="separator:ga93b00d2fd1d3cd1f85f5331cf843fac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddb4989826b25f0f3d833c871cd74a0d" id="r_gaddb4989826b25f0f3d833c871cd74a0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__memory__core.html#ga383a711a2f5768faf100865babda61b3">buffer_overflow_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__core.html#gaddb4989826b25f0f3d833c871cd74a0d">get_buffer_overflow_handler</a> ()</td></tr>
<tr class="memdesc:gaddb4989826b25f0f3d833c871cd74a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="group__memory__core.html#ga383a711a2f5768faf100865babda61b3">buffer_overflow_handler</a>.  <br /></td></tr>
<tr class="separator:gaddb4989826b25f0f3d833c871cd74a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f311d60d4857926d16396fc6a3be15a" id="r_a7f311d60d4857926d16396fc6a3be15a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1memory_1_1temporary__stack.html">temporary_stack</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1temporary__stack.html#a7f311d60d4857926d16396fc6a3be15a">get_temporary_stack</a> (std::size_t initial_size=<a class="el" href="classwpi_1_1memory_1_1temporary__stack__initializer.html#a0865fd66d723b06d205efe6a295bfa0c">temporary_stack_initializer::default_stack_size</a>)</td></tr>
<tr class="separator:a7f311d60d4857926d16396fc6a3be15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15a6de6bb77fc58b63b3d387656b61d" id="r_ac15a6de6bb77fc58b63b3d387656b61d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , class Impl &gt; </td></tr>
<tr class="memitem:ac15a6de6bb77fc58b63b3d387656b61d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1std__allocator.html#ac15a6de6bb77fc58b63b3d387656b61d">operator==</a> (const <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, Impl &gt; &amp;lhs, const <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; U, Impl &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ac15a6de6bb77fc58b63b3d387656b61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade728d2962d0d3f292e4286f666044cd" id="r_ade728d2962d0d3f292e4286f666044cd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , class Impl &gt; </td></tr>
<tr class="memitem:ade728d2962d0d3f292e4286f666044cd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1std__allocator.html#ade728d2962d0d3f292e4286f666044cd">operator!=</a> (const <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, Impl &gt; &amp;lhs, const <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; U, Impl &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ade728d2962d0d3f292e4286f666044cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bb35bfde10edb491e593b1938f1614" id="r_ad4bb35bfde10edb491e593b1938f1614"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:ad4bb35bfde10edb491e593b1938f1614"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1std__allocator.html#ad4bb35bfde10edb491e593b1938f1614">make_std_allocator</a> (RawAllocator &amp;&amp;allocator) noexcept -&gt; <a class="el" href="classwpi_1_1memory_1_1std__allocator.html">std_allocator</a>&lt; T, typename std::decay&lt; RawAllocator &gt;::type &gt;</td></tr>
<tr class="separator:ad4bb35bfde10edb491e593b1938f1614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8c2aa43d28190826bdccc1bd1e5879" id="r_aeb8c2aa43d28190826bdccc1bd1e5879"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:aeb8c2aa43d28190826bdccc1bd1e5879"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1memory_1_1any__std__allocator.html">any_std_allocator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1any__std__allocator.html#aeb8c2aa43d28190826bdccc1bd1e5879">make_any_std_allocator</a> (RawAllocator &amp;&amp;allocator) noexcept</td></tr>
<tr class="separator:aeb8c2aa43d28190826bdccc1bd1e5879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae213bfb960bfc3c2779841efc97b6a79" id="r_ae213bfb960bfc3c2779841efc97b6a79"><td class="memTemplParams" colspan="2">template&lt;class Tracker , class RawAllocator &gt; </td></tr>
<tr class="memitem:ae213bfb960bfc3c2779841efc97b6a79"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1tracked__allocator.html#ae213bfb960bfc3c2779841efc97b6a79">make_tracked_allocator</a> (Tracker t, RawAllocator &amp;&amp;alloc) -&gt; <a class="el" href="classwpi_1_1memory_1_1tracked__allocator.html">tracked_allocator</a>&lt; Tracker, typename std::decay&lt; RawAllocator &gt;::type &gt;</td></tr>
<tr class="separator:ae213bfb960bfc3c2779841efc97b6a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad946cba33e16c42c37a042a4b3ba1bed" id="r_ad946cba33e16c42c37a042a4b3ba1bed"><td class="memTemplParams" colspan="2">template&lt;class RawAllocator , class Tracker , typename... Args&gt; </td></tr>
<tr class="memitem:ad946cba33e16c42c37a042a4b3ba1bed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1deeply__tracked__allocator.html#ad946cba33e16c42c37a042a4b3ba1bed">make_deeply_tracked_allocator</a> (Tracker t, Args &amp;&amp;... args) -&gt; <a class="el" href="classwpi_1_1memory_1_1deeply__tracked__allocator.html">deeply_tracked_allocator</a>&lt; Tracker, RawAllocator &gt;</td></tr>
<tr class="separator:ad946cba33e16c42c37a042a4b3ba1bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a54dd2f73b0157da83742c212599a2" id="r_aa5a54dd2f73b0157da83742c212599a2"><td class="memTemplParams" colspan="2">template&lt;class RawAllocator &gt; </td></tr>
<tr class="memitem:aa5a54dd2f73b0157da83742c212599a2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__adapter.html#aa5a54dd2f73b0157da83742c212599a2">make_allocator_adapter</a> (RawAllocator &amp;&amp;allocator) noexcept -&gt; <a class="el" href="classwpi_1_1memory_1_1allocator__adapter.html">allocator_adapter</a>&lt; typename std::decay&lt; RawAllocator &gt;::type &gt;</td></tr>
<tr class="separator:aa5a54dd2f73b0157da83742c212599a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e71d2d611c906a547cc9565f9a00d7" id="r_a61e71d2d611c906a547cc9565f9a00d7"><td class="memTemplParams" colspan="2">template&lt;class Mutex , class RawAllocator &gt; </td></tr>
<tr class="memitem:a61e71d2d611c906a547cc9565f9a00d7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1thread__safe__allocator.html#a61e71d2d611c906a547cc9565f9a00d7">make_thread_safe_allocator</a> (RawAllocator &amp;&amp;allocator) -&gt; <a class="el" href="classwpi_1_1memory_1_1thread__safe__allocator.html">thread_safe_allocator</a>&lt; typename std::decay&lt; RawAllocator &gt;::type, Mutex &gt;</td></tr>
<tr class="separator:a61e71d2d611c906a547cc9565f9a00d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704415b59f769d1578478a9fbbbab698" id="r_a704415b59f769d1578478a9fbbbab698"><td class="memTemplParams" colspan="2">template&lt;class RawAllocator &gt; </td></tr>
<tr class="memitem:a704415b59f769d1578478a9fbbbab698"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__reference.html#a704415b59f769d1578478a9fbbbab698">make_allocator_reference</a> (RawAllocator &amp;&amp;allocator) noexcept -&gt; <a class="el" href="classwpi_1_1memory_1_1allocator__reference.html">allocator_reference</a>&lt; typename std::decay&lt; RawAllocator &gt;::type &gt;</td></tr>
<tr class="separator:a704415b59f769d1578478a9fbbbab698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e3f2e61ea938eaa4f45e603e4c027e" id="r_a49e3f2e61ea938eaa4f45e603e4c027e"><td class="memTemplParams" colspan="2">template&lt;class RawAllocator &gt; </td></tr>
<tr class="memitem:a49e3f2e61ea938eaa4f45e603e4c027e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1aligned__allocator.html#a49e3f2e61ea938eaa4f45e603e4c027e">make_aligned_allocator</a> (std::size_t min_alignment, RawAllocator &amp;&amp;allocator) noexcept -&gt; <a class="el" href="classwpi_1_1memory_1_1aligned__allocator.html">aligned_allocator</a>&lt; typename std::decay&lt; RawAllocator &gt;::type &gt;</td></tr>
<tr class="separator:a49e3f2e61ea938eaa4f45e603e4c027e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b04188f7ced9f0a29006efc9c7f648e" id="r_a2b04188f7ced9f0a29006efc9c7f648e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a2b04188f7ced9f0a29006efc9c7f648e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1segregator.html#a2b04188f7ced9f0a29006efc9c7f648e">make_segregator</a> (Args &amp;&amp;... args) -&gt; <a class="el" href="classwpi_1_1memory_1_1segregator.html">segregator</a>&lt; typename std::decay&lt; Args &gt;::type... &gt;</td></tr>
<tr class="separator:a2b04188f7ced9f0a29006efc9c7f648e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3083c047d212b6d52b8ba27431d0d8e2" id="r_a3083c047d212b6d52b8ba27431d0d8e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3083c047d212b6d52b8ba27431d0d8e2">operator!=</a> (const <a class="el" href="classwpi_1_1memory_1_1memory__resource__allocator.html">memory_resource_allocator</a> &amp;lhs, const <a class="el" href="classwpi_1_1memory_1_1memory__resource__allocator.html">memory_resource_allocator</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:a3083c047d212b6d52b8ba27431d0d8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga1d38ee5d6a9b2d723f259c2c4607622f" id="r_ga1d38ee5d6a9b2d723f259c2c4607622f"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator , class Container  = deque&lt;T, RawAllocator&gt;&gt; </td></tr>
<tr class="memitem:ga1d38ee5d6a9b2d723f259c2c4607622f"><td class="memTemplItemLeft" align="right" valign="top">std::stack&lt; T, Container &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__adapter.html#ga1d38ee5d6a9b2d723f259c2c4607622f">make_stack</a> (RawAllocator &amp;allocator)</td></tr>
<tr class="separator:ga1d38ee5d6a9b2d723f259c2c4607622f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab060b6ef926a7d11d224db99f19bf708" id="r_gab060b6ef926a7d11d224db99f19bf708"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator , class Container  = deque&lt;T, RawAllocator&gt;&gt; </td></tr>
<tr class="memitem:gab060b6ef926a7d11d224db99f19bf708"><td class="memTemplItemLeft" align="right" valign="top">std::queue&lt; T, Container &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__adapter.html#gab060b6ef926a7d11d224db99f19bf708">make_queue</a> (RawAllocator &amp;allocator)</td></tr>
<tr class="separator:gab060b6ef926a7d11d224db99f19bf708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37f596862c12bf216230bf62df611014" id="r_ga37f596862c12bf216230bf62df611014"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator , class Container  = deque&lt;T, RawAllocator&gt;, class Compare  = std::less&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga37f596862c12bf216230bf62df611014"><td class="memTemplItemLeft" align="right" valign="top">std::priority_queue&lt; T, Container, Compare &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__adapter.html#ga37f596862c12bf216230bf62df611014">make_priority_queue</a> (RawAllocator &amp;allocator, Compare comp={})</td></tr>
<tr class="separator:ga37f596862c12bf216230bf62df611014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaadbfe56850e983927e8a47d82b565f1e" id="r_gaadbfe56850e983927e8a47d82b565f1e"><td class="memTemplParams" colspan="2">template&lt;class BlockOrRawAllocator , typename... Args&gt; </td></tr>
<tr class="memitem:gaadbfe56850e983927e8a47d82b565f1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__memory__core.html#ga2c98b0ef7658d9beda86fa166f4c02fb">make_block_allocator_t</a>&lt; BlockOrRawAllocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__core.html#gaadbfe56850e983927e8a47d82b565f1e">make_block_allocator</a> (std::size_t block_size, Args &amp;&amp;... args)</td></tr>
<tr class="separator:gaadbfe56850e983927e8a47d82b565f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2818c818ef45e69d31b01b11e0e8bb7b" id="r_ga2818c818ef45e69d31b01b11e0e8bb7b"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class BlockAllocator, class BlockOrRawAllocator , typename... Args&gt; </td></tr>
<tr class="memitem:ga2818c818ef45e69d31b01b11e0e8bb7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__memory__core.html#ga2c98b0ef7658d9beda86fa166f4c02fb">make_block_allocator_t</a>&lt; BlockOrRawAllocator, BlockAllocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__core.html#ga2818c818ef45e69d31b01b11e0e8bb7b">make_block_allocator</a> (std::size_t block_size, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ga2818c818ef45e69d31b01b11e0e8bb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adc89098b5cf93bab9d2ec6629d0af4f6" id="r_adc89098b5cf93bab9d2ec6629d0af4f6"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:adc89098b5cf93bab9d2ec6629d0af4f6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adc89098b5cf93bab9d2ec6629d0af4f6">operator==</a> (std::nullptr_t, const <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt; &amp;<a class="el" href="format_8h.html#adb6e274f8eb0b74b2865215e1b49c535">ptr</a>)</td></tr>
<tr class="separator:adc89098b5cf93bab9d2ec6629d0af4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9341e2480e1ebc5809c6e2e08fd48102" id="r_a9341e2480e1ebc5809c6e2e08fd48102"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:a9341e2480e1ebc5809c6e2e08fd48102"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9341e2480e1ebc5809c6e2e08fd48102">operator==</a> (T *p, const <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt; &amp;<a class="el" href="format_8h.html#adb6e274f8eb0b74b2865215e1b49c535">ptr</a>)</td></tr>
<tr class="separator:a9341e2480e1ebc5809c6e2e08fd48102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af5264ae0d5d04ad3175df9f5063ecaa4" id="r_af5264ae0d5d04ad3175df9f5063ecaa4"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:af5264ae0d5d04ad3175df9f5063ecaa4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af5264ae0d5d04ad3175df9f5063ecaa4">operator!=</a> (std::nullptr_t, const <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt; &amp;<a class="el" href="format_8h.html#adb6e274f8eb0b74b2865215e1b49c535">ptr</a>)</td></tr>
<tr class="separator:af5264ae0d5d04ad3175df9f5063ecaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abf70288c708a52bf2cc49f97389179e1" id="r_abf70288c708a52bf2cc49f97389179e1"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator &gt; </td></tr>
<tr class="memitem:abf70288c708a52bf2cc49f97389179e1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abf70288c708a52bf2cc49f97389179e1">operator!=</a> (T *p, const <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt; &amp;<a class="el" href="format_8h.html#adb6e274f8eb0b74b2865215e1b49c535">ptr</a>)</td></tr>
<tr class="separator:abf70288c708a52bf2cc49f97389179e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaa386e46d510b33b9ccd41de08abab54b" id="r_gaa386e46d510b33b9ccd41de08abab54b"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator , typename... Args&gt; </td></tr>
<tr class="memitem:gaa386e46d510b33b9ccd41de08abab54b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__allocator.html#gaa386e46d510b33b9ccd41de08abab54b">allocate_joint</a> (RawAllocator &amp;alloc, <a class="el" href="structwpi_1_1memory_1_1joint__size.html">joint_size</a> additional_size, Args &amp;&amp;... args) -&gt; <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt;</td></tr>
<tr class="separator:gaa386e46d510b33b9ccd41de08abab54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bbc913798578781b6dea3d4aeae8a0e" id="r_ga2bbc913798578781b6dea3d4aeae8a0e"><td class="memTemplParams" colspan="2">template&lt;typename T , class RawAllocator , typename... Args&gt; </td></tr>
<tr class="memitem:ga2bbc913798578781b6dea3d4aeae8a0e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__allocator.html#ga2bbc913798578781b6dea3d4aeae8a0e">allocate_joint</a> (const RawAllocator &amp;alloc, <a class="el" href="structwpi_1_1memory_1_1joint__size.html">joint_size</a> additional_size, Args &amp;&amp;... args) -&gt; <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt;</td></tr>
<tr class="separator:ga2bbc913798578781b6dea3d4aeae8a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaf36e52257430764b51aa6f8938124dfe" id="r_gaf36e52257430764b51aa6f8938124dfe"><td class="memTemplParams" colspan="2">template&lt;class RawAllocator , typename T &gt; </td></tr>
<tr class="memitem:gaf36e52257430764b51aa6f8938124dfe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__allocator.html#gaf36e52257430764b51aa6f8938124dfe">clone_joint</a> (RawAllocator &amp;alloc, const <a class="el" href="classwpi_1_1memory_1_1joint__type.html">joint_type</a>&lt; T &gt; &amp;<a class="el" href="classwpi_1_1memory_1_1joint.html">joint</a>) -&gt; <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt;</td></tr>
<tr class="separator:gaf36e52257430764b51aa6f8938124dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39c25e85f4a787cb798de13ea70d16ca" id="r_ga39c25e85f4a787cb798de13ea70d16ca"><td class="memTemplParams" colspan="2">template&lt;class RawAllocator , typename T &gt; </td></tr>
<tr class="memitem:ga39c25e85f4a787cb798de13ea70d16ca"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__allocator.html#ga39c25e85f4a787cb798de13ea70d16ca">clone_joint</a> (const RawAllocator &amp;alloc, const <a class="el" href="classwpi_1_1memory_1_1joint__type.html">joint_type</a>&lt; T &gt; &amp;<a class="el" href="classwpi_1_1memory_1_1joint.html">joint</a>) -&gt; <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt;</td></tr>
<tr class="separator:ga39c25e85f4a787cb798de13ea70d16ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aac1cd336eb08ccc5224fa69660fd47a6" id="r_aac1cd336eb08ccc5224fa69660fd47a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac1cd336eb08ccc5224fa69660fd47a6">operator!=</a> (const <a class="el" href="classwpi_1_1memory_1_1joint__allocator.html">joint_allocator</a> &amp;lhs, const <a class="el" href="classwpi_1_1memory_1_1joint__allocator.html">joint_allocator</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:aac1cd336eb08ccc5224fa69660fd47a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a77b62de1899448095fcf1a01b8d57ff4" id="r_a77b62de1899448095fcf1a01b8d57ff4"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class Segregator , class Fallback &gt; </td></tr>
<tr class="memitem:a77b62de1899448095fcf1a01b8d57ff4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a77b62de1899448095fcf1a01b8d57ff4">get_segregatable_allocator</a> (const <a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt; Segregator, Fallback &gt; &amp;s) -&gt; const segregatable_allocator_type&lt; I, <a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt; Segregator, Fallback &gt; &gt;</td></tr>
<tr class="separator:a77b62de1899448095fcf1a01b8d57ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5d1928bde45f651f7a9e6f02a76beb44" id="r_a5d1928bde45f651f7a9e6f02a76beb44"><td class="memTemplParams" colspan="2">template&lt;class Segregator , class Fallback &gt; </td></tr>
<tr class="memitem:a5d1928bde45f651f7a9e6f02a76beb44"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5d1928bde45f651f7a9e6f02a76beb44">get_fallback_allocator</a> (const <a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt; Segregator, Fallback &gt; &amp;s) -&gt; const fallback_allocator_type&lt; <a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt; Segregator, Fallback &gt; &gt; &amp;</td></tr>
<tr class="separator:a5d1928bde45f651f7a9e6f02a76beb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga638f9e52b33b10f14e50de5beb306976" id="r_ga638f9e52b33b10f14e50de5beb306976"><td class="memItemLeft" align="right" valign="top">const std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__allocator.html#ga638f9e52b33b10f14e50de5beb306976">virtual_memory_page_size</a></td></tr>
<tr class="memdesc:ga638f9e52b33b10f14e50de5beb306976"><td class="mdescLeft">&#160;</td><td class="mdescRight">The page size of the virtual memory.  <br /></td></tr>
<tr class="separator:ga638f9e52b33b10f14e50de5beb306976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga71ad064608460ad27607935f45a0ca69" id="r_ga71ad064608460ad27607935f45a0ca69"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__core.html#ga71ad064608460ad27607935f45a0ca69">cached_arena</a> = true</td></tr>
<tr class="separator:ga71ad064608460ad27607935f45a0ca69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad457e2d02a734d669ba2490d2e4b0ef8" id="r_gad457e2d02a734d669ba2490d2e4b0ef8"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory__core.html#gad457e2d02a734d669ba2490d2e4b0ef8">uncached_arena</a> = false</td></tr>
<tr class="separator:gad457e2d02a734d669ba2490d2e4b0ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Memory namespace. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a5d1928bde45f651f7a9e6f02a76beb44" name="a5d1928bde45f651f7a9e6f02a76beb44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1928bde45f651f7a9e6f02a76beb44">&#9670;&#160;</a></span>get_fallback_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Segregator , class Fallback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::memory::get_fallback_allocator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt; Segregator, Fallback &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> -&gt; const fallback_allocator_type&lt;<a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt;Segregator, Fallback&gt;&gt;&amp;
        </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77b62de1899448095fcf1a01b8d57ff4" name="a77b62de1899448095fcf1a01b8d57ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b62de1899448095fcf1a01b8d57ff4">&#9670;&#160;</a></span>get_segregatable_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, class Segregator , class Fallback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto wpi::memory::get_segregatable_allocator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt; Segregator, Fallback &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> -&gt; const segregatable_allocator_type&lt;I, <a class="el" href="classwpi_1_1memory_1_1binary__segregator.html">binary_segregator</a>&lt;Segregator, Fallback&gt;&gt;
        </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f311d60d4857926d16396fc6a3be15a" name="a7f311d60d4857926d16396fc6a3be15a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f311d60d4857926d16396fc6a3be15a">&#9670;&#160;</a></span>get_temporary_stack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1memory_1_1temporary__stack.html">temporary_stack</a> &amp; get_temporary_stack </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>initial_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classwpi_1_1memory_1_1temporary__stack__initializer.html#a0865fd66d723b06d205efe6a295bfa0c">temporary_stack_initializer::default_stack_size</a></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Creates the per-thread <a class="el" href="classwpi_1_1memory_1_1temporary__stack.html">temporary_stack</a> with the given initial size, if it wasn't already created. </dd></dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The per-thread <a class="el" href="classwpi_1_1memory_1_1temporary__stack.html">temporary_stack</a>. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd>There must be a per-thread temporary stack (<a class="el" href="group__memory__allocator.html#ga1cf12a43d0d3af418c32a76a4572eb57">WPI_MEMORY_TEMPORARY_STACK_MODE</a> must not be equal to <code>0</code>). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <a class="el" href="group__memory__allocator.html#ga1cf12a43d0d3af418c32a76a4572eb57">WPI_MEMORY_TEMPORARY_STACK_MODE</a> is equal to <code>1</code>, this function can create the temporary stack. But if there is no <a class="el" href="classwpi_1_1memory_1_1temporary__stack__initializer.html">temporary_stack_initializer</a>, it won't be destroyed. </dd></dl>

</div>
</div>
<a id="aac1cd336eb08ccc5224fa69660fd47a6" name="aac1cd336eb08ccc5224fa69660fd47a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1cd336eb08ccc5224fa69660fd47a6">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::memory::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1memory_1_1joint__allocator.html">joint_allocator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1memory_1_1joint__allocator.html">joint_allocator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3083c047d212b6d52b8ba27431d0d8e2" name="a3083c047d212b6d52b8ba27431d0d8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3083c047d212b6d52b8ba27431d0d8e2">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::memory::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1memory_1_1memory__resource__allocator.html">memory_resource_allocator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1memory_1_1memory__resource__allocator.html">memory_resource_allocator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5264ae0d5d04ad3175df9f5063ecaa4" name="af5264ae0d5d04ad3175df9f5063ecaa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5264ae0d5d04ad3175df9f5063ecaa4">&#9670;&#160;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::memory::operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf70288c708a52bf2cc49f97389179e1" name="abf70288c708a52bf2cc49f97389179e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf70288c708a52bf2cc49f97389179e1">&#9670;&#160;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::memory::operator!= </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adc89098b5cf93bab9d2ec6629d0af4f6" name="adc89098b5cf93bab9d2ec6629d0af4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc89098b5cf93bab9d2ec6629d0af4f6">&#9670;&#160;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::memory::operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9341e2480e1ebc5809c6e2e08fd48102" name="a9341e2480e1ebc5809c6e2e08fd48102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9341e2480e1ebc5809c6e2e08fd48102">&#9670;&#160;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::memory::operator== </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1memory_1_1joint__ptr.html">joint_ptr</a>&lt; T, RawAllocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24426d9ba265765e4762dd23e2a9f70a" name="a24426d9ba265765e4762dd23e2a9f70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24426d9ba265765e4762dd23e2a9f70a">&#9670;&#160;</a></span>threshold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RawAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1memory_1_1threshold__segregatable.html">threshold_segregatable</a>&lt; typename std::decay&lt; RawAllocator &gt;::type &gt; wpi::memory::threshold </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RawAllocator &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>A <a class="el" href="classwpi_1_1memory_1_1threshold__segregatable.html">threshold_segregatable</a> with the same parameter. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacewpi.html">wpi</a></li><li class="navelem"><a class="el" href="namespacewpi_1_1memory.html">memory</a></li>
    <li class="footer">Generated on Sun Oct 13 2024 07:19:02 for WPILibC++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
