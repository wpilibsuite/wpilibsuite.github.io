<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: Core components</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="wpilib-128.png"/></td>
  <td id="projectalign">
   <div id="projectname">WPILibC++<span id="projectnumber">&#160;2025.1.1-beta-1-35-g9a5f73d</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__memory__core.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Core components<div class="ingroups"><a class="el" href="group__memory.html">Memory Allocator Library</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1allocator__info.html">wpi::memory::allocator_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains information about an allocator.  <a href="structwpi_1_1memory_1_1allocator__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1out__of__memory.html">wpi::memory::out_of_memory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when a low level allocator runs out of memory.  <a href="classwpi_1_1memory_1_1out__of__memory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1out__of__fixed__memory.html">wpi::memory::out_of_fixed_memory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special case of <a class="el" href="classwpi_1_1memory_1_1out__of__memory.html">out_of_memory</a> errors thrown when a low-level allocator with a fixed size runs out of memory.  <a href="classwpi_1_1memory_1_1out__of__fixed__memory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1bad__allocation__size.html">wpi::memory::bad_allocation_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when an allocation size is bigger than the supported maximum.  <a href="classwpi_1_1memory_1_1bad__allocation__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1bad__node__size.html">wpi::memory::bad_node_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when the node size exceeds the supported maximum, i.e.  <a href="classwpi_1_1memory_1_1bad__node__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1bad__array__size.html">wpi::memory::bad_array_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when the array size exceeds the supported maximum, i.e.  <a href="classwpi_1_1memory_1_1bad__array__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1bad__alignment.html">wpi::memory::bad_alignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when the alignment exceeds the supported maximum, i.e.  <a href="classwpi_1_1memory_1_1bad__alignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1memory__block.html">wpi::memory::memory_block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory block.  <a href="structwpi_1_1memory_1_1memory__block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1is__block__allocator.html">wpi::memory::is_block_allocator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits that check whether a type models concept BlockAllocator.  <a href="structwpi_1_1memory_1_1is__block__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1memory__arena.html">wpi::memory::memory_arena&lt; BlockAllocator, Cached &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory arena that manages huge memory blocks for a higher-level allocator.  <a href="classwpi_1_1memory_1_1memory__arena.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1allocator__is__raw__allocator.html">wpi::memory::allocator_is_raw_allocator&lt; Allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class that checks whether or not a standard <code>Allocator</code> can be used as RawAllocator.  <a href="structwpi_1_1memory_1_1allocator__is__raw__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1allocator__is__raw__allocator_3_01std_1_1allocator_3_01_t_01_4_01_4.html">wpi::memory::allocator_is_raw_allocator&lt; std::allocator&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structwpi_1_1memory_1_1allocator__is__raw__allocator.html">allocator_is_raw_allocator</a> that allows <code>std::allocator</code> again.  <a href="structwpi_1_1memory_1_1allocator__is__raw__allocator_3_01std_1_1allocator_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1allocator__traits.html">wpi::memory::allocator_traits&lt; Allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default specialization of the <a class="el" href="classwpi_1_1memory_1_1allocator__traits.html" title="The default specialization of the allocator_traits for a RawAllocator.">allocator_traits</a> for a RawAllocator.  <a href="classwpi_1_1memory_1_1allocator__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1is__raw__allocator.html">wpi::memory::is_raw_allocator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits that check whether a type models concept RawAllocator.  <a href="structwpi_1_1memory_1_1is__raw__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwpi_1_1memory_1_1composable__allocator__traits.html">wpi::memory::composable_allocator_traits&lt; Allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default specialization of the <a class="el" href="classwpi_1_1memory_1_1composable__allocator__traits.html" title="The default specialization of the composable_allocator_traits for a ComposableAllocator.">composable_allocator_traits</a> for a ComposableAllocator.  <a href="classwpi_1_1memory_1_1composable__allocator__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1is__composable__allocator.html">wpi::memory::is_composable_allocator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits that check whether a type models concept ComposableAllocator.  <a href="structwpi_1_1memory_1_1is__composable__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1no__mutex.html">wpi::memory::no_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dummy <code>Mutex</code> class that does not lock anything.  <a href="structwpi_1_1memory_1_1no__mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwpi_1_1memory_1_1is__thread__safe__allocator.html">wpi::memory::is_thread_safe_allocator&lt; RawAllocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether or not a RawAllocator is thread safe as-is.  <a href="structwpi_1_1memory_1_1is__thread__safe__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gacdaebb1f6c1ae385eb6cfa31e0da8ae6" id="r_gacdaebb1f6c1ae385eb6cfa31e0da8ae6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacdaebb1f6c1ae385eb6cfa31e0da8ae6">WPI_MEMORY_VERSION_MAJOR</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gacdaebb1f6c1ae385eb6cfa31e0da8ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The major version number.  <br /></td></tr>
<tr class="separator:gacdaebb1f6c1ae385eb6cfa31e0da8ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54a4805a48b94cba315485990d6fe622" id="r_ga54a4805a48b94cba315485990d6fe622"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga54a4805a48b94cba315485990d6fe622">WPI_MEMORY_VERSION_MINOR</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga54a4805a48b94cba315485990d6fe622"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minor version number.  <br /></td></tr>
<tr class="separator:ga54a4805a48b94cba315485990d6fe622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5b3b270fc70040846395fc91d9dfc9f" id="r_gac5b3b270fc70040846395fc91d9dfc9f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac5b3b270fc70040846395fc91d9dfc9f">WPI_MEMORY_VERSION</a>&#160;&#160;&#160;    (<a class="el" href="#gacdaebb1f6c1ae385eb6cfa31e0da8ae6">WPI_MEMORY_VERSION_MAJOR</a> * 100 + <a class="el" href="#ga54a4805a48b94cba315485990d6fe622">WPI_MEMORY_VERSION_MINOR</a>)</td></tr>
<tr class="memdesc:gac5b3b270fc70040846395fc91d9dfc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total version number of the form <code>Mmm</code>.  <br /></td></tr>
<tr class="separator:gac5b3b270fc70040846395fc91d9dfc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5b3b270fc70040846395fc91d9dfc9f" id="r_gac5b3b270fc70040846395fc91d9dfc9f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac5b3b270fc70040846395fc91d9dfc9f">WPI_MEMORY_VERSION</a>&#160;&#160;&#160;    (<a class="el" href="#gacdaebb1f6c1ae385eb6cfa31e0da8ae6">WPI_MEMORY_VERSION_MAJOR</a> * 100 + <a class="el" href="#ga54a4805a48b94cba315485990d6fe622">WPI_MEMORY_VERSION_MINOR</a>)</td></tr>
<tr class="memdesc:gac5b3b270fc70040846395fc91d9dfc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total version number of the form <code>Mmm</code>.  <br /></td></tr>
<tr class="separator:gac5b3b270fc70040846395fc91d9dfc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57b1022994b32a1f74a8c002856e3883" id="r_ga57b1022994b32a1f74a8c002856e3883"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga57b1022994b32a1f74a8c002856e3883">WPI_MEMORY_CHECK_ALLOCATION_SIZE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga57b1022994b32a1f74a8c002856e3883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not the allocation size will be checked, i.e.  <br /></td></tr>
<tr class="separator:ga57b1022994b32a1f74a8c002856e3883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf10070094ffa70f5ce02ad04d5dd24ce" id="r_gaf10070094ffa70f5ce02ad04d5dd24ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf10070094ffa70f5ce02ad04d5dd24ce">WPI_MEMORY_DEBUG_ASSERT</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gaf10070094ffa70f5ce02ad04d5dd24ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not internal assertions in the library are enabled.  <br /></td></tr>
<tr class="separator:gaf10070094ffa70f5ce02ad04d5dd24ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac40b66a1885b7cf7afae0d2050c00abd" id="r_gac40b66a1885b7cf7afae0d2050c00abd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac40b66a1885b7cf7afae0d2050c00abd">WPI_MEMORY_DEBUG_FILL</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gac40b66a1885b7cf7afae0d2050c00abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not allocated memory will be filled with special values.  <br /></td></tr>
<tr class="separator:gac40b66a1885b7cf7afae0d2050c00abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga222a6578b1e094965c12acbc73fadf0a" id="r_ga222a6578b1e094965c12acbc73fadf0a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga222a6578b1e094965c12acbc73fadf0a">WPI_MEMORY_DEBUG_FENCE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga222a6578b1e094965c12acbc73fadf0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the fence memory, it has no effect if <a class="el" href="#gac40b66a1885b7cf7afae0d2050c00abd">WPI_MEMORY_DEBUG_FILL</a> is <code>false</code>.  <br /></td></tr>
<tr class="separator:ga222a6578b1e094965c12acbc73fadf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16e0cfef5357f196ca782490f2803a88" id="r_ga16e0cfef5357f196ca782490f2803a88"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga16e0cfef5357f196ca782490f2803a88">WPI_MEMORY_DEBUG_LEAK_CHECK</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga16e0cfef5357f196ca782490f2803a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not leak checking is enabled.  <br /></td></tr>
<tr class="separator:ga16e0cfef5357f196ca782490f2803a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac730449713e353efca2a2c98bd68c7bd" id="r_gac730449713e353efca2a2c98bd68c7bd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac730449713e353efca2a2c98bd68c7bd">WPI_MEMORY_DEBUG_POINTER_CHECK</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gac730449713e353efca2a2c98bd68c7bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not the deallocation functions will check for pointers that were never allocated by an allocator.  <br /></td></tr>
<tr class="separator:gac730449713e353efca2a2c98bd68c7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga934af5f27120effddf902a7b7755706f" id="r_ga934af5f27120effddf902a7b7755706f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga934af5f27120effddf902a7b7755706f">WPI_MEMORY_DEBUG_DOUBLE_DEALLOC_CHECK</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga934af5f27120effddf902a7b7755706f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not the deallocation functions will check for double free errors.  <br /></td></tr>
<tr class="separator:ga934af5f27120effddf902a7b7755706f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae224895f3a5f1c58c0b92e218c51ca1" id="r_gaae224895f3a5f1c58c0b92e218c51ca1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaae224895f3a5f1c58c0b92e218c51ca1">WPI_MEMORY_NAMESPACE_PREFIX</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gaae224895f3a5f1c58c0b92e218c51ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not everything is in namespace <code><a class="el" href="namespacewpi_1_1memory.html" title="Memory namespace.">wpi::memory</a></code>.  <br /></td></tr>
<tr class="separator:gaae224895f3a5f1c58c0b92e218c51ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga2c98b0ef7658d9beda86fa166f4c02fb" id="r_ga2c98b0ef7658d9beda86fa166f4c02fb"><td class="memTemplParams" colspan="2">template&lt;class BlockOrRawAllocator , template&lt; typename... &gt; class BlockAllocator = detail::default_block_wrapper&gt; </td></tr>
<tr class="memitem:ga2c98b0ef7658d9beda86fa166f4c02fb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga2c98b0ef7658d9beda86fa166f4c02fb">wpi::memory::make_block_allocator_t</a></td></tr>
<tr class="memdesc:ga2c98b0ef7658d9beda86fa166f4c02fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes either a BlockAllocator or a RawAllocator.  <br /></td></tr>
<tr class="separator:ga2c98b0ef7658d9beda86fa166f4c02fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a0fece8ca703197ea9d82ffd20ccd05" id="r_ga8a0fece8ca703197ea9d82ffd20ccd05"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8a0fece8ca703197ea9d82ffd20ccd05">wpi::memory::leak_handler</a> = void (*)(const <a class="el" href="structwpi_1_1memory_1_1allocator__info.html">allocator_info</a>&amp; info, std::ptrdiff_t amount)</td></tr>
<tr class="memdesc:ga8a0fece8ca703197ea9d82ffd20ccd05"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the handler called when a memory leak is detected.  <br /></td></tr>
<tr class="separator:ga8a0fece8ca703197ea9d82ffd20ccd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4328906339679434218f91b2eb168ae" id="r_gab4328906339679434218f91b2eb168ae"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab4328906339679434218f91b2eb168ae">wpi::memory::invalid_pointer_handler</a> = void (*)(const <a class="el" href="structwpi_1_1memory_1_1allocator__info.html">allocator_info</a>&amp; info, const void* <a class="el" href="format_8h.html#adb6e274f8eb0b74b2865215e1b49c535">ptr</a>)</td></tr>
<tr class="memdesc:gab4328906339679434218f91b2eb168ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the handler called when an invalid pointer is passed to a deallocation function.  <br /></td></tr>
<tr class="separator:gab4328906339679434218f91b2eb168ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga383a711a2f5768faf100865babda61b3" id="r_ga383a711a2f5768faf100865babda61b3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga383a711a2f5768faf100865babda61b3">wpi::memory::buffer_overflow_handler</a></td></tr>
<tr class="memdesc:ga383a711a2f5768faf100865babda61b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the handler called when a buffer under/overflow is detected.  <br /></td></tr>
<tr class="separator:ga383a711a2f5768faf100865babda61b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gadea26fb93affed8c409ec360412d762e" id="r_gadea26fb93affed8c409ec360412d762e"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadea26fb93affed8c409ec360412d762e">wpi::memory::debug_magic</a> : unsigned char { <br />
&#160;&#160;<a class="el" href="#ggadea26fb93affed8c409ec360412d762ea7bd4be20559c1a287369c8df4c117afe">wpi::memory::debug_magic::internal_memory</a> = 0xAB
, <a class="el" href="#ggadea26fb93affed8c409ec360412d762eaa5c32a0fcc06d646d53c71b55c9cf5cb">wpi::memory::debug_magic::internal_freed_memory</a> = 0xFB
, <a class="el" href="#ggadea26fb93affed8c409ec360412d762ea9e1988b82181dbe51272459a8ac8e0c0">wpi::memory::debug_magic::new_memory</a> = 0xCD
, <a class="el" href="#ggadea26fb93affed8c409ec360412d762ea635e5f9da5635b909461fd93c09130ed">wpi::memory::debug_magic::freed_memory</a> = 0xDD
, <br />
&#160;&#160;<a class="el" href="#ggadea26fb93affed8c409ec360412d762ea682318fff515ed43a48b718f46c21308">wpi::memory::debug_magic::alignment_memory</a> = 0xED
, <a class="el" href="#ggadea26fb93affed8c409ec360412d762ea99ec421b05ddc9b5565897f6a0cfb360">wpi::memory::debug_magic::fence_memory</a> = 0xFD
<br />
 }</td></tr>
<tr class="memdesc:gadea26fb93affed8c409ec360412d762e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The magic values that are used for debug filling.  <a href="#gadea26fb93affed8c409ec360412d762e">More...</a><br /></td></tr>
<tr class="separator:gadea26fb93affed8c409ec360412d762e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga834abe9622c747efdfa8619009d2e373" id="r_ga834abe9622c747efdfa8619009d2e373"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga8a0fece8ca703197ea9d82ffd20ccd05">leak_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga834abe9622c747efdfa8619009d2e373">wpi::memory::set_leak_handler</a> (<a class="el" href="#ga8a0fece8ca703197ea9d82ffd20ccd05">leak_handler</a> h)</td></tr>
<tr class="memdesc:ga834abe9622c747efdfa8619009d2e373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the <a class="el" href="#ga8a0fece8ca703197ea9d82ffd20ccd05">leak_handler</a>.  <br /></td></tr>
<tr class="separator:ga834abe9622c747efdfa8619009d2e373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa60befedaaf9af29fcf7ce4aa837cc6e" id="r_gaa60befedaaf9af29fcf7ce4aa837cc6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga8a0fece8ca703197ea9d82ffd20ccd05">leak_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa60befedaaf9af29fcf7ce4aa837cc6e">wpi::memory::get_leak_handler</a> ()</td></tr>
<tr class="memdesc:gaa60befedaaf9af29fcf7ce4aa837cc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="#ga8a0fece8ca703197ea9d82ffd20ccd05">leak_handler</a>.  <br /></td></tr>
<tr class="separator:gaa60befedaaf9af29fcf7ce4aa837cc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8d5aef2a6a2d4e65cfcc0eeac06c02b" id="r_gab8d5aef2a6a2d4e65cfcc0eeac06c02b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#gab4328906339679434218f91b2eb168ae">invalid_pointer_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab8d5aef2a6a2d4e65cfcc0eeac06c02b">wpi::memory::set_invalid_pointer_handler</a> (<a class="el" href="#gab4328906339679434218f91b2eb168ae">invalid_pointer_handler</a> h)</td></tr>
<tr class="memdesc:gab8d5aef2a6a2d4e65cfcc0eeac06c02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the <a class="el" href="#gab4328906339679434218f91b2eb168ae">invalid_pointer_handler</a>.  <br /></td></tr>
<tr class="separator:gab8d5aef2a6a2d4e65cfcc0eeac06c02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34d9478573193d39208d340a6586f8a1" id="r_ga34d9478573193d39208d340a6586f8a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#gab4328906339679434218f91b2eb168ae">invalid_pointer_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga34d9478573193d39208d340a6586f8a1">wpi::memory::get_invalid_pointer_handler</a> ()</td></tr>
<tr class="memdesc:ga34d9478573193d39208d340a6586f8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="#gab4328906339679434218f91b2eb168ae">invalid_pointer_handler</a>.  <br /></td></tr>
<tr class="separator:ga34d9478573193d39208d340a6586f8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93b00d2fd1d3cd1f85f5331cf843fac3" id="r_ga93b00d2fd1d3cd1f85f5331cf843fac3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga383a711a2f5768faf100865babda61b3">buffer_overflow_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga93b00d2fd1d3cd1f85f5331cf843fac3">wpi::memory::set_buffer_overflow_handler</a> (<a class="el" href="#ga383a711a2f5768faf100865babda61b3">buffer_overflow_handler</a> h)</td></tr>
<tr class="memdesc:ga93b00d2fd1d3cd1f85f5331cf843fac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the <a class="el" href="#ga383a711a2f5768faf100865babda61b3">buffer_overflow_handler</a>.  <br /></td></tr>
<tr class="separator:ga93b00d2fd1d3cd1f85f5331cf843fac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddb4989826b25f0f3d833c871cd74a0d" id="r_gaddb4989826b25f0f3d833c871cd74a0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga383a711a2f5768faf100865babda61b3">buffer_overflow_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaddb4989826b25f0f3d833c871cd74a0d">wpi::memory::get_buffer_overflow_handler</a> ()</td></tr>
<tr class="memdesc:gaddb4989826b25f0f3d833c871cd74a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="#ga383a711a2f5768faf100865babda61b3">buffer_overflow_handler</a>.  <br /></td></tr>
<tr class="separator:gaddb4989826b25f0f3d833c871cd74a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71ad064608460ad27607935f45a0ca69" id="r_ga71ad064608460ad27607935f45a0ca69"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga71ad064608460ad27607935f45a0ca69">wpi::memory::cached_arena</a> = true</td></tr>
<tr class="separator:ga71ad064608460ad27607935f45a0ca69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad457e2d02a734d669ba2490d2e4b0ef8" id="r_gad457e2d02a734d669ba2490d2e4b0ef8"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad457e2d02a734d669ba2490d2e4b0ef8">wpi::memory::uncached_arena</a> = false</td></tr>
<tr class="separator:gad457e2d02a734d669ba2490d2e4b0ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadbfe56850e983927e8a47d82b565f1e" id="r_gaadbfe56850e983927e8a47d82b565f1e"><td class="memTemplParams" colspan="2">template&lt;class BlockOrRawAllocator , typename... Args&gt; </td></tr>
<tr class="memitem:gaadbfe56850e983927e8a47d82b565f1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ga2c98b0ef7658d9beda86fa166f4c02fb">make_block_allocator_t</a>&lt; BlockOrRawAllocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gaadbfe56850e983927e8a47d82b565f1e">wpi::memory::make_block_allocator</a> (std::size_t block_size, Args &amp;&amp;... args)</td></tr>
<tr class="separator:gaadbfe56850e983927e8a47d82b565f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2818c818ef45e69d31b01b11e0e8bb7b" id="r_ga2818c818ef45e69d31b01b11e0e8bb7b"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class BlockAllocator, class BlockOrRawAllocator , typename... Args&gt; </td></tr>
<tr class="memitem:ga2818c818ef45e69d31b01b11e0e8bb7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ga2c98b0ef7658d9beda86fa166f4c02fb">make_block_allocator_t</a>&lt; BlockOrRawAllocator, BlockAllocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga2818c818ef45e69d31b01b11e0e8bb7b">wpi::memory::make_block_allocator</a> (std::size_t block_size, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ga2818c818ef45e69d31b01b11e0e8bb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad024a1083a2014e2ceeaf0f5bf50e2d0" id="r_gad024a1083a2014e2ceeaf0f5bf50e2d0"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad024a1083a2014e2ceeaf0f5bf50e2d0">wpi::memory::literals::operator&quot;&quot;_KiB</a> (unsigned long long value) noexcept</td></tr>
<tr class="memdesc:gad024a1083a2014e2ceeaf0f5bf50e2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntax sugar to express sizes with unit prefixes.  <br /></td></tr>
<tr class="separator:gad024a1083a2014e2ceeaf0f5bf50e2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafae301e52377f80c766ea6f3c83d4918" id="r_gafae301e52377f80c766ea6f3c83d4918"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafae301e52377f80c766ea6f3c83d4918">wpi::memory::literals::operator&quot;&quot;_KB</a> (unsigned long long value) noexcept</td></tr>
<tr class="separator:gafae301e52377f80c766ea6f3c83d4918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5d8d8e9590325637ae5bf332b803520" id="r_gaf5d8d8e9590325637ae5bf332b803520"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf5d8d8e9590325637ae5bf332b803520">wpi::memory::literals::operator&quot;&quot;_MiB</a> (unsigned long long value) noexcept</td></tr>
<tr class="separator:gaf5d8d8e9590325637ae5bf332b803520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38794f6c4f6d8a8ff0a251e90a8aa747" id="r_ga38794f6c4f6d8a8ff0a251e90a8aa747"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga38794f6c4f6d8a8ff0a251e90a8aa747">wpi::memory::literals::operator&quot;&quot;_MB</a> (unsigned long long value) noexcept</td></tr>
<tr class="separator:ga38794f6c4f6d8a8ff0a251e90a8aa747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed65b53071366fd13070b7776014863f" id="r_gaed65b53071366fd13070b7776014863f"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaed65b53071366fd13070b7776014863f">wpi::memory::literals::operator&quot;&quot;_GiB</a> (unsigned long long value) noexcept</td></tr>
<tr class="separator:gaed65b53071366fd13070b7776014863f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga258b6cbb4bf752e95ef0fc527a3e1961" id="r_ga258b6cbb4bf752e95ef0fc527a3e1961"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga258b6cbb4bf752e95ef0fc527a3e1961">wpi::memory::literals::operator&quot;&quot;_GB</a> (unsigned long long value) noexcept</td></tr>
<tr class="separator:ga258b6cbb4bf752e95ef0fc527a3e1961"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga57b1022994b32a1f74a8c002856e3883" name="ga57b1022994b32a1f74a8c002856e3883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57b1022994b32a1f74a8c002856e3883">&#9670;&#160;</a></span>WPI_MEMORY_CHECK_ALLOCATION_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WPI_MEMORY_CHECK_ALLOCATION_SIZE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not the allocation size will be checked, i.e. </p>
<p>the <a class="el" href="classwpi_1_1memory_1_1bad__allocation__size.html">wpi::memory::bad_allocation_size</a> thrown. </p>

</div>
</div>
<a id="gaf10070094ffa70f5ce02ad04d5dd24ce" name="gaf10070094ffa70f5ce02ad04d5dd24ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf10070094ffa70f5ce02ad04d5dd24ce">&#9670;&#160;</a></span>WPI_MEMORY_DEBUG_ASSERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WPI_MEMORY_DEBUG_ASSERT&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not internal assertions in the library are enabled. </p>

</div>
</div>
<a id="ga934af5f27120effddf902a7b7755706f" name="ga934af5f27120effddf902a7b7755706f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga934af5f27120effddf902a7b7755706f">&#9670;&#160;</a></span>WPI_MEMORY_DEBUG_DOUBLE_DEALLOC_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WPI_MEMORY_DEBUG_DOUBLE_DEALLOC_CHECK&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not the deallocation functions will check for double free errors. </p>
<p>This option makes no sense if <a class="el" href="#gac730449713e353efca2a2c98bd68c7bd">WPI_MEMORY_DEBUG_POINTER_CHECK</a> is <code>false</code>. </p>

</div>
</div>
<a id="ga222a6578b1e094965c12acbc73fadf0a" name="ga222a6578b1e094965c12acbc73fadf0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga222a6578b1e094965c12acbc73fadf0a">&#9670;&#160;</a></span>WPI_MEMORY_DEBUG_FENCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WPI_MEMORY_DEBUG_FENCE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size of the fence memory, it has no effect if <a class="el" href="#gac40b66a1885b7cf7afae0d2050c00abd">WPI_MEMORY_DEBUG_FILL</a> is <code>false</code>. </p>
<dl class="section note"><dt>Note</dt><dd>For most allocators, the actual value doesn't matter and they use appropriate defaults to ensure alignment etc. </dd></dl>

</div>
</div>
<a id="gac40b66a1885b7cf7afae0d2050c00abd" name="gac40b66a1885b7cf7afae0d2050c00abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac40b66a1885b7cf7afae0d2050c00abd">&#9670;&#160;</a></span>WPI_MEMORY_DEBUG_FILL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WPI_MEMORY_DEBUG_FILL&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not allocated memory will be filled with special values. </p>

</div>
</div>
<a id="ga16e0cfef5357f196ca782490f2803a88" name="ga16e0cfef5357f196ca782490f2803a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16e0cfef5357f196ca782490f2803a88">&#9670;&#160;</a></span>WPI_MEMORY_DEBUG_LEAK_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WPI_MEMORY_DEBUG_LEAK_CHECK&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not leak checking is enabled. </p>

</div>
</div>
<a id="gac730449713e353efca2a2c98bd68c7bd" name="gac730449713e353efca2a2c98bd68c7bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac730449713e353efca2a2c98bd68c7bd">&#9670;&#160;</a></span>WPI_MEMORY_DEBUG_POINTER_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WPI_MEMORY_DEBUG_POINTER_CHECK&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not the deallocation functions will check for pointers that were never allocated by an allocator. </p>

</div>
</div>
<a id="gaae224895f3a5f1c58c0b92e218c51ca1" name="gaae224895f3a5f1c58c0b92e218c51ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae224895f3a5f1c58c0b92e218c51ca1">&#9670;&#160;</a></span>WPI_MEMORY_NAMESPACE_PREFIX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WPI_MEMORY_NAMESPACE_PREFIX&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not everything is in namespace <code><a class="el" href="namespacewpi_1_1memory.html" title="Memory namespace.">wpi::memory</a></code>. </p>
<p>If <code>false</code>, a namespace alias <code>namespace memory = <a class="el" href="namespacewpi_1_1memory.html" title="Memory namespace.">wpi::memory</a></code> is automatically inserted into each header, allowing to qualify everything with <code>wpi::</code>. </p><dl class="section note"><dt>Note</dt><dd>This option breaks in combination with using <code>using namespace wpi;</code>. </dd></dl>

</div>
</div>
<a id="gac5b3b270fc70040846395fc91d9dfc9f" name="gac5b3b270fc70040846395fc91d9dfc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5b3b270fc70040846395fc91d9dfc9f">&#9670;&#160;</a></span>WPI_MEMORY_VERSION <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WPI_MEMORY_VERSION&#160;&#160;&#160;    (<a class="el" href="#gacdaebb1f6c1ae385eb6cfa31e0da8ae6">WPI_MEMORY_VERSION_MAJOR</a> * 100 + <a class="el" href="#ga54a4805a48b94cba315485990d6fe622">WPI_MEMORY_VERSION_MINOR</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The total version number of the form <code>Mmm</code>. </p>

</div>
</div>
<a id="gac5b3b270fc70040846395fc91d9dfc9f" name="gac5b3b270fc70040846395fc91d9dfc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5b3b270fc70040846395fc91d9dfc9f">&#9670;&#160;</a></span>WPI_MEMORY_VERSION <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WPI_MEMORY_VERSION&#160;&#160;&#160;    (<a class="el" href="#gacdaebb1f6c1ae385eb6cfa31e0da8ae6">WPI_MEMORY_VERSION_MAJOR</a> * 100 + <a class="el" href="#ga54a4805a48b94cba315485990d6fe622">WPI_MEMORY_VERSION_MINOR</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The total version number of the form <code>Mmm</code>. </p>

</div>
</div>
<a id="gacdaebb1f6c1ae385eb6cfa31e0da8ae6" name="gacdaebb1f6c1ae385eb6cfa31e0da8ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdaebb1f6c1ae385eb6cfa31e0da8ae6">&#9670;&#160;</a></span>WPI_MEMORY_VERSION_MAJOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WPI_MEMORY_VERSION_MAJOR&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The major version number. </p>

</div>
</div>
<a id="ga54a4805a48b94cba315485990d6fe622" name="ga54a4805a48b94cba315485990d6fe622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54a4805a48b94cba315485990d6fe622">&#9670;&#160;</a></span>WPI_MEMORY_VERSION_MINOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WPI_MEMORY_VERSION_MINOR&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The minor version number. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga383a711a2f5768faf100865babda61b3" name="ga383a711a2f5768faf100865babda61b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga383a711a2f5768faf100865babda61b3">&#9670;&#160;</a></span>buffer_overflow_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga383a711a2f5768faf100865babda61b3">wpi::memory::buffer_overflow_handler</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> void (*)(<span class="keyword">const</span> <span class="keywordtype">void</span>* <a class="code hl_namespace" href="namespacewpi_1_1memory.html">memory</a>, std::size_t size,</div>
<div class="line">                                                 <span class="keyword">const</span> <span class="keywordtype">void</span>* write_ptr)</div>
<div class="ttc" id="anamespacewpi_1_1memory_html"><div class="ttname"><a href="namespacewpi_1_1memory.html">wpi::memory</a></div><div class="ttdoc">Memory namespace.</div><div class="ttdef"><b>Definition</b> heap_allocator.hpp:20</div></div>
</div><!-- fragment -->
<p>The type of the handler called when a buffer under/overflow is detected. </p>
<p>If <a class="el" href="#gac40b66a1885b7cf7afae0d2050c00abd">WPI_MEMORY_DEBUG_FILL</a> is <code>true</code> and <a class="el" href="#ga222a6578b1e094965c12acbc73fadf0a">WPI_MEMORY_DEBUG_FENCE</a> has a non-zero value the allocator classes check if a write into the fence has occured upon deallocation. The handler gets the memory block belonging to the corrupted fence, its size and the exact address. </p><dl class="section user"><dt><em>Required Behavior:</em></dt><dd>A buffer overflow handler shall terminate the program. It must not throw any exceptions since it me be called in the cleanup process. </dd></dl>
<dl class="section user"><dt><em>Default Behavior:</em></dt><dd>On a hosted implementation it logs the information to <code>stderr</code> and calls <code>std::abort()</code>. On a freestanding implementation it only calls <code>std::abort()</code>. </dd></dl>

</div>
</div>
<a id="gab4328906339679434218f91b2eb168ae" name="gab4328906339679434218f91b2eb168ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4328906339679434218f91b2eb168ae">&#9670;&#160;</a></span>invalid_pointer_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gab4328906339679434218f91b2eb168ae">wpi::memory::invalid_pointer_handler</a> = void (*)(const <a class="el" href="structwpi_1_1memory_1_1allocator__info.html">allocator_info</a>&amp; info, const void* <a class="el" href="format_8h.html#adb6e274f8eb0b74b2865215e1b49c535">ptr</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the handler called when an invalid pointer is passed to a deallocation function. </p>
<p>Pointer checking can be controlled via the options <a class="el" href="#gac730449713e353efca2a2c98bd68c7bd">WPI_MEMORY_DEBUG_POINTER_CHECK</a> and <a class="el" href="#ga934af5f27120effddf902a7b7755706f">WPI_MEMORY_DEBUG_DOUBLE_DEALLOC_CHECK</a>. The handler gets the <a class="el" href="structwpi_1_1memory_1_1allocator__info.html">allocator_info</a> and the invalid pointer. </p><dl class="section user"><dt><em>Required Behavior:</em></dt><dd>An invalid pointer handler shall terminate the program. It must not throw any exceptions since it might be called in the cleanup process. </dd></dl>
<dl class="section user"><dt><em>Default Behavior:</em></dt><dd>On a hosted implementation it logs the information to <code>stderr</code> and calls <code>std::abort()</code>. On a freestanding implementation it only calls <code>std::abort()</code>. </dd></dl>

</div>
</div>
<a id="ga8a0fece8ca703197ea9d82ffd20ccd05" name="ga8a0fece8ca703197ea9d82ffd20ccd05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a0fece8ca703197ea9d82ffd20ccd05">&#9670;&#160;</a></span>leak_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga8a0fece8ca703197ea9d82ffd20ccd05">wpi::memory::leak_handler</a> = void (*)(const <a class="el" href="structwpi_1_1memory_1_1allocator__info.html">allocator_info</a>&amp; info, std::ptrdiff_t amount)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the handler called when a memory leak is detected. </p>
<p>Leak checking can be controlled via the option <a class="el" href="#ga16e0cfef5357f196ca782490f2803a88">WPI_MEMORY_DEBUG_LEAK_CHECK</a> and only affects calls through the <a class="el" href="classwpi_1_1memory_1_1allocator__traits.html">allocator_traits</a>, not direct calls. The handler gets the <a class="el" href="structwpi_1_1memory_1_1allocator__info.html">allocator_info</a> and the amount of memory leaked. This can also be negative, meaning that more memory has been freed than allocated. </p><dl class="section user"><dt><em>Required Behavior:</em></dt><dd>A leak handler shall log the leak, abort the program, do nothing or anything else that seems appropriate. It must not throw any exceptions since it is called in the cleanup process. </dd></dl>
<dl class="section user"><dt><em>Default Behavior:</em></dt><dd>On a hosted implementation it logs the leak to <code>stderr</code> and returns, continuing execution. On a freestanding implementation it does nothing. </dd></dl>

</div>
</div>
<a id="ga2c98b0ef7658d9beda86fa166f4c02fb" name="ga2c98b0ef7658d9beda86fa166f4c02fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c98b0ef7658d9beda86fa166f4c02fb">&#9670;&#160;</a></span>make_block_allocator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockOrRawAllocator , template&lt; typename... &gt; class BlockAllocator = detail::default_block_wrapper&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga2c98b0ef7658d9beda86fa166f4c02fb">wpi::memory::make_block_allocator_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> implementation_defined</div>
</div><!-- fragment -->
<p>Takes either a BlockAllocator or a RawAllocator. </p>
<p>In the first case simply aliases the type unchanged, in the second to <a class="el" href="classwpi_1_1memory_1_1growing__block__allocator.html">growing_block_allocator</a> (or the template in <code>BlockAllocator</code>) with the RawAllocator. Using this allows passing normal RawAllocators as BlockAllocators. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gadea26fb93affed8c409ec360412d762e" name="gadea26fb93affed8c409ec360412d762e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadea26fb93affed8c409ec360412d762e">&#9670;&#160;</a></span>debug_magic</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#gadea26fb93affed8c409ec360412d762e">wpi::memory::debug_magic</a> : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The magic values that are used for debug filling. </p>
<p>If <a class="el" href="#gac40b66a1885b7cf7afae0d2050c00abd">WPI_MEMORY_DEBUG_FILL</a> is <code>true</code>, memory will be filled to help detect use-after-free or missing initialization errors. These are the constants for the different types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadea26fb93affed8c409ec360412d762ea7bd4be20559c1a287369c8df4c117afe" name="ggadea26fb93affed8c409ec360412d762ea7bd4be20559c1a287369c8df4c117afe"></a>internal_memory&#160;</td><td class="fielddoc"><p>Marks internal memory used by the allocator - "allocated block". </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadea26fb93affed8c409ec360412d762eaa5c32a0fcc06d646d53c71b55c9cf5cb" name="ggadea26fb93affed8c409ec360412d762eaa5c32a0fcc06d646d53c71b55c9cf5cb"></a>internal_freed_memory&#160;</td><td class="fielddoc"><p>Marks internal memory currently not used by the allocator - "freed block". </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadea26fb93affed8c409ec360412d762ea9e1988b82181dbe51272459a8ac8e0c0" name="ggadea26fb93affed8c409ec360412d762ea9e1988b82181dbe51272459a8ac8e0c0"></a>new_memory&#160;</td><td class="fielddoc"><p>Marks allocated, but not yet used memory - "clean memory". </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadea26fb93affed8c409ec360412d762ea635e5f9da5635b909461fd93c09130ed" name="ggadea26fb93affed8c409ec360412d762ea635e5f9da5635b909461fd93c09130ed"></a>freed_memory&#160;</td><td class="fielddoc"><p>Marks freed memory - "dead memory". </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadea26fb93affed8c409ec360412d762ea682318fff515ed43a48b718f46c21308" name="ggadea26fb93affed8c409ec360412d762ea682318fff515ed43a48b718f46c21308"></a>alignment_memory&#160;</td><td class="fielddoc"><p>Marks buffer memory used to ensure proper alignment. </p>
<p>This memory can also serve as <a class="el" href="#ggadea26fb93affed8c409ec360412d762ea99ec421b05ddc9b5565897f6a0cfb360">debug_magic::fence_memory</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadea26fb93affed8c409ec360412d762ea99ec421b05ddc9b5565897f6a0cfb360" name="ggadea26fb93affed8c409ec360412d762ea99ec421b05ddc9b5565897f6a0cfb360"></a>fence_memory&#160;</td><td class="fielddoc"><p>Marks buffer memory used to protect against overflow - "fence memory". </p>
<p>The option <a class="el" href="#ga222a6578b1e094965c12acbc73fadf0a">WPI_MEMORY_DEBUG_FENCE</a> controls the size of a memory fence that will be placed before or after a memory block. It helps catching buffer overflows. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaddb4989826b25f0f3d833c871cd74a0d" name="gaddb4989826b25f0f3d833c871cd74a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddb4989826b25f0f3d833c871cd74a0d">&#9670;&#160;</a></span>get_buffer_overflow_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga383a711a2f5768faf100865babda61b3">buffer_overflow_handler</a> wpi::memory::get_buffer_overflow_handler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="#ga383a711a2f5768faf100865babda61b3">buffer_overflow_handler</a>. </p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The current <a class="el" href="#ga383a711a2f5768faf100865babda61b3">buffer_overflow_handler</a>. This is never <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="ga34d9478573193d39208d340a6586f8a1" name="ga34d9478573193d39208d340a6586f8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34d9478573193d39208d340a6586f8a1">&#9670;&#160;</a></span>get_invalid_pointer_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#gab4328906339679434218f91b2eb168ae">invalid_pointer_handler</a> wpi::memory::get_invalid_pointer_handler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="#gab4328906339679434218f91b2eb168ae">invalid_pointer_handler</a>. </p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The current <a class="el" href="#gab4328906339679434218f91b2eb168ae">invalid_pointer_handler</a>. This is never <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="gaa60befedaaf9af29fcf7ce4aa837cc6e" name="gaa60befedaaf9af29fcf7ce4aa837cc6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa60befedaaf9af29fcf7ce4aa837cc6e">&#9670;&#160;</a></span>get_leak_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga8a0fece8ca703197ea9d82ffd20ccd05">leak_handler</a> wpi::memory::get_leak_handler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="#ga8a0fece8ca703197ea9d82ffd20ccd05">leak_handler</a>. </p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The current <a class="el" href="#ga8a0fece8ca703197ea9d82ffd20ccd05">leak_handler</a>. This is never <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="gaadbfe56850e983927e8a47d82b565f1e" name="gaadbfe56850e983927e8a47d82b565f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadbfe56850e983927e8a47d82b565f1e">&#9670;&#160;</a></span>make_block_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockOrRawAllocator , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga2c98b0ef7658d9beda86fa166f4c02fb">make_block_allocator_t</a>&lt; BlockOrRawAllocator &gt; wpi::memory::make_block_allocator </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>block_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function make a BlockAllocator. </p><dl class="section user"><dt><em>Returns:</em></dt><dd>A BlockAllocator of the given type created with the given arguments. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd>Same requirements as the constructor. </dd></dl>

</div>
</div>
<a id="ga2818c818ef45e69d31b01b11e0e8bb7b" name="ga2818c818ef45e69d31b01b11e0e8bb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2818c818ef45e69d31b01b11e0e8bb7b">&#9670;&#160;</a></span>make_block_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class... &gt; class BlockAllocator, class BlockOrRawAllocator , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga2c98b0ef7658d9beda86fa166f4c02fb">make_block_allocator_t</a>&lt; BlockOrRawAllocator, BlockAllocator &gt; wpi::memory::make_block_allocator </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>block_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga258b6cbb4bf752e95ef0fc527a3e1961" name="ga258b6cbb4bf752e95ef0fc527a3e1961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga258b6cbb4bf752e95ef0fc527a3e1961">&#9670;&#160;</a></span>operator&quot;&quot;_GB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t wpi::memory::literals::operator&quot;&quot;_GB </td>
          <td>(</td>
          <td class="paramtype">unsigned long long</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gaed65b53071366fd13070b7776014863f" name="gaed65b53071366fd13070b7776014863f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed65b53071366fd13070b7776014863f">&#9670;&#160;</a></span>operator&quot;&quot;_GiB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t wpi::memory::literals::operator&quot;&quot;_GiB </td>
          <td>(</td>
          <td class="paramtype">unsigned long long</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gafae301e52377f80c766ea6f3c83d4918" name="gafae301e52377f80c766ea6f3c83d4918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafae301e52377f80c766ea6f3c83d4918">&#9670;&#160;</a></span>operator&quot;&quot;_KB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t wpi::memory::literals::operator&quot;&quot;_KB </td>
          <td>(</td>
          <td class="paramtype">unsigned long long</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gad024a1083a2014e2ceeaf0f5bf50e2d0" name="gad024a1083a2014e2ceeaf0f5bf50e2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad024a1083a2014e2ceeaf0f5bf50e2d0">&#9670;&#160;</a></span>operator&quot;&quot;_KiB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t wpi::memory::literals::operator&quot;&quot;_KiB </td>
          <td>(</td>
          <td class="paramtype">unsigned long long</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Syntax sugar to express sizes with unit prefixes. </p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The number of bytes <code>value</code> is in the given unit. </dd></dl>

</div>
</div>
<a id="ga38794f6c4f6d8a8ff0a251e90a8aa747" name="ga38794f6c4f6d8a8ff0a251e90a8aa747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38794f6c4f6d8a8ff0a251e90a8aa747">&#9670;&#160;</a></span>operator&quot;&quot;_MB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t wpi::memory::literals::operator&quot;&quot;_MB </td>
          <td>(</td>
          <td class="paramtype">unsigned long long</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf5d8d8e9590325637ae5bf332b803520" name="gaf5d8d8e9590325637ae5bf332b803520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5d8d8e9590325637ae5bf332b803520">&#9670;&#160;</a></span>operator&quot;&quot;_MiB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t wpi::memory::literals::operator&quot;&quot;_MiB </td>
          <td>(</td>
          <td class="paramtype">unsigned long long</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga93b00d2fd1d3cd1f85f5331cf843fac3" name="ga93b00d2fd1d3cd1f85f5331cf843fac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93b00d2fd1d3cd1f85f5331cf843fac3">&#9670;&#160;</a></span>set_buffer_overflow_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga383a711a2f5768faf100865babda61b3">buffer_overflow_handler</a> wpi::memory::set_buffer_overflow_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga383a711a2f5768faf100865babda61b3">buffer_overflow_handler</a></td>          <td class="paramname"><span class="paramname"><em>h</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchanges the <a class="el" href="#ga383a711a2f5768faf100865babda61b3">buffer_overflow_handler</a>. </p>
<dl class="section user"><dt><em>Effects:</em></dt><dd>Sets <code>h</code> as the new <a class="el" href="#ga383a711a2f5768faf100865babda61b3">buffer_overflow_handler</a> in an atomic operation. A <code>nullptr</code> sets the default <a class="el" href="#ga383a711a2f5768faf100865babda61b3">buffer_overflow_handler</a>. </dd></dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The previous <a class="el" href="#ga383a711a2f5768faf100865babda61b3">buffer_overflow_handler</a>. This is never <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="gab8d5aef2a6a2d4e65cfcc0eeac06c02b" name="gab8d5aef2a6a2d4e65cfcc0eeac06c02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8d5aef2a6a2d4e65cfcc0eeac06c02b">&#9670;&#160;</a></span>set_invalid_pointer_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#gab4328906339679434218f91b2eb168ae">invalid_pointer_handler</a> wpi::memory::set_invalid_pointer_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gab4328906339679434218f91b2eb168ae">invalid_pointer_handler</a></td>          <td class="paramname"><span class="paramname"><em>h</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchanges the <a class="el" href="#gab4328906339679434218f91b2eb168ae">invalid_pointer_handler</a>. </p>
<dl class="section user"><dt><em>Effects:</em></dt><dd>Sets <code>h</code> as the new <a class="el" href="#gab4328906339679434218f91b2eb168ae">invalid_pointer_handler</a> in an atomic operation. A <code>nullptr</code> sets the default <a class="el" href="#gab4328906339679434218f91b2eb168ae">invalid_pointer_handler</a>. </dd></dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The previous <a class="el" href="#gab4328906339679434218f91b2eb168ae">invalid_pointer_handler</a>. This is never <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="ga834abe9622c747efdfa8619009d2e373" name="ga834abe9622c747efdfa8619009d2e373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga834abe9622c747efdfa8619009d2e373">&#9670;&#160;</a></span>set_leak_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga8a0fece8ca703197ea9d82ffd20ccd05">leak_handler</a> wpi::memory::set_leak_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga8a0fece8ca703197ea9d82ffd20ccd05">leak_handler</a></td>          <td class="paramname"><span class="paramname"><em>h</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchanges the <a class="el" href="#ga8a0fece8ca703197ea9d82ffd20ccd05">leak_handler</a>. </p>
<dl class="section user"><dt><em>Effects:</em></dt><dd>Sets <code>h</code> as the new <a class="el" href="#ga8a0fece8ca703197ea9d82ffd20ccd05">leak_handler</a> in an atomic operation. A <code>nullptr</code> sets the default <a class="el" href="#ga8a0fece8ca703197ea9d82ffd20ccd05">leak_handler</a>. </dd></dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The previous <a class="el" href="#ga8a0fece8ca703197ea9d82ffd20ccd05">leak_handler</a>. This is never <code>nullptr</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga71ad064608460ad27607935f45a0ca69" name="ga71ad064608460ad27607935f45a0ca69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71ad064608460ad27607935f45a0ca69">&#9670;&#160;</a></span>cached_arena</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::memory::cached_arena = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Controls the caching of <a class="el" href="classwpi_1_1memory_1_1memory__arena.html">memory_arena</a>. By default, deallocated blocks are put onto a cache, so they can be reused later; this tag value enable/disable it..<br  />
 This can be useful, e.g. if there will never be blocks available for deallocation. The (tiny) overhead for the cache can then be disabled. An example is <a class="el" href="classwpi_1_1memory_1_1memory__pool.html">memory_pool</a>. </p>

</div>
</div>
<a id="gad457e2d02a734d669ba2490d2e4b0ef8" name="gad457e2d02a734d669ba2490d2e4b0ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad457e2d02a734d669ba2490d2e4b0ef8">&#9670;&#160;</a></span>uncached_arena</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wpi::memory::uncached_arena = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Oct 24 2024 04:48:53 for WPILibC++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
